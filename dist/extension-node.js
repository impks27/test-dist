/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@octokit/auth-token/dist-web/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@octokit/auth-token/dist-web/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTokenAuth: () => (/* binding */ createTokenAuth)
/* harmony export */ });
const REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
const REGEX_IS_INSTALLATION = /^ghs_/;
const REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
    const isApp = token.split(/\./).length === 3;
    const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) ||
        REGEX_IS_INSTALLATION.test(token);
    const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
    const tokenType = isApp
        ? "app"
        : isInstallation
            ? "installation"
            : isUserToServer
                ? "user-to-server"
                : "oauth";
    return {
        type: "token",
        token: token,
        tokenType,
    };
}

/**
 * Prefix token for usage in the Authorization header
 *
 * @param token OAuth token or JSON Web Token
 */
function withAuthorizationPrefix(token) {
    if (token.split(/\./).length === 3) {
        return `bearer ${token}`;
    }
    return `token ${token}`;
}

async function hook(token, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    endpoint.headers.authorization = withAuthorizationPrefix(token);
    return request(endpoint);
}

const createTokenAuth = function createTokenAuth(token) {
    if (!token) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
    }
    if (typeof token !== "string") {
        throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
    }
    token = token.replace(/^(token|bearer) +/i, "");
    return Object.assign(auth.bind(null, token), {
        hook: hook.bind(null, token),
    });
};




/***/ }),

/***/ "./node_modules/@octokit/core/dist-web/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@octokit/core/dist-web/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Octokit: () => (/* binding */ Octokit)
/* harmony export */ });
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-node/index.js");
/* harmony import */ var before_after_hook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! before-after-hook */ "./node_modules/before-after-hook/index.js");
/* harmony import */ var before_after_hook__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(before_after_hook__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _octokit_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @octokit/request */ "./node_modules/@octokit/request/dist-web/index.js");
/* harmony import */ var _octokit_graphql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @octokit/graphql */ "./node_modules/@octokit/graphql/dist-web/index.js");
/* harmony import */ var _octokit_auth_token__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @octokit/auth-token */ "./node_modules/@octokit/auth-token/dist-web/index.js");






const VERSION = "4.1.0";

class Octokit {
    constructor(options = {}) {
        const hook = new before_after_hook__WEBPACK_IMPORTED_MODULE_0__.Collection();
        const requestDefaults = {
            baseUrl: _octokit_request__WEBPACK_IMPORTED_MODULE_1__.request.endpoint.DEFAULTS.baseUrl,
            headers: {},
            request: Object.assign({}, options.request, {
                // @ts-ignore internal usage only, no need to type
                hook: hook.bind(null, "request"),
            }),
            mediaType: {
                previews: [],
                format: "",
            },
        };
        // prepend default user agent with `options.userAgent` if set
        requestDefaults.headers["user-agent"] = [
            options.userAgent,
            `octokit-core.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_2__.getUserAgent)()}`,
        ]
            .filter(Boolean)
            .join(" ");
        if (options.baseUrl) {
            requestDefaults.baseUrl = options.baseUrl;
        }
        if (options.previews) {
            requestDefaults.mediaType.previews = options.previews;
        }
        if (options.timeZone) {
            requestDefaults.headers["time-zone"] = options.timeZone;
        }
        this.request = _octokit_request__WEBPACK_IMPORTED_MODULE_1__.request.defaults(requestDefaults);
        this.graphql = (0,_octokit_graphql__WEBPACK_IMPORTED_MODULE_3__.withCustomRequest)(this.request).defaults(requestDefaults);
        this.log = Object.assign({
            debug: () => { },
            info: () => { },
            warn: console.warn.bind(console),
            error: console.error.bind(console),
        }, options.log);
        this.hook = hook;
        // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance
        //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.
        // (2) If only `options.auth` is set, use the default token authentication strategy.
        // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.
        // TODO: type `options.auth` based on `options.authStrategy`.
        if (!options.authStrategy) {
            if (!options.auth) {
                // (1)
                this.auth = async () => ({
                    type: "unauthenticated",
                });
            }
            else {
                // (2)
                const auth = (0,_octokit_auth_token__WEBPACK_IMPORTED_MODULE_4__.createTokenAuth)(options.auth);
                // @ts-ignore  ¯\_(ツ)_/¯
                hook.wrap("request", auth.hook);
                this.auth = auth;
            }
        }
        else {
            const { authStrategy, ...otherOptions } = options;
            const auth = authStrategy(Object.assign({
                request: this.request,
                log: this.log,
                // we pass the current octokit instance as well as its constructor options
                // to allow for authentication strategies that return a new octokit instance
                // that shares the same internal state as the current one. The original
                // requirement for this was the "event-octokit" authentication strategy
                // of https://github.com/probot/octokit-auth-probot.
                octokit: this,
                octokitOptions: otherOptions,
            }, options.auth));
            // @ts-ignore  ¯\_(ツ)_/¯
            hook.wrap("request", auth.hook);
            this.auth = auth;
        }
        // apply plugins
        // https://stackoverflow.com/a/16345172
        const classConstructor = this.constructor;
        classConstructor.plugins.forEach((plugin) => {
            Object.assign(this, plugin(this, options));
        });
    }
    static defaults(defaults) {
        const OctokitWithDefaults = class extends this {
            constructor(...args) {
                const options = args[0] || {};
                if (typeof defaults === "function") {
                    super(defaults(options));
                    return;
                }
                super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent
                    ? {
                        userAgent: `${options.userAgent} ${defaults.userAgent}`,
                    }
                    : null));
            }
        };
        return OctokitWithDefaults;
    }
    /**
     * Attach a plugin (or many) to your Octokit instance.
     *
     * @example
     * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
     */
    static plugin(...newPlugins) {
        var _a;
        const currentPlugins = this.plugins;
        const NewOctokit = (_a = class extends this {
            },
            _a.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin))),
            _a);
        return NewOctokit;
    }
}
Octokit.VERSION = VERSION;
Octokit.plugins = [];




/***/ }),

/***/ "./node_modules/@octokit/endpoint/dist-web/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@octokit/endpoint/dist-web/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   endpoint: () => (/* binding */ endpoint)
/* harmony export */ });
/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ "./node_modules/@octokit/endpoint/node_modules/is-plain-object/dist/is-plain-object.mjs");
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-node/index.js");



function lowercaseKeys(object) {
    if (!object) {
        return {};
    }
    return Object.keys(object).reduce((newObj, key) => {
        newObj[key.toLowerCase()] = object[key];
        return newObj;
    }, {});
}

function mergeDeep(defaults, options) {
    const result = Object.assign({}, defaults);
    Object.keys(options).forEach((key) => {
        if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(options[key])) {
            if (!(key in defaults))
                Object.assign(result, { [key]: options[key] });
            else
                result[key] = mergeDeep(defaults[key], options[key]);
        }
        else {
            Object.assign(result, { [key]: options[key] });
        }
    });
    return result;
}

function removeUndefinedProperties(obj) {
    for (const key in obj) {
        if (obj[key] === undefined) {
            delete obj[key];
        }
    }
    return obj;
}

function merge(defaults, route, options) {
    if (typeof route === "string") {
        let [method, url] = route.split(" ");
        options = Object.assign(url ? { method, url } : { url: method }, options);
    }
    else {
        options = Object.assign({}, route);
    }
    // lowercase header names before merging with defaults to avoid duplicates
    options.headers = lowercaseKeys(options.headers);
    // remove properties with undefined values before merging
    removeUndefinedProperties(options);
    removeUndefinedProperties(options.headers);
    const mergedOptions = mergeDeep(defaults || {}, options);
    // mediaType.previews arrays are merged, instead of overwritten
    if (defaults && defaults.mediaType.previews.length) {
        mergedOptions.mediaType.previews = defaults.mediaType.previews
            .filter((preview) => !mergedOptions.mediaType.previews.includes(preview))
            .concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
    return mergedOptions;
}

function addQueryParameters(url, parameters) {
    const separator = /\?/.test(url) ? "&" : "?";
    const names = Object.keys(parameters);
    if (names.length === 0) {
        return url;
    }
    return (url +
        separator +
        names
            .map((name) => {
            if (name === "q") {
                return ("q=" + parameters.q.split("+").map(encodeURIComponent).join("+"));
            }
            return `${name}=${encodeURIComponent(parameters[name])}`;
        })
            .join("&"));
}

const urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
    return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
    const matches = url.match(urlVariableRegex);
    if (!matches) {
        return [];
    }
    return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}

function omit(object, keysToOmit) {
    return Object.keys(object)
        .filter((option) => !keysToOmit.includes(option))
        .reduce((obj, key) => {
        obj[key] = object[key];
        return obj;
    }, {});
}

// Based on https://github.com/bramstein/url-template, licensed under BSD
// TODO: create separate package.
//
// Copyright (c) 2012-2014, Bram Stein
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/* istanbul ignore file */
function encodeReserved(str) {
    return str
        .split(/(%[0-9A-Fa-f]{2})/g)
        .map(function (part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
            part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
        }
        return part;
    })
        .join("");
}
function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}
function encodeValue(operator, value, key) {
    value =
        operator === "+" || operator === "#"
            ? encodeReserved(value)
            : encodeUnreserved(value);
    if (key) {
        return encodeUnreserved(key) + "=" + value;
    }
    else {
        return value;
    }
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
    var value = context[key], result = [];
    if (isDefined(value) && value !== "") {
        if (typeof value === "string" ||
            typeof value === "number" ||
            typeof value === "boolean") {
            value = value.toString();
            if (modifier && modifier !== "*") {
                value = value.substring(0, parseInt(modifier, 10));
            }
            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
        }
        else {
            if (modifier === "*") {
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
                    });
                }
                else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            result.push(encodeValue(operator, value[k], k));
                        }
                    });
                }
            }
            else {
                const tmp = [];
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        tmp.push(encodeValue(operator, value));
                    });
                }
                else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            tmp.push(encodeUnreserved(k));
                            tmp.push(encodeValue(operator, value[k].toString()));
                        }
                    });
                }
                if (isKeyOperator(operator)) {
                    result.push(encodeUnreserved(key) + "=" + tmp.join(","));
                }
                else if (tmp.length !== 0) {
                    result.push(tmp.join(","));
                }
            }
        }
    }
    else {
        if (operator === ";") {
            if (isDefined(value)) {
                result.push(encodeUnreserved(key));
            }
        }
        else if (value === "" && (operator === "&" || operator === "?")) {
            result.push(encodeUnreserved(key) + "=");
        }
        else if (value === "") {
            result.push("");
        }
    }
    return result;
}
function parseUrl(template) {
    return {
        expand: expand.bind(null, template),
    };
}
function expand(template, context) {
    var operators = ["+", "#", ".", "/", ";", "?", "&"];
    return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
        if (expression) {
            let operator = "";
            const values = [];
            if (operators.indexOf(expression.charAt(0)) !== -1) {
                operator = expression.charAt(0);
                expression = expression.substr(1);
            }
            expression.split(/,/g).forEach(function (variable) {
                var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
            });
            if (operator && operator !== "+") {
                var separator = ",";
                if (operator === "?") {
                    separator = "&";
                }
                else if (operator !== "#") {
                    separator = operator;
                }
                return (values.length !== 0 ? operator : "") + values.join(separator);
            }
            else {
                return values.join(",");
            }
        }
        else {
            return encodeReserved(literal);
        }
    });
}

function parse(options) {
    // https://fetch.spec.whatwg.org/#methods
    let method = options.method.toUpperCase();
    // replace :varname with {varname} to make it RFC 6570 compatible
    let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
    let headers = Object.assign({}, options.headers);
    let body;
    let parameters = omit(options, [
        "method",
        "baseUrl",
        "url",
        "headers",
        "request",
        "mediaType",
    ]);
    // extract variable names from URL to calculate remaining variables later
    const urlVariableNames = extractUrlVariableNames(url);
    url = parseUrl(url).expand(parameters);
    if (!/^http/.test(url)) {
        url = options.baseUrl + url;
    }
    const omittedParameters = Object.keys(options)
        .filter((option) => urlVariableNames.includes(option))
        .concat("baseUrl");
    const remainingParameters = omit(parameters, omittedParameters);
    const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
    if (!isBinaryRequest) {
        if (options.mediaType.format) {
            // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw
            headers.accept = headers.accept
                .split(/,/)
                .map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`))
                .join(",");
        }
        if (options.mediaType.previews.length) {
            const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
            headers.accept = previewsFromAcceptHeader
                .concat(options.mediaType.previews)
                .map((preview) => {
                const format = options.mediaType.format
                    ? `.${options.mediaType.format}`
                    : "+json";
                return `application/vnd.github.${preview}-preview${format}`;
            })
                .join(",");
        }
    }
    // for GET/HEAD requests, set URL query parameters from remaining parameters
    // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters
    if (["GET", "HEAD"].includes(method)) {
        url = addQueryParameters(url, remainingParameters);
    }
    else {
        if ("data" in remainingParameters) {
            body = remainingParameters.data;
        }
        else {
            if (Object.keys(remainingParameters).length) {
                body = remainingParameters;
            }
        }
    }
    // default content-type for JSON if body is set
    if (!headers["content-type"] && typeof body !== "undefined") {
        headers["content-type"] = "application/json; charset=utf-8";
    }
    // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.
    // fetch does not allow to set `content-length` header, but we can set body to an empty string
    if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
        body = "";
    }
    // Only return body/request keys if present
    return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}

function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
}

function withDefaults(oldDefaults, newDefaults) {
    const DEFAULTS = merge(oldDefaults, newDefaults);
    const endpoint = endpointWithDefaults.bind(null, DEFAULTS);
    return Object.assign(endpoint, {
        DEFAULTS,
        defaults: withDefaults.bind(null, DEFAULTS),
        merge: merge.bind(null, DEFAULTS),
        parse,
    });
}

const VERSION = "7.0.3";

const userAgent = `octokit-endpoint.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_1__.getUserAgent)()}`;
// DEFAULTS has all properties set that EndpointOptions has, except url.
// So we use RequestParameters and add method as additional required property.
const DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
        accept: "application/vnd.github.v3+json",
        "user-agent": userAgent,
    },
    mediaType: {
        format: "",
        previews: [],
    },
};

const endpoint = withDefaults(null, DEFAULTS);




/***/ }),

/***/ "./node_modules/@octokit/graphql/dist-web/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@octokit/graphql/dist-web/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphqlResponseError: () => (/* binding */ GraphqlResponseError),
/* harmony export */   graphql: () => (/* binding */ graphql$1),
/* harmony export */   withCustomRequest: () => (/* binding */ withCustomRequest)
/* harmony export */ });
/* harmony import */ var _octokit_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @octokit/request */ "./node_modules/@octokit/request/dist-web/index.js");
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-node/index.js");



const VERSION = "5.0.4";

function _buildMessageForResponseErrors(data) {
    return (`Request failed due to following response errors:\n` +
        data.errors.map((e) => ` - ${e.message}`).join("\n"));
}
class GraphqlResponseError extends Error {
    constructor(request, headers, response) {
        super(_buildMessageForResponseErrors(response));
        this.request = request;
        this.headers = headers;
        this.response = response;
        this.name = "GraphqlResponseError";
        // Expose the errors and response data in their shorthand properties.
        this.errors = response.errors;
        this.data = response.data;
        // Maintains proper stack trace (only available on V8)
        /* istanbul ignore next */
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}

const NON_VARIABLE_OPTIONS = [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "query",
    "mediaType",
];
const FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
const GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request, query, options) {
    if (options) {
        if (typeof query === "string" && "query" in options) {
            return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
        }
        for (const key in options) {
            if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
                continue;
            return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
        }
    }
    const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
    const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
        if (NON_VARIABLE_OPTIONS.includes(key)) {
            result[key] = parsedOptions[key];
            return result;
        }
        if (!result.variables) {
            result.variables = {};
        }
        result.variables[key] = parsedOptions[key];
        return result;
    }, {});
    // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix
    // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451
    const baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;
    if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
        requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
    }
    return request(requestOptions).then((response) => {
        if (response.data.errors) {
            const headers = {};
            for (const key of Object.keys(response.headers)) {
                headers[key] = response.headers[key];
            }
            throw new GraphqlResponseError(requestOptions, headers, response.data);
        }
        return response.data.data;
    });
}

function withDefaults(request, newDefaults) {
    const newRequest = request.defaults(newDefaults);
    const newApi = (query, options) => {
        return graphql(newRequest, query, options);
    };
    return Object.assign(newApi, {
        defaults: withDefaults.bind(null, newRequest),
        endpoint: newRequest.endpoint,
    });
}

const graphql$1 = withDefaults(_octokit_request__WEBPACK_IMPORTED_MODULE_0__.request, {
    headers: {
        "user-agent": `octokit-graphql.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_1__.getUserAgent)()}`,
    },
    method: "POST",
    url: "/graphql",
});
function withCustomRequest(customRequest) {
    return withDefaults(customRequest, {
        method: "POST",
        url: "/graphql",
    });
}




/***/ }),

/***/ "./node_modules/@octokit/plugin-paginate-rest/dist-web/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@octokit/plugin-paginate-rest/dist-web/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   composePaginateRest: () => (/* binding */ composePaginateRest),
/* harmony export */   isPaginatingEndpoint: () => (/* binding */ isPaginatingEndpoint),
/* harmony export */   paginateRest: () => (/* binding */ paginateRest),
/* harmony export */   paginatingEndpoints: () => (/* binding */ paginatingEndpoints)
/* harmony export */ });
const VERSION = "6.0.0";

/**
 * Some “list” response that can be paginated have a different response structure
 *
 * They have a `total_count` key in the response (search also has `incomplete_results`,
 * /installation/repositories also has `repository_selection`), as well as a key with
 * the list of the items which name varies from endpoint to endpoint.
 *
 * Octokit normalizes these responses so that paginated results are always returned following
 * the same structure. One challenge is that if the list response has only one page, no Link
 * header is provided, so this header alone is not sufficient to check wether a response is
 * paginated or not.
 *
 * We check if a "total_count" key is present in the response data, but also make sure that
 * a "url" property is not, as the "Get the combined status for a specific ref" endpoint would
 * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
 */
function normalizePaginatedListResponse(response) {
    // endpoints can respond with 204 if repository is empty
    if (!response.data) {
        return {
            ...response,
            data: [],
        };
    }
    const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
    if (!responseNeedsNormalization)
        return response;
    // keep the additional properties intact as there is currently no other way
    // to retrieve the same information.
    const incompleteResults = response.data.incomplete_results;
    const repositorySelection = response.data.repository_selection;
    const totalCount = response.data.total_count;
    delete response.data.incomplete_results;
    delete response.data.repository_selection;
    delete response.data.total_count;
    const namespaceKey = Object.keys(response.data)[0];
    const data = response.data[namespaceKey];
    response.data = data;
    if (typeof incompleteResults !== "undefined") {
        response.data.incomplete_results = incompleteResults;
    }
    if (typeof repositorySelection !== "undefined") {
        response.data.repository_selection = repositorySelection;
    }
    response.data.total_count = totalCount;
    return response;
}

function iterator(octokit, route, parameters) {
    const options = typeof route === "function"
        ? route.endpoint(parameters)
        : octokit.request.endpoint(route, parameters);
    const requestMethod = typeof route === "function" ? route : octokit.request;
    const method = options.method;
    const headers = options.headers;
    let url = options.url;
    return {
        [Symbol.asyncIterator]: () => ({
            async next() {
                if (!url)
                    return { done: true };
                try {
                    const response = await requestMethod({ method, url, headers });
                    const normalizedResponse = normalizePaginatedListResponse(response);
                    // `response.headers.link` format:
                    // '<https://api.github.com/users/aseemk/followers?page=2>; rel="next", <https://api.github.com/users/aseemk/followers?page=2>; rel="last"'
                    // sets `url` to undefined if "next" URL is not present or `link` header is not set
                    url = ((normalizedResponse.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
                    return { value: normalizedResponse };
                }
                catch (error) {
                    if (error.status !== 409)
                        throw error;
                    url = "";
                    return {
                        value: {
                            status: 200,
                            headers: {},
                            data: [],
                        },
                    };
                }
            },
        }),
    };
}

function paginate(octokit, route, parameters, mapFn) {
    if (typeof parameters === "function") {
        mapFn = parameters;
        parameters = undefined;
    }
    return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}
function gather(octokit, results, iterator, mapFn) {
    return iterator.next().then((result) => {
        if (result.done) {
            return results;
        }
        let earlyExit = false;
        function done() {
            earlyExit = true;
        }
        results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
        if (earlyExit) {
            return results;
        }
        return gather(octokit, results, iterator, mapFn);
    });
}

const composePaginateRest = Object.assign(paginate, {
    iterator,
});

const paginatingEndpoints = [
    "GET /app/hook/deliveries",
    "GET /app/installations",
    "GET /enterprises/{enterprise}/actions/runner-groups",
    "GET /enterprises/{enterprise}/dependabot/alerts",
    "GET /enterprises/{enterprise}/secret-scanning/alerts",
    "GET /events",
    "GET /gists",
    "GET /gists/public",
    "GET /gists/starred",
    "GET /gists/{gist_id}/comments",
    "GET /gists/{gist_id}/commits",
    "GET /gists/{gist_id}/forks",
    "GET /installation/repositories",
    "GET /issues",
    "GET /licenses",
    "GET /marketplace_listing/plans",
    "GET /marketplace_listing/plans/{plan_id}/accounts",
    "GET /marketplace_listing/stubbed/plans",
    "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
    "GET /networks/{owner}/{repo}/events",
    "GET /notifications",
    "GET /organizations",
    "GET /orgs/{org}/actions/cache/usage-by-repository",
    "GET /orgs/{org}/actions/permissions/repositories",
    "GET /orgs/{org}/actions/required_workflows",
    "GET /orgs/{org}/actions/runner-groups",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners",
    "GET /orgs/{org}/actions/runners",
    "GET /orgs/{org}/actions/secrets",
    "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/actions/variables",
    "GET /orgs/{org}/actions/variables/{name}/repositories",
    "GET /orgs/{org}/blocks",
    "GET /orgs/{org}/code-scanning/alerts",
    "GET /orgs/{org}/codespaces",
    "GET /orgs/{org}/codespaces/secrets",
    "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/dependabot/alerts",
    "GET /orgs/{org}/dependabot/secrets",
    "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/events",
    "GET /orgs/{org}/failed_invitations",
    "GET /orgs/{org}/hooks",
    "GET /orgs/{org}/hooks/{hook_id}/deliveries",
    "GET /orgs/{org}/installations",
    "GET /orgs/{org}/invitations",
    "GET /orgs/{org}/invitations/{invitation_id}/teams",
    "GET /orgs/{org}/issues",
    "GET /orgs/{org}/members",
    "GET /orgs/{org}/members/{username}/codespaces",
    "GET /orgs/{org}/migrations",
    "GET /orgs/{org}/migrations/{migration_id}/repositories",
    "GET /orgs/{org}/outside_collaborators",
    "GET /orgs/{org}/packages",
    "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
    "GET /orgs/{org}/projects",
    "GET /orgs/{org}/public_members",
    "GET /orgs/{org}/repos",
    "GET /orgs/{org}/secret-scanning/alerts",
    "GET /orgs/{org}/teams",
    "GET /orgs/{org}/teams/{team_slug}/discussions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/invitations",
    "GET /orgs/{org}/teams/{team_slug}/members",
    "GET /orgs/{org}/teams/{team_slug}/projects",
    "GET /orgs/{org}/teams/{team_slug}/repos",
    "GET /orgs/{org}/teams/{team_slug}/teams",
    "GET /projects/columns/{column_id}/cards",
    "GET /projects/{project_id}/collaborators",
    "GET /projects/{project_id}/columns",
    "GET /repos/{org}/{repo}/actions/required_workflows",
    "GET /repos/{owner}/{repo}/actions/artifacts",
    "GET /repos/{owner}/{repo}/actions/caches",
    "GET /repos/{owner}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/runs",
    "GET /repos/{owner}/{repo}/actions/runners",
    "GET /repos/{owner}/{repo}/actions/runs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
    "GET /repos/{owner}/{repo}/actions/secrets",
    "GET /repos/{owner}/{repo}/actions/variables",
    "GET /repos/{owner}/{repo}/actions/workflows",
    "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
    "GET /repos/{owner}/{repo}/assignees",
    "GET /repos/{owner}/{repo}/branches",
    "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
    "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
    "GET /repos/{owner}/{repo}/code-scanning/alerts",
    "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
    "GET /repos/{owner}/{repo}/code-scanning/analyses",
    "GET /repos/{owner}/{repo}/codespaces",
    "GET /repos/{owner}/{repo}/codespaces/devcontainers",
    "GET /repos/{owner}/{repo}/codespaces/secrets",
    "GET /repos/{owner}/{repo}/collaborators",
    "GET /repos/{owner}/{repo}/comments",
    "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/commits",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
    "GET /repos/{owner}/{repo}/commits/{ref}/status",
    "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
    "GET /repos/{owner}/{repo}/contributors",
    "GET /repos/{owner}/{repo}/dependabot/alerts",
    "GET /repos/{owner}/{repo}/dependabot/secrets",
    "GET /repos/{owner}/{repo}/deployments",
    "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
    "GET /repos/{owner}/{repo}/environments",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
    "GET /repos/{owner}/{repo}/events",
    "GET /repos/{owner}/{repo}/forks",
    "GET /repos/{owner}/{repo}/hooks",
    "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
    "GET /repos/{owner}/{repo}/invitations",
    "GET /repos/{owner}/{repo}/issues",
    "GET /repos/{owner}/{repo}/issues/comments",
    "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/issues/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
    "GET /repos/{owner}/{repo}/keys",
    "GET /repos/{owner}/{repo}/labels",
    "GET /repos/{owner}/{repo}/milestones",
    "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
    "GET /repos/{owner}/{repo}/notifications",
    "GET /repos/{owner}/{repo}/pages/builds",
    "GET /repos/{owner}/{repo}/projects",
    "GET /repos/{owner}/{repo}/pulls",
    "GET /repos/{owner}/{repo}/pulls/comments",
    "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
    "GET /repos/{owner}/{repo}/releases",
    "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
    "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
    "GET /repos/{owner}/{repo}/stargazers",
    "GET /repos/{owner}/{repo}/subscribers",
    "GET /repos/{owner}/{repo}/tags",
    "GET /repos/{owner}/{repo}/teams",
    "GET /repos/{owner}/{repo}/topics",
    "GET /repositories",
    "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
    "GET /repositories/{repository_id}/environments/{environment_name}/variables",
    "GET /search/code",
    "GET /search/commits",
    "GET /search/issues",
    "GET /search/labels",
    "GET /search/repositories",
    "GET /search/topics",
    "GET /search/users",
    "GET /teams/{team_id}/discussions",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
    "GET /teams/{team_id}/invitations",
    "GET /teams/{team_id}/members",
    "GET /teams/{team_id}/projects",
    "GET /teams/{team_id}/repos",
    "GET /teams/{team_id}/teams",
    "GET /user/blocks",
    "GET /user/codespaces",
    "GET /user/codespaces/secrets",
    "GET /user/emails",
    "GET /user/followers",
    "GET /user/following",
    "GET /user/gpg_keys",
    "GET /user/installations",
    "GET /user/installations/{installation_id}/repositories",
    "GET /user/issues",
    "GET /user/keys",
    "GET /user/marketplace_purchases",
    "GET /user/marketplace_purchases/stubbed",
    "GET /user/memberships/orgs",
    "GET /user/migrations",
    "GET /user/migrations/{migration_id}/repositories",
    "GET /user/orgs",
    "GET /user/packages",
    "GET /user/packages/{package_type}/{package_name}/versions",
    "GET /user/public_emails",
    "GET /user/repos",
    "GET /user/repository_invitations",
    "GET /user/ssh_signing_keys",
    "GET /user/starred",
    "GET /user/subscriptions",
    "GET /user/teams",
    "GET /users",
    "GET /users/{username}/events",
    "GET /users/{username}/events/orgs/{org}",
    "GET /users/{username}/events/public",
    "GET /users/{username}/followers",
    "GET /users/{username}/following",
    "GET /users/{username}/gists",
    "GET /users/{username}/gpg_keys",
    "GET /users/{username}/keys",
    "GET /users/{username}/orgs",
    "GET /users/{username}/packages",
    "GET /users/{username}/projects",
    "GET /users/{username}/received_events",
    "GET /users/{username}/received_events/public",
    "GET /users/{username}/repos",
    "GET /users/{username}/ssh_signing_keys",
    "GET /users/{username}/starred",
    "GET /users/{username}/subscriptions",
];

function isPaginatingEndpoint(arg) {
    if (typeof arg === "string") {
        return paginatingEndpoints.includes(arg);
    }
    else {
        return false;
    }
}

/**
 * @param octokit Octokit instance
 * @param options Options passed to Octokit constructor
 */
function paginateRest(octokit) {
    return {
        paginate: Object.assign(paginate.bind(null, octokit), {
            iterator: iterator.bind(null, octokit),
        }),
    };
}
paginateRest.VERSION = VERSION;




/***/ }),

/***/ "./node_modules/@octokit/plugin-request-log/dist-web/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@octokit/plugin-request-log/dist-web/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   requestLog: () => (/* binding */ requestLog)
/* harmony export */ });
const VERSION = "1.0.4";

/**
 * @param octokit Octokit instance
 * @param options Options passed to Octokit constructor
 */
function requestLog(octokit) {
    octokit.hook.wrap("request", (request, options) => {
        octokit.log.debug("request", options);
        const start = Date.now();
        const requestOptions = octokit.request.endpoint.parse(options);
        const path = requestOptions.url.replace(options.baseUrl, "");
        return request(options)
            .then((response) => {
            octokit.log.info(`${requestOptions.method} ${path} - ${response.status} in ${Date.now() - start}ms`);
            return response;
        })
            .catch((error) => {
            octokit.log.info(`${requestOptions.method} ${path} - ${error.status} in ${Date.now() - start}ms`);
            throw error;
        });
    });
}
requestLog.VERSION = VERSION;




/***/ }),

/***/ "./node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   legacyRestEndpointMethods: () => (/* binding */ legacyRestEndpointMethods),
/* harmony export */   restEndpointMethods: () => (/* binding */ restEndpointMethods)
/* harmony export */ });
const Endpoints = {
    actions: {
        addCustomLabelsToSelfHostedRunnerForOrg: [
            "POST /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        addCustomLabelsToSelfHostedRunnerForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
        ],
        addSelectedRepoToOrgVariable: [
            "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}",
        ],
        addSelectedRepoToRequiredWorkflow: [
            "PUT /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories/{repository_id}",
        ],
        approveWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve",
        ],
        cancelWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel",
        ],
        createEnvironmentVariable: [
            "POST /repositories/{repository_id}/environments/{environment_name}/variables",
        ],
        createOrUpdateEnvironmentSecret: [
            "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
        ],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}",
        ],
        createOrgVariable: ["POST /orgs/{org}/actions/variables"],
        createRegistrationTokenForOrg: [
            "POST /orgs/{org}/actions/runners/registration-token",
        ],
        createRegistrationTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/registration-token",
        ],
        createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
        createRemoveTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/remove-token",
        ],
        createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
        createRequiredWorkflow: ["POST /orgs/{org}/actions/required_workflows"],
        createWorkflowDispatch: [
            "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches",
        ],
        deleteActionsCacheById: [
            "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}",
        ],
        deleteActionsCacheByKey: [
            "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}",
        ],
        deleteArtifact: [
            "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}",
        ],
        deleteEnvironmentSecret: [
            "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
        ],
        deleteEnvironmentVariable: [
            "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}",
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
        deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}",
        ],
        deleteRepoVariable: [
            "DELETE /repos/{owner}/{repo}/actions/variables/{name}",
        ],
        deleteRequiredWorkflow: [
            "DELETE /orgs/{org}/actions/required_workflows/{required_workflow_id}",
        ],
        deleteSelfHostedRunnerFromOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}",
        ],
        deleteSelfHostedRunnerFromRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}",
        ],
        deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
        deleteWorkflowRunLogs: [
            "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
        ],
        disableSelectedRepositoryGithubActionsOrganization: [
            "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}",
        ],
        disableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable",
        ],
        downloadArtifact: [
            "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}",
        ],
        downloadJobLogsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs",
        ],
        downloadWorkflowRunAttemptLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs",
        ],
        downloadWorkflowRunLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
        ],
        enableSelectedRepositoryGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}",
        ],
        enableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable",
        ],
        getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
        getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
        getActionsCacheUsageByRepoForOrg: [
            "GET /orgs/{org}/actions/cache/usage-by-repository",
        ],
        getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
        getAllowedActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/selected-actions",
        ],
        getAllowedActionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/selected-actions",
        ],
        getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        getEnvironmentPublicKey: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key",
        ],
        getEnvironmentSecret: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}",
        ],
        getEnvironmentVariable: [
            "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}",
        ],
        getGithubActionsDefaultWorkflowPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions/workflow",
        ],
        getGithubActionsDefaultWorkflowPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/workflow",
        ],
        getGithubActionsPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions",
        ],
        getGithubActionsPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions",
        ],
        getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
        getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
        getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
        getPendingDeploymentsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
        ],
        getRepoPermissions: [
            "GET /repos/{owner}/{repo}/actions/permissions",
            {},
            { renamed: ["actions", "getGithubActionsPermissionsRepository"] },
        ],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
        getRepoRequiredWorkflow: [
            "GET /repos/{org}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}",
        ],
        getRepoRequiredWorkflowUsage: [
            "GET /repos/{org}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/timing",
        ],
        getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
        getRequiredWorkflow: [
            "GET /orgs/{org}/actions/required_workflows/{required_workflow_id}",
        ],
        getReviewsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals",
        ],
        getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
        getSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}",
        ],
        getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
        getWorkflowAccessToRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/access",
        ],
        getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
        getWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}",
        ],
        getWorkflowRunUsage: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing",
        ],
        getWorkflowUsage: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing",
        ],
        listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
        listEnvironmentSecrets: [
            "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
        ],
        listEnvironmentVariables: [
            "GET /repositories/{repository_id}/environments/{environment_name}/variables",
        ],
        listJobsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
        ],
        listJobsForWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
        ],
        listLabelsForSelfHostedRunnerForOrg: [
            "GET /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        listLabelsForSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
        listOrgVariables: ["GET /orgs/{org}/actions/variables"],
        listRepoRequiredWorkflows: [
            "GET /repos/{org}/{repo}/actions/required_workflows",
        ],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
        listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
        listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
        listRequiredWorkflowRuns: [
            "GET /repos/{owner}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/runs",
        ],
        listRequiredWorkflows: ["GET /orgs/{org}/actions/required_workflows"],
        listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
        listRunnerApplicationsForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/downloads",
        ],
        listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
        ],
        listSelectedReposForOrgVariable: [
            "GET /orgs/{org}/actions/variables/{name}/repositories",
        ],
        listSelectedRepositoriesEnabledGithubActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/repositories",
        ],
        listSelectedRepositoriesRequiredWorkflow: [
            "GET /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories",
        ],
        listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
        listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
        listWorkflowRunArtifacts: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
        ],
        listWorkflowRuns: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
        ],
        listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
        reRunJobForWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun",
        ],
        reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
        reRunWorkflowFailedJobs: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs",
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        removeCustomLabelFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}",
        ],
        removeCustomLabelFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}",
        ],
        removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
        ],
        removeSelectedRepoFromOrgVariable: [
            "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}",
        ],
        removeSelectedRepoFromRequiredWorkflow: [
            "DELETE /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories/{repository_id}",
        ],
        reviewPendingDeploymentsForRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
        ],
        setAllowedActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/selected-actions",
        ],
        setAllowedActionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions",
        ],
        setCustomLabelsForSelfHostedRunnerForOrg: [
            "PUT /orgs/{org}/actions/runners/{runner_id}/labels",
        ],
        setCustomLabelsForSelfHostedRunnerForRepo: [
            "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
        ],
        setGithubActionsDefaultWorkflowPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/workflow",
        ],
        setGithubActionsDefaultWorkflowPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/workflow",
        ],
        setGithubActionsPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions",
        ],
        setGithubActionsPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions",
        ],
        setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories",
        ],
        setSelectedReposForOrgVariable: [
            "PUT /orgs/{org}/actions/variables/{name}/repositories",
        ],
        setSelectedReposToRequiredWorkflow: [
            "PUT /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories",
        ],
        setSelectedRepositoriesEnabledGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories",
        ],
        setWorkflowAccessToRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/access",
        ],
        updateEnvironmentVariable: [
            "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}",
        ],
        updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
        updateRepoVariable: [
            "PATCH /repos/{owner}/{repo}/actions/variables/{name}",
        ],
        updateRequiredWorkflow: [
            "PATCH /orgs/{org}/actions/required_workflows/{required_workflow_id}",
        ],
    },
    activity: {
        checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
        deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
        deleteThreadSubscription: [
            "DELETE /notifications/threads/{thread_id}/subscription",
        ],
        getFeeds: ["GET /feeds"],
        getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
        getThread: ["GET /notifications/threads/{thread_id}"],
        getThreadSubscriptionForAuthenticatedUser: [
            "GET /notifications/threads/{thread_id}/subscription",
        ],
        listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
        listNotificationsForAuthenticatedUser: ["GET /notifications"],
        listOrgEventsForAuthenticatedUser: [
            "GET /users/{username}/events/orgs/{org}",
        ],
        listPublicEvents: ["GET /events"],
        listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
        listPublicEventsForUser: ["GET /users/{username}/events/public"],
        listPublicOrgEvents: ["GET /orgs/{org}/events"],
        listReceivedEventsForUser: ["GET /users/{username}/received_events"],
        listReceivedPublicEventsForUser: [
            "GET /users/{username}/received_events/public",
        ],
        listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
        listRepoNotificationsForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/notifications",
        ],
        listReposStarredByAuthenticatedUser: ["GET /user/starred"],
        listReposStarredByUser: ["GET /users/{username}/starred"],
        listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
        listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
        listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
        listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
        markNotificationsAsRead: ["PUT /notifications"],
        markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
        markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
        setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
        setThreadSubscription: [
            "PUT /notifications/threads/{thread_id}/subscription",
        ],
        starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
        unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"],
    },
    apps: {
        addRepoToInstallation: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] },
        ],
        addRepoToInstallationForAuthenticatedUser: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}",
        ],
        checkToken: ["POST /applications/{client_id}/token"],
        createFromManifest: ["POST /app-manifests/{code}/conversions"],
        createInstallationAccessToken: [
            "POST /app/installations/{installation_id}/access_tokens",
        ],
        deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
        deleteInstallation: ["DELETE /app/installations/{installation_id}"],
        deleteToken: ["DELETE /applications/{client_id}/token"],
        getAuthenticated: ["GET /app"],
        getBySlug: ["GET /apps/{app_slug}"],
        getInstallation: ["GET /app/installations/{installation_id}"],
        getOrgInstallation: ["GET /orgs/{org}/installation"],
        getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
        getSubscriptionPlanForAccount: [
            "GET /marketplace_listing/accounts/{account_id}",
        ],
        getSubscriptionPlanForAccountStubbed: [
            "GET /marketplace_listing/stubbed/accounts/{account_id}",
        ],
        getUserInstallation: ["GET /users/{username}/installation"],
        getWebhookConfigForApp: ["GET /app/hook/config"],
        getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
        listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
        listAccountsForPlanStubbed: [
            "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
        ],
        listInstallationReposForAuthenticatedUser: [
            "GET /user/installations/{installation_id}/repositories",
        ],
        listInstallations: ["GET /app/installations"],
        listInstallationsForAuthenticatedUser: ["GET /user/installations"],
        listPlans: ["GET /marketplace_listing/plans"],
        listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
        listReposAccessibleToInstallation: ["GET /installation/repositories"],
        listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
        listSubscriptionsForAuthenticatedUserStubbed: [
            "GET /user/marketplace_purchases/stubbed",
        ],
        listWebhookDeliveries: ["GET /app/hook/deliveries"],
        redeliverWebhookDelivery: [
            "POST /app/hook/deliveries/{delivery_id}/attempts",
        ],
        removeRepoFromInstallation: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] },
        ],
        removeRepoFromInstallationForAuthenticatedUser: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
        ],
        resetToken: ["PATCH /applications/{client_id}/token"],
        revokeInstallationAccessToken: ["DELETE /installation/token"],
        scopeToken: ["POST /applications/{client_id}/token/scoped"],
        suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
        unsuspendInstallation: [
            "DELETE /app/installations/{installation_id}/suspended",
        ],
        updateWebhookConfigForApp: ["PATCH /app/hook/config"],
    },
    billing: {
        getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
        getGithubActionsBillingUser: [
            "GET /users/{username}/settings/billing/actions",
        ],
        getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
        getGithubPackagesBillingUser: [
            "GET /users/{username}/settings/billing/packages",
        ],
        getSharedStorageBillingOrg: [
            "GET /orgs/{org}/settings/billing/shared-storage",
        ],
        getSharedStorageBillingUser: [
            "GET /users/{username}/settings/billing/shared-storage",
        ],
    },
    checks: {
        create: ["POST /repos/{owner}/{repo}/check-runs"],
        createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
        get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
        getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
        listAnnotations: [
            "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
        ],
        listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
        listForSuite: [
            "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
        ],
        listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
        rerequestRun: [
            "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest",
        ],
        rerequestSuite: [
            "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest",
        ],
        setSuitesPreferences: [
            "PATCH /repos/{owner}/{repo}/check-suites/preferences",
        ],
        update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    },
    codeScanning: {
        deleteAnalysis: [
            "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}",
        ],
        getAlert: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
            {},
            { renamedParameters: { alert_id: "alert_number" } },
        ],
        getAnalysis: [
            "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}",
        ],
        getCodeqlDatabase: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}",
        ],
        getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
        listAlertInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
        ],
        listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
        listAlertsInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
            {},
            { renamed: ["codeScanning", "listAlertInstances"] },
        ],
        listCodeqlDatabases: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/databases",
        ],
        listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
        updateAlert: [
            "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
        ],
        uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"],
    },
    codesOfConduct: {
        getAllCodesOfConduct: ["GET /codes_of_conduct"],
        getConductCode: ["GET /codes_of_conduct/{key}"],
    },
    codespaces: {
        addRepositoryForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}",
        ],
        addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}",
        ],
        codespaceMachinesForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/machines",
        ],
        createForAuthenticatedUser: ["POST /user/codespaces"],
        createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}",
        ],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
        ],
        createOrUpdateSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}",
        ],
        createWithPrForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces",
        ],
        createWithRepoForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/codespaces",
        ],
        deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
        deleteFromOrganization: [
            "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}",
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
        ],
        deleteSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}",
        ],
        exportForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/exports",
        ],
        getCodespacesForUserInOrg: [
            "GET /orgs/{org}/members/{username}/codespaces",
        ],
        getExportDetailsForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/exports/{export_id}",
        ],
        getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
        getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
        getPublicKeyForAuthenticatedUser: [
            "GET /user/codespaces/secrets/public-key",
        ],
        getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/public-key",
        ],
        getRepoSecret: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
        ],
        getSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}",
        ],
        listDevcontainersInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/devcontainers",
        ],
        listForAuthenticatedUser: ["GET /user/codespaces"],
        listInOrganization: [
            "GET /orgs/{org}/codespaces",
            {},
            { renamedParameters: { org_id: "org" } },
        ],
        listInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces",
        ],
        listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
        listRepositoriesForSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}/repositories",
        ],
        listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
        listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
        ],
        preFlightWithRepoForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/new",
        ],
        publishForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/publish",
        ],
        removeRepositoryForSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}",
        ],
        removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}",
        ],
        repoMachinesForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/machines",
        ],
        setCodespacesBilling: ["PUT /orgs/{org}/codespaces/billing"],
        setRepositoriesForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories",
        ],
        setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
        ],
        startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
        stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
        stopInOrganization: [
            "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop",
        ],
        updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"],
    },
    dependabot: {
        addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}",
        ],
        createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}",
        ],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
        ],
        deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
        ],
        getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
        getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
        getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/public-key",
        ],
        getRepoSecret: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
        ],
        listAlertsForEnterprise: [
            "GET /enterprises/{enterprise}/dependabot/alerts",
        ],
        listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
        listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
        listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
        ],
        removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}",
        ],
        setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
        ],
        updateAlert: [
            "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}",
        ],
    },
    dependencyGraph: {
        createRepositorySnapshot: [
            "POST /repos/{owner}/{repo}/dependency-graph/snapshots",
        ],
        diffRange: [
            "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}",
        ],
    },
    emojis: { get: ["GET /emojis"] },
    enterpriseAdmin: {
        addCustomLabelsToSelfHostedRunnerForEnterprise: [
            "POST /enterprises/{enterprise}/actions/runners/{runner_id}/labels",
        ],
        enableSelectedOrganizationGithubActionsEnterprise: [
            "PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}",
        ],
        listLabelsForSelfHostedRunnerForEnterprise: [
            "GET /enterprises/{enterprise}/actions/runners/{runner_id}/labels",
        ],
    },
    gists: {
        checkIsStarred: ["GET /gists/{gist_id}/star"],
        create: ["POST /gists"],
        createComment: ["POST /gists/{gist_id}/comments"],
        delete: ["DELETE /gists/{gist_id}"],
        deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
        fork: ["POST /gists/{gist_id}/forks"],
        get: ["GET /gists/{gist_id}"],
        getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
        getRevision: ["GET /gists/{gist_id}/{sha}"],
        list: ["GET /gists"],
        listComments: ["GET /gists/{gist_id}/comments"],
        listCommits: ["GET /gists/{gist_id}/commits"],
        listForUser: ["GET /users/{username}/gists"],
        listForks: ["GET /gists/{gist_id}/forks"],
        listPublic: ["GET /gists/public"],
        listStarred: ["GET /gists/starred"],
        star: ["PUT /gists/{gist_id}/star"],
        unstar: ["DELETE /gists/{gist_id}/star"],
        update: ["PATCH /gists/{gist_id}"],
        updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"],
    },
    git: {
        createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
        createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
        createRef: ["POST /repos/{owner}/{repo}/git/refs"],
        createTag: ["POST /repos/{owner}/{repo}/git/tags"],
        createTree: ["POST /repos/{owner}/{repo}/git/trees"],
        deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
        getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
        getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
        getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
        getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
        getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
        listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
        updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"],
    },
    gitignore: {
        getAllTemplates: ["GET /gitignore/templates"],
        getTemplate: ["GET /gitignore/templates/{name}"],
    },
    interactions: {
        getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
        getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
        getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
        getRestrictionsForYourPublicRepos: [
            "GET /user/interaction-limits",
            {},
            { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] },
        ],
        removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
        removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
        removeRestrictionsForRepo: [
            "DELETE /repos/{owner}/{repo}/interaction-limits",
        ],
        removeRestrictionsForYourPublicRepos: [
            "DELETE /user/interaction-limits",
            {},
            { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] },
        ],
        setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
        setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
        setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
        setRestrictionsForYourPublicRepos: [
            "PUT /user/interaction-limits",
            {},
            { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] },
        ],
    },
    issues: {
        addAssignees: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees",
        ],
        addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
        checkUserCanBeAssignedToIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}",
        ],
        create: ["POST /repos/{owner}/{repo}/issues"],
        createComment: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/comments",
        ],
        createLabel: ["POST /repos/{owner}/{repo}/labels"],
        createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
        deleteComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}",
        ],
        deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
        deleteMilestone: [
            "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}",
        ],
        get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
        getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
        getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
        getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
        list: ["GET /issues"],
        listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
        listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
        listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
        listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
        listEventsForTimeline: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
        ],
        listForAuthenticatedUser: ["GET /user/issues"],
        listForOrg: ["GET /orgs/{org}/issues"],
        listForRepo: ["GET /repos/{owner}/{repo}/issues"],
        listLabelsForMilestone: [
            "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
        ],
        listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
        listLabelsOnIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
        ],
        listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
        lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        removeAllLabels: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels",
        ],
        removeAssignees: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees",
        ],
        removeLabel: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}",
        ],
        setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
        updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
        updateMilestone: [
            "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}",
        ],
    },
    licenses: {
        get: ["GET /licenses/{license}"],
        getAllCommonlyUsed: ["GET /licenses"],
        getForRepo: ["GET /repos/{owner}/{repo}/license"],
    },
    markdown: {
        render: ["POST /markdown"],
        renderRaw: [
            "POST /markdown/raw",
            { headers: { "content-type": "text/plain; charset=utf-8" } },
        ],
    },
    meta: {
        get: ["GET /meta"],
        getAllVersions: ["GET /versions"],
        getOctocat: ["GET /octocat"],
        getZen: ["GET /zen"],
        root: ["GET /"],
    },
    migrations: {
        cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
        deleteArchiveForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/archive",
        ],
        deleteArchiveForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/archive",
        ],
        downloadArchiveForOrg: [
            "GET /orgs/{org}/migrations/{migration_id}/archive",
        ],
        getArchiveForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/archive",
        ],
        getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
        getImportStatus: ["GET /repos/{owner}/{repo}/import"],
        getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
        getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
        getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
        listForAuthenticatedUser: ["GET /user/migrations"],
        listForOrg: ["GET /orgs/{org}/migrations"],
        listReposForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/repositories",
        ],
        listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
        listReposForUser: [
            "GET /user/migrations/{migration_id}/repositories",
            {},
            { renamed: ["migrations", "listReposForAuthenticatedUser"] },
        ],
        mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
        setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
        startForAuthenticatedUser: ["POST /user/migrations"],
        startForOrg: ["POST /orgs/{org}/migrations"],
        startImport: ["PUT /repos/{owner}/{repo}/import"],
        unlockRepoForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock",
        ],
        unlockRepoForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock",
        ],
        updateImport: ["PATCH /repos/{owner}/{repo}/import"],
    },
    orgs: {
        addSecurityManagerTeam: [
            "PUT /orgs/{org}/security-managers/teams/{team_slug}",
        ],
        blockUser: ["PUT /orgs/{org}/blocks/{username}"],
        cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
        checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
        checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
        checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
        convertMemberToOutsideCollaborator: [
            "PUT /orgs/{org}/outside_collaborators/{username}",
        ],
        createInvitation: ["POST /orgs/{org}/invitations"],
        createWebhook: ["POST /orgs/{org}/hooks"],
        deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
        enableOrDisableSecurityProductOnAllOrgRepos: [
            "POST /orgs/{org}/{security_product}/{enablement}",
        ],
        get: ["GET /orgs/{org}"],
        getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
        getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
        getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
        getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
        getWebhookDelivery: [
            "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}",
        ],
        list: ["GET /organizations"],
        listAppInstallations: ["GET /orgs/{org}/installations"],
        listBlockedUsers: ["GET /orgs/{org}/blocks"],
        listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
        listForAuthenticatedUser: ["GET /user/orgs"],
        listForUser: ["GET /users/{username}/orgs"],
        listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
        listMembers: ["GET /orgs/{org}/members"],
        listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
        listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
        listPendingInvitations: ["GET /orgs/{org}/invitations"],
        listPublicMembers: ["GET /orgs/{org}/public_members"],
        listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
        listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /orgs/{org}/hooks"],
        pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
            "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
        ],
        removeMember: ["DELETE /orgs/{org}/members/{username}"],
        removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
        removeOutsideCollaborator: [
            "DELETE /orgs/{org}/outside_collaborators/{username}",
        ],
        removePublicMembershipForAuthenticatedUser: [
            "DELETE /orgs/{org}/public_members/{username}",
        ],
        removeSecurityManagerTeam: [
            "DELETE /orgs/{org}/security-managers/teams/{team_slug}",
        ],
        setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
        setPublicMembershipForAuthenticatedUser: [
            "PUT /orgs/{org}/public_members/{username}",
        ],
        unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
        update: ["PATCH /orgs/{org}"],
        updateMembershipForAuthenticatedUser: [
            "PATCH /user/memberships/orgs/{org}",
        ],
        updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
        updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"],
    },
    packages: {
        deletePackageForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}",
        ],
        deletePackageForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}",
        ],
        deletePackageForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}",
        ],
        deletePackageVersionForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        deletePackageVersionForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        deletePackageVersionForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        getAllPackageVersionsForAPackageOwnedByAnOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
            {},
            { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] },
        ],
        getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions",
            {},
            {
                renamed: [
                    "packages",
                    "getAllPackageVersionsForPackageOwnedByAuthenticatedUser",
                ],
            },
        ],
        getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions",
        ],
        getAllPackageVersionsForPackageOwnedByOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
        ],
        getAllPackageVersionsForPackageOwnedByUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions",
        ],
        getPackageForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}",
        ],
        getPackageForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}",
        ],
        getPackageForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}",
        ],
        getPackageVersionForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        getPackageVersionForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        getPackageVersionForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
        ],
        listPackagesForAuthenticatedUser: ["GET /user/packages"],
        listPackagesForOrganization: ["GET /orgs/{org}/packages"],
        listPackagesForUser: ["GET /users/{username}/packages"],
        restorePackageForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/restore{?token}",
        ],
        restorePackageForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}",
        ],
        restorePackageForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}",
        ],
        restorePackageVersionForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
        ],
        restorePackageVersionForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
        ],
        restorePackageVersionForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
        ],
    },
    projects: {
        addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
        createCard: ["POST /projects/columns/{column_id}/cards"],
        createColumn: ["POST /projects/{project_id}/columns"],
        createForAuthenticatedUser: ["POST /user/projects"],
        createForOrg: ["POST /orgs/{org}/projects"],
        createForRepo: ["POST /repos/{owner}/{repo}/projects"],
        delete: ["DELETE /projects/{project_id}"],
        deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
        deleteColumn: ["DELETE /projects/columns/{column_id}"],
        get: ["GET /projects/{project_id}"],
        getCard: ["GET /projects/columns/cards/{card_id}"],
        getColumn: ["GET /projects/columns/{column_id}"],
        getPermissionForUser: [
            "GET /projects/{project_id}/collaborators/{username}/permission",
        ],
        listCards: ["GET /projects/columns/{column_id}/cards"],
        listCollaborators: ["GET /projects/{project_id}/collaborators"],
        listColumns: ["GET /projects/{project_id}/columns"],
        listForOrg: ["GET /orgs/{org}/projects"],
        listForRepo: ["GET /repos/{owner}/{repo}/projects"],
        listForUser: ["GET /users/{username}/projects"],
        moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
        moveColumn: ["POST /projects/columns/{column_id}/moves"],
        removeCollaborator: [
            "DELETE /projects/{project_id}/collaborators/{username}",
        ],
        update: ["PATCH /projects/{project_id}"],
        updateCard: ["PATCH /projects/columns/cards/{card_id}"],
        updateColumn: ["PATCH /projects/columns/{column_id}"],
    },
    pulls: {
        checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        create: ["POST /repos/{owner}/{repo}/pulls"],
        createReplyForReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies",
        ],
        createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        createReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments",
        ],
        deletePendingReview: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
        ],
        deleteReviewComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}",
        ],
        dismissReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals",
        ],
        get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
        getReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
        ],
        getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        list: ["GET /repos/{owner}/{repo}/pulls"],
        listCommentsForReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
        ],
        listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
        listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
        listRequestedReviewers: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
        ],
        listReviewComments: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
        ],
        listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
        listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        removeRequestedReviewers: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
        ],
        requestReviewers: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
        ],
        submitReview: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events",
        ],
        update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
        updateBranch: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch",
        ],
        updateReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
        ],
        updateReviewComment: [
            "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}",
        ],
    },
    rateLimit: { get: ["GET /rate_limit"] },
    reactions: {
        createForCommitComment: [
            "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions",
        ],
        createForIssue: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions",
        ],
        createForIssueComment: [
            "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
        ],
        createForPullRequestReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
        ],
        createForRelease: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/reactions",
        ],
        createForTeamDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
        ],
        createForTeamDiscussionInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
        ],
        deleteForCommitComment: [
            "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}",
        ],
        deleteForIssue: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}",
        ],
        deleteForIssueComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}",
        ],
        deleteForPullRequestComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}",
        ],
        deleteForRelease: [
            "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}",
        ],
        deleteForTeamDiscussion: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}",
        ],
        deleteForTeamDiscussionComment: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}",
        ],
        listForCommitComment: [
            "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
        ],
        listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        listForIssueComment: [
            "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
        ],
        listForPullRequestReviewComment: [
            "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
        ],
        listForRelease: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
        ],
        listForTeamDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
        ],
        listForTeamDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
        ],
    },
    repos: {
        acceptInvitation: [
            "PATCH /user/repository_invitations/{invitation_id}",
            {},
            { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] },
        ],
        acceptInvitationForAuthenticatedUser: [
            "PATCH /user/repository_invitations/{invitation_id}",
        ],
        addAppAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
        ],
        addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
        addStatusCheckContexts: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
        ],
        addTeamAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
        ],
        addUserAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
        ],
        checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
        checkVulnerabilityAlerts: [
            "GET /repos/{owner}/{repo}/vulnerability-alerts",
        ],
        codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
        compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
        compareCommitsWithBasehead: [
            "GET /repos/{owner}/{repo}/compare/{basehead}",
        ],
        createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
        createCommitComment: [
            "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments",
        ],
        createCommitSignatureProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
        ],
        createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
        createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
        createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
        createDeploymentBranchPolicy: [
            "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
        ],
        createDeploymentStatus: [
            "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
        ],
        createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
        createForAuthenticatedUser: ["POST /user/repos"],
        createFork: ["POST /repos/{owner}/{repo}/forks"],
        createInOrg: ["POST /orgs/{org}/repos"],
        createOrUpdateEnvironment: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}",
        ],
        createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
        createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployment"],
        createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
        createRelease: ["POST /repos/{owner}/{repo}/releases"],
        createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
        createUsingTemplate: [
            "POST /repos/{template_owner}/{template_repo}/generate",
        ],
        createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
        declineInvitation: [
            "DELETE /user/repository_invitations/{invitation_id}",
            {},
            { renamed: ["repos", "declineInvitationForAuthenticatedUser"] },
        ],
        declineInvitationForAuthenticatedUser: [
            "DELETE /user/repository_invitations/{invitation_id}",
        ],
        delete: ["DELETE /repos/{owner}/{repo}"],
        deleteAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
        ],
        deleteAdminBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
        ],
        deleteAnEnvironment: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}",
        ],
        deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        deleteBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection",
        ],
        deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
        deleteCommitSignatureProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
        ],
        deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
        deleteDeployment: [
            "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}",
        ],
        deleteDeploymentBranchPolicy: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}",
        ],
        deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
        deleteInvitation: [
            "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}",
        ],
        deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
        deletePullRequestReviewProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
        ],
        deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
        deleteReleaseAsset: [
            "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}",
        ],
        deleteTagProtection: [
            "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}",
        ],
        deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
        disableAutomatedSecurityFixes: [
            "DELETE /repos/{owner}/{repo}/automated-security-fixes",
        ],
        disableLfsForRepo: ["DELETE /repos/{owner}/{repo}/lfs"],
        disableVulnerabilityAlerts: [
            "DELETE /repos/{owner}/{repo}/vulnerability-alerts",
        ],
        downloadArchive: [
            "GET /repos/{owner}/{repo}/zipball/{ref}",
            {},
            { renamed: ["repos", "downloadZipballArchive"] },
        ],
        downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
        downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
        enableAutomatedSecurityFixes: [
            "PUT /repos/{owner}/{repo}/automated-security-fixes",
        ],
        enableLfsForRepo: ["PUT /repos/{owner}/{repo}/lfs"],
        enableVulnerabilityAlerts: [
            "PUT /repos/{owner}/{repo}/vulnerability-alerts",
        ],
        generateReleaseNotes: [
            "POST /repos/{owner}/{repo}/releases/generate-notes",
        ],
        get: ["GET /repos/{owner}/{repo}"],
        getAccessRestrictions: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
        ],
        getAdminBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
        ],
        getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
        getAllStatusCheckContexts: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        ],
        getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
        getAppsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        ],
        getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
        getBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection",
        ],
        getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
        getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
        getCollaboratorPermissionLevel: [
            "GET /repos/{owner}/{repo}/collaborators/{username}/permission",
        ],
        getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
        getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
        getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
        getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
        getCommitSignatureProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
        ],
        getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
        getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
        getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
        getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
        getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
        getDeploymentBranchPolicy: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}",
        ],
        getDeploymentStatus: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}",
        ],
        getEnvironment: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}",
        ],
        getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
        getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
        getPages: ["GET /repos/{owner}/{repo}/pages"],
        getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
        getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
        getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
        getPullRequestReviewProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
        ],
        getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
        getReadme: ["GET /repos/{owner}/{repo}/readme"],
        getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
        getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
        getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
        getStatusChecksProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        ],
        getTeamsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        ],
        getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
        getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
        getUsersWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        ],
        getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
        getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
        getWebhookConfigForRepo: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/config",
        ],
        getWebhookDelivery: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}",
        ],
        listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
        listBranches: ["GET /repos/{owner}/{repo}/branches"],
        listBranchesForHeadCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head",
        ],
        listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
        listCommentsForCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
        ],
        listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
        listCommitStatusesForRef: [
            "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
        ],
        listCommits: ["GET /repos/{owner}/{repo}/commits"],
        listContributors: ["GET /repos/{owner}/{repo}/contributors"],
        listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
        listDeploymentBranchPolicies: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
        ],
        listDeploymentStatuses: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
        ],
        listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
        listForAuthenticatedUser: ["GET /user/repos"],
        listForOrg: ["GET /orgs/{org}/repos"],
        listForUser: ["GET /users/{username}/repos"],
        listForks: ["GET /repos/{owner}/{repo}/forks"],
        listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
        listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
        listLanguages: ["GET /repos/{owner}/{repo}/languages"],
        listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
        listPublic: ["GET /repositories"],
        listPullRequestsAssociatedWithCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
        ],
        listReleaseAssets: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
        ],
        listReleases: ["GET /repos/{owner}/{repo}/releases"],
        listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
        listTags: ["GET /repos/{owner}/{repo}/tags"],
        listTeams: ["GET /repos/{owner}/{repo}/teams"],
        listWebhookDeliveries: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
        ],
        listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
        merge: ["POST /repos/{owner}/{repo}/merges"],
        mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
        pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: [
            "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
        ],
        removeAppAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
        ],
        removeCollaborator: [
            "DELETE /repos/{owner}/{repo}/collaborators/{username}",
        ],
        removeStatusCheckContexts: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
        ],
        removeStatusCheckProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        ],
        removeTeamAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
        ],
        removeUserAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
        ],
        renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
        replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
        requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
        setAdminBranchProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
        ],
        setAppAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
        ],
        setStatusCheckContexts: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
        ],
        setTeamAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
        ],
        setUserAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
        ],
        testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
        transfer: ["POST /repos/{owner}/{repo}/transfer"],
        update: ["PATCH /repos/{owner}/{repo}"],
        updateBranchProtection: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection",
        ],
        updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
        updateDeploymentBranchPolicy: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}",
        ],
        updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
        updateInvitation: [
            "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}",
        ],
        updatePullRequestReviewProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
        ],
        updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
        updateReleaseAsset: [
            "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}",
        ],
        updateStatusCheckPotection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
            {},
            { renamed: ["repos", "updateStatusCheckProtection"] },
        ],
        updateStatusCheckProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        ],
        updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
        updateWebhookConfigForRepo: [
            "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config",
        ],
        uploadReleaseAsset: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
            { baseUrl: "https://uploads.github.com" },
        ],
    },
    search: {
        code: ["GET /search/code"],
        commits: ["GET /search/commits"],
        issuesAndPullRequests: ["GET /search/issues"],
        labels: ["GET /search/labels"],
        repos: ["GET /search/repositories"],
        topics: ["GET /search/topics"],
        users: ["GET /search/users"],
    },
    secretScanning: {
        getAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
        ],
        getSecurityAnalysisSettingsForEnterprise: [
            "GET /enterprises/{enterprise}/code_security_and_analysis",
        ],
        listAlertsForEnterprise: [
            "GET /enterprises/{enterprise}/secret-scanning/alerts",
        ],
        listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
        listLocationsForAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
        ],
        patchSecurityAnalysisSettingsForEnterprise: [
            "PATCH /enterprises/{enterprise}/code_security_and_analysis",
        ],
        postSecurityProductEnablementForEnterprise: [
            "POST /enterprises/{enterprise}/{security_product}/{enablement}",
        ],
        updateAlert: [
            "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
        ],
    },
    teams: {
        addOrUpdateMembershipForUserInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}",
        ],
        addOrUpdateProjectPermissionsInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        ],
        addOrUpdateRepoPermissionsInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
        ],
        checkPermissionsForProjectInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        ],
        checkPermissionsForRepoInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
        ],
        create: ["POST /orgs/{org}/teams"],
        createDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
        ],
        createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
        deleteDiscussionCommentInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
        ],
        deleteDiscussionInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
        ],
        deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
        getByName: ["GET /orgs/{org}/teams/{team_slug}"],
        getDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
        ],
        getDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
        ],
        getMembershipForUserInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/memberships/{username}",
        ],
        list: ["GET /orgs/{org}/teams"],
        listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
        listDiscussionCommentsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
        ],
        listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
        listForAuthenticatedUser: ["GET /user/teams"],
        listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
        listPendingInvitationsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/invitations",
        ],
        listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
        listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
        removeMembershipForUserInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}",
        ],
        removeProjectInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}",
        ],
        removeRepoInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
        ],
        updateDiscussionCommentInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
        ],
        updateDiscussionInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
        ],
        updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"],
    },
    users: {
        addEmailForAuthenticated: [
            "POST /user/emails",
            {},
            { renamed: ["users", "addEmailForAuthenticatedUser"] },
        ],
        addEmailForAuthenticatedUser: ["POST /user/emails"],
        block: ["PUT /user/blocks/{username}"],
        checkBlocked: ["GET /user/blocks/{username}"],
        checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
        checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
        createGpgKeyForAuthenticated: [
            "POST /user/gpg_keys",
            {},
            { renamed: ["users", "createGpgKeyForAuthenticatedUser"] },
        ],
        createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
        createPublicSshKeyForAuthenticated: [
            "POST /user/keys",
            {},
            { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] },
        ],
        createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
        createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
        deleteEmailForAuthenticated: [
            "DELETE /user/emails",
            {},
            { renamed: ["users", "deleteEmailForAuthenticatedUser"] },
        ],
        deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
        deleteGpgKeyForAuthenticated: [
            "DELETE /user/gpg_keys/{gpg_key_id}",
            {},
            { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] },
        ],
        deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
        deletePublicSshKeyForAuthenticated: [
            "DELETE /user/keys/{key_id}",
            {},
            { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] },
        ],
        deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
        deleteSshSigningKeyForAuthenticatedUser: [
            "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}",
        ],
        follow: ["PUT /user/following/{username}"],
        getAuthenticated: ["GET /user"],
        getByUsername: ["GET /users/{username}"],
        getContextForUser: ["GET /users/{username}/hovercard"],
        getGpgKeyForAuthenticated: [
            "GET /user/gpg_keys/{gpg_key_id}",
            {},
            { renamed: ["users", "getGpgKeyForAuthenticatedUser"] },
        ],
        getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
        getPublicSshKeyForAuthenticated: [
            "GET /user/keys/{key_id}",
            {},
            { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] },
        ],
        getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
        getSshSigningKeyForAuthenticatedUser: [
            "GET /user/ssh_signing_keys/{ssh_signing_key_id}",
        ],
        list: ["GET /users"],
        listBlockedByAuthenticated: [
            "GET /user/blocks",
            {},
            { renamed: ["users", "listBlockedByAuthenticatedUser"] },
        ],
        listBlockedByAuthenticatedUser: ["GET /user/blocks"],
        listEmailsForAuthenticated: [
            "GET /user/emails",
            {},
            { renamed: ["users", "listEmailsForAuthenticatedUser"] },
        ],
        listEmailsForAuthenticatedUser: ["GET /user/emails"],
        listFollowedByAuthenticated: [
            "GET /user/following",
            {},
            { renamed: ["users", "listFollowedByAuthenticatedUser"] },
        ],
        listFollowedByAuthenticatedUser: ["GET /user/following"],
        listFollowersForAuthenticatedUser: ["GET /user/followers"],
        listFollowersForUser: ["GET /users/{username}/followers"],
        listFollowingForUser: ["GET /users/{username}/following"],
        listGpgKeysForAuthenticated: [
            "GET /user/gpg_keys",
            {},
            { renamed: ["users", "listGpgKeysForAuthenticatedUser"] },
        ],
        listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
        listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
        listPublicEmailsForAuthenticated: [
            "GET /user/public_emails",
            {},
            { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] },
        ],
        listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
        listPublicKeysForUser: ["GET /users/{username}/keys"],
        listPublicSshKeysForAuthenticated: [
            "GET /user/keys",
            {},
            { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] },
        ],
        listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
        listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
        listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
        setPrimaryEmailVisibilityForAuthenticated: [
            "PATCH /user/email/visibility",
            {},
            { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] },
        ],
        setPrimaryEmailVisibilityForAuthenticatedUser: [
            "PATCH /user/email/visibility",
        ],
        unblock: ["DELETE /user/blocks/{username}"],
        unfollow: ["DELETE /user/following/{username}"],
        updateAuthenticated: ["PATCH /user"],
    },
};

const VERSION = "7.0.1";

function endpointsToMethods(octokit, endpointsMap) {
    const newMethods = {};
    for (const [scope, endpoints] of Object.entries(endpointsMap)) {
        for (const [methodName, endpoint] of Object.entries(endpoints)) {
            const [route, defaults, decorations] = endpoint;
            const [method, url] = route.split(/ /);
            const endpointDefaults = Object.assign({ method, url }, defaults);
            if (!newMethods[scope]) {
                newMethods[scope] = {};
            }
            const scopeMethods = newMethods[scope];
            if (decorations) {
                scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
                continue;
            }
            scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
        }
    }
    return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
    const requestWithDefaults = octokit.request.defaults(defaults);
    /* istanbul ignore next */
    function withDecorations(...args) {
        // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
        let options = requestWithDefaults.endpoint.merge(...args);
        // There are currently no other decorations than `.mapToData`
        if (decorations.mapToData) {
            options = Object.assign({}, options, {
                data: options[decorations.mapToData],
                [decorations.mapToData]: undefined,
            });
            return requestWithDefaults(options);
        }
        if (decorations.renamed) {
            const [newScope, newMethodName] = decorations.renamed;
            octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
        }
        if (decorations.deprecated) {
            octokit.log.warn(decorations.deprecated);
        }
        if (decorations.renamedParameters) {
            // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
            const options = requestWithDefaults.endpoint.merge(...args);
            for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
                if (name in options) {
                    octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
                    if (!(alias in options)) {
                        options[alias] = options[name];
                    }
                    delete options[name];
                }
            }
            return requestWithDefaults(options);
        }
        // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
        return requestWithDefaults(...args);
    }
    return Object.assign(withDecorations, requestWithDefaults);
}

function restEndpointMethods(octokit) {
    const api = endpointsToMethods(octokit, Endpoints);
    return {
        rest: api,
    };
}
restEndpointMethods.VERSION = VERSION;
function legacyRestEndpointMethods(octokit) {
    const api = endpointsToMethods(octokit, Endpoints);
    return {
        ...api,
        rest: api,
    };
}
legacyRestEndpointMethods.VERSION = VERSION;




/***/ }),

/***/ "./node_modules/@octokit/request-error/dist-web/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@octokit/request-error/dist-web/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RequestError: () => (/* binding */ RequestError)
/* harmony export */ });
/* harmony import */ var deprecation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deprecation */ "./node_modules/deprecation/dist-web/index.js");
/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! once */ "./node_modules/once/once.js");
/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_0__);



const logOnceCode = once__WEBPACK_IMPORTED_MODULE_0___default()((deprecation) => console.warn(deprecation));
const logOnceHeaders = once__WEBPACK_IMPORTED_MODULE_0___default()((deprecation) => console.warn(deprecation));
/**
 * Error with extra properties to help with debugging
 */
class RequestError extends Error {
    constructor(message, statusCode, options) {
        super(message);
        // Maintains proper stack trace (only available on V8)
        /* istanbul ignore next */
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
        this.name = "HttpError";
        this.status = statusCode;
        let headers;
        if ("headers" in options && typeof options.headers !== "undefined") {
            headers = options.headers;
        }
        if ("response" in options) {
            this.response = options.response;
            headers = options.response.headers;
        }
        // redact request credentials without mutating original request options
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
            requestCopy.headers = Object.assign({}, options.request.headers, {
                authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]"),
            });
        }
        requestCopy.url = requestCopy.url
            // client_id & client_secret can be passed as URL query parameters to increase rate limit
            // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications
            .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]")
            // OAuth tokens can be passed as URL query parameters, although it is not recommended
            // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header
            .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
        // deprecations
        Object.defineProperty(this, "code", {
            get() {
                logOnceCode(new deprecation__WEBPACK_IMPORTED_MODULE_1__.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
                return statusCode;
            },
        });
        Object.defineProperty(this, "headers", {
            get() {
                logOnceHeaders(new deprecation__WEBPACK_IMPORTED_MODULE_1__.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
                return headers || {};
            },
        });
    }
}




/***/ }),

/***/ "./node_modules/@octokit/request/dist-web/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@octokit/request/dist-web/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   request: () => (/* binding */ request)
/* harmony export */ });
/* harmony import */ var _octokit_endpoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @octokit/endpoint */ "./node_modules/@octokit/endpoint/dist-web/index.js");
/* harmony import */ var universal_user_agent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! universal-user-agent */ "./node_modules/universal-user-agent/dist-node/index.js");
/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ "./node_modules/@octokit/request/node_modules/is-plain-object/dist/is-plain-object.mjs");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/lib/index.mjs");
/* harmony import */ var _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @octokit/request-error */ "./node_modules/@octokit/request-error/dist-web/index.js");






const VERSION = "6.2.2";

function getBufferResponse(response) {
    return response.arrayBuffer();
}

function fetchWrapper(requestOptions) {
    const log = requestOptions.request && requestOptions.request.log
        ? requestOptions.request.log
        : console;
    if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(requestOptions.body) ||
        Array.isArray(requestOptions.body)) {
        requestOptions.body = JSON.stringify(requestOptions.body);
    }
    let headers = {};
    let status;
    let url;
    const fetch = (requestOptions.request && requestOptions.request.fetch) ||
        globalThis.fetch ||
        /* istanbul ignore next */ node_fetch__WEBPACK_IMPORTED_MODULE_1__["default"];
    return fetch(requestOptions.url, Object.assign({
        method: requestOptions.method,
        body: requestOptions.body,
        headers: requestOptions.headers,
        redirect: requestOptions.redirect,
    }, 
    // `requestOptions.request.agent` type is incompatible
    // see https://github.com/octokit/types.ts/pull/264
    requestOptions.request))
        .then(async (response) => {
        url = response.url;
        status = response.status;
        for (const keyAndValue of response.headers) {
            headers[keyAndValue[0]] = keyAndValue[1];
        }
        if ("deprecation" in headers) {
            const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
            const deprecationLink = matches && matches.pop();
            log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
        }
        if (status === 204 || status === 205) {
            return;
        }
        // GitHub API returns 200 for HEAD requests
        if (requestOptions.method === "HEAD") {
            if (status < 400) {
                return;
            }
            throw new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError(response.statusText, status, {
                response: {
                    url,
                    status,
                    headers,
                    data: undefined,
                },
                request: requestOptions,
            });
        }
        if (status === 304) {
            throw new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError("Not modified", status, {
                response: {
                    url,
                    status,
                    headers,
                    data: await getResponseData(response),
                },
                request: requestOptions,
            });
        }
        if (status >= 400) {
            const data = await getResponseData(response);
            const error = new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError(toErrorMessage(data), status, {
                response: {
                    url,
                    status,
                    headers,
                    data,
                },
                request: requestOptions,
            });
            throw error;
        }
        return getResponseData(response);
    })
        .then((data) => {
        return {
            status,
            url,
            headers,
            data,
        };
    })
        .catch((error) => {
        if (error instanceof _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError)
            throw error;
        else if (error.name === "AbortError")
            throw error;
        throw new _octokit_request_error__WEBPACK_IMPORTED_MODULE_2__.RequestError(error.message, 500, {
            request: requestOptions,
        });
    });
}
async function getResponseData(response) {
    const contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType)) {
        return response.json();
    }
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
        return response.text();
    }
    return getBufferResponse(response);
}
function toErrorMessage(data) {
    if (typeof data === "string")
        return data;
    // istanbul ignore else - just in case
    if ("message" in data) {
        if (Array.isArray(data.errors)) {
            return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
        }
        return data.message;
    }
    // istanbul ignore next - just in case
    return `Unknown error: ${JSON.stringify(data)}`;
}

function withDefaults(oldEndpoint, newDefaults) {
    const endpoint = oldEndpoint.defaults(newDefaults);
    const newApi = function (route, parameters) {
        const endpointOptions = endpoint.merge(route, parameters);
        if (!endpointOptions.request || !endpointOptions.request.hook) {
            return fetchWrapper(endpoint.parse(endpointOptions));
        }
        const request = (route, parameters) => {
            return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));
        };
        Object.assign(request, {
            endpoint,
            defaults: withDefaults.bind(null, endpoint),
        });
        return endpointOptions.request.hook(request, endpointOptions);
    };
    return Object.assign(newApi, {
        endpoint,
        defaults: withDefaults.bind(null, endpoint),
    });
}

const request = withDefaults(_octokit_endpoint__WEBPACK_IMPORTED_MODULE_3__.endpoint, {
    headers: {
        "user-agent": `octokit-request.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_4__.getUserAgent)()}`,
    },
});




/***/ }),

/***/ "./node_modules/@octokit/rest/dist-web/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@octokit/rest/dist-web/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Octokit: () => (/* binding */ Octokit)
/* harmony export */ });
/* harmony import */ var _octokit_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @octokit/core */ "./node_modules/@octokit/core/dist-web/index.js");
/* harmony import */ var _octokit_plugin_request_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @octokit/plugin-request-log */ "./node_modules/@octokit/plugin-request-log/dist-web/index.js");
/* harmony import */ var _octokit_plugin_paginate_rest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @octokit/plugin-paginate-rest */ "./node_modules/@octokit/plugin-paginate-rest/dist-web/index.js");
/* harmony import */ var _octokit_plugin_rest_endpoint_methods__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @octokit/plugin-rest-endpoint-methods */ "./node_modules/@octokit/plugin-rest-endpoint-methods/dist-web/index.js");





const VERSION = "19.0.7";

const Octokit = _octokit_core__WEBPACK_IMPORTED_MODULE_0__.Octokit.plugin(_octokit_plugin_request_log__WEBPACK_IMPORTED_MODULE_1__.requestLog, _octokit_plugin_rest_endpoint_methods__WEBPACK_IMPORTED_MODULE_2__.legacyRestEndpointMethods, _octokit_plugin_paginate_rest__WEBPACK_IMPORTED_MODULE_3__.paginateRest).defaults({
    userAgent: `octokit-rest.js/${VERSION}`,
});




/***/ }),

/***/ "./node_modules/balanced-match/index.js":
/*!**********************************************!*\
  !*** ./node_modules/balanced-match/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ "./node_modules/before-after-hook/index.js":
/*!*************************************************!*\
  !*** ./node_modules/before-after-hook/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var register = __webpack_require__(/*! ./lib/register */ "./node_modules/before-after-hook/lib/register.js");
var addHook = __webpack_require__(/*! ./lib/add */ "./node_modules/before-after-hook/lib/add.js");
var removeHook = __webpack_require__(/*! ./lib/remove */ "./node_modules/before-after-hook/lib/remove.js");

// bind with array of arguments: https://stackoverflow.com/a/21792913
var bind = Function.bind;
var bindable = bind.bind(bind);

function bindApi(hook, state, name) {
  var removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook.api = { remove: removeHookRef };
  hook.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach(function (kind) {
    var args = name ? [state, kind, name] : [state, kind];
    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
  });
}

function HookSingular() {
  var singularHookName = "h";
  var singularHookState = {
    registry: {},
  };
  var singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}

function HookCollection() {
  var state = {
    registry: {},
  };

  var hook = register.bind(null, state);
  bindApi(hook, state);

  return hook;
}

var collectionHookDeprecationMessageDisplayed = false;
function Hook() {
  if (!collectionHookDeprecationMessageDisplayed) {
    console.warn(
      '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
    );
    collectionHookDeprecationMessageDisplayed = true;
  }
  return HookCollection();
}

Hook.Singular = HookSingular.bind();
Hook.Collection = HookCollection.bind();

module.exports = Hook;
// expose constructors as a named property for TypeScript
module.exports.Hook = Hook;
module.exports.Singular = Hook.Singular;
module.exports.Collection = Hook.Collection;


/***/ }),

/***/ "./node_modules/before-after-hook/lib/add.js":
/*!***************************************************!*\
  !*** ./node_modules/before-after-hook/lib/add.js ***!
  \***************************************************/
/***/ ((module) => {

module.exports = addHook;

function addHook(state, kind, name, hook) {
  var orig = hook;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }

  if (kind === "before") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(orig.bind(null, options))
        .then(method.bind(null, options));
    };
  }

  if (kind === "after") {
    hook = function (method, options) {
      var result;
      return Promise.resolve()
        .then(method.bind(null, options))
        .then(function (result_) {
          result = result_;
          return orig(result, options);
        })
        .then(function () {
          return result;
        });
    };
  }

  if (kind === "error") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(method.bind(null, options))
        .catch(function (error) {
          return orig(error, options);
        });
    };
  }

  state.registry[name].push({
    hook: hook,
    orig: orig,
  });
}


/***/ }),

/***/ "./node_modules/before-after-hook/lib/register.js":
/*!********************************************************!*\
  !*** ./node_modules/before-after-hook/lib/register.js ***!
  \********************************************************/
/***/ ((module) => {

module.exports = register;

function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }

  if (!options) {
    options = {};
  }

  if (Array.isArray(name)) {
    return name.reverse().reduce(function (callback, name) {
      return register.bind(null, state, name, callback, options);
    }, method)();
  }

  return Promise.resolve().then(function () {
    if (!state.registry[name]) {
      return method(options);
    }

    return state.registry[name].reduce(function (method, registered) {
      return registered.hook.bind(null, method, options);
    }, method)();
  });
}


/***/ }),

/***/ "./node_modules/before-after-hook/lib/remove.js":
/*!******************************************************!*\
  !*** ./node_modules/before-after-hook/lib/remove.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = removeHook;

function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }

  var index = state.registry[name]
    .map(function (registered) {
      return registered.orig;
    })
    .indexOf(method);

  if (index === -1) {
    return;
  }

  state.registry[name].splice(index, 1);
}


/***/ }),

/***/ "./node_modules/brace-expansion/index.js":
/*!***********************************************!*\
  !*** ./node_modules/brace-expansion/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var concatMap = __webpack_require__(/*! concat-map */ "./node_modules/concat-map/index.js");
var balanced = __webpack_require__(/*! balanced-match */ "./node_modules/balanced-match/index.js");

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ "./node_modules/concat-map/index.js":
/*!******************************************!*\
  !*** ./node_modules/concat-map/index.js ***!
  \******************************************/
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/cronstrue/dist/cronstrue.js":
/*!**************************************************!*\
  !*** ./node_modules/cronstrue/dist/cronstrue.js ***!
  \**************************************************/
/***/ ((module) => {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(globalThis, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 794:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_540__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CronParser = void 0;
var rangeValidator_1 = __nested_webpack_require_540__(586);
var CronParser = (function () {
    function CronParser(expression, dayOfWeekStartIndexZero, monthStartIndexZero) {
        if (dayOfWeekStartIndexZero === void 0) { dayOfWeekStartIndexZero = true; }
        if (monthStartIndexZero === void 0) { monthStartIndexZero = false; }
        this.expression = expression;
        this.dayOfWeekStartIndexZero = dayOfWeekStartIndexZero;
        this.monthStartIndexZero = monthStartIndexZero;
    }
    CronParser.prototype.parse = function () {
        var parsed = this.extractParts(this.expression);
        this.normalize(parsed);
        this.validate(parsed);
        return parsed;
    };
    CronParser.prototype.extractParts = function (expression) {
        if (!this.expression) {
            throw new Error("Expression is empty");
        }
        var parsed = expression.trim().split(/[ ]+/);
        if (parsed.length < 5) {
            throw new Error("Expression has only ".concat(parsed.length, " part").concat(parsed.length == 1 ? "" : "s", ". At least 5 parts are required."));
        }
        else if (parsed.length == 5) {
            parsed.unshift("");
            parsed.push("");
        }
        else if (parsed.length == 6) {
            var isYearWithNoSecondsPart = /\d{4}$/.test(parsed[5]) || parsed[4] == "?" || parsed[2] == "?";
            if (isYearWithNoSecondsPart) {
                parsed.unshift("");
            }
            else {
                parsed.push("");
            }
        }
        else if (parsed.length > 7) {
            throw new Error("Expression has ".concat(parsed.length, " parts; too many!"));
        }
        return parsed;
    };
    CronParser.prototype.normalize = function (expressionParts) {
        var _this = this;
        expressionParts[3] = expressionParts[3].replace("?", "*");
        expressionParts[5] = expressionParts[5].replace("?", "*");
        expressionParts[2] = expressionParts[2].replace("?", "*");
        if (expressionParts[0].indexOf("0/") == 0) {
            expressionParts[0] = expressionParts[0].replace("0/", "*/");
        }
        if (expressionParts[1].indexOf("0/") == 0) {
            expressionParts[1] = expressionParts[1].replace("0/", "*/");
        }
        if (expressionParts[2].indexOf("0/") == 0) {
            expressionParts[2] = expressionParts[2].replace("0/", "*/");
        }
        if (expressionParts[3].indexOf("1/") == 0) {
            expressionParts[3] = expressionParts[3].replace("1/", "*/");
        }
        if (expressionParts[4].indexOf("1/") == 0) {
            expressionParts[4] = expressionParts[4].replace("1/", "*/");
        }
        if (expressionParts[6].indexOf("1/") == 0) {
            expressionParts[6] = expressionParts[6].replace("1/", "*/");
        }
        expressionParts[5] = expressionParts[5].replace(/(^\d)|([^#/\s]\d)/g, function (t) {
            var dowDigits = t.replace(/\D/, "");
            var dowDigitsAdjusted = dowDigits;
            if (_this.dayOfWeekStartIndexZero) {
                if (dowDigits == "7") {
                    dowDigitsAdjusted = "0";
                }
            }
            else {
                dowDigitsAdjusted = (parseInt(dowDigits) - 1).toString();
            }
            return t.replace(dowDigits, dowDigitsAdjusted);
        });
        if (expressionParts[5] == "L") {
            expressionParts[5] = "6";
        }
        if (expressionParts[3] == "?") {
            expressionParts[3] = "*";
        }
        if (expressionParts[3].indexOf("W") > -1 &&
            (expressionParts[3].indexOf(",") > -1 || expressionParts[3].indexOf("-") > -1)) {
            throw new Error("The 'W' character can be specified only when the day-of-month is a single day, not a range or list of days.");
        }
        var days = {
            SUN: 0,
            MON: 1,
            TUE: 2,
            WED: 3,
            THU: 4,
            FRI: 5,
            SAT: 6,
        };
        for (var day in days) {
            expressionParts[5] = expressionParts[5].replace(new RegExp(day, "gi"), days[day].toString());
        }
        expressionParts[4] = expressionParts[4].replace(/(^\d{1,2})|([^#/\s]\d{1,2})/g, function (t) {
            var dowDigits = t.replace(/\D/, "");
            var dowDigitsAdjusted = dowDigits;
            if (_this.monthStartIndexZero) {
                dowDigitsAdjusted = (parseInt(dowDigits) + 1).toString();
            }
            return t.replace(dowDigits, dowDigitsAdjusted);
        });
        var months = {
            JAN: 1,
            FEB: 2,
            MAR: 3,
            APR: 4,
            MAY: 5,
            JUN: 6,
            JUL: 7,
            AUG: 8,
            SEP: 9,
            OCT: 10,
            NOV: 11,
            DEC: 12,
        };
        for (var month in months) {
            expressionParts[4] = expressionParts[4].replace(new RegExp(month, "gi"), months[month].toString());
        }
        if (expressionParts[0] == "0") {
            expressionParts[0] = "";
        }
        if (!/\*|\-|\,|\//.test(expressionParts[2]) &&
            (/\*|\//.test(expressionParts[1]) || /\*|\//.test(expressionParts[0]))) {
            expressionParts[2] += "-".concat(expressionParts[2]);
        }
        for (var i = 0; i < expressionParts.length; i++) {
            if (expressionParts[i].indexOf(",") != -1) {
                expressionParts[i] =
                    expressionParts[i]
                        .split(",")
                        .filter(function (str) { return str !== ""; })
                        .join(",") || "*";
            }
            if (expressionParts[i] == "*/1") {
                expressionParts[i] = "*";
            }
            if (expressionParts[i].indexOf("/") > -1 && !/^\*|\-|\,/.test(expressionParts[i])) {
                var stepRangeThrough = null;
                switch (i) {
                    case 4:
                        stepRangeThrough = "12";
                        break;
                    case 5:
                        stepRangeThrough = "6";
                        break;
                    case 6:
                        stepRangeThrough = "9999";
                        break;
                    default:
                        stepRangeThrough = null;
                        break;
                }
                if (stepRangeThrough !== null) {
                    var parts = expressionParts[i].split("/");
                    expressionParts[i] = "".concat(parts[0], "-").concat(stepRangeThrough, "/").concat(parts[1]);
                }
            }
        }
    };
    CronParser.prototype.validate = function (parsed) {
        this.assertNoInvalidCharacters("DOW", parsed[5]);
        this.assertNoInvalidCharacters("DOM", parsed[3]);
        this.validateRange(parsed);
    };
    CronParser.prototype.validateRange = function (parsed) {
        rangeValidator_1.default.secondRange(parsed[0]);
        rangeValidator_1.default.minuteRange(parsed[1]);
        rangeValidator_1.default.hourRange(parsed[2]);
        rangeValidator_1.default.dayOfMonthRange(parsed[3]);
        rangeValidator_1.default.monthRange(parsed[4], this.monthStartIndexZero);
        rangeValidator_1.default.dayOfWeekRange(parsed[5], this.dayOfWeekStartIndexZero);
    };
    CronParser.prototype.assertNoInvalidCharacters = function (partDescription, expression) {
        var invalidChars = expression.match(/[A-KM-VX-Z]+/gi);
        if (invalidChars && invalidChars.length) {
            throw new Error("".concat(partDescription, " part contains invalid values: '").concat(invalidChars.toString(), "'"));
        }
    };
    return CronParser;
}());
exports.CronParser = CronParser;


/***/ }),

/***/ 728:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_8463__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExpressionDescriptor = void 0;
var stringUtilities_1 = __nested_webpack_require_8463__(910);
var cronParser_1 = __nested_webpack_require_8463__(794);
var ExpressionDescriptor = (function () {
    function ExpressionDescriptor(expression, options) {
        this.expression = expression;
        this.options = options;
        this.expressionParts = new Array(5);
        if (!this.options.locale && ExpressionDescriptor.defaultLocale) {
            this.options.locale = ExpressionDescriptor.defaultLocale;
        }
        if (!ExpressionDescriptor.locales[this.options.locale]) {
            var fallBackLocale = Object.keys(ExpressionDescriptor.locales)[0];
            console.warn("Locale '".concat(this.options.locale, "' could not be found; falling back to '").concat(fallBackLocale, "'."));
            this.options.locale = fallBackLocale;
        }
        this.i18n = ExpressionDescriptor.locales[this.options.locale];
        if (options.use24HourTimeFormat === undefined) {
            options.use24HourTimeFormat = this.i18n.use24HourTimeFormatByDefault();
        }
    }
    ExpressionDescriptor.toString = function (expression, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.throwExceptionOnParseError, throwExceptionOnParseError = _c === void 0 ? true : _c, _d = _b.verbose, verbose = _d === void 0 ? false : _d, _e = _b.dayOfWeekStartIndexZero, dayOfWeekStartIndexZero = _e === void 0 ? true : _e, _f = _b.monthStartIndexZero, monthStartIndexZero = _f === void 0 ? false : _f, use24HourTimeFormat = _b.use24HourTimeFormat, _g = _b.locale, locale = _g === void 0 ? null : _g, _h = _b.tzOffset, tzOffset = _h === void 0 ? 0 : _h;
        var options = {
            throwExceptionOnParseError: throwExceptionOnParseError,
            verbose: verbose,
            dayOfWeekStartIndexZero: dayOfWeekStartIndexZero,
            monthStartIndexZero: monthStartIndexZero,
            use24HourTimeFormat: use24HourTimeFormat,
            locale: locale,
            tzOffset: tzOffset
        };
        var descripter = new ExpressionDescriptor(expression, options);
        return descripter.getFullDescription();
    };
    ExpressionDescriptor.initialize = function (localesLoader, defaultLocale) {
        if (defaultLocale === void 0) { defaultLocale = "en"; }
        ExpressionDescriptor.specialCharacters = ["/", "-", ",", "*"];
        ExpressionDescriptor.defaultLocale = defaultLocale;
        localesLoader.load(ExpressionDescriptor.locales);
    };
    ExpressionDescriptor.prototype.getFullDescription = function () {
        var description = "";
        try {
            var parser = new cronParser_1.CronParser(this.expression, this.options.dayOfWeekStartIndexZero, this.options.monthStartIndexZero);
            this.expressionParts = parser.parse();
            var timeSegment = this.getTimeOfDayDescription();
            var dayOfMonthDesc = this.getDayOfMonthDescription();
            var monthDesc = this.getMonthDescription();
            var dayOfWeekDesc = this.getDayOfWeekDescription();
            var yearDesc = this.getYearDescription();
            description += timeSegment + dayOfMonthDesc + dayOfWeekDesc + monthDesc + yearDesc;
            description = this.transformVerbosity(description, !!this.options.verbose);
            description = description.charAt(0).toLocaleUpperCase() + description.substr(1);
        }
        catch (ex) {
            if (!this.options.throwExceptionOnParseError) {
                description = this.i18n.anErrorOccuredWhenGeneratingTheExpressionD();
            }
            else {
                throw "".concat(ex);
            }
        }
        return description;
    };
    ExpressionDescriptor.prototype.getTimeOfDayDescription = function () {
        var secondsExpression = this.expressionParts[0];
        var minuteExpression = this.expressionParts[1];
        var hourExpression = this.expressionParts[2];
        var description = "";
        if (!stringUtilities_1.StringUtilities.containsAny(minuteExpression, ExpressionDescriptor.specialCharacters) &&
            !stringUtilities_1.StringUtilities.containsAny(hourExpression, ExpressionDescriptor.specialCharacters) &&
            !stringUtilities_1.StringUtilities.containsAny(secondsExpression, ExpressionDescriptor.specialCharacters)) {
            description += this.i18n.atSpace() + this.formatTime(hourExpression, minuteExpression, secondsExpression);
        }
        else if (!secondsExpression &&
            minuteExpression.indexOf("-") > -1 &&
            !(minuteExpression.indexOf(",") > -1) &&
            !(minuteExpression.indexOf("/") > -1) &&
            !stringUtilities_1.StringUtilities.containsAny(hourExpression, ExpressionDescriptor.specialCharacters)) {
            var minuteParts = minuteExpression.split("-");
            description += stringUtilities_1.StringUtilities.format(this.i18n.everyMinuteBetweenX0AndX1(), this.formatTime(hourExpression, minuteParts[0], ""), this.formatTime(hourExpression, minuteParts[1], ""));
        }
        else if (!secondsExpression &&
            hourExpression.indexOf(",") > -1 &&
            hourExpression.indexOf("-") == -1 &&
            hourExpression.indexOf("/") == -1 &&
            !stringUtilities_1.StringUtilities.containsAny(minuteExpression, ExpressionDescriptor.specialCharacters)) {
            var hourParts = hourExpression.split(",");
            description += this.i18n.at();
            for (var i = 0; i < hourParts.length; i++) {
                description += " ";
                description += this.formatTime(hourParts[i], minuteExpression, "");
                if (i < hourParts.length - 2) {
                    description += ",";
                }
                if (i == hourParts.length - 2) {
                    description += this.i18n.spaceAnd();
                }
            }
        }
        else {
            var secondsDescription = this.getSecondsDescription();
            var minutesDescription = this.getMinutesDescription();
            var hoursDescription = this.getHoursDescription();
            description += secondsDescription;
            if (description && minutesDescription) {
                description += ", ";
            }
            description += minutesDescription;
            if (minutesDescription === hoursDescription) {
                return description;
            }
            if (description && hoursDescription) {
                description += ", ";
            }
            description += hoursDescription;
        }
        return description;
    };
    ExpressionDescriptor.prototype.getSecondsDescription = function () {
        var _this = this;
        var description = this.getSegmentDescription(this.expressionParts[0], this.i18n.everySecond(), function (s) {
            return s;
        }, function (s) {
            return stringUtilities_1.StringUtilities.format(_this.i18n.everyX0Seconds(s), s);
        }, function (s) {
            return _this.i18n.secondsX0ThroughX1PastTheMinute();
        }, function (s) {
            return s == "0"
                ? ""
                : parseInt(s) < 20
                    ? _this.i18n.atX0SecondsPastTheMinute(s)
                    : _this.i18n.atX0SecondsPastTheMinuteGt20() || _this.i18n.atX0SecondsPastTheMinute(s);
        });
        return description;
    };
    ExpressionDescriptor.prototype.getMinutesDescription = function () {
        var _this = this;
        var secondsExpression = this.expressionParts[0];
        var hourExpression = this.expressionParts[2];
        var description = this.getSegmentDescription(this.expressionParts[1], this.i18n.everyMinute(), function (s) {
            return s;
        }, function (s) {
            return stringUtilities_1.StringUtilities.format(_this.i18n.everyX0Minutes(s), s);
        }, function (s) {
            return _this.i18n.minutesX0ThroughX1PastTheHour();
        }, function (s) {
            try {
                return s == "0" && hourExpression.indexOf("/") == -1 && secondsExpression == ""
                    ? _this.i18n.everyHour()
                    : parseInt(s) < 20
                        ? _this.i18n.atX0MinutesPastTheHour(s)
                        : _this.i18n.atX0MinutesPastTheHourGt20() || _this.i18n.atX0MinutesPastTheHour(s);
            }
            catch (e) {
                return _this.i18n.atX0MinutesPastTheHour(s);
            }
        });
        return description;
    };
    ExpressionDescriptor.prototype.getHoursDescription = function () {
        var _this = this;
        var expression = this.expressionParts[2];
        var description = this.getSegmentDescription(expression, this.i18n.everyHour(), function (s) {
            return _this.formatTime(s, "0", "");
        }, function (s) {
            return stringUtilities_1.StringUtilities.format(_this.i18n.everyX0Hours(s), s);
        }, function (s) {
            return _this.i18n.betweenX0AndX1();
        }, function (s) {
            return _this.i18n.atX0();
        });
        if (description && expression.includes("-") && this.expressionParts[1] != "0") {
            var atTheHourMatches = Array.from(description.matchAll(/:00/g));
            if (atTheHourMatches.length > 1) {
                var lastAtTheHourMatchIndex = atTheHourMatches[atTheHourMatches.length - 1].index;
                description =
                    description.substring(0, lastAtTheHourMatchIndex) +
                        ":59" +
                        description.substring(lastAtTheHourMatchIndex + 3);
            }
        }
        return description;
    };
    ExpressionDescriptor.prototype.getDayOfWeekDescription = function () {
        var _this = this;
        var daysOfWeekNames = this.i18n.daysOfTheWeek();
        var description = null;
        if (this.expressionParts[5] == "*") {
            description = "";
        }
        else {
            description = this.getSegmentDescription(this.expressionParts[5], this.i18n.commaEveryDay(), function (s, form) {
                var exp = s;
                if (s.indexOf("#") > -1) {
                    exp = s.substring(0, s.indexOf("#"));
                }
                else if (s.indexOf("L") > -1) {
                    exp = exp.replace("L", "");
                }
                var description = _this.i18n.daysOfTheWeekInCase
                    ? _this.i18n.daysOfTheWeekInCase(form)[parseInt(exp)]
                    : daysOfWeekNames[parseInt(exp)];
                if (s.indexOf("#") > -1) {
                    var dayOfWeekOfMonthDescription = null;
                    var dayOfWeekOfMonthNumber = s.substring(s.indexOf("#") + 1);
                    var dayOfWeekNumber = s.substring(0, s.indexOf("#"));
                    switch (dayOfWeekOfMonthNumber) {
                        case "1":
                            dayOfWeekOfMonthDescription = _this.i18n.first(dayOfWeekNumber);
                            break;
                        case "2":
                            dayOfWeekOfMonthDescription = _this.i18n.second(dayOfWeekNumber);
                            break;
                        case "3":
                            dayOfWeekOfMonthDescription = _this.i18n.third(dayOfWeekNumber);
                            break;
                        case "4":
                            dayOfWeekOfMonthDescription = _this.i18n.fourth(dayOfWeekNumber);
                            break;
                        case "5":
                            dayOfWeekOfMonthDescription = _this.i18n.fifth(dayOfWeekNumber);
                            break;
                    }
                    description = dayOfWeekOfMonthDescription + " " + description;
                }
                return description;
            }, function (s) {
                if (parseInt(s) == 1) {
                    return "";
                }
                else {
                    return stringUtilities_1.StringUtilities.format(_this.i18n.commaEveryX0DaysOfTheWeek(s), s);
                }
            }, function (s) {
                var beginFrom = s.substring(0, s.indexOf("-"));
                var domSpecified = _this.expressionParts[3] != "*";
                return domSpecified ? _this.i18n.commaAndX0ThroughX1(beginFrom) : _this.i18n.commaX0ThroughX1(beginFrom);
            }, function (s) {
                var format = null;
                if (s.indexOf("#") > -1) {
                    var dayOfWeekOfMonthNumber = s.substring(s.indexOf("#") + 1);
                    format = _this.i18n.commaOnThe(dayOfWeekOfMonthNumber).trim() + _this.i18n.spaceX0OfTheMonth();
                }
                else if (s.indexOf("L") > -1) {
                    format = _this.i18n.commaOnTheLastX0OfTheMonth(s.replace("L", ""));
                }
                else {
                    var domSpecified = _this.expressionParts[3] != "*";
                    format = domSpecified ? _this.i18n.commaAndOnX0() : _this.i18n.commaOnlyOnX0(s);
                }
                return format;
            });
        }
        return description;
    };
    ExpressionDescriptor.prototype.getMonthDescription = function () {
        var _this = this;
        var monthNames = this.i18n.monthsOfTheYear();
        var description = this.getSegmentDescription(this.expressionParts[4], "", function (s, form) {
            return form && _this.i18n.monthsOfTheYearInCase
                ? _this.i18n.monthsOfTheYearInCase(form)[parseInt(s) - 1]
                : monthNames[parseInt(s) - 1];
        }, function (s) {
            if (parseInt(s) == 1) {
                return "";
            }
            else {
                return stringUtilities_1.StringUtilities.format(_this.i18n.commaEveryX0Months(s), s);
            }
        }, function (s) {
            return _this.i18n.commaMonthX0ThroughMonthX1() || _this.i18n.commaX0ThroughX1();
        }, function (s) {
            return _this.i18n.commaOnlyInMonthX0 ? _this.i18n.commaOnlyInMonthX0() : _this.i18n.commaOnlyInX0();
        });
        return description;
    };
    ExpressionDescriptor.prototype.getDayOfMonthDescription = function () {
        var _this = this;
        var description = null;
        var expression = this.expressionParts[3];
        switch (expression) {
            case "L":
                description = this.i18n.commaOnTheLastDayOfTheMonth();
                break;
            case "WL":
            case "LW":
                description = this.i18n.commaOnTheLastWeekdayOfTheMonth();
                break;
            default:
                var weekDayNumberMatches = expression.match(/(\d{1,2}W)|(W\d{1,2})/);
                if (weekDayNumberMatches) {
                    var dayNumber = parseInt(weekDayNumberMatches[0].replace("W", ""));
                    var dayString = dayNumber == 1
                        ? this.i18n.firstWeekday()
                        : stringUtilities_1.StringUtilities.format(this.i18n.weekdayNearestDayX0(), dayNumber.toString());
                    description = stringUtilities_1.StringUtilities.format(this.i18n.commaOnTheX0OfTheMonth(), dayString);
                    break;
                }
                else {
                    var lastDayOffSetMatches = expression.match(/L-(\d{1,2})/);
                    if (lastDayOffSetMatches) {
                        var offSetDays = lastDayOffSetMatches[1];
                        description = stringUtilities_1.StringUtilities.format(this.i18n.commaDaysBeforeTheLastDayOfTheMonth(offSetDays), offSetDays);
                        break;
                    }
                    else if (expression == "*" && this.expressionParts[5] != "*") {
                        return "";
                    }
                    else {
                        description = this.getSegmentDescription(expression, this.i18n.commaEveryDay(), function (s) {
                            return s == "L"
                                ? _this.i18n.lastDay()
                                : _this.i18n.dayX0
                                    ? stringUtilities_1.StringUtilities.format(_this.i18n.dayX0(), s)
                                    : s;
                        }, function (s) {
                            return s == "1" ? _this.i18n.commaEveryDay() : _this.i18n.commaEveryX0Days(s);
                        }, function (s) {
                            return _this.i18n.commaBetweenDayX0AndX1OfTheMonth(s);
                        }, function (s) {
                            return _this.i18n.commaOnDayX0OfTheMonth(s);
                        });
                    }
                    break;
                }
        }
        return description;
    };
    ExpressionDescriptor.prototype.getYearDescription = function () {
        var _this = this;
        var description = this.getSegmentDescription(this.expressionParts[6], "", function (s) {
            return /^\d+$/.test(s) ? new Date(parseInt(s), 1).getFullYear().toString() : s;
        }, function (s) {
            return stringUtilities_1.StringUtilities.format(_this.i18n.commaEveryX0Years(s), s);
        }, function (s) {
            return _this.i18n.commaYearX0ThroughYearX1() || _this.i18n.commaX0ThroughX1();
        }, function (s) {
            return _this.i18n.commaOnlyInYearX0 ? _this.i18n.commaOnlyInYearX0() : _this.i18n.commaOnlyInX0();
        });
        return description;
    };
    ExpressionDescriptor.prototype.getSegmentDescription = function (expression, allDescription, getSingleItemDescription, getIncrementDescriptionFormat, getRangeDescriptionFormat, getDescriptionFormat) {
        var description = null;
        var doesExpressionContainIncrement = expression.indexOf("/") > -1;
        var doesExpressionContainRange = expression.indexOf("-") > -1;
        var doesExpressionContainMultipleValues = expression.indexOf(",") > -1;
        if (!expression) {
            description = "";
        }
        else if (expression === "*") {
            description = allDescription;
        }
        else if (!doesExpressionContainIncrement && !doesExpressionContainRange && !doesExpressionContainMultipleValues) {
            description = stringUtilities_1.StringUtilities.format(getDescriptionFormat(expression), getSingleItemDescription(expression));
        }
        else if (doesExpressionContainMultipleValues) {
            var segments = expression.split(",");
            var descriptionContent = "";
            for (var i = 0; i < segments.length; i++) {
                if (i > 0 && segments.length > 2) {
                    descriptionContent += ",";
                    if (i < segments.length - 1) {
                        descriptionContent += " ";
                    }
                }
                if (i > 0 && segments.length > 1 && (i == segments.length - 1 || segments.length == 2)) {
                    descriptionContent += "".concat(this.i18n.spaceAnd(), " ");
                }
                if (segments[i].indexOf("/") > -1 || segments[i].indexOf("-") > -1) {
                    var isSegmentRangeWithoutIncrement = segments[i].indexOf("-") > -1 && segments[i].indexOf("/") == -1;
                    var currentDescriptionContent = this.getSegmentDescription(segments[i], allDescription, getSingleItemDescription, getIncrementDescriptionFormat, isSegmentRangeWithoutIncrement ? this.i18n.commaX0ThroughX1 : getRangeDescriptionFormat, getDescriptionFormat);
                    if (isSegmentRangeWithoutIncrement) {
                        currentDescriptionContent = currentDescriptionContent.replace(", ", "");
                    }
                    descriptionContent += currentDescriptionContent;
                }
                else if (!doesExpressionContainIncrement) {
                    descriptionContent += getSingleItemDescription(segments[i]);
                }
                else {
                    descriptionContent += this.getSegmentDescription(segments[i], allDescription, getSingleItemDescription, getIncrementDescriptionFormat, getRangeDescriptionFormat, getDescriptionFormat);
                }
            }
            if (!doesExpressionContainIncrement) {
                description = stringUtilities_1.StringUtilities.format(getDescriptionFormat(expression), descriptionContent);
            }
            else {
                description = descriptionContent;
            }
        }
        else if (doesExpressionContainIncrement) {
            var segments = expression.split("/");
            description = stringUtilities_1.StringUtilities.format(getIncrementDescriptionFormat(segments[1]), segments[1]);
            if (segments[0].indexOf("-") > -1) {
                var rangeSegmentDescription = this.generateRangeSegmentDescription(segments[0], getRangeDescriptionFormat, getSingleItemDescription);
                if (rangeSegmentDescription.indexOf(", ") != 0) {
                    description += ", ";
                }
                description += rangeSegmentDescription;
            }
            else if (segments[0].indexOf("*") == -1) {
                var rangeItemDescription = stringUtilities_1.StringUtilities.format(getDescriptionFormat(segments[0]), getSingleItemDescription(segments[0]));
                rangeItemDescription = rangeItemDescription.replace(", ", "");
                description += stringUtilities_1.StringUtilities.format(this.i18n.commaStartingX0(), rangeItemDescription);
            }
        }
        else if (doesExpressionContainRange) {
            description = this.generateRangeSegmentDescription(expression, getRangeDescriptionFormat, getSingleItemDescription);
        }
        return description;
    };
    ExpressionDescriptor.prototype.generateRangeSegmentDescription = function (rangeExpression, getRangeDescriptionFormat, getSingleItemDescription) {
        var description = "";
        var rangeSegments = rangeExpression.split("-");
        var rangeSegment1Description = getSingleItemDescription(rangeSegments[0], 1);
        var rangeSegment2Description = getSingleItemDescription(rangeSegments[1], 2);
        var rangeDescriptionFormat = getRangeDescriptionFormat(rangeExpression);
        description += stringUtilities_1.StringUtilities.format(rangeDescriptionFormat, rangeSegment1Description, rangeSegment2Description);
        return description;
    };
    ExpressionDescriptor.prototype.formatTime = function (hourExpression, minuteExpression, secondExpression) {
        var hour = parseInt(hourExpression) + (this.options.tzOffset ? this.options.tzOffset : 0);
        if (hour >= 24) {
            hour = hour - 24;
        }
        else if (hour < 0) {
            hour = 24 + hour;
        }
        var period = "";
        var setPeriodBeforeTime = false;
        if (!this.options.use24HourTimeFormat) {
            setPeriodBeforeTime = !!(this.i18n.setPeriodBeforeTime && this.i18n.setPeriodBeforeTime());
            period = setPeriodBeforeTime ? "".concat(this.getPeriod(hour), " ") : " ".concat(this.getPeriod(hour));
            if (hour > 12) {
                hour -= 12;
            }
            if (hour === 0) {
                hour = 12;
            }
        }
        var minute = minuteExpression;
        var second = "";
        if (secondExpression) {
            second = ":".concat(("00" + secondExpression).substring(secondExpression.length));
        }
        return "".concat(setPeriodBeforeTime ? period : "").concat(("00" + hour.toString()).substring(hour.toString().length), ":").concat(("00" + minute.toString()).substring(minute.toString().length)).concat(second).concat(!setPeriodBeforeTime ? period : "");
    };
    ExpressionDescriptor.prototype.transformVerbosity = function (description, useVerboseFormat) {
        if (!useVerboseFormat) {
            description = description.replace(new RegExp(", ".concat(this.i18n.everyMinute()), "g"), "");
            description = description.replace(new RegExp(", ".concat(this.i18n.everyHour()), "g"), "");
            description = description.replace(new RegExp(this.i18n.commaEveryDay(), "g"), "");
            description = description.replace(/\, ?$/, "");
        }
        return description;
    };
    ExpressionDescriptor.prototype.getPeriod = function (hour) {
        return hour >= 12 ? (this.i18n.pm && this.i18n.pm()) || "PM" : (this.i18n.am && this.i18n.am()) || "AM";
    };
    ExpressionDescriptor.locales = {};
    return ExpressionDescriptor;
}());
exports.ExpressionDescriptor = ExpressionDescriptor;


/***/ }),

/***/ 336:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_33146__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.enLocaleLoader = void 0;
var en_1 = __nested_webpack_require_33146__(751);
var enLocaleLoader = (function () {
    function enLocaleLoader() {
    }
    enLocaleLoader.prototype.load = function (availableLocales) {
        availableLocales["en"] = new en_1.en();
    };
    return enLocaleLoader;
}());
exports.enLocaleLoader = enLocaleLoader;


/***/ }),

/***/ 751:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.en = void 0;
var en = (function () {
    function en() {
    }
    en.prototype.atX0SecondsPastTheMinuteGt20 = function () {
        return null;
    };
    en.prototype.atX0MinutesPastTheHourGt20 = function () {
        return null;
    };
    en.prototype.commaMonthX0ThroughMonthX1 = function () {
        return null;
    };
    en.prototype.commaYearX0ThroughYearX1 = function () {
        return null;
    };
    en.prototype.use24HourTimeFormatByDefault = function () {
        return false;
    };
    en.prototype.anErrorOccuredWhenGeneratingTheExpressionD = function () {
        return "An error occured when generating the expression description.  Check the cron expression syntax.";
    };
    en.prototype.everyMinute = function () {
        return "every minute";
    };
    en.prototype.everyHour = function () {
        return "every hour";
    };
    en.prototype.atSpace = function () {
        return "At ";
    };
    en.prototype.everyMinuteBetweenX0AndX1 = function () {
        return "Every minute between %s and %s";
    };
    en.prototype.at = function () {
        return "At";
    };
    en.prototype.spaceAnd = function () {
        return " and";
    };
    en.prototype.everySecond = function () {
        return "every second";
    };
    en.prototype.everyX0Seconds = function () {
        return "every %s seconds";
    };
    en.prototype.secondsX0ThroughX1PastTheMinute = function () {
        return "seconds %s through %s past the minute";
    };
    en.prototype.atX0SecondsPastTheMinute = function () {
        return "at %s seconds past the minute";
    };
    en.prototype.everyX0Minutes = function () {
        return "every %s minutes";
    };
    en.prototype.minutesX0ThroughX1PastTheHour = function () {
        return "minutes %s through %s past the hour";
    };
    en.prototype.atX0MinutesPastTheHour = function () {
        return "at %s minutes past the hour";
    };
    en.prototype.everyX0Hours = function () {
        return "every %s hours";
    };
    en.prototype.betweenX0AndX1 = function () {
        return "between %s and %s";
    };
    en.prototype.atX0 = function () {
        return "at %s";
    };
    en.prototype.commaEveryDay = function () {
        return ", every day";
    };
    en.prototype.commaEveryX0DaysOfTheWeek = function () {
        return ", every %s days of the week";
    };
    en.prototype.commaX0ThroughX1 = function () {
        return ", %s through %s";
    };
    en.prototype.commaAndX0ThroughX1 = function () {
        return ", %s through %s";
    };
    en.prototype.first = function () {
        return "first";
    };
    en.prototype.second = function () {
        return "second";
    };
    en.prototype.third = function () {
        return "third";
    };
    en.prototype.fourth = function () {
        return "fourth";
    };
    en.prototype.fifth = function () {
        return "fifth";
    };
    en.prototype.commaOnThe = function () {
        return ", on the ";
    };
    en.prototype.spaceX0OfTheMonth = function () {
        return " %s of the month";
    };
    en.prototype.lastDay = function () {
        return "the last day";
    };
    en.prototype.commaOnTheLastX0OfTheMonth = function () {
        return ", on the last %s of the month";
    };
    en.prototype.commaOnlyOnX0 = function () {
        return ", only on %s";
    };
    en.prototype.commaAndOnX0 = function () {
        return ", and on %s";
    };
    en.prototype.commaEveryX0Months = function () {
        return ", every %s months";
    };
    en.prototype.commaOnlyInX0 = function () {
        return ", only in %s";
    };
    en.prototype.commaOnTheLastDayOfTheMonth = function () {
        return ", on the last day of the month";
    };
    en.prototype.commaOnTheLastWeekdayOfTheMonth = function () {
        return ", on the last weekday of the month";
    };
    en.prototype.commaDaysBeforeTheLastDayOfTheMonth = function () {
        return ", %s days before the last day of the month";
    };
    en.prototype.firstWeekday = function () {
        return "first weekday";
    };
    en.prototype.weekdayNearestDayX0 = function () {
        return "weekday nearest day %s";
    };
    en.prototype.commaOnTheX0OfTheMonth = function () {
        return ", on the %s of the month";
    };
    en.prototype.commaEveryX0Days = function () {
        return ", every %s days";
    };
    en.prototype.commaBetweenDayX0AndX1OfTheMonth = function () {
        return ", between day %s and %s of the month";
    };
    en.prototype.commaOnDayX0OfTheMonth = function () {
        return ", on day %s of the month";
    };
    en.prototype.commaEveryHour = function () {
        return ", every hour";
    };
    en.prototype.commaEveryX0Years = function () {
        return ", every %s years";
    };
    en.prototype.commaStartingX0 = function () {
        return ", starting %s";
    };
    en.prototype.daysOfTheWeek = function () {
        return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    };
    en.prototype.monthsOfTheYear = function () {
        return [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ];
    };
    return en;
}());
exports.en = en;


/***/ }),

/***/ 586:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
function assert(value, message) {
    if (!value) {
        throw new Error(message);
    }
}
var RangeValidator = (function () {
    function RangeValidator() {
    }
    RangeValidator.secondRange = function (parse) {
        var parsed = parse.split(',');
        for (var i = 0; i < parsed.length; i++) {
            if (!isNaN(parseInt(parsed[i], 10))) {
                var second = parseInt(parsed[i], 10);
                assert(second >= 0 && second <= 59, 'seconds part must be >= 0 and <= 59');
            }
        }
    };
    RangeValidator.minuteRange = function (parse) {
        var parsed = parse.split(',');
        for (var i = 0; i < parsed.length; i++) {
            if (!isNaN(parseInt(parsed[i], 10))) {
                var minute = parseInt(parsed[i], 10);
                assert(minute >= 0 && minute <= 59, 'minutes part must be >= 0 and <= 59');
            }
        }
    };
    RangeValidator.hourRange = function (parse) {
        var parsed = parse.split(',');
        for (var i = 0; i < parsed.length; i++) {
            if (!isNaN(parseInt(parsed[i], 10))) {
                var hour = parseInt(parsed[i], 10);
                assert(hour >= 0 && hour <= 23, 'hours part must be >= 0 and <= 23');
            }
        }
    };
    RangeValidator.dayOfMonthRange = function (parse) {
        var parsed = parse.split(',');
        for (var i = 0; i < parsed.length; i++) {
            if (!isNaN(parseInt(parsed[i], 10))) {
                var dayOfMonth = parseInt(parsed[i], 10);
                assert(dayOfMonth >= 1 && dayOfMonth <= 31, 'DOM part must be >= 1 and <= 31');
            }
        }
    };
    RangeValidator.monthRange = function (parse, monthStartIndexZero) {
        var parsed = parse.split(',');
        for (var i = 0; i < parsed.length; i++) {
            if (!isNaN(parseInt(parsed[i], 10))) {
                var month = parseInt(parsed[i], 10);
                assert(month >= 1 && month <= 12, monthStartIndexZero ? 'month part must be >= 0 and <= 11' : 'month part must be >= 1 and <= 12');
            }
        }
    };
    RangeValidator.dayOfWeekRange = function (parse, dayOfWeekStartIndexZero) {
        var parsed = parse.split(',');
        for (var i = 0; i < parsed.length; i++) {
            if (!isNaN(parseInt(parsed[i], 10))) {
                var dayOfWeek = parseInt(parsed[i], 10);
                assert(dayOfWeek >= 0 && dayOfWeek <= 6, dayOfWeekStartIndexZero ? 'DOW part must be >= 0 and <= 6' : 'DOW part must be >= 1 and <= 7');
            }
        }
    };
    return RangeValidator;
}());
exports["default"] = RangeValidator;


/***/ }),

/***/ 910:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringUtilities = void 0;
var StringUtilities = (function () {
    function StringUtilities() {
    }
    StringUtilities.format = function (template) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
        }
        return template.replace(/%s/g, function (substring) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return values.shift();
        });
    };
    StringUtilities.containsAny = function (text, searchStrings) {
        return searchStrings.some(function (c) {
            return text.indexOf(c) > -1;
        });
    };
    return StringUtilities;
}());
exports.StringUtilities = StringUtilities;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_43082__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_43082__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __nested_webpack_exports__;

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toString = void 0;
var expressionDescriptor_1 = __nested_webpack_require_43082__(728);
var enLocaleLoader_1 = __nested_webpack_require_43082__(336);
expressionDescriptor_1.ExpressionDescriptor.initialize(new enLocaleLoader_1.enLocaleLoader());
exports["default"] = expressionDescriptor_1.ExpressionDescriptor;
var toString = expressionDescriptor_1.ExpressionDescriptor.toString;
exports.toString = toString;

})();

/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/dayjs/dayjs.min.js":
/*!*****************************************!*\
  !*** ./node_modules/dayjs/dayjs.min.js ***!
  \*****************************************/
/***/ (function(module) {

!function(t,e){ true?module.exports=e():0}(this,(function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(t){var e=["th","st","nd","rd"],n=t%100;return"["+t+(e[(n-20)%10]||e[n]||e[0])+"]"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},g="en",D={};D[g]=M;var p=function(t){return t instanceof _},S=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=v;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t)}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return O},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),l=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(h){case c:return r?l(1,0):l(31,11);case f:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),l=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,l=this;r=Number(r);var $=O.p(h),y=function(t){var e=w(l);return O.w(e.date(e.date()+Math.round(t*r)),l)};if($===f)return this.set(f,this.$M+r);if($===c)return this.set(c,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},$={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||$[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,v=this-M,g=O.m(this,M);return g=($={},$[c]=g/12,$[f]=g,$[h]=g/3,$[o]=(v-m)/6048e5,$[a]=(v-m)/864e5,$[u]=v/n,$[s]=v/e,$[i]=v/t,$)[y]||v,l?g:O.a(g)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),T=_.prototype;return w.prototype=T,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){T[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=D[g],w.Ls=D,w.p={},w}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/duration.js":
/*!***********************************************!*\
  !*** ./node_modules/dayjs/plugin/duration.js ***!
  \***********************************************/
/***/ (function(module) {

!function(t,s){ true?module.exports=s():0}(this,(function(){"use strict";var t,s,n=1e3,i=6e4,e=36e5,r=864e5,o=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,u=31536e6,h=2592e6,a=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/,d={years:u,months:h,days:r,hours:e,minutes:i,seconds:n,milliseconds:1,weeks:6048e5},c=function(t){return t instanceof p},f=function(t,s,n){return new p(t,n,s.$l)},m=function(t){return s.p(t)+"s"},l=function(t){return t<0},$=function(t){return l(t)?Math.ceil(t):Math.floor(t)},y=function(t){return Math.abs(t)},g=function(t,s){return t?l(t)?{negative:!0,format:""+y(t)+s}:{negative:!1,format:""+t+s}:{negative:!1,format:""}},p=function(){function l(t,s,n){var i=this;if(this.$d={},this.$l=n,void 0===t&&(this.$ms=0,this.parseFromMilliseconds()),s)return f(t*d[m(s)],this);if("number"==typeof t)return this.$ms=t,this.parseFromMilliseconds(),this;if("object"==typeof t)return Object.keys(t).forEach((function(s){i.$d[m(s)]=t[s]})),this.calMilliseconds(),this;if("string"==typeof t){var e=t.match(a);if(e){var r=e.slice(2).map((function(t){return null!=t?Number(t):0}));return this.$d.years=r[0],this.$d.months=r[1],this.$d.weeks=r[2],this.$d.days=r[3],this.$d.hours=r[4],this.$d.minutes=r[5],this.$d.seconds=r[6],this.calMilliseconds(),this}}return this}var y=l.prototype;return y.calMilliseconds=function(){var t=this;this.$ms=Object.keys(this.$d).reduce((function(s,n){return s+(t.$d[n]||0)*d[n]}),0)},y.parseFromMilliseconds=function(){var t=this.$ms;this.$d.years=$(t/u),t%=u,this.$d.months=$(t/h),t%=h,this.$d.days=$(t/r),t%=r,this.$d.hours=$(t/e),t%=e,this.$d.minutes=$(t/i),t%=i,this.$d.seconds=$(t/n),t%=n,this.$d.milliseconds=t},y.toISOString=function(){var t=g(this.$d.years,"Y"),s=g(this.$d.months,"M"),n=+this.$d.days||0;this.$d.weeks&&(n+=7*this.$d.weeks);var i=g(n,"D"),e=g(this.$d.hours,"H"),r=g(this.$d.minutes,"M"),o=this.$d.seconds||0;this.$d.milliseconds&&(o+=this.$d.milliseconds/1e3);var u=g(o,"S"),h=t.negative||s.negative||i.negative||e.negative||r.negative||u.negative,a=e.format||r.format||u.format?"T":"",d=(h?"-":"")+"P"+t.format+s.format+i.format+a+e.format+r.format+u.format;return"P"===d||"-P"===d?"P0D":d},y.toJSON=function(){return this.toISOString()},y.format=function(t){var n=t||"YYYY-MM-DDTHH:mm:ss",i={Y:this.$d.years,YY:s.s(this.$d.years,2,"0"),YYYY:s.s(this.$d.years,4,"0"),M:this.$d.months,MM:s.s(this.$d.months,2,"0"),D:this.$d.days,DD:s.s(this.$d.days,2,"0"),H:this.$d.hours,HH:s.s(this.$d.hours,2,"0"),m:this.$d.minutes,mm:s.s(this.$d.minutes,2,"0"),s:this.$d.seconds,ss:s.s(this.$d.seconds,2,"0"),SSS:s.s(this.$d.milliseconds,3,"0")};return n.replace(o,(function(t,s){return s||String(i[t])}))},y.as=function(t){return this.$ms/d[m(t)]},y.get=function(t){var s=this.$ms,n=m(t);return"milliseconds"===n?s%=1e3:s="weeks"===n?$(s/d[n]):this.$d[n],0===s?0:s},y.add=function(t,s,n){var i;return i=s?t*d[m(s)]:c(t)?t.$ms:f(t,this).$ms,f(this.$ms+i*(n?-1:1),this)},y.subtract=function(t,s){return this.add(t,s,!0)},y.locale=function(t){var s=this.clone();return s.$l=t,s},y.clone=function(){return f(this.$ms,this)},y.humanize=function(s){return t().add(this.$ms,"ms").locale(this.$l).fromNow(!s)},y.milliseconds=function(){return this.get("milliseconds")},y.asMilliseconds=function(){return this.as("milliseconds")},y.seconds=function(){return this.get("seconds")},y.asSeconds=function(){return this.as("seconds")},y.minutes=function(){return this.get("minutes")},y.asMinutes=function(){return this.as("minutes")},y.hours=function(){return this.get("hours")},y.asHours=function(){return this.as("hours")},y.days=function(){return this.get("days")},y.asDays=function(){return this.as("days")},y.weeks=function(){return this.get("weeks")},y.asWeeks=function(){return this.as("weeks")},y.months=function(){return this.get("months")},y.asMonths=function(){return this.as("months")},y.years=function(){return this.get("years")},y.asYears=function(){return this.as("years")},l}();return function(n,i,e){t=e,s=e().$utils(),e.duration=function(t,s){var n=e.locale();return f(t,{$l:n},s)},e.isDuration=c;var r=i.prototype.add,o=i.prototype.subtract;i.prototype.add=function(t,s){return c(t)&&(t=t.asMilliseconds()),r.bind(this)(t,s)},i.prototype.subtract=function(t,s){return c(t)&&(t=t.asMilliseconds()),o.bind(this)(t,s)}}}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/localizedFormat.js":
/*!******************************************************!*\
  !*** ./node_modules/dayjs/plugin/localizedFormat.js ***!
  \******************************************************/
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(function(){"use strict";var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};return function(t,o,n){var r=o.prototype,i=r.format;n.en.formats=e,r.format=function(t){void 0===t&&(t="YYYY-MM-DDTHH:mm:ssZ");var o=this.$locale().formats,n=function(t,o){return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var i=r&&r.toUpperCase();return n||o[r]||e[r]||o[i].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,o){return t||o.slice(1)}))}))}(t,void 0===o?{}:o);return i.call(this,n)}}}));

/***/ }),

/***/ "./node_modules/dayjs/plugin/relativeTime.js":
/*!***************************************************!*\
  !*** ./node_modules/dayjs/plugin/relativeTime.js ***!
  \***************************************************/
/***/ (function(module) {

!function(r,e){ true?module.exports=e():0}(this,(function(){"use strict";return function(r,e,t){r=r||{};var n=e.prototype,o={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function i(r,e,t,o){return n.fromToBase(r,e,t,o)}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(""+p)),a="string"==typeof v?v.replace("%d",p):v(p,n,y.l,s);break}}if(n)return a;var M=s?l.future:l.past;return"function"==typeof M?M(a):M.replace("%s",a)},n.to=function(r,e){return i(r,e,this,!0)},n.from=function(r,e){return i(r,e,this)};var d=function(r){return r.$u?t.utc():t()};n.toNow=function(r){return this.to(d(this),r)},n.fromNow=function(r){return this.from(d(this),r)}}}));

/***/ }),

/***/ "./node_modules/deprecation/dist-web/index.js":
/*!****************************************************!*\
  !*** ./node_modules/deprecation/dist-web/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Deprecation: () => (/* binding */ Deprecation)
/* harmony export */ });
class Deprecation extends Error {
  constructor(message) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = 'Deprecation';
  }

}




/***/ }),

/***/ "./node_modules/libsodium-wrappers/dist/modules/libsodium-wrappers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/libsodium-wrappers/dist/modules/libsodium-wrappers.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(e){function r(e,r){"use strict";var t,a=r.ready.then((function(){function a(){if(0!==t._sodium_init())throw new Error("libsodium was not correctly initialized.");for(var r=["crypto_aead_chacha20poly1305_decrypt","crypto_aead_chacha20poly1305_decrypt_detached","crypto_aead_chacha20poly1305_encrypt","crypto_aead_chacha20poly1305_encrypt_detached","crypto_aead_chacha20poly1305_ietf_decrypt","crypto_aead_chacha20poly1305_ietf_decrypt_detached","crypto_aead_chacha20poly1305_ietf_encrypt","crypto_aead_chacha20poly1305_ietf_encrypt_detached","crypto_aead_chacha20poly1305_ietf_keygen","crypto_aead_chacha20poly1305_keygen","crypto_aead_xchacha20poly1305_ietf_decrypt","crypto_aead_xchacha20poly1305_ietf_decrypt_detached","crypto_aead_xchacha20poly1305_ietf_encrypt","crypto_aead_xchacha20poly1305_ietf_encrypt_detached","crypto_aead_xchacha20poly1305_ietf_keygen","crypto_auth","crypto_auth_hmacsha256","crypto_auth_hmacsha256_final","crypto_auth_hmacsha256_init","crypto_auth_hmacsha256_keygen","crypto_auth_hmacsha256_update","crypto_auth_hmacsha256_verify","crypto_auth_hmacsha512","crypto_auth_hmacsha512_final","crypto_auth_hmacsha512_init","crypto_auth_hmacsha512_keygen","crypto_auth_hmacsha512_update","crypto_auth_hmacsha512_verify","crypto_auth_keygen","crypto_auth_verify","crypto_box_beforenm","crypto_box_curve25519xchacha20poly1305_keypair","crypto_box_curve25519xchacha20poly1305_seal","crypto_box_curve25519xchacha20poly1305_seal_open","crypto_box_detached","crypto_box_easy","crypto_box_easy_afternm","crypto_box_keypair","crypto_box_open_detached","crypto_box_open_easy","crypto_box_open_easy_afternm","crypto_box_seal","crypto_box_seal_open","crypto_box_seed_keypair","crypto_core_ed25519_add","crypto_core_ed25519_from_hash","crypto_core_ed25519_from_uniform","crypto_core_ed25519_is_valid_point","crypto_core_ed25519_random","crypto_core_ed25519_scalar_add","crypto_core_ed25519_scalar_complement","crypto_core_ed25519_scalar_invert","crypto_core_ed25519_scalar_mul","crypto_core_ed25519_scalar_negate","crypto_core_ed25519_scalar_random","crypto_core_ed25519_scalar_reduce","crypto_core_ed25519_scalar_sub","crypto_core_ed25519_sub","crypto_core_hchacha20","crypto_core_hsalsa20","crypto_core_ristretto255_add","crypto_core_ristretto255_from_hash","crypto_core_ristretto255_is_valid_point","crypto_core_ristretto255_random","crypto_core_ristretto255_scalar_add","crypto_core_ristretto255_scalar_complement","crypto_core_ristretto255_scalar_invert","crypto_core_ristretto255_scalar_mul","crypto_core_ristretto255_scalar_negate","crypto_core_ristretto255_scalar_random","crypto_core_ristretto255_scalar_reduce","crypto_core_ristretto255_scalar_sub","crypto_core_ristretto255_sub","crypto_generichash","crypto_generichash_blake2b_salt_personal","crypto_generichash_final","crypto_generichash_init","crypto_generichash_keygen","crypto_generichash_update","crypto_hash","crypto_hash_sha256","crypto_hash_sha256_final","crypto_hash_sha256_init","crypto_hash_sha256_update","crypto_hash_sha512","crypto_hash_sha512_final","crypto_hash_sha512_init","crypto_hash_sha512_update","crypto_kdf_derive_from_key","crypto_kdf_keygen","crypto_kx_client_session_keys","crypto_kx_keypair","crypto_kx_seed_keypair","crypto_kx_server_session_keys","crypto_onetimeauth","crypto_onetimeauth_final","crypto_onetimeauth_init","crypto_onetimeauth_keygen","crypto_onetimeauth_update","crypto_onetimeauth_verify","crypto_pwhash","crypto_pwhash_scryptsalsa208sha256","crypto_pwhash_scryptsalsa208sha256_ll","crypto_pwhash_scryptsalsa208sha256_str","crypto_pwhash_scryptsalsa208sha256_str_verify","crypto_pwhash_str","crypto_pwhash_str_needs_rehash","crypto_pwhash_str_verify","crypto_scalarmult","crypto_scalarmult_base","crypto_scalarmult_ed25519","crypto_scalarmult_ed25519_base","crypto_scalarmult_ed25519_base_noclamp","crypto_scalarmult_ed25519_noclamp","crypto_scalarmult_ristretto255","crypto_scalarmult_ristretto255_base","crypto_secretbox_detached","crypto_secretbox_easy","crypto_secretbox_keygen","crypto_secretbox_open_detached","crypto_secretbox_open_easy","crypto_secretstream_xchacha20poly1305_init_pull","crypto_secretstream_xchacha20poly1305_init_push","crypto_secretstream_xchacha20poly1305_keygen","crypto_secretstream_xchacha20poly1305_pull","crypto_secretstream_xchacha20poly1305_push","crypto_secretstream_xchacha20poly1305_rekey","crypto_shorthash","crypto_shorthash_keygen","crypto_shorthash_siphashx24","crypto_sign","crypto_sign_detached","crypto_sign_ed25519_pk_to_curve25519","crypto_sign_ed25519_sk_to_curve25519","crypto_sign_ed25519_sk_to_pk","crypto_sign_ed25519_sk_to_seed","crypto_sign_final_create","crypto_sign_final_verify","crypto_sign_init","crypto_sign_keypair","crypto_sign_open","crypto_sign_seed_keypair","crypto_sign_update","crypto_sign_verify_detached","crypto_stream_chacha20","crypto_stream_chacha20_ietf_xor","crypto_stream_chacha20_ietf_xor_ic","crypto_stream_chacha20_keygen","crypto_stream_chacha20_xor","crypto_stream_chacha20_xor_ic","crypto_stream_keygen","crypto_stream_xchacha20_keygen","crypto_stream_xchacha20_xor","crypto_stream_xchacha20_xor_ic","randombytes_buf","randombytes_buf_deterministic","randombytes_close","randombytes_random","randombytes_set_implementation","randombytes_stir","randombytes_uniform","sodium_version_string"],a=[E,x,k,S,T,w,Y,B,A,K,M,I,N,L,U,O,C,R,P,G,X,D,F,V,H,q,j,z,W,J,Q,Z,$,ee,re,te,ae,_e,se,ne,ce,oe,he,pe,ye,ie,le,ue,de,ve,ge,be,fe,me,Ee,xe,ke,Se,Te,we,Ye,Be,Ae,Ke,Me,Ie,Ne,Le,Ue,Oe,Ce,Re,Pe,Ge,Xe,De,Fe,Ve,He,qe,je,ze,We,Je,Qe,Ze,$e,er,rr,tr,ar,_r,sr,nr,cr,or,hr,pr,yr,ir,lr,ur,dr,vr,gr,br,fr,mr,Er,xr,kr,Sr,Tr,wr,Yr,Br,Ar,Kr,Mr,Ir,Nr,Lr,Ur,Or,Cr,Rr,Pr,Gr,Xr,Dr,Fr,Vr,Hr,qr,jr,zr,Wr,Jr,Qr,Zr,$r,et,rt,tt,at,_t,st,nt,ct,ot,ht,pt,yt,it,lt,ut,dt,vt,gt,bt,ft,mt],_=0;_<a.length;_++)"function"==typeof t["_"+r[_]]&&(e[r[_]]=a[_]);var s=["SODIUM_LIBRARY_VERSION_MAJOR","SODIUM_LIBRARY_VERSION_MINOR","crypto_aead_chacha20poly1305_ABYTES","crypto_aead_chacha20poly1305_IETF_ABYTES","crypto_aead_chacha20poly1305_IETF_KEYBYTES","crypto_aead_chacha20poly1305_IETF_MESSAGEBYTES_MAX","crypto_aead_chacha20poly1305_IETF_NPUBBYTES","crypto_aead_chacha20poly1305_IETF_NSECBYTES","crypto_aead_chacha20poly1305_KEYBYTES","crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX","crypto_aead_chacha20poly1305_NPUBBYTES","crypto_aead_chacha20poly1305_NSECBYTES","crypto_aead_chacha20poly1305_ietf_ABYTES","crypto_aead_chacha20poly1305_ietf_KEYBYTES","crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX","crypto_aead_chacha20poly1305_ietf_NPUBBYTES","crypto_aead_chacha20poly1305_ietf_NSECBYTES","crypto_aead_xchacha20poly1305_IETF_ABYTES","crypto_aead_xchacha20poly1305_IETF_KEYBYTES","crypto_aead_xchacha20poly1305_IETF_MESSAGEBYTES_MAX","crypto_aead_xchacha20poly1305_IETF_NPUBBYTES","crypto_aead_xchacha20poly1305_IETF_NSECBYTES","crypto_aead_xchacha20poly1305_ietf_ABYTES","crypto_aead_xchacha20poly1305_ietf_KEYBYTES","crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX","crypto_aead_xchacha20poly1305_ietf_NPUBBYTES","crypto_aead_xchacha20poly1305_ietf_NSECBYTES","crypto_auth_BYTES","crypto_auth_KEYBYTES","crypto_auth_hmacsha256_BYTES","crypto_auth_hmacsha256_KEYBYTES","crypto_auth_hmacsha512256_BYTES","crypto_auth_hmacsha512256_KEYBYTES","crypto_auth_hmacsha512_BYTES","crypto_auth_hmacsha512_KEYBYTES","crypto_box_BEFORENMBYTES","crypto_box_MACBYTES","crypto_box_MESSAGEBYTES_MAX","crypto_box_NONCEBYTES","crypto_box_PUBLICKEYBYTES","crypto_box_SEALBYTES","crypto_box_SECRETKEYBYTES","crypto_box_SEEDBYTES","crypto_box_curve25519xchacha20poly1305_BEFORENMBYTES","crypto_box_curve25519xchacha20poly1305_MACBYTES","crypto_box_curve25519xchacha20poly1305_MESSAGEBYTES_MAX","crypto_box_curve25519xchacha20poly1305_NONCEBYTES","crypto_box_curve25519xchacha20poly1305_PUBLICKEYBYTES","crypto_box_curve25519xchacha20poly1305_SEALBYTES","crypto_box_curve25519xchacha20poly1305_SECRETKEYBYTES","crypto_box_curve25519xchacha20poly1305_SEEDBYTES","crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES","crypto_box_curve25519xsalsa20poly1305_MACBYTES","crypto_box_curve25519xsalsa20poly1305_MESSAGEBYTES_MAX","crypto_box_curve25519xsalsa20poly1305_NONCEBYTES","crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES","crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES","crypto_box_curve25519xsalsa20poly1305_SEEDBYTES","crypto_core_ed25519_BYTES","crypto_core_ed25519_HASHBYTES","crypto_core_ed25519_NONREDUCEDSCALARBYTES","crypto_core_ed25519_SCALARBYTES","crypto_core_ed25519_UNIFORMBYTES","crypto_core_hchacha20_CONSTBYTES","crypto_core_hchacha20_INPUTBYTES","crypto_core_hchacha20_KEYBYTES","crypto_core_hchacha20_OUTPUTBYTES","crypto_core_hsalsa20_CONSTBYTES","crypto_core_hsalsa20_INPUTBYTES","crypto_core_hsalsa20_KEYBYTES","crypto_core_hsalsa20_OUTPUTBYTES","crypto_core_ristretto255_BYTES","crypto_core_ristretto255_HASHBYTES","crypto_core_ristretto255_NONREDUCEDSCALARBYTES","crypto_core_ristretto255_SCALARBYTES","crypto_core_salsa2012_CONSTBYTES","crypto_core_salsa2012_INPUTBYTES","crypto_core_salsa2012_KEYBYTES","crypto_core_salsa2012_OUTPUTBYTES","crypto_core_salsa20_CONSTBYTES","crypto_core_salsa20_INPUTBYTES","crypto_core_salsa20_KEYBYTES","crypto_core_salsa20_OUTPUTBYTES","crypto_generichash_BYTES","crypto_generichash_BYTES_MAX","crypto_generichash_BYTES_MIN","crypto_generichash_KEYBYTES","crypto_generichash_KEYBYTES_MAX","crypto_generichash_KEYBYTES_MIN","crypto_generichash_blake2b_BYTES","crypto_generichash_blake2b_BYTES_MAX","crypto_generichash_blake2b_BYTES_MIN","crypto_generichash_blake2b_KEYBYTES","crypto_generichash_blake2b_KEYBYTES_MAX","crypto_generichash_blake2b_KEYBYTES_MIN","crypto_generichash_blake2b_PERSONALBYTES","crypto_generichash_blake2b_SALTBYTES","crypto_hash_BYTES","crypto_hash_sha256_BYTES","crypto_hash_sha512_BYTES","crypto_kdf_BYTES_MAX","crypto_kdf_BYTES_MIN","crypto_kdf_CONTEXTBYTES","crypto_kdf_KEYBYTES","crypto_kdf_blake2b_BYTES_MAX","crypto_kdf_blake2b_BYTES_MIN","crypto_kdf_blake2b_CONTEXTBYTES","crypto_kdf_blake2b_KEYBYTES","crypto_kx_PUBLICKEYBYTES","crypto_kx_SECRETKEYBYTES","crypto_kx_SEEDBYTES","crypto_kx_SESSIONKEYBYTES","crypto_onetimeauth_BYTES","crypto_onetimeauth_KEYBYTES","crypto_onetimeauth_poly1305_BYTES","crypto_onetimeauth_poly1305_KEYBYTES","crypto_pwhash_ALG_ARGON2I13","crypto_pwhash_ALG_ARGON2ID13","crypto_pwhash_ALG_DEFAULT","crypto_pwhash_BYTES_MAX","crypto_pwhash_BYTES_MIN","crypto_pwhash_MEMLIMIT_INTERACTIVE","crypto_pwhash_MEMLIMIT_MAX","crypto_pwhash_MEMLIMIT_MIN","crypto_pwhash_MEMLIMIT_MODERATE","crypto_pwhash_MEMLIMIT_SENSITIVE","crypto_pwhash_OPSLIMIT_INTERACTIVE","crypto_pwhash_OPSLIMIT_MAX","crypto_pwhash_OPSLIMIT_MIN","crypto_pwhash_OPSLIMIT_MODERATE","crypto_pwhash_OPSLIMIT_SENSITIVE","crypto_pwhash_PASSWD_MAX","crypto_pwhash_PASSWD_MIN","crypto_pwhash_SALTBYTES","crypto_pwhash_STRBYTES","crypto_pwhash_argon2i_BYTES_MAX","crypto_pwhash_argon2i_BYTES_MIN","crypto_pwhash_argon2i_SALTBYTES","crypto_pwhash_argon2i_STRBYTES","crypto_pwhash_argon2id_BYTES_MAX","crypto_pwhash_argon2id_BYTES_MIN","crypto_pwhash_argon2id_SALTBYTES","crypto_pwhash_argon2id_STRBYTES","crypto_pwhash_scryptsalsa208sha256_BYTES_MAX","crypto_pwhash_scryptsalsa208sha256_BYTES_MIN","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN","crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN","crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE","crypto_pwhash_scryptsalsa208sha256_SALTBYTES","crypto_pwhash_scryptsalsa208sha256_STRBYTES","crypto_scalarmult_BYTES","crypto_scalarmult_SCALARBYTES","crypto_scalarmult_curve25519_BYTES","crypto_scalarmult_curve25519_SCALARBYTES","crypto_scalarmult_ed25519_BYTES","crypto_scalarmult_ed25519_SCALARBYTES","crypto_scalarmult_ristretto255_BYTES","crypto_scalarmult_ristretto255_SCALARBYTES","crypto_secretbox_KEYBYTES","crypto_secretbox_MACBYTES","crypto_secretbox_MESSAGEBYTES_MAX","crypto_secretbox_NONCEBYTES","crypto_secretbox_xchacha20poly1305_KEYBYTES","crypto_secretbox_xchacha20poly1305_MACBYTES","crypto_secretbox_xchacha20poly1305_MESSAGEBYTES_MAX","crypto_secretbox_xchacha20poly1305_NONCEBYTES","crypto_secretbox_xsalsa20poly1305_KEYBYTES","crypto_secretbox_xsalsa20poly1305_MACBYTES","crypto_secretbox_xsalsa20poly1305_MESSAGEBYTES_MAX","crypto_secretbox_xsalsa20poly1305_NONCEBYTES","crypto_secretstream_xchacha20poly1305_ABYTES","crypto_secretstream_xchacha20poly1305_HEADERBYTES","crypto_secretstream_xchacha20poly1305_KEYBYTES","crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX","crypto_secretstream_xchacha20poly1305_TAG_FINAL","crypto_secretstream_xchacha20poly1305_TAG_MESSAGE","crypto_secretstream_xchacha20poly1305_TAG_PUSH","crypto_secretstream_xchacha20poly1305_TAG_REKEY","crypto_shorthash_BYTES","crypto_shorthash_KEYBYTES","crypto_shorthash_siphash24_BYTES","crypto_shorthash_siphash24_KEYBYTES","crypto_shorthash_siphashx24_BYTES","crypto_shorthash_siphashx24_KEYBYTES","crypto_sign_BYTES","crypto_sign_MESSAGEBYTES_MAX","crypto_sign_PUBLICKEYBYTES","crypto_sign_SECRETKEYBYTES","crypto_sign_SEEDBYTES","crypto_sign_ed25519_BYTES","crypto_sign_ed25519_MESSAGEBYTES_MAX","crypto_sign_ed25519_PUBLICKEYBYTES","crypto_sign_ed25519_SECRETKEYBYTES","crypto_sign_ed25519_SEEDBYTES","crypto_stream_KEYBYTES","crypto_stream_MESSAGEBYTES_MAX","crypto_stream_NONCEBYTES","crypto_stream_chacha20_IETF_KEYBYTES","crypto_stream_chacha20_IETF_MESSAGEBYTES_MAX","crypto_stream_chacha20_IETF_NONCEBYTES","crypto_stream_chacha20_KEYBYTES","crypto_stream_chacha20_MESSAGEBYTES_MAX","crypto_stream_chacha20_NONCEBYTES","crypto_stream_chacha20_ietf_KEYBYTES","crypto_stream_chacha20_ietf_MESSAGEBYTES_MAX","crypto_stream_chacha20_ietf_NONCEBYTES","crypto_stream_salsa2012_KEYBYTES","crypto_stream_salsa2012_MESSAGEBYTES_MAX","crypto_stream_salsa2012_NONCEBYTES","crypto_stream_salsa208_KEYBYTES","crypto_stream_salsa208_MESSAGEBYTES_MAX","crypto_stream_salsa208_NONCEBYTES","crypto_stream_salsa20_KEYBYTES","crypto_stream_salsa20_MESSAGEBYTES_MAX","crypto_stream_salsa20_NONCEBYTES","crypto_stream_xchacha20_KEYBYTES","crypto_stream_xchacha20_MESSAGEBYTES_MAX","crypto_stream_xchacha20_NONCEBYTES","crypto_stream_xsalsa20_KEYBYTES","crypto_stream_xsalsa20_MESSAGEBYTES_MAX","crypto_stream_xsalsa20_NONCEBYTES","crypto_verify_16_BYTES","crypto_verify_32_BYTES","crypto_verify_64_BYTES"];for(_=0;_<s.length;_++)"function"==typeof(c=t["_"+s[_].toLowerCase()])&&(e[s[_]]=c());var n=["SODIUM_VERSION_STRING","crypto_pwhash_STRPREFIX","crypto_pwhash_scryptsalsa208sha256_STRPREFIX"];for(_=0;_<n.length;_++){var c;"function"==typeof(c=t["_"+n[_].toLowerCase()])&&(e[n[_]]=t.UTF8ToString(c()))}}t=r;try{a();var _=new Uint8Array([98,97,108,108,115]),s=e.randombytes_buf(e.crypto_secretbox_NONCEBYTES),n=e.randombytes_buf(e.crypto_secretbox_KEYBYTES),c=e.crypto_secretbox_easy(_,s,n),o=e.crypto_secretbox_open_easy(c,s,n);if(e.memcmp(_,o))return}catch(e){if(null==t.useBackupModule)throw new Error("Both wasm and asm failed to load"+e)}t.useBackupModule(),a()}));function _(e){if("function"==typeof TextEncoder)return(new TextEncoder).encode(e);e=unescape(encodeURIComponent(e));for(var r=new Uint8Array(e.length),t=0,a=e.length;t<a;t++)r[t]=e.charCodeAt(t);return r}function s(e){if("function"==typeof TextDecoder)return new TextDecoder("utf-8",{fatal:!0}).decode(e);var r=8192,t=Math.ceil(e.length/r);if(t<=1)try{return decodeURIComponent(escape(String.fromCharCode.apply(null,e)))}catch(e){throw new TypeError("The encoded data was not valid.")}for(var a="",_=0,n=0;n<t;n++){var c=Array.prototype.slice.call(e,n*r+_,(n+1)*r+_);if(0!=c.length){var o,h=c.length,p=0;do{var y=c[--h];y>=240?(p=4,o=!0):y>=224?(p=3,o=!0):y>=192?(p=2,o=!0):y<128&&(p=1,o=!0)}while(!o);for(var i=p-(c.length-h),l=0;l<i;l++)_--,c.pop();a+=s(c)}}return a}function n(e){e=m(null,e,"input");for(var r,t,a,_="",s=0;s<e.length;s++)a=87+(t=15&e[s])+(t-10>>8&-39)<<8|87+(r=e[s]>>>4)+(r-10>>8&-39),_+=String.fromCharCode(255&a)+String.fromCharCode(a>>>8);return _}var c={ORIGINAL:1,ORIGINAL_NO_PADDING:3,URLSAFE:5,URLSAFE_NO_PADDING:7};function o(e){if(null==e)return c.URLSAFE_NO_PADDING;if(e!==c.ORIGINAL&&e!==c.ORIGINAL_NO_PADDING&&e!==c.URLSAFE&&e!=c.URLSAFE_NO_PADDING)throw new Error("unsupported base64 variant");return e}function h(e,r){r=o(r),e=m(_,e,"input");var a,_=[],n=0|Math.floor(e.length/3),c=e.length-3*n,h=4*n+(0!==c?0==(2&r)?4:2+(c>>>1):0),p=new l(h+1),y=u(e);return _.push(y),_.push(p.address),0===t._sodium_bin2base64(p.address,p.length,y,e.length,r)&&g(_,"conversion failed"),p.length=h,a=s(p.to_Uint8Array()),v(_),a}function p(e,r){var t=r||"uint8array";if(!y(t))throw new Error(t+" output format is not available");if(e instanceof l){if("uint8array"===t)return e.to_Uint8Array();if("text"===t)return s(e.to_Uint8Array());if("hex"===t)return n(e.to_Uint8Array());if("base64"===t)return h(e.to_Uint8Array(),c.URLSAFE_NO_PADDING);throw new Error('What is output format "'+t+'"?')}if("object"==typeof e){for(var a=Object.keys(e),_={},o=0;o<a.length;o++)_[a[o]]=p(e[a[o]],t);return _}if("string"==typeof e)return e;throw new TypeError("Cannot format output")}function y(e){for(var r=["uint8array","text","hex","base64"],t=0;t<r.length;t++)if(r[t]===e)return!0;return!1}function i(e){if(e){if("string"!=typeof e)throw new TypeError("When defined, the output format must be a string");if(!y(e))throw new Error(e+" is not a supported output format")}}function l(e){this.length=e,this.address=d(e)}function u(e){var r=d(e.length);return t.HEAPU8.set(e,r),r}function d(e){var r=t._malloc(e);if(0===r)throw{message:"_malloc() failed",length:e};return r}function v(e){if(e)for(var r=0;r<e.length;r++)a=e[r],t._free(a);var a}function g(e,r){throw v(e),new Error(r)}function b(e,r){throw v(e),new TypeError(r)}function f(e,r,t){null==r&&b(e,t+" cannot be null or undefined")}function m(e,r,t){return f(e,r,t),r instanceof Uint8Array?r:"string"==typeof r?_(r):void b(e,"unsupported input type for "+t)}function E(e,r,a,_,s,n){var c=[];i(n);var o=null;null!=e&&(o=u(e=m(c,e,"secret_nonce")),e.length,c.push(o)),r=m(c,r,"ciphertext");var h,y=t._crypto_aead_chacha20poly1305_abytes(),d=r.length;d<y&&b(c,"ciphertext is too short"),h=u(r),c.push(h);var f=null,E=0;null!=a&&(f=u(a=m(c,a,"additional_data")),E=a.length,c.push(f)),_=m(c,_,"public_nonce");var x,k=0|t._crypto_aead_chacha20poly1305_npubbytes();_.length!==k&&b(c,"invalid public_nonce length"),x=u(_),c.push(x),s=m(c,s,"key");var S,T=0|t._crypto_aead_chacha20poly1305_keybytes();s.length!==T&&b(c,"invalid key length"),S=u(s),c.push(S);var w=new l(d-t._crypto_aead_chacha20poly1305_abytes()|0),Y=w.address;if(c.push(Y),0===t._crypto_aead_chacha20poly1305_decrypt(Y,null,o,h,d,0,f,E,0,x,S)){var B=p(w,n);return v(c),B}g(c,"ciphertext cannot be decrypted using that key")}function x(e,r,a,_,s,n,c){var o=[];i(c);var h=null;null!=e&&(h=u(e=m(o,e,"secret_nonce")),e.length,o.push(h));var y=u(r=m(o,r,"ciphertext")),d=r.length;o.push(y),a=m(o,a,"mac");var f,E=0|t._crypto_box_macbytes();a.length!==E&&b(o,"invalid mac length"),f=u(a),o.push(f);var x=null,k=0;null!=_&&(x=u(_=m(o,_,"additional_data")),k=_.length,o.push(x)),s=m(o,s,"public_nonce");var S,T=0|t._crypto_aead_chacha20poly1305_npubbytes();s.length!==T&&b(o,"invalid public_nonce length"),S=u(s),o.push(S),n=m(o,n,"key");var w,Y=0|t._crypto_aead_chacha20poly1305_keybytes();n.length!==Y&&b(o,"invalid key length"),w=u(n),o.push(w);var B=new l(0|d),A=B.address;if(o.push(A),0===t._crypto_aead_chacha20poly1305_decrypt_detached(A,h,y,d,0,f,x,k,0,S,w)){var K=p(B,c);return v(o),K}g(o,"ciphertext cannot be decrypted using that key")}function k(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_chacha20poly1305_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_chacha20poly1305_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(h+t._crypto_aead_chacha20poly1305_abytes()|0),w=T.address;if(c.push(w),0===t._crypto_aead_chacha20poly1305_encrypt(w,null,o,h,0,y,d,0,f,E,k)){var Y=p(T,n);return v(c),Y}g(c,"invalid usage")}function S(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_chacha20poly1305_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_chacha20poly1305_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(0|h),w=T.address;c.push(w);var Y=new l(0|t._crypto_aead_chacha20poly1305_abytes()),B=Y.address;if(c.push(B),0===t._crypto_aead_chacha20poly1305_encrypt_detached(w,B,null,o,h,0,y,d,0,f,E,k)){var A=p({ciphertext:T,mac:Y},n);return v(c),A}g(c,"invalid usage")}function T(e,r,a,_,s,n){var c=[];i(n);var o=null;null!=e&&(o=u(e=m(c,e,"secret_nonce")),e.length,c.push(o)),r=m(c,r,"ciphertext");var h,y=t._crypto_aead_chacha20poly1305_ietf_abytes(),d=r.length;d<y&&b(c,"ciphertext is too short"),h=u(r),c.push(h);var f=null,E=0;null!=a&&(f=u(a=m(c,a,"additional_data")),E=a.length,c.push(f)),_=m(c,_,"public_nonce");var x,k=0|t._crypto_aead_chacha20poly1305_ietf_npubbytes();_.length!==k&&b(c,"invalid public_nonce length"),x=u(_),c.push(x),s=m(c,s,"key");var S,T=0|t._crypto_aead_chacha20poly1305_ietf_keybytes();s.length!==T&&b(c,"invalid key length"),S=u(s),c.push(S);var w=new l(d-t._crypto_aead_chacha20poly1305_ietf_abytes()|0),Y=w.address;if(c.push(Y),0===t._crypto_aead_chacha20poly1305_ietf_decrypt(Y,null,o,h,d,0,f,E,0,x,S)){var B=p(w,n);return v(c),B}g(c,"ciphertext cannot be decrypted using that key")}function w(e,r,a,_,s,n,c){var o=[];i(c);var h=null;null!=e&&(h=u(e=m(o,e,"secret_nonce")),e.length,o.push(h));var y=u(r=m(o,r,"ciphertext")),d=r.length;o.push(y),a=m(o,a,"mac");var f,E=0|t._crypto_box_macbytes();a.length!==E&&b(o,"invalid mac length"),f=u(a),o.push(f);var x=null,k=0;null!=_&&(x=u(_=m(o,_,"additional_data")),k=_.length,o.push(x)),s=m(o,s,"public_nonce");var S,T=0|t._crypto_aead_chacha20poly1305_ietf_npubbytes();s.length!==T&&b(o,"invalid public_nonce length"),S=u(s),o.push(S),n=m(o,n,"key");var w,Y=0|t._crypto_aead_chacha20poly1305_ietf_keybytes();n.length!==Y&&b(o,"invalid key length"),w=u(n),o.push(w);var B=new l(0|d),A=B.address;if(o.push(A),0===t._crypto_aead_chacha20poly1305_ietf_decrypt_detached(A,h,y,d,0,f,x,k,0,S,w)){var K=p(B,c);return v(o),K}g(o,"ciphertext cannot be decrypted using that key")}function Y(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_chacha20poly1305_ietf_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_chacha20poly1305_ietf_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(h+t._crypto_aead_chacha20poly1305_ietf_abytes()|0),w=T.address;if(c.push(w),0===t._crypto_aead_chacha20poly1305_ietf_encrypt(w,null,o,h,0,y,d,0,f,E,k)){var Y=p(T,n);return v(c),Y}g(c,"invalid usage")}function B(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_chacha20poly1305_ietf_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_chacha20poly1305_ietf_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(0|h),w=T.address;c.push(w);var Y=new l(0|t._crypto_aead_chacha20poly1305_ietf_abytes()),B=Y.address;if(c.push(B),0===t._crypto_aead_chacha20poly1305_ietf_encrypt_detached(w,B,null,o,h,0,y,d,0,f,E,k)){var A=p({ciphertext:T,mac:Y},n);return v(c),A}g(c,"invalid usage")}function A(e){var r=[];i(e);var a=new l(0|t._crypto_aead_chacha20poly1305_ietf_keybytes()),_=a.address;r.push(_),t._crypto_aead_chacha20poly1305_ietf_keygen(_);var s=p(a,e);return v(r),s}function K(e){var r=[];i(e);var a=new l(0|t._crypto_aead_chacha20poly1305_keybytes()),_=a.address;r.push(_),t._crypto_aead_chacha20poly1305_keygen(_);var s=p(a,e);return v(r),s}function M(e,r,a,_,s,n){var c=[];i(n);var o=null;null!=e&&(o=u(e=m(c,e,"secret_nonce")),e.length,c.push(o)),r=m(c,r,"ciphertext");var h,y=t._crypto_aead_xchacha20poly1305_ietf_abytes(),d=r.length;d<y&&b(c,"ciphertext is too short"),h=u(r),c.push(h);var f=null,E=0;null!=a&&(f=u(a=m(c,a,"additional_data")),E=a.length,c.push(f)),_=m(c,_,"public_nonce");var x,k=0|t._crypto_aead_xchacha20poly1305_ietf_npubbytes();_.length!==k&&b(c,"invalid public_nonce length"),x=u(_),c.push(x),s=m(c,s,"key");var S,T=0|t._crypto_aead_xchacha20poly1305_ietf_keybytes();s.length!==T&&b(c,"invalid key length"),S=u(s),c.push(S);var w=new l(d-t._crypto_aead_xchacha20poly1305_ietf_abytes()|0),Y=w.address;if(c.push(Y),0===t._crypto_aead_xchacha20poly1305_ietf_decrypt(Y,null,o,h,d,0,f,E,0,x,S)){var B=p(w,n);return v(c),B}g(c,"ciphertext cannot be decrypted using that key")}function I(e,r,a,_,s,n,c){var o=[];i(c);var h=null;null!=e&&(h=u(e=m(o,e,"secret_nonce")),e.length,o.push(h));var y=u(r=m(o,r,"ciphertext")),d=r.length;o.push(y),a=m(o,a,"mac");var f,E=0|t._crypto_box_macbytes();a.length!==E&&b(o,"invalid mac length"),f=u(a),o.push(f);var x=null,k=0;null!=_&&(x=u(_=m(o,_,"additional_data")),k=_.length,o.push(x)),s=m(o,s,"public_nonce");var S,T=0|t._crypto_aead_xchacha20poly1305_ietf_npubbytes();s.length!==T&&b(o,"invalid public_nonce length"),S=u(s),o.push(S),n=m(o,n,"key");var w,Y=0|t._crypto_aead_xchacha20poly1305_ietf_keybytes();n.length!==Y&&b(o,"invalid key length"),w=u(n),o.push(w);var B=new l(0|d),A=B.address;if(o.push(A),0===t._crypto_aead_xchacha20poly1305_ietf_decrypt_detached(A,h,y,d,0,f,x,k,0,S,w)){var K=p(B,c);return v(o),K}g(o,"ciphertext cannot be decrypted using that key")}function N(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_xchacha20poly1305_ietf_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_xchacha20poly1305_ietf_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(h+t._crypto_aead_xchacha20poly1305_ietf_abytes()|0),w=T.address;if(c.push(w),0===t._crypto_aead_xchacha20poly1305_ietf_encrypt(w,null,o,h,0,y,d,0,f,E,k)){var Y=p(T,n);return v(c),Y}g(c,"invalid usage")}function L(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"message")),h=e.length;c.push(o);var y=null,d=0;null!=r&&(y=u(r=m(c,r,"additional_data")),d=r.length,c.push(y));var f=null;null!=a&&(f=u(a=m(c,a,"secret_nonce")),a.length,c.push(f)),_=m(c,_,"public_nonce");var E,x=0|t._crypto_aead_xchacha20poly1305_ietf_npubbytes();_.length!==x&&b(c,"invalid public_nonce length"),E=u(_),c.push(E),s=m(c,s,"key");var k,S=0|t._crypto_aead_xchacha20poly1305_ietf_keybytes();s.length!==S&&b(c,"invalid key length"),k=u(s),c.push(k);var T=new l(0|h),w=T.address;c.push(w);var Y=new l(0|t._crypto_aead_xchacha20poly1305_ietf_abytes()),B=Y.address;if(c.push(B),0===t._crypto_aead_xchacha20poly1305_ietf_encrypt_detached(w,B,null,o,h,0,y,d,0,f,E,k)){var A=p({ciphertext:T,mac:Y},n);return v(c),A}g(c,"invalid usage")}function U(e){var r=[];i(e);var a=new l(0|t._crypto_aead_xchacha20poly1305_ietf_keybytes()),_=a.address;r.push(_),t._crypto_aead_xchacha20poly1305_ietf_keygen(_);var s=p(a,e);return v(r),s}function O(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_auth_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_auth_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_auth(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function C(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_auth_hmacsha256_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_auth_hmacsha256_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_auth_hmacsha256(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function R(e,r){var a=[];i(r),f(a,e,"state_address");var _=new l(0|t._crypto_auth_hmacsha256_bytes()),s=_.address;if(a.push(s),0==(0|t._crypto_auth_hmacsha256_final(e,s))){var n=(t._free(e),p(_,r));return v(a),n}g(a,"invalid usage")}function P(e,r){var a=[];i(r);var _=null,s=0;null!=e&&(_=u(e=m(a,e,"key")),s=e.length,a.push(_));var n=new l(208).address;if(0==(0|t._crypto_auth_hmacsha256_init(n,_,s))){var c=n;return v(a),c}g(a,"invalid usage")}function G(e){var r=[];i(e);var a=new l(0|t._crypto_auth_hmacsha256_keybytes()),_=a.address;r.push(_),t._crypto_auth_hmacsha256_keygen(_);var s=p(a,e);return v(r),s}function X(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_auth_hmacsha256_update(e,s,n))&&g(_,"invalid usage"),v(_)}function D(e,r,a){var _=[];e=m(_,e,"tag");var s,n=0|t._crypto_auth_hmacsha256_bytes();e.length!==n&&b(_,"invalid tag length"),s=u(e),_.push(s);var c=u(r=m(_,r,"message")),o=r.length;_.push(c),a=m(_,a,"key");var h,p=0|t._crypto_auth_hmacsha256_keybytes();a.length!==p&&b(_,"invalid key length"),h=u(a),_.push(h);var y=0==(0|t._crypto_auth_hmacsha256_verify(s,c,o,0,h));return v(_),y}function F(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_auth_hmacsha512_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_auth_hmacsha512_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_auth_hmacsha512(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function V(e,r){var a=[];i(r),f(a,e,"state_address");var _=new l(0|t._crypto_auth_hmacsha512_bytes()),s=_.address;if(a.push(s),0==(0|t._crypto_auth_hmacsha512_final(e,s))){var n=(t._free(e),p(_,r));return v(a),n}g(a,"invalid usage")}function H(e,r){var a=[];i(r);var _=null,s=0;null!=e&&(_=u(e=m(a,e,"key")),s=e.length,a.push(_));var n=new l(416).address;if(0==(0|t._crypto_auth_hmacsha512_init(n,_,s))){var c=n;return v(a),c}g(a,"invalid usage")}function q(e){var r=[];i(e);var a=new l(0|t._crypto_auth_hmacsha512_keybytes()),_=a.address;r.push(_),t._crypto_auth_hmacsha512_keygen(_);var s=p(a,e);return v(r),s}function j(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_auth_hmacsha512_update(e,s,n))&&g(_,"invalid usage"),v(_)}function z(e,r,a){var _=[];e=m(_,e,"tag");var s,n=0|t._crypto_auth_hmacsha512_bytes();e.length!==n&&b(_,"invalid tag length"),s=u(e),_.push(s);var c=u(r=m(_,r,"message")),o=r.length;_.push(c),a=m(_,a,"key");var h,p=0|t._crypto_auth_hmacsha512_keybytes();a.length!==p&&b(_,"invalid key length"),h=u(a),_.push(h);var y=0==(0|t._crypto_auth_hmacsha512_verify(s,c,o,0,h));return v(_),y}function W(e){var r=[];i(e);var a=new l(0|t._crypto_auth_keybytes()),_=a.address;r.push(_),t._crypto_auth_keygen(_);var s=p(a,e);return v(r),s}function J(e,r,a){var _=[];e=m(_,e,"tag");var s,n=0|t._crypto_auth_bytes();e.length!==n&&b(_,"invalid tag length"),s=u(e),_.push(s);var c=u(r=m(_,r,"message")),o=r.length;_.push(c),a=m(_,a,"key");var h,p=0|t._crypto_auth_keybytes();a.length!==p&&b(_,"invalid key length"),h=u(a),_.push(h);var y=0==(0|t._crypto_auth_verify(s,c,o,0,h));return v(_),y}function Q(e,r,a){var _=[];i(a),e=m(_,e,"publicKey");var s,n=0|t._crypto_box_publickeybytes();e.length!==n&&b(_,"invalid publicKey length"),s=u(e),_.push(s),r=m(_,r,"privateKey");var c,o=0|t._crypto_box_secretkeybytes();r.length!==o&&b(_,"invalid privateKey length"),c=u(r),_.push(c);var h=new l(0|t._crypto_box_beforenmbytes()),y=h.address;if(_.push(y),0==(0|t._crypto_box_beforenm(y,s,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function Z(e){var r=[];i(e);var a=new l(0|t._crypto_box_curve25519xchacha20poly1305_publickeybytes()),_=a.address;r.push(_);var s=new l(0|t._crypto_box_curve25519xchacha20poly1305_secretkeybytes()),n=s.address;r.push(n),t._crypto_box_curve25519xchacha20poly1305_keypair(_,n);var c=p({publicKey:a,privateKey:s,keyType:"curve25519"},e);return v(r),c}function $(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"publicKey");var c,o=0|t._crypto_box_curve25519xchacha20poly1305_publickeybytes();r.length!==o&&b(_,"invalid publicKey length"),c=u(r),_.push(c);var h=new l(n+t._crypto_box_curve25519xchacha20poly1305_sealbytes()|0),y=h.address;_.push(y),t._crypto_box_curve25519xchacha20poly1305_seal(y,s,n,0,c);var d=p(h,a);return v(_),d}function ee(e,r,a,_){var s=[];i(_),e=m(s,e,"ciphertext");var n,c=t._crypto_box_curve25519xchacha20poly1305_sealbytes(),o=e.length;o<c&&b(s,"ciphertext is too short"),n=u(e),s.push(n),r=m(s,r,"publicKey");var h,y=0|t._crypto_box_curve25519xchacha20poly1305_publickeybytes();r.length!==y&&b(s,"invalid publicKey length"),h=u(r),s.push(h),a=m(s,a,"secretKey");var d,g=0|t._crypto_box_curve25519xchacha20poly1305_secretkeybytes();a.length!==g&&b(s,"invalid secretKey length"),d=u(a),s.push(d);var f=new l(o-t._crypto_box_curve25519xchacha20poly1305_sealbytes()|0),E=f.address;s.push(E),t._crypto_box_curve25519xchacha20poly1305_seal_open(E,n,o,0,h,d);var x=p(f,_);return v(s),x}function re(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"message")),o=e.length;n.push(c),r=m(n,r,"nonce");var h,y=0|t._crypto_box_noncebytes();r.length!==y&&b(n,"invalid nonce length"),h=u(r),n.push(h),a=m(n,a,"publicKey");var d,f=0|t._crypto_box_publickeybytes();a.length!==f&&b(n,"invalid publicKey length"),d=u(a),n.push(d),_=m(n,_,"privateKey");var E,x=0|t._crypto_box_secretkeybytes();_.length!==x&&b(n,"invalid privateKey length"),E=u(_),n.push(E);var k=new l(0|o),S=k.address;n.push(S);var T=new l(0|t._crypto_box_macbytes()),w=T.address;if(n.push(w),0==(0|t._crypto_box_detached(S,w,c,o,0,h,d,E))){var Y=p({ciphertext:k,mac:T},s);return v(n),Y}g(n,"invalid usage")}function te(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"message")),o=e.length;n.push(c),r=m(n,r,"nonce");var h,y=0|t._crypto_box_noncebytes();r.length!==y&&b(n,"invalid nonce length"),h=u(r),n.push(h),a=m(n,a,"publicKey");var d,f=0|t._crypto_box_publickeybytes();a.length!==f&&b(n,"invalid publicKey length"),d=u(a),n.push(d),_=m(n,_,"privateKey");var E,x=0|t._crypto_box_secretkeybytes();_.length!==x&&b(n,"invalid privateKey length"),E=u(_),n.push(E);var k=new l(o+t._crypto_box_macbytes()|0),S=k.address;if(n.push(S),0==(0|t._crypto_box_easy(S,c,o,0,h,d,E))){var T=p(k,s);return v(n),T}g(n,"invalid usage")}function ae(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_box_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"sharedKey");var y,d=0|t._crypto_box_beforenmbytes();a.length!==d&&b(s,"invalid sharedKey length"),y=u(a),s.push(y);var f=new l(c+t._crypto_box_macbytes()|0),E=f.address;if(s.push(E),0==(0|t._crypto_box_easy_afternm(E,n,c,0,o,y))){var x=p(f,_);return v(s),x}g(s,"invalid usage")}function _e(e){var r=[];i(e);var a=new l(0|t._crypto_box_publickeybytes()),_=a.address;r.push(_);var s=new l(0|t._crypto_box_secretkeybytes()),n=s.address;if(r.push(n),0==(0|t._crypto_box_keypair(_,n))){var c={publicKey:p(a,e),privateKey:p(s,e),keyType:"x25519"};return v(r),c}g(r,"internal error")}function se(e,r,a,_,s,n){var c=[];i(n);var o=u(e=m(c,e,"ciphertext")),h=e.length;c.push(o),r=m(c,r,"mac");var y,d=0|t._crypto_box_macbytes();r.length!==d&&b(c,"invalid mac length"),y=u(r),c.push(y),a=m(c,a,"nonce");var f,E=0|t._crypto_box_noncebytes();a.length!==E&&b(c,"invalid nonce length"),f=u(a),c.push(f),_=m(c,_,"publicKey");var x,k=0|t._crypto_box_publickeybytes();_.length!==k&&b(c,"invalid publicKey length"),x=u(_),c.push(x),s=m(c,s,"privateKey");var S,T=0|t._crypto_box_secretkeybytes();s.length!==T&&b(c,"invalid privateKey length"),S=u(s),c.push(S);var w=new l(0|h),Y=w.address;if(c.push(Y),0==(0|t._crypto_box_open_detached(Y,o,y,h,0,f,x,S))){var B=p(w,n);return v(c),B}g(c,"incorrect key pair for the given ciphertext")}function ne(e,r,a,_,s){var n=[];i(s),e=m(n,e,"ciphertext");var c,o=t._crypto_box_macbytes(),h=e.length;h<o&&b(n,"ciphertext is too short"),c=u(e),n.push(c),r=m(n,r,"nonce");var y,d=0|t._crypto_box_noncebytes();r.length!==d&&b(n,"invalid nonce length"),y=u(r),n.push(y),a=m(n,a,"publicKey");var f,E=0|t._crypto_box_publickeybytes();a.length!==E&&b(n,"invalid publicKey length"),f=u(a),n.push(f),_=m(n,_,"privateKey");var x,k=0|t._crypto_box_secretkeybytes();_.length!==k&&b(n,"invalid privateKey length"),x=u(_),n.push(x);var S=new l(h-t._crypto_box_macbytes()|0),T=S.address;if(n.push(T),0==(0|t._crypto_box_open_easy(T,c,h,0,y,f,x))){var w=p(S,s);return v(n),w}g(n,"incorrect key pair for the given ciphertext")}function ce(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"ciphertext")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_box_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"sharedKey");var y,d=0|t._crypto_box_beforenmbytes();a.length!==d&&b(s,"invalid sharedKey length"),y=u(a),s.push(y);var f=new l(c-t._crypto_box_macbytes()|0),E=f.address;if(s.push(E),0==(0|t._crypto_box_open_easy_afternm(E,n,c,0,o,y))){var x=p(f,_);return v(s),x}g(s,"incorrect secret key for the given ciphertext")}function oe(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"publicKey");var c,o=0|t._crypto_box_publickeybytes();r.length!==o&&b(_,"invalid publicKey length"),c=u(r),_.push(c);var h=new l(n+t._crypto_box_sealbytes()|0),y=h.address;if(_.push(y),0==(0|t._crypto_box_seal(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function he(e,r,a,_){var s=[];i(_),e=m(s,e,"ciphertext");var n,c=t._crypto_box_sealbytes(),o=e.length;o<c&&b(s,"ciphertext is too short"),n=u(e),s.push(n),r=m(s,r,"publicKey");var h,y=0|t._crypto_box_publickeybytes();r.length!==y&&b(s,"invalid publicKey length"),h=u(r),s.push(h),a=m(s,a,"privateKey");var d,f=0|t._crypto_box_secretkeybytes();a.length!==f&&b(s,"invalid privateKey length"),d=u(a),s.push(d);var E=new l(o-t._crypto_box_sealbytes()|0),x=E.address;if(s.push(x),0==(0|t._crypto_box_seal_open(x,n,o,0,h,d))){var k=p(E,_);return v(s),k}g(s,"incorrect key pair for the given ciphertext")}function pe(e,r){var a=[];i(r),e=m(a,e,"seed");var _,s=0|t._crypto_box_seedbytes();e.length!==s&&b(a,"invalid seed length"),_=u(e),a.push(_);var n=new l(0|t._crypto_box_publickeybytes()),c=n.address;a.push(c);var o=new l(0|t._crypto_box_secretkeybytes()),h=o.address;if(a.push(h),0==(0|t._crypto_box_seed_keypair(c,h,_))){var y={publicKey:p(n,r),privateKey:p(o,r),keyType:"x25519"};return v(a),y}g(a,"invalid usage")}function ye(e,r,a){var _=[];i(a),e=m(_,e,"p");var s,n=0|t._crypto_core_ed25519_bytes();e.length!==n&&b(_,"invalid p length"),s=u(e),_.push(s),r=m(_,r,"q");var c,o=0|t._crypto_core_ed25519_bytes();r.length!==o&&b(_,"invalid q length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ed25519_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_core_ed25519_add(y,s,c))){var d=p(h,a);return v(_),d}g(_,"input is an invalid element")}function ie(e,r){var a=[];i(r);var _=u(e=m(a,e,"r"));e.length,a.push(_);var s=new l(0|t._crypto_core_ed25519_bytes()),n=s.address;if(a.push(n),0==(0|t._crypto_core_ed25519_from_hash(n,_))){var c=p(s,r);return v(a),c}g(a,"invalid usage")}function le(e,r){var a=[];i(r);var _=u(e=m(a,e,"r"));e.length,a.push(_);var s=new l(0|t._crypto_core_ed25519_bytes()),n=s.address;if(a.push(n),0==(0|t._crypto_core_ed25519_from_uniform(n,_))){var c=p(s,r);return v(a),c}g(a,"invalid usage")}function ue(e,r){var a=[];i(r),e=m(a,e,"repr");var _,s=0|t._crypto_core_ed25519_bytes();e.length!==s&&b(a,"invalid repr length"),_=u(e),a.push(_);var n=1==(0|t._crypto_core_ed25519_is_valid_point(_));return v(a),n}function de(e){var r=[];i(e);var a=new l(0|t._crypto_core_ed25519_bytes()),_=a.address;r.push(_),t._crypto_core_ed25519_random(_);var s=p(a,e);return v(r),s}function ve(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ed25519_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ed25519_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ed25519_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ed25519_scalar_add(y,s,c);var d=p(h,a);return v(_),d}function ge(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ed25519_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ed25519_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ed25519_scalar_complement(c,_);var o=p(n,r);return v(a),o}function be(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ed25519_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ed25519_scalarbytes()),c=n.address;if(a.push(c),0==(0|t._crypto_core_ed25519_scalar_invert(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid reciprocate")}function fe(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ed25519_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ed25519_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ed25519_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ed25519_scalar_mul(y,s,c);var d=p(h,a);return v(_),d}function me(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ed25519_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ed25519_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ed25519_scalar_negate(c,_);var o=p(n,r);return v(a),o}function Ee(e){var r=[];i(e);var a=new l(0|t._crypto_core_ed25519_scalarbytes()),_=a.address;r.push(_),t._crypto_core_ed25519_scalar_random(_);var s=p(a,e);return v(r),s}function xe(e,r){var a=[];i(r),e=m(a,e,"sample");var _,s=0|t._crypto_core_ed25519_nonreducedscalarbytes();e.length!==s&&b(a,"invalid sample length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ed25519_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ed25519_scalar_reduce(c,_);var o=p(n,r);return v(a),o}function ke(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ed25519_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ed25519_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ed25519_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ed25519_scalar_sub(y,s,c);var d=p(h,a);return v(_),d}function Se(e,r,a){var _=[];i(a),e=m(_,e,"p");var s,n=0|t._crypto_core_ed25519_bytes();e.length!==n&&b(_,"invalid p length"),s=u(e),_.push(s),r=m(_,r,"q");var c,o=0|t._crypto_core_ed25519_bytes();r.length!==o&&b(_,"invalid q length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ed25519_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_core_ed25519_sub(y,s,c))){var d=p(h,a);return v(_),d}g(_,"input is an invalid element")}function Te(e,r,a,_){var s=[];i(_),e=m(s,e,"input");var n,c=0|t._crypto_core_hchacha20_inputbytes();e.length!==c&&b(s,"invalid input length"),n=u(e),s.push(n),r=m(s,r,"privateKey");var o,h=0|t._crypto_core_hchacha20_keybytes();r.length!==h&&b(s,"invalid privateKey length"),o=u(r),s.push(o);var y=null;null!=a&&(y=u(a=m(s,a,"constant")),a.length,s.push(y));var d=new l(0|t._crypto_core_hchacha20_outputbytes()),f=d.address;if(s.push(f),0==(0|t._crypto_core_hchacha20(f,n,o,y))){var E=p(d,_);return v(s),E}g(s,"invalid usage")}function we(e,r,a,_){var s=[];i(_),e=m(s,e,"input");var n,c=0|t._crypto_core_hsalsa20_inputbytes();e.length!==c&&b(s,"invalid input length"),n=u(e),s.push(n),r=m(s,r,"privateKey");var o,h=0|t._crypto_core_hsalsa20_keybytes();r.length!==h&&b(s,"invalid privateKey length"),o=u(r),s.push(o);var y=null;null!=a&&(y=u(a=m(s,a,"constant")),a.length,s.push(y));var d=new l(0|t._crypto_core_hsalsa20_outputbytes()),f=d.address;if(s.push(f),0==(0|t._crypto_core_hsalsa20(f,n,o,y))){var E=p(d,_);return v(s),E}g(s,"invalid usage")}function Ye(e,r,a){var _=[];i(a),e=m(_,e,"p");var s,n=0|t._crypto_core_ristretto255_bytes();e.length!==n&&b(_,"invalid p length"),s=u(e),_.push(s),r=m(_,r,"q");var c,o=0|t._crypto_core_ristretto255_bytes();r.length!==o&&b(_,"invalid q length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ristretto255_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_core_ristretto255_add(y,s,c))){var d=p(h,a);return v(_),d}g(_,"input is an invalid element")}function Be(e,r){var a=[];i(r);var _=u(e=m(a,e,"r"));e.length,a.push(_);var s=new l(0|t._crypto_core_ristretto255_bytes()),n=s.address;if(a.push(n),0==(0|t._crypto_core_ristretto255_from_hash(n,_))){var c=p(s,r);return v(a),c}g(a,"invalid usage")}function Ae(e,r){var a=[];i(r),e=m(a,e,"repr");var _,s=0|t._crypto_core_ristretto255_bytes();e.length!==s&&b(a,"invalid repr length"),_=u(e),a.push(_);var n=1==(0|t._crypto_core_ristretto255_is_valid_point(_));return v(a),n}function Ke(e){var r=[];i(e);var a=new l(0|t._crypto_core_ristretto255_bytes()),_=a.address;r.push(_),t._crypto_core_ristretto255_random(_);var s=p(a,e);return v(r),s}function Me(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ristretto255_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ristretto255_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ristretto255_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ristretto255_scalar_add(y,s,c);var d=p(h,a);return v(_),d}function Ie(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ristretto255_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ristretto255_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ristretto255_scalar_complement(c,_);var o=p(n,r);return v(a),o}function Ne(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ristretto255_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ristretto255_scalarbytes()),c=n.address;if(a.push(c),0==(0|t._crypto_core_ristretto255_scalar_invert(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid reciprocate")}function Le(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ristretto255_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ristretto255_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ristretto255_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ristretto255_scalar_mul(y,s,c);var d=p(h,a);return v(_),d}function Ue(e,r){var a=[];i(r),e=m(a,e,"s");var _,s=0|t._crypto_core_ristretto255_scalarbytes();e.length!==s&&b(a,"invalid s length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ristretto255_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ristretto255_scalar_negate(c,_);var o=p(n,r);return v(a),o}function Oe(e){var r=[];i(e);var a=new l(0|t._crypto_core_ristretto255_scalarbytes()),_=a.address;r.push(_),t._crypto_core_ristretto255_scalar_random(_);var s=p(a,e);return v(r),s}function Ce(e,r){var a=[];i(r),e=m(a,e,"sample");var _,s=0|t._crypto_core_ristretto255_nonreducedscalarbytes();e.length!==s&&b(a,"invalid sample length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ristretto255_scalarbytes()),c=n.address;a.push(c),t._crypto_core_ristretto255_scalar_reduce(c,_);var o=p(n,r);return v(a),o}function Re(e,r,a){var _=[];i(a),e=m(_,e,"x");var s,n=0|t._crypto_core_ristretto255_scalarbytes();e.length!==n&&b(_,"invalid x length"),s=u(e),_.push(s),r=m(_,r,"y");var c,o=0|t._crypto_core_ristretto255_scalarbytes();r.length!==o&&b(_,"invalid y length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ristretto255_scalarbytes()),y=h.address;_.push(y),t._crypto_core_ristretto255_scalar_sub(y,s,c);var d=p(h,a);return v(_),d}function Pe(e,r,a){var _=[];i(a),e=m(_,e,"p");var s,n=0|t._crypto_core_ristretto255_bytes();e.length!==n&&b(_,"invalid p length"),s=u(e),_.push(s),r=m(_,r,"q");var c,o=0|t._crypto_core_ristretto255_bytes();r.length!==o&&b(_,"invalid q length"),c=u(r),_.push(c);var h=new l(0|t._crypto_core_ristretto255_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_core_ristretto255_sub(y,s,c))){var d=p(h,a);return v(_),d}g(_,"input is an invalid element")}function Ge(e,r,a,_){var s=[];i(_),f(s,e,"hash_length"),("number"!=typeof e||(0|e)!==e||e<0)&&b(s,"hash_length must be an unsigned integer");var n=u(r=m(s,r,"message")),c=r.length;s.push(n);var o=null,h=0;null!=a&&(o=u(a=m(s,a,"key")),h=a.length,s.push(o));var y=new l(e|=0),d=y.address;if(s.push(d),0==(0|t._crypto_generichash(d,e,n,c,0,o,h))){var E=p(y,_);return v(s),E}g(s,"invalid usage")}function Xe(e,r,a,_,s){var n=[];i(s),f(n,e,"subkey_len"),("number"!=typeof e||(0|e)!==e||e<0)&&b(n,"subkey_len must be an unsigned integer");var c=null,o=0;null!=r&&(c=u(r=m(n,r,"key")),o=r.length,n.push(c)),a=m(n,a,"id");var h,y=0|t._crypto_generichash_blake2b_saltbytes();a.length!==y&&b(n,"invalid id length"),h=u(a),n.push(h),_=m(n,_,"ctx");var d,E=0|t._crypto_generichash_blake2b_personalbytes();_.length!==E&&b(n,"invalid ctx length"),d=u(_),n.push(d);var x=new l(0|e),k=x.address;if(n.push(k),0==(0|t._crypto_generichash_blake2b_salt_personal(k,e,null,0,0,c,o,h,d))){var S=p(x,s);return v(n),S}g(n,"invalid usage")}function De(e,r,a){var _=[];i(a),f(_,e,"state_address"),f(_,r,"hash_length"),("number"!=typeof r||(0|r)!==r||r<0)&&b(_,"hash_length must be an unsigned integer");var s=new l(r|=0),n=s.address;if(_.push(n),0==(0|t._crypto_generichash_final(e,n,r))){var c=(t._free(e),p(s,a));return v(_),c}g(_,"invalid usage")}function Fe(e,r,a){var _=[];i(a);var s=null,n=0;null!=e&&(s=u(e=m(_,e,"key")),n=e.length,_.push(s)),f(_,r,"hash_length"),("number"!=typeof r||(0|r)!==r||r<0)&&b(_,"hash_length must be an unsigned integer");var c=new l(357).address;if(0==(0|t._crypto_generichash_init(c,s,n,r))){var o=c;return v(_),o}g(_,"invalid usage")}function Ve(e){var r=[];i(e);var a=new l(0|t._crypto_generichash_keybytes()),_=a.address;r.push(_),t._crypto_generichash_keygen(_);var s=p(a,e);return v(r),s}function He(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_generichash_update(e,s,n))&&g(_,"invalid usage"),v(_)}function qe(e,r){var a=[];i(r);var _=u(e=m(a,e,"message")),s=e.length;a.push(_);var n=new l(0|t._crypto_hash_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_hash(c,_,s,0))){var o=p(n,r);return v(a),o}g(a,"invalid usage")}function je(e,r){var a=[];i(r);var _=u(e=m(a,e,"message")),s=e.length;a.push(_);var n=new l(0|t._crypto_hash_sha256_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_hash_sha256(c,_,s,0))){var o=p(n,r);return v(a),o}g(a,"invalid usage")}function ze(e,r){var a=[];i(r),f(a,e,"state_address");var _=new l(0|t._crypto_hash_sha256_bytes()),s=_.address;if(a.push(s),0==(0|t._crypto_hash_sha256_final(e,s))){var n=(t._free(e),p(_,r));return v(a),n}g(a,"invalid usage")}function We(e){var r=[];i(e);var a=new l(104).address;if(0==(0|t._crypto_hash_sha256_init(a))){var _=a;return v(r),_}g(r,"invalid usage")}function Je(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_hash_sha256_update(e,s,n))&&g(_,"invalid usage"),v(_)}function Qe(e,r){var a=[];i(r);var _=u(e=m(a,e,"message")),s=e.length;a.push(_);var n=new l(0|t._crypto_hash_sha512_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_hash_sha512(c,_,s,0))){var o=p(n,r);return v(a),o}g(a,"invalid usage")}function Ze(e,r){var a=[];i(r),f(a,e,"state_address");var _=new l(0|t._crypto_hash_sha512_bytes()),s=_.address;if(a.push(s),0==(0|t._crypto_hash_sha512_final(e,s))){var n=(t._free(e),p(_,r));return v(a),n}g(a,"invalid usage")}function $e(e){var r=[];i(e);var a=new l(208).address;if(0==(0|t._crypto_hash_sha512_init(a))){var _=a;return v(r),_}g(r,"invalid usage")}function er(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_hash_sha512_update(e,s,n))&&g(_,"invalid usage"),v(_)}function rr(e,r,a,s,n){var c=[];i(n),f(c,e,"subkey_len"),("number"!=typeof e||(0|e)!==e||e<0)&&b(c,"subkey_len must be an unsigned integer"),f(c,r,"subkey_id"),("number"!=typeof r||(0|r)!==r||r<0)&&b(c,"subkey_id must be an unsigned integer"),"string"!=typeof a&&b(c,"ctx must be a string"),a=_(a+"\0"),null!=h&&a.length-1!==h&&b(c,"invalid ctx length");var o=u(a),h=a.length-1;c.push(o),s=m(c,s,"key");var y,d=0|t._crypto_kdf_keybytes();s.length!==d&&b(c,"invalid key length"),y=u(s),c.push(y);var g=new l(0|e),E=g.address;c.push(E),t._crypto_kdf_derive_from_key(E,e,r,r>>>24>>>8,o,y);var x=p(g,n);return v(c),x}function tr(e){var r=[];i(e);var a=new l(0|t._crypto_kdf_keybytes()),_=a.address;r.push(_),t._crypto_kdf_keygen(_);var s=p(a,e);return v(r),s}function ar(e,r,a,_){var s=[];i(_),e=m(s,e,"clientPublicKey");var n,c=0|t._crypto_kx_publickeybytes();e.length!==c&&b(s,"invalid clientPublicKey length"),n=u(e),s.push(n),r=m(s,r,"clientSecretKey");var o,h=0|t._crypto_kx_secretkeybytes();r.length!==h&&b(s,"invalid clientSecretKey length"),o=u(r),s.push(o),a=m(s,a,"serverPublicKey");var y,d=0|t._crypto_kx_publickeybytes();a.length!==d&&b(s,"invalid serverPublicKey length"),y=u(a),s.push(y);var f=new l(0|t._crypto_kx_sessionkeybytes()),E=f.address;s.push(E);var x=new l(0|t._crypto_kx_sessionkeybytes()),k=x.address;if(s.push(k),0==(0|t._crypto_kx_client_session_keys(E,k,n,o,y))){var S=p({sharedRx:f,sharedTx:x},_);return v(s),S}g(s,"invalid usage")}function _r(e){var r=[];i(e);var a=new l(0|t._crypto_kx_publickeybytes()),_=a.address;r.push(_);var s=new l(0|t._crypto_kx_secretkeybytes()),n=s.address;if(r.push(n),0==(0|t._crypto_kx_keypair(_,n))){var c={publicKey:p(a,e),privateKey:p(s,e),keyType:"x25519"};return v(r),c}g(r,"internal error")}function sr(e,r){var a=[];i(r),e=m(a,e,"seed");var _,s=0|t._crypto_kx_seedbytes();e.length!==s&&b(a,"invalid seed length"),_=u(e),a.push(_);var n=new l(0|t._crypto_kx_publickeybytes()),c=n.address;a.push(c);var o=new l(0|t._crypto_kx_secretkeybytes()),h=o.address;if(a.push(h),0==(0|t._crypto_kx_seed_keypair(c,h,_))){var y={publicKey:p(n,r),privateKey:p(o,r),keyType:"x25519"};return v(a),y}g(a,"internal error")}function nr(e,r,a,_){var s=[];i(_),e=m(s,e,"serverPublicKey");var n,c=0|t._crypto_kx_publickeybytes();e.length!==c&&b(s,"invalid serverPublicKey length"),n=u(e),s.push(n),r=m(s,r,"serverSecretKey");var o,h=0|t._crypto_kx_secretkeybytes();r.length!==h&&b(s,"invalid serverSecretKey length"),o=u(r),s.push(o),a=m(s,a,"clientPublicKey");var y,d=0|t._crypto_kx_publickeybytes();a.length!==d&&b(s,"invalid clientPublicKey length"),y=u(a),s.push(y);var f=new l(0|t._crypto_kx_sessionkeybytes()),E=f.address;s.push(E);var x=new l(0|t._crypto_kx_sessionkeybytes()),k=x.address;if(s.push(k),0==(0|t._crypto_kx_server_session_keys(E,k,n,o,y))){var S=p({sharedRx:f,sharedTx:x},_);return v(s),S}g(s,"invalid usage")}function cr(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_onetimeauth_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_onetimeauth_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_onetimeauth(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function or(e,r){var a=[];i(r),f(a,e,"state_address");var _=new l(0|t._crypto_onetimeauth_bytes()),s=_.address;if(a.push(s),0==(0|t._crypto_onetimeauth_final(e,s))){var n=(t._free(e),p(_,r));return v(a),n}g(a,"invalid usage")}function hr(e,r){var a=[];i(r);var _=null;null!=e&&(_=u(e=m(a,e,"key")),e.length,a.push(_));var s=new l(144).address;if(0==(0|t._crypto_onetimeauth_init(s,_))){var n=s;return v(a),n}g(a,"invalid usage")}function pr(e){var r=[];i(e);var a=new l(0|t._crypto_onetimeauth_keybytes()),_=a.address;r.push(_),t._crypto_onetimeauth_keygen(_);var s=p(a,e);return v(r),s}function yr(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_onetimeauth_update(e,s,n))&&g(_,"invalid usage"),v(_)}function ir(e,r,a){var _=[];e=m(_,e,"hash");var s,n=0|t._crypto_onetimeauth_bytes();e.length!==n&&b(_,"invalid hash length"),s=u(e),_.push(s);var c=u(r=m(_,r,"message")),o=r.length;_.push(c),a=m(_,a,"key");var h,p=0|t._crypto_onetimeauth_keybytes();a.length!==p&&b(_,"invalid key length"),h=u(a),_.push(h);var y=0==(0|t._crypto_onetimeauth_verify(s,c,o,0,h));return v(_),y}function lr(e,r,a,_,s,n,c){var o=[];i(c),f(o,e,"keyLength"),("number"!=typeof e||(0|e)!==e||e<0)&&b(o,"keyLength must be an unsigned integer");var h=u(r=m(o,r,"password")),y=r.length;o.push(h),a=m(o,a,"salt");var d,E=0|t._crypto_pwhash_saltbytes();a.length!==E&&b(o,"invalid salt length"),d=u(a),o.push(d),f(o,_,"opsLimit"),("number"!=typeof _||(0|_)!==_||_<0)&&b(o,"opsLimit must be an unsigned integer"),f(o,s,"memLimit"),("number"!=typeof s||(0|s)!==s||s<0)&&b(o,"memLimit must be an unsigned integer"),f(o,n,"algorithm"),("number"!=typeof n||(0|n)!==n||n<0)&&b(o,"algorithm must be an unsigned integer");var x=new l(0|e),k=x.address;if(o.push(k),0==(0|t._crypto_pwhash(k,e,0,h,y,0,d,_,0,s,n))){var S=p(x,c);return v(o),S}g(o,"invalid usage")}function ur(e,r,a,_,s,n){var c=[];i(n),f(c,e,"keyLength"),("number"!=typeof e||(0|e)!==e||e<0)&&b(c,"keyLength must be an unsigned integer");var o=u(r=m(c,r,"password")),h=r.length;c.push(o),a=m(c,a,"salt");var y,d=0|t._crypto_pwhash_scryptsalsa208sha256_saltbytes();a.length!==d&&b(c,"invalid salt length"),y=u(a),c.push(y),f(c,_,"opsLimit"),("number"!=typeof _||(0|_)!==_||_<0)&&b(c,"opsLimit must be an unsigned integer"),f(c,s,"memLimit"),("number"!=typeof s||(0|s)!==s||s<0)&&b(c,"memLimit must be an unsigned integer");var E=new l(0|e),x=E.address;if(c.push(x),0==(0|t._crypto_pwhash_scryptsalsa208sha256(x,e,0,o,h,0,y,_,0,s))){var k=p(E,n);return v(c),k}g(c,"invalid usage")}function dr(e,r,a,_,s,n,c){var o=[];i(c);var h=u(e=m(o,e,"password")),y=e.length;o.push(h);var d=u(r=m(o,r,"salt")),E=r.length;o.push(d),f(o,a,"opsLimit"),("number"!=typeof a||(0|a)!==a||a<0)&&b(o,"opsLimit must be an unsigned integer"),f(o,_,"r"),("number"!=typeof _||(0|_)!==_||_<0)&&b(o,"r must be an unsigned integer"),f(o,s,"p"),("number"!=typeof s||(0|s)!==s||s<0)&&b(o,"p must be an unsigned integer"),f(o,n,"keyLength"),("number"!=typeof n||(0|n)!==n||n<0)&&b(o,"keyLength must be an unsigned integer");var x=new l(0|n),k=x.address;if(o.push(k),0==(0|t._crypto_pwhash_scryptsalsa208sha256_ll(h,y,d,E,a,0,_,s,k,n))){var S=p(x,c);return v(o),S}g(o,"invalid usage")}function vr(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"password")),c=e.length;s.push(n),f(s,r,"opsLimit"),("number"!=typeof r||(0|r)!==r||r<0)&&b(s,"opsLimit must be an unsigned integer"),f(s,a,"memLimit"),("number"!=typeof a||(0|a)!==a||a<0)&&b(s,"memLimit must be an unsigned integer");var o=new l(0|t._crypto_pwhash_scryptsalsa208sha256_strbytes()).address;if(s.push(o),0==(0|t._crypto_pwhash_scryptsalsa208sha256_str(o,n,c,0,r,0,a))){var h=t.UTF8ToString(o);return v(s),h}g(s,"invalid usage")}function gr(e,r,a){var s=[];i(a),"string"!=typeof e&&b(s,"hashed_password must be a string"),e=_(e+"\0"),null!=c&&e.length-1!==c&&b(s,"invalid hashed_password length");var n=u(e),c=e.length-1;s.push(n);var o=u(r=m(s,r,"password")),h=r.length;s.push(o);var p=0==(0|t._crypto_pwhash_scryptsalsa208sha256_str_verify(n,o,h,0));return v(s),p}function br(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"password")),c=e.length;s.push(n),f(s,r,"opsLimit"),("number"!=typeof r||(0|r)!==r||r<0)&&b(s,"opsLimit must be an unsigned integer"),f(s,a,"memLimit"),("number"!=typeof a||(0|a)!==a||a<0)&&b(s,"memLimit must be an unsigned integer");var o=new l(0|t._crypto_pwhash_strbytes()).address;if(s.push(o),0==(0|t._crypto_pwhash_str(o,n,c,0,r,0,a))){var h=t.UTF8ToString(o);return v(s),h}g(s,"invalid usage")}function fr(e,r,a,s){var n=[];i(s),"string"!=typeof e&&b(n,"hashed_password must be a string"),e=_(e+"\0"),null!=o&&e.length-1!==o&&b(n,"invalid hashed_password length");var c=u(e),o=e.length-1;n.push(c),f(n,r,"opsLimit"),("number"!=typeof r||(0|r)!==r||r<0)&&b(n,"opsLimit must be an unsigned integer"),f(n,a,"memLimit"),("number"!=typeof a||(0|a)!==a||a<0)&&b(n,"memLimit must be an unsigned integer");var h=0!=(0|t._crypto_pwhash_str_needs_rehash(c,r,0,a));return v(n),h}function mr(e,r,a){var s=[];i(a),"string"!=typeof e&&b(s,"hashed_password must be a string"),e=_(e+"\0"),null!=c&&e.length-1!==c&&b(s,"invalid hashed_password length");var n=u(e),c=e.length-1;s.push(n);var o=u(r=m(s,r,"password")),h=r.length;s.push(o);var p=0==(0|t._crypto_pwhash_str_verify(n,o,h,0));return v(s),p}function Er(e,r,a){var _=[];i(a),e=m(_,e,"privateKey");var s,n=0|t._crypto_scalarmult_scalarbytes();e.length!==n&&b(_,"invalid privateKey length"),s=u(e),_.push(s),r=m(_,r,"publicKey");var c,o=0|t._crypto_scalarmult_bytes();r.length!==o&&b(_,"invalid publicKey length"),c=u(r),_.push(c);var h=new l(0|t._crypto_scalarmult_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_scalarmult(y,s,c))){var d=p(h,a);return v(_),d}g(_,"weak public key")}function xr(e,r){var a=[];i(r),e=m(a,e,"privateKey");var _,s=0|t._crypto_scalarmult_scalarbytes();e.length!==s&&b(a,"invalid privateKey length"),_=u(e),a.push(_);var n=new l(0|t._crypto_scalarmult_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_scalarmult_base(c,_))){var o=p(n,r);return v(a),o}g(a,"unknown error")}function kr(e,r,a){var _=[];i(a),e=m(_,e,"n");var s,n=0|t._crypto_scalarmult_ed25519_scalarbytes();e.length!==n&&b(_,"invalid n length"),s=u(e),_.push(s),r=m(_,r,"p");var c,o=0|t._crypto_scalarmult_ed25519_bytes();r.length!==o&&b(_,"invalid p length"),c=u(r),_.push(c);var h=new l(0|t._crypto_scalarmult_ed25519_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_scalarmult_ed25519(y,s,c))){var d=p(h,a);return v(_),d}g(_,"invalid point or scalar is 0")}function Sr(e,r){var a=[];i(r),e=m(a,e,"scalar");var _,s=0|t._crypto_scalarmult_ed25519_scalarbytes();e.length!==s&&b(a,"invalid scalar length"),_=u(e),a.push(_);var n=new l(0|t._crypto_scalarmult_ed25519_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_scalarmult_ed25519_base(c,_))){var o=p(n,r);return v(a),o}g(a,"scalar is 0")}function Tr(e,r){var a=[];i(r),e=m(a,e,"scalar");var _,s=0|t._crypto_scalarmult_ed25519_scalarbytes();e.length!==s&&b(a,"invalid scalar length"),_=u(e),a.push(_);var n=new l(0|t._crypto_scalarmult_ed25519_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_scalarmult_ed25519_base_noclamp(c,_))){var o=p(n,r);return v(a),o}g(a,"scalar is 0")}function wr(e,r,a){var _=[];i(a),e=m(_,e,"n");var s,n=0|t._crypto_scalarmult_ed25519_scalarbytes();e.length!==n&&b(_,"invalid n length"),s=u(e),_.push(s),r=m(_,r,"p");var c,o=0|t._crypto_scalarmult_ed25519_bytes();r.length!==o&&b(_,"invalid p length"),c=u(r),_.push(c);var h=new l(0|t._crypto_scalarmult_ed25519_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_scalarmult_ed25519_noclamp(y,s,c))){var d=p(h,a);return v(_),d}g(_,"invalid point or scalar is 0")}function Yr(e,r,a){var _=[];i(a),e=m(_,e,"scalar");var s,n=0|t._crypto_scalarmult_ristretto255_scalarbytes();e.length!==n&&b(_,"invalid scalar length"),s=u(e),_.push(s),r=m(_,r,"element");var c,o=0|t._crypto_scalarmult_ristretto255_bytes();r.length!==o&&b(_,"invalid element length"),c=u(r),_.push(c);var h=new l(0|t._crypto_scalarmult_ristretto255_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_scalarmult_ristretto255(y,s,c))){var d=p(h,a);return v(_),d}g(_,"result is identity element")}function Br(e,r){var a=[];i(r),e=m(a,e,"scalar");var _,s=0|t._crypto_core_ristretto255_scalarbytes();e.length!==s&&b(a,"invalid scalar length"),_=u(e),a.push(_);var n=new l(0|t._crypto_core_ristretto255_bytes()),c=n.address;if(a.push(c),0==(0|t._crypto_scalarmult_ristretto255_base(c,_))){var o=p(n,r);return v(a),o}g(a,"scalar is 0")}function Ar(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_secretbox_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"key");var y,d=0|t._crypto_secretbox_keybytes();a.length!==d&&b(s,"invalid key length"),y=u(a),s.push(y);var f=new l(0|c),E=f.address;s.push(E);var x=new l(0|t._crypto_secretbox_macbytes()),k=x.address;if(s.push(k),0==(0|t._crypto_secretbox_detached(E,k,n,c,0,o,y))){var S=p({mac:x,cipher:f},_);return v(s),S}g(s,"invalid usage")}function Kr(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_secretbox_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"key");var y,d=0|t._crypto_secretbox_keybytes();a.length!==d&&b(s,"invalid key length"),y=u(a),s.push(y);var f=new l(c+t._crypto_secretbox_macbytes()|0),E=f.address;if(s.push(E),0==(0|t._crypto_secretbox_easy(E,n,c,0,o,y))){var x=p(f,_);return v(s),x}g(s,"invalid usage")}function Mr(e){var r=[];i(e);var a=new l(0|t._crypto_secretbox_keybytes()),_=a.address;r.push(_),t._crypto_secretbox_keygen(_);var s=p(a,e);return v(r),s}function Ir(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"ciphertext")),o=e.length;n.push(c),r=m(n,r,"mac");var h,y=0|t._crypto_secretbox_macbytes();r.length!==y&&b(n,"invalid mac length"),h=u(r),n.push(h),a=m(n,a,"nonce");var d,f=0|t._crypto_secretbox_noncebytes();a.length!==f&&b(n,"invalid nonce length"),d=u(a),n.push(d),_=m(n,_,"key");var E,x=0|t._crypto_secretbox_keybytes();_.length!==x&&b(n,"invalid key length"),E=u(_),n.push(E);var k=new l(0|o),S=k.address;if(n.push(S),0==(0|t._crypto_secretbox_open_detached(S,c,h,o,0,d,E))){var T=p(k,s);return v(n),T}g(n,"wrong secret key for the given ciphertext")}function Nr(e,r,a,_){var s=[];i(_),e=m(s,e,"ciphertext");var n,c=t._crypto_secretbox_macbytes(),o=e.length;o<c&&b(s,"ciphertext is too short"),n=u(e),s.push(n),r=m(s,r,"nonce");var h,y=0|t._crypto_secretbox_noncebytes();r.length!==y&&b(s,"invalid nonce length"),h=u(r),s.push(h),a=m(s,a,"key");var d,f=0|t._crypto_secretbox_keybytes();a.length!==f&&b(s,"invalid key length"),d=u(a),s.push(d);var E=new l(o-t._crypto_secretbox_macbytes()|0),x=E.address;if(s.push(x),0==(0|t._crypto_secretbox_open_easy(x,n,o,0,h,d))){var k=p(E,_);return v(s),k}g(s,"wrong secret key for the given ciphertext")}function Lr(e,r,a){var _=[];i(a),e=m(_,e,"header");var s,n=0|t._crypto_secretstream_xchacha20poly1305_headerbytes();e.length!==n&&b(_,"invalid header length"),s=u(e),_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_secretstream_xchacha20poly1305_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(52).address;if(0==(0|t._crypto_secretstream_xchacha20poly1305_init_pull(h,s,c))){var p=h;return v(_),p}g(_,"invalid usage")}function Ur(e,r){var a=[];i(r),e=m(a,e,"key");var _,s=0|t._crypto_secretstream_xchacha20poly1305_keybytes();e.length!==s&&b(a,"invalid key length"),_=u(e),a.push(_);var n=new l(52).address,c=new l(0|t._crypto_secretstream_xchacha20poly1305_headerbytes()),o=c.address;if(a.push(o),0==(0|t._crypto_secretstream_xchacha20poly1305_init_push(n,o,_))){var h={state:n,header:p(c,r)};return v(a),h}g(a,"invalid usage")}function Or(e){var r=[];i(e);var a=new l(0|t._crypto_secretstream_xchacha20poly1305_keybytes()),_=a.address;r.push(_),t._crypto_secretstream_xchacha20poly1305_keygen(_);var s=p(a,e);return v(r),s}function Cr(e,r,a,_){var s=[];i(_),f(s,e,"state_address"),r=m(s,r,"cipher");var n,c=t._crypto_secretstream_xchacha20poly1305_abytes(),o=r.length;o<c&&b(s,"cipher is too short"),n=u(r),s.push(n);var h=null,y=0;null!=a&&(h=u(a=m(s,a,"ad")),y=a.length,s.push(h));var g=new l(o-t._crypto_secretstream_xchacha20poly1305_abytes()|0),E=g.address;s.push(E);var x,k=(x=d(1),s.push(x),(k=0===t._crypto_secretstream_xchacha20poly1305_pull(e,E,0,x,n,o,0,h,y)&&{tag:t.HEAPU8[x],message:g})&&{message:p(k.message,_),tag:k.tag});return v(s),k}function Rr(e,r,a,_,s){var n=[];i(s),f(n,e,"state_address");var c=u(r=m(n,r,"message_chunk")),o=r.length;n.push(c);var h=null,y=0;null!=a&&(h=u(a=m(n,a,"ad")),y=a.length,n.push(h)),f(n,_,"tag"),("number"!=typeof _||(0|_)!==_||_<0)&&b(n,"tag must be an unsigned integer");var d=new l(o+t._crypto_secretstream_xchacha20poly1305_abytes()|0),E=d.address;if(n.push(E),0==(0|t._crypto_secretstream_xchacha20poly1305_push(e,E,0,c,o,0,h,y,0,_))){var x=p(d,s);return v(n),x}g(n,"invalid usage")}function Pr(e,r){var a=[];return i(r),f(a,e,"state_address"),t._crypto_secretstream_xchacha20poly1305_rekey(e),v(a),!0}function Gr(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_shorthash_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_shorthash_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_shorthash(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function Xr(e){var r=[];i(e);var a=new l(0|t._crypto_shorthash_keybytes()),_=a.address;r.push(_),t._crypto_shorthash_keygen(_);var s=p(a,e);return v(r),s}function Dr(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"key");var c,o=0|t._crypto_shorthash_siphashx24_keybytes();r.length!==o&&b(_,"invalid key length"),c=u(r),_.push(c);var h=new l(0|t._crypto_shorthash_siphashx24_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_shorthash_siphashx24(y,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function Fr(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"privateKey");var c,o=0|t._crypto_sign_secretkeybytes();r.length!==o&&b(_,"invalid privateKey length"),c=u(r),_.push(c);var h=new l(e.length+t._crypto_sign_bytes()|0),y=h.address;if(_.push(y),0==(0|t._crypto_sign(y,null,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function Vr(e,r,a){var _=[];i(a);var s=u(e=m(_,e,"message")),n=e.length;_.push(s),r=m(_,r,"privateKey");var c,o=0|t._crypto_sign_secretkeybytes();r.length!==o&&b(_,"invalid privateKey length"),c=u(r),_.push(c);var h=new l(0|t._crypto_sign_bytes()),y=h.address;if(_.push(y),0==(0|t._crypto_sign_detached(y,null,s,n,0,c))){var d=p(h,a);return v(_),d}g(_,"invalid usage")}function Hr(e,r){var a=[];i(r),e=m(a,e,"edPk");var _,s=0|t._crypto_sign_publickeybytes();e.length!==s&&b(a,"invalid edPk length"),_=u(e),a.push(_);var n=new l(0|t._crypto_scalarmult_scalarbytes()),c=n.address;if(a.push(c),0==(0|t._crypto_sign_ed25519_pk_to_curve25519(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid key")}function qr(e,r){var a=[];i(r),e=m(a,e,"edSk");var _,s=0|t._crypto_sign_secretkeybytes();e.length!==s&&b(a,"invalid edSk length"),_=u(e),a.push(_);var n=new l(0|t._crypto_scalarmult_scalarbytes()),c=n.address;if(a.push(c),0==(0|t._crypto_sign_ed25519_sk_to_curve25519(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid key")}function jr(e,r){var a=[];i(r),e=m(a,e,"privateKey");var _,s=0|t._crypto_sign_secretkeybytes();e.length!==s&&b(a,"invalid privateKey length"),_=u(e),a.push(_);var n=new l(0|t._crypto_sign_publickeybytes()),c=n.address;if(a.push(c),0==(0|t._crypto_sign_ed25519_sk_to_pk(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid key")}function zr(e,r){var a=[];i(r),e=m(a,e,"privateKey");var _,s=0|t._crypto_sign_secretkeybytes();e.length!==s&&b(a,"invalid privateKey length"),_=u(e),a.push(_);var n=new l(0|t._crypto_sign_seedbytes()),c=n.address;if(a.push(c),0==(0|t._crypto_sign_ed25519_sk_to_seed(c,_))){var o=p(n,r);return v(a),o}g(a,"invalid key")}function Wr(e,r,a){var _=[];i(a),f(_,e,"state_address"),r=m(_,r,"privateKey");var s,n=0|t._crypto_sign_secretkeybytes();r.length!==n&&b(_,"invalid privateKey length"),s=u(r),_.push(s);var c=new l(0|t._crypto_sign_bytes()),o=c.address;if(_.push(o),0==(0|t._crypto_sign_final_create(e,o,null,s))){var h=(t._free(e),p(c,a));return v(_),h}g(_,"invalid usage")}function Jr(e,r,a,_){var s=[];i(_),f(s,e,"state_address"),r=m(s,r,"signature");var n,c=0|t._crypto_sign_bytes();r.length!==c&&b(s,"invalid signature length"),n=u(r),s.push(n),a=m(s,a,"publicKey");var o,h=0|t._crypto_sign_publickeybytes();a.length!==h&&b(s,"invalid publicKey length"),o=u(a),s.push(o);var p=0==(0|t._crypto_sign_final_verify(e,n,o));return v(s),p}function Qr(e){var r=[];i(e);var a=new l(208).address;if(0==(0|t._crypto_sign_init(a))){var _=a;return v(r),_}g(r,"internal error")}function Zr(e){var r=[];i(e);var a=new l(0|t._crypto_sign_publickeybytes()),_=a.address;r.push(_);var s=new l(0|t._crypto_sign_secretkeybytes()),n=s.address;if(r.push(n),0==(0|t._crypto_sign_keypair(_,n))){var c={publicKey:p(a,e),privateKey:p(s,e),keyType:"ed25519"};return v(r),c}g(r,"internal error")}function $r(e,r,a){var _=[];i(a),e=m(_,e,"signedMessage");var s,n=t._crypto_sign_bytes(),c=e.length;c<n&&b(_,"signedMessage is too short"),s=u(e),_.push(s),r=m(_,r,"publicKey");var o,h=0|t._crypto_sign_publickeybytes();r.length!==h&&b(_,"invalid publicKey length"),o=u(r),_.push(o);var y=new l(c-t._crypto_sign_bytes()|0),d=y.address;if(_.push(d),0==(0|t._crypto_sign_open(d,null,s,c,0,o))){var f=p(y,a);return v(_),f}g(_,"incorrect signature for the given public key")}function et(e,r){var a=[];i(r),e=m(a,e,"seed");var _,s=0|t._crypto_sign_seedbytes();e.length!==s&&b(a,"invalid seed length"),_=u(e),a.push(_);var n=new l(0|t._crypto_sign_publickeybytes()),c=n.address;a.push(c);var o=new l(0|t._crypto_sign_secretkeybytes()),h=o.address;if(a.push(h),0==(0|t._crypto_sign_seed_keypair(c,h,_))){var y={publicKey:p(n,r),privateKey:p(o,r),keyType:"ed25519"};return v(a),y}g(a,"invalid usage")}function rt(e,r,a){var _=[];i(a),f(_,e,"state_address");var s=u(r=m(_,r,"message_chunk")),n=r.length;_.push(s),0!=(0|t._crypto_sign_update(e,s,n,0))&&g(_,"invalid usage"),v(_)}function tt(e,r,a){var _=[];e=m(_,e,"signature");var s,n=0|t._crypto_sign_bytes();e.length!==n&&b(_,"invalid signature length"),s=u(e),_.push(s);var c=u(r=m(_,r,"message")),o=r.length;_.push(c),a=m(_,a,"publicKey");var h,p=0|t._crypto_sign_publickeybytes();a.length!==p&&b(_,"invalid publicKey length"),h=u(a),_.push(h);var y=0==(0|t._crypto_sign_verify_detached(s,c,o,0,h));return v(_),y}function at(e,r,a,_){var s=[];i(_),f(s,e,"outLength"),("number"!=typeof e||(0|e)!==e||e<0)&&b(s,"outLength must be an unsigned integer"),r=m(s,r,"key");var n,c=0|t._crypto_stream_chacha20_keybytes();r.length!==c&&b(s,"invalid key length"),n=u(r),s.push(n),a=m(s,a,"nonce");var o,h=0|t._crypto_stream_chacha20_noncebytes();a.length!==h&&b(s,"invalid nonce length"),o=u(a),s.push(o);var y=new l(0|e),d=y.address;s.push(d),t._crypto_stream_chacha20(d,e,0,o,n);var g=p(y,_);return v(s),g}function _t(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"input_message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_stream_chacha20_ietf_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"key");var y,d=0|t._crypto_stream_chacha20_ietf_keybytes();a.length!==d&&b(s,"invalid key length"),y=u(a),s.push(y);var f=new l(0|c),E=f.address;if(s.push(E),0===t._crypto_stream_chacha20_ietf_xor(E,n,c,0,o,y)){var x=p(f,_);return v(s),x}g(s,"invalid usage")}function st(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"input_message")),o=e.length;n.push(c),r=m(n,r,"nonce");var h,y=0|t._crypto_stream_chacha20_ietf_noncebytes();r.length!==y&&b(n,"invalid nonce length"),h=u(r),n.push(h),f(n,a,"nonce_increment"),("number"!=typeof a||(0|a)!==a||a<0)&&b(n,"nonce_increment must be an unsigned integer"),_=m(n,_,"key");var d,E=0|t._crypto_stream_chacha20_ietf_keybytes();_.length!==E&&b(n,"invalid key length"),d=u(_),n.push(d);var x=new l(0|o),k=x.address;if(n.push(k),0===t._crypto_stream_chacha20_ietf_xor_ic(k,c,o,0,h,a,d)){var S=p(x,s);return v(n),S}g(n,"invalid usage")}function nt(e){var r=[];i(e);var a=new l(0|t._crypto_stream_chacha20_keybytes()),_=a.address;r.push(_),t._crypto_stream_chacha20_keygen(_);var s=p(a,e);return v(r),s}function ct(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"input_message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_stream_chacha20_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"key");var y,d=0|t._crypto_stream_chacha20_keybytes();a.length!==d&&b(s,"invalid key length"),y=u(a),s.push(y);var f=new l(0|c),E=f.address;if(s.push(E),0===t._crypto_stream_chacha20_xor(E,n,c,0,o,y)){var x=p(f,_);return v(s),x}g(s,"invalid usage")}function ot(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"input_message")),o=e.length;n.push(c),r=m(n,r,"nonce");var h,y=0|t._crypto_stream_chacha20_noncebytes();r.length!==y&&b(n,"invalid nonce length"),h=u(r),n.push(h),f(n,a,"nonce_increment"),("number"!=typeof a||(0|a)!==a||a<0)&&b(n,"nonce_increment must be an unsigned integer"),_=m(n,_,"key");var d,E=0|t._crypto_stream_chacha20_keybytes();_.length!==E&&b(n,"invalid key length"),d=u(_),n.push(d);var x=new l(0|o),k=x.address;if(n.push(k),0===t._crypto_stream_chacha20_xor_ic(k,c,o,0,h,a,0,d)){var S=p(x,s);return v(n),S}g(n,"invalid usage")}function ht(e){var r=[];i(e);var a=new l(0|t._crypto_stream_keybytes()),_=a.address;r.push(_),t._crypto_stream_keygen(_);var s=p(a,e);return v(r),s}function pt(e){var r=[];i(e);var a=new l(0|t._crypto_stream_xchacha20_keybytes()),_=a.address;r.push(_),t._crypto_stream_xchacha20_keygen(_);var s=p(a,e);return v(r),s}function yt(e,r,a,_){var s=[];i(_);var n=u(e=m(s,e,"input_message")),c=e.length;s.push(n),r=m(s,r,"nonce");var o,h=0|t._crypto_stream_xchacha20_noncebytes();r.length!==h&&b(s,"invalid nonce length"),o=u(r),s.push(o),a=m(s,a,"key");var y,d=0|t._crypto_stream_xchacha20_keybytes();a.length!==d&&b(s,"invalid key length"),y=u(a),s.push(y);var f=new l(0|c),E=f.address;if(s.push(E),0===t._crypto_stream_xchacha20_xor(E,n,c,0,o,y)){var x=p(f,_);return v(s),x}g(s,"invalid usage")}function it(e,r,a,_,s){var n=[];i(s);var c=u(e=m(n,e,"input_message")),o=e.length;n.push(c),r=m(n,r,"nonce");var h,y=0|t._crypto_stream_xchacha20_noncebytes();r.length!==y&&b(n,"invalid nonce length"),h=u(r),n.push(h),f(n,a,"nonce_increment"),("number"!=typeof a||(0|a)!==a||a<0)&&b(n,"nonce_increment must be an unsigned integer"),_=m(n,_,"key");var d,E=0|t._crypto_stream_xchacha20_keybytes();_.length!==E&&b(n,"invalid key length"),d=u(_),n.push(d);var x=new l(0|o),k=x.address;if(n.push(k),0===t._crypto_stream_xchacha20_xor_ic(k,c,o,0,h,a,0,d)){var S=p(x,s);return v(n),S}g(n,"invalid usage")}function lt(e,r){var a=[];i(r),f(a,e,"length"),("number"!=typeof e||(0|e)!==e||e<0)&&b(a,"length must be an unsigned integer");var _=new l(0|e),s=_.address;a.push(s),t._randombytes_buf(s,e);var n=p(_,r);return v(a),n}function ut(e,r,a){var _=[];i(a),f(_,e,"length"),("number"!=typeof e||(0|e)!==e||e<0)&&b(_,"length must be an unsigned integer"),r=m(_,r,"seed");var s,n=0|t._randombytes_seedbytes();r.length!==n&&b(_,"invalid seed length"),s=u(r),_.push(s);var c=new l(0|e),o=c.address;_.push(o),t._randombytes_buf_deterministic(o,e,s);var h=p(c,a);return v(_),h}function dt(e){i(e),t._randombytes_close()}function vt(e){i(e);var r=t._randombytes_random()>>>0;return v([]),r}function gt(e,r){var a=[];i(r);for(var _=t._malloc(24),s=0;s<6;s++)t.setValue(_+4*s,t.Runtime.addFunction(e[["implementation_name","random","stir","uniform","buf","close"][s]]),"i32");0!=(0|t._randombytes_set_implementation(_))&&g(a,"unsupported implementation"),v(a)}function bt(e){i(e),t._randombytes_stir()}function ft(e,r){var a=[];i(r),f(a,e,"upper_bound"),("number"!=typeof e||(0|e)!==e||e<0)&&b(a,"upper_bound must be an unsigned integer");var _=t._randombytes_uniform(e)>>>0;return v(a),_}function mt(){var e=t._sodium_version_string(),r=t.UTF8ToString(e);return v([]),r}return l.prototype.to_Uint8Array=function(){var e=new Uint8Array(this.length);return e.set(t.HEAPU8.subarray(this.address,this.address+this.length)),e},e.add=function(e,r){if(!(e instanceof Uint8Array&&r instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can added");var t=e.length,a=0,_=0;if(r.length!=e.length)throw new TypeError("Arguments must have the same length");for(_=0;_<t;_++)a>>=8,a+=e[_]+r[_],e[_]=255&a},e.base64_variants=c,e.compare=function(e,r){if(!(e instanceof Uint8Array&&r instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be compared");if(e.length!==r.length)throw new TypeError("Only instances of identical length can be compared");for(var t=0,a=1,_=e.length;_-- >0;)t|=r[_]-e[_]>>8&a,a&=(r[_]^e[_])-1>>8;return t+t+a-1},e.from_base64=function(e,r){r=o(r);var a,_=[],s=new l(3*(e=m(_,e,"input")).length/4),n=u(e),c=d(4),h=d(4);return _.push(n),_.push(s.address),_.push(s.result_bin_len_p),_.push(s.b64_end_p),0!==t._sodium_base642bin(s.address,s.length,n,e.length,0,c,h,r)&&g(_,"invalid input"),t.getValue(h,"i32")-n!==e.length&&g(_,"incomplete input"),s.length=t.getValue(c,"i32"),a=s.to_Uint8Array(),v(_),a},e.from_hex=function(e){var r,a=[],_=new l((e=m(a,e,"input")).length/2),s=u(e),n=d(4);return a.push(s),a.push(_.address),a.push(_.hex_end_p),0!==t._sodium_hex2bin(_.address,_.length,s,e.length,0,0,n)&&g(a,"invalid input"),t.getValue(n,"i32")-s!==e.length&&g(a,"incomplete input"),r=_.to_Uint8Array(),v(a),r},e.from_string=_,e.increment=function(e){if(!(e instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be incremented");for(var r=256,t=0,a=e.length;t<a;t++)r>>=8,r+=e[t],e[t]=255&r},e.is_zero=function(e){if(!(e instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be checked");for(var r=0,t=0,a=e.length;t<a;t++)r|=e[t];return 0===r},e.libsodium=r,e.memcmp=function(e,r){if(!(e instanceof Uint8Array&&r instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be compared");if(e.length!==r.length)throw new TypeError("Only instances of identical length can be compared");for(var t=0,a=0,_=e.length;a<_;a++)t|=e[a]^r[a];return 0===t},e.memzero=function(e){if(!(e instanceof Uint8Array))throw new TypeError("Only Uint8Array instances can be wiped");for(var r=0,t=e.length;r<t;r++)e[r]=0},e.output_formats=function(){return["uint8array","text","hex","base64"]},e.pad=function(e,r){if(!(e instanceof Uint8Array))throw new TypeError("buffer must be a Uint8Array");if((r|=0)<=0)throw new Error("block size must be > 0");var a,_=[],s=d(4),n=1,c=0,o=0|e.length,h=new l(o+r);_.push(s),_.push(h.address);for(var p=h.address,y=h.address+o+r;p<y;p++)t.HEAPU8[p]=e[c],c+=n=1&~((65535&((o-=n)>>>48|o>>>32|o>>>16|o))-1>>16);return 0!==t._sodium_pad(s,h.address,e.length,r,h.length)&&g(_,"internal error"),h.length=t.getValue(s,"i32"),a=h.to_Uint8Array(),v(_),a},e.unpad=function(e,r){if(!(e instanceof Uint8Array))throw new TypeError("buffer must be a Uint8Array");if((r|=0)<=0)throw new Error("block size must be > 0");var a=[],_=u(e),s=d(4);return a.push(_),a.push(s),0!==t._sodium_unpad(s,_,e.length,r)&&g(a,"unsupported/invalid padding"),e=(e=new Uint8Array(e)).subarray(0,t.getValue(s,"i32")),v(a),e},e.ready=a,e.symbols=function(){return Object.keys(e).sort()},e.to_base64=h,e.to_hex=n,e.to_string=s,e}var t="object"==typeof e.sodium&&"function"==typeof e.sodium.onload?e.sodium.onload:null; true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports,__webpack_require__(/*! libsodium */ "./node_modules/libsodium/dist/modules/libsodium.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (r),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0,t&&e.sodium.ready.then((function(){t(e.sodium)}))}(this);


/***/ }),

/***/ "./node_modules/libsodium/dist/modules/libsodium.js":
/*!**********************************************************!*\
  !*** ./node_modules/libsodium/dist/modules/libsodium.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(A){function I(A){"use strict";var I;void 0===(I=A)&&(I={});var g=I;"object"!=typeof g.sodium&&("object"==typeof global?g=global:"object"==typeof window&&(g=window)),"object"==typeof g.sodium&&"number"==typeof g.sodium.totalMemory&&(I.TOTAL_MEMORY=g.sodium.totalMemory);var B=I;return I.ready=new Promise((function(A,I){(a=B).onAbort=I,a.print=function(A){},a.printErr=function(A){},a.onRuntimeInitialized=function(){try{a._crypto_secretbox_keybytes(),A()}catch(A){I(A)}},a.useBackupModule=function(){return new Promise((function(A,I){(a={}).onAbort=I,a.onRuntimeInitialized=function(){Object.keys(B).forEach((function(A){"getRandomValue"!==A&&delete B[A]})),Object.keys(a).forEach((function(A){B[A]=a[A]})),A()};var g,C,Q,E,i,n,a=void 0!==a?a:{},r=Object.assign({},a),o=[],t="object"==typeof window,e="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,c="";f?(c=e?(__webpack_require__(/*! path */ "path").dirname)(c)+"/":__dirname+"/",n=()=>{i||(E=__webpack_require__(/*! fs */ "fs"),i=__webpack_require__(/*! path */ "path"))},g=function(A,I){var g=AA(A);return g?I?g:g.toString():(n(),A=i.normalize(A),E.readFileSync(A,I?void 0:"utf8"))},Q=A=>{var I=g(A,!0);return I.buffer||(I=new Uint8Array(I)),I},C=(A,I,g)=>{var B=AA(A);B&&I(B),n(),A=i.normalize(A),E.readFile(A,(function(A,B){A?g(A):I(B.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),o=process.argv.slice(2), true&&(module.exports=a),a.inspect=function(){return"[Emscripten Module object]"}):(t||e)&&(e?c=self.location.href:"undefined"!=typeof document&&document.currentScript&&(c=document.currentScript.src),c=0!==c.indexOf("blob:")?c.substr(0,c.replace(/[?#].*/,"").lastIndexOf("/")+1):"",g=A=>{try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.send(null),I.responseText}catch(I){var g=AA(A);if(g)return function(A){for(var I=[],g=0;g<A.length;g++){var B=A[g];B>255&&(B&=255),I.push(String.fromCharCode(B))}return I.join("")}(g);throw I}},e&&(Q=A=>{try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)}catch(I){var g=AA(A);if(g)return g;throw I}}),C=(A,I,g)=>{var B=new XMLHttpRequest;B.open("GET",A,!0),B.responseType="arraybuffer",B.onload=()=>{if(200==B.status||0==B.status&&B.response)I(B.response);else{var C=AA(A);C?I(C.buffer):g()}},B.onerror=g,B.send(null)}),a.print;var y,s=a.printErr||void 0;Object.assign(a,r),r=null,a.arguments&&(o=a.arguments),a.thisProgram&&a.thisProgram,a.quit&&a.quit,a.wasmBinary&&(y=a.wasmBinary),a.noExitRuntime;var w,D={Memory:function(A){this.buffer=new ArrayBuffer(65536*A.initial)},Module:function(A){},Instance:function(A,I){this.exports=function(A){for(var I,g=new Uint8Array(123),B=25;B>=0;--B)g[48+B]=52+B,g[65+B]=B,g[97+B]=26+B;function C(A,I,B){for(var C,Q,E=0,i=I,n=B.length,a=I+(3*n>>2)-("="==B[n-2])-("="==B[n-1]);E<n;E+=4)C=g[B.charCodeAt(E+1)],Q=g[B.charCodeAt(E+2)],A[i++]=g[B.charCodeAt(E)]<<2|C>>4,i<a&&(A[i++]=C<<4|Q>>2),i<a&&(A[i++]=Q<<6|g[B.charCodeAt(E+3)])}return g[43]=62,g[47]=63,function(A){var g=A.a,B=g.buffer;g.grow=function(A){A|=0;var C=0|Mg(),o=C+A|0;if(C<o&&o<65536){var t=new ArrayBuffer(r(o,65536));new Int8Array(t).set(Q),Q=new Int8Array(t),E=new Int16Array(t),i=new Int32Array(t),n=new Uint8Array(t),new Uint16Array(t),a=new Uint32Array(t),new Float32Array(t),new Float64Array(t),B=t,g.buffer=B,I=n}return C};var Q=new Int8Array(B),E=new Int16Array(B),i=new Int32Array(B),n=new Uint8Array(B),a=(new Uint16Array(B),new Uint32Array(B)),r=(new Float32Array(B),new Float64Array(B),Math.imul),o=(Math.fround,Math.abs,Math.clz32),t=(Math.min,Math.max,Math.floor,Math.ceil,Math.trunc,Math.sqrt,A.abort),e=A.b,f=A.c,c=A.d,y=A.e,s=5279280,w=0,D=0,h=0;function p(A,I){var g,B,C,E,a,r=0,o=0,t=0,e=0,f=0,c=0,y=0,w=0,D=0,p=0,u=0,F=0,l=0,_=0,k=0,H=0,G=0,U=0,S=0,b=0,m=0,v=0,M=0,P=0,Y=0,N=0,R=0,d=0,J=0,x=0,L=0,K=0,X=0,T=0,V=0,q=0,z=0,j=0,W=0,O=0,Z=0,$=0,AA=0,IA=0,gA=0,BA=0,CA=0,QA=0,EA=0,iA=0,nA=0,aA=0,rA=0,oA=0,tA=0,eA=0,fA=0,cA=0,yA=0,sA=0,wA=0;for(s=q=s-256|0;j=(K=X<<3)+(q+128|0)|0,IA=n[4+(K=I+K|0)|0]|n[K+5|0]<<8|n[K+6|0]<<16|n[K+7|0]<<24,i[j>>2]=n[0|K]|n[K+1|0]<<8|n[K+2|0]<<16|n[K+3|0]<<24,i[j+4>>2]=IA,16!=(0|(X=X+1|0)););for(g=eI(q,A,64),K=i[(I=g)>>2],X=i[I+4>>2],o=K,K=(IA=i[I+32>>2])+(q=i[I+128>>2])|0,I=(O=i[I+36>>2])+i[I+132>>2]|0,I=K>>>0<q>>>0?I+1|0:I,q=K,I=I+X|0,q=I=(K=o+K|0)>>>0<q>>>0?I+1|0:I,L=pA((X=K)^(n[0|(K=A- -64|0)]|n[K+1|0]<<8|n[K+2|0]<<16|n[K+3|0]<<24)^-1377402159,I^(n[K+4|0]|n[K+5|0]<<8|n[K+6|0]<<16|n[K+7|0]<<24)^1359893119,32),K=I=h,I=I+1779033703|0,o=IA^(j=L-205731576|0),IA=I=j>>>0<4089235720?I+1|0:I,H=pA(o,O^I,24),O=I=h,T=K,o=L,I=I+q|0,I=(I=(L=H+X|0)>>>0<X>>>0?I+1|0:I)+(t=B=i[g+140>>2])|0,r=pA(o^(b=X=(K=i[g+136>>2])+L|0),(p=b>>>0<L>>>0?I+1|0:I)^T,16),I=IA+(f=h)|0,o=pA((Y=X=j+r|0)^H,(q=Y>>>0<j>>>0?I+1|0:I)^O,63),w=h,j=i[g+12>>2],X=(H=i[g+144>>2])+(IA=i[g+40>>2])|0,I=(gA=i[g+148>>2])+(O=i[g+44>>2])|0,T=X,I=(I=X>>>0<IA>>>0?I+1|0:I)+j|0,I=(X=X+i[g+8>>2]|0)>>>0<T>>>0?I+1|0:I,L=pA(X^(n[A+72|0]|n[A+73|0]<<8|n[A+74|0]<<16|n[A+75|0]<<24)^725511199,(n[A+76|0]|n[A+77|0]<<8|n[A+78|0]<<16|n[A+79|0]<<24)^I^-1694144372,32),T=pA(u=IA^(j=L-2067093701|0),O^(t=(IA=h)-((L>>>0<2067093701)+1150833018|0)|0),24),G=i[g+156>>2],u=T,I=I+(O=h)|0,I=(I=(T=X+T|0)>>>0<X>>>0?I+1|0:I)+G|0,z=pA((S=X=T+i[g+152>>2]|0)^L,(_=S>>>0<T>>>0?I+1|0:I)^IA,16),I=t+(v=h)|0,fA=X=j+z|0,L=pA(u^X,(j=X>>>0<j>>>0?I+1|0:I)^O,63),t=h,IA=i[g+20>>2],X=(U=i[g+160>>2])+(T=i[g+48>>2])|0,I=(QA=i[g+164>>2])+(G=i[g+52>>2])|0,O=X,I=(I=X>>>0<T>>>0?I+1|0:I)+IA|0,nA=X=X+i[g+16>>2]|0,X=X>>>0<O>>>0?I+1|0:I,k=pA(nA^(n[A+80|0]|n[A+81|0]<<8|n[A+82|0]<<16|n[A+83|0]<<24)^-79577749,X^(n[A+84|0]|n[A+85|0]<<8|n[A+86|0]<<16|n[A+87|0]<<24)^528734635,32),IA=I=h,I=I+1013904242|0,u=T^(O=k-23791573|0),T=I=O>>>0<4271175723?I+1|0:I,I=pA(u,G^I,24),c=IA,C=i[g+172>>2],e=I,u=k,k=I,nA=I+nA|0,I=(G=h)+X|0,I=(I=k>>>0>nA>>>0?I+1|0:I)+(F=C)|0,J=pA(u^(F=X=(IA=i[g+168>>2])+(k=nA)|0),(M=k>>>0>F>>>0?I+1|0:I)^c,16),I=T+(l=h)|0,G=pA(e^(P=X=O+J|0),(T=P>>>0<O>>>0?I+1|0:I)^G,63),c=h,k=i[g+28>>2],O=(X=i[g+176>>2])+(nA=i[g+56>>2])|0,I=(E=i[g+180>>2])+(m=i[g+60>>2])|0,I=(I=O>>>0<nA>>>0?I+1|0:I)+k|0,I=(y=O)>>>0>(N=O=y+i[g+24>>2]|0)>>>0?I+1|0:I,e=pA(N^(n[A+88|0]|n[A+89|0]<<8|n[A+90|0]<<16|n[A+91|0]<<24)^327033209,I^(n[A+92|0]|n[A+93|0]<<8|n[A+94|0]<<16|n[A+95|0]<<24)^1541459225,32),k=pA(u=nA^(D=(k=e)+1595750129|0),m^(nA=(O=h)-((k>>>0<2699217167)+1521486533|0)|0),24),y=nA,u=O,nA=i[g+188>>2],d=k,I=(m=h)+I|0,I=(I=(N=k+N|0)>>>0<k>>>0?I+1|0:I)+nA|0,V=k=(O=i[g+184>>2])+N|0,e=pA(k^e,(R=u)^(u=k>>>0<N>>>0?I+1|0:I),16),I=(I=y)+(y=h)|0,N=k=e+D|0,D=m,m=I=k>>>0<e>>>0?I+1|0:I,R=pA(d^k,D^I,63),k=h,d=L,I=t+p|0,I=(I=(b=b+L|0)>>>0<L>>>0?I+1|0:I)+(D=W=i[g+196>>2])|0,D=P,b=pA((P=L=(CA=i[g+192>>2])+(p=b)|0)^e,(L=p>>>0>P>>>0?I+1|0:I)^y,32),I=(I=T)+(T=h)|0,e=t,t=I=(p=D+(y=b)|0)>>>0<y>>>0?I+1|0:I,I=pA(d^p,e^I,24),aA=i[g+204>>2],x=I,d=y,e=P,P=I,e=e+I|0,I=(y=h)+L|0,I=(I=e>>>0<P>>>0?I+1|0:I)+(D=aA)|0,Z=L=(b=i[g+200>>2])+e|0,oA=pA(d^L,(P=e>>>0>L>>>0?I+1|0:I)^T,16),I=t+(e=h)|0,x=pA(x^(D=T=p+oA|0),(t=y)^(y=p>>>0>D>>>0?I+1|0:I),63),p=h,d=G,I=c+_|0,I=(I=(T=G+S|0)>>>0<G>>>0?I+1|0:I)+(t=iA=i[g+212>>2])|0,S=pA((t=r)^(r=T=(L=i[g+208>>2])+(G=T)|0),(G=G>>>0>r>>>0?I+1|0:I)^f,32),I=m+(t=h)|0,T=pA(d^(m=T=N+S|0),(I=N>>>0>m>>>0?I+1|0:I)^c,24),f=I,_=t,AA=i[g+220>>2],$=T,d=m,I=(c=h)+G|0,I=(I=(m=r+T|0)>>>0<T>>>0?I+1|0:I)+(N=AA)|0,_=pA((m=T=(t=i[g+216>>2])+(G=m)|0)^S,(N=G>>>0>m>>>0?I+1|0:I)^_,16),I=(r=h)+f|0,rA=T=d+_|0,d=pA($^T,(G=_>>>0>T>>>0?I+1|0:I)^c,63),c=h,$=R,I=k+M|0,I=(f=F+R|0)>>>0<F>>>0?I+1|0:I,F=f,I=I+(S=a=i[g+228>>2])|0,R=pA((M=f=(T=i[g+224>>2])+f|0)^z,(f=f>>>0<F>>>0?I+1|0:I)^v,32),I=(v=h)+q|0,Y=F=R+Y|0,q=pA($^F,(I=F>>>0<R>>>0?I+1|0:I)^k,24),F=I,z=i[g+236>>2],$=q,I=(k=h)+f|0,I=(I=(M=M+q|0)>>>0<q>>>0?I+1|0:I)+(S=z)|0,eA=pA((M=q=(BA=i[g+232>>2])+(f=M)|0)^R,(S=v)^(v=f>>>0>M>>>0?I+1|0:I),16),I=(I=F)+(F=h)|0,k=pA($^(R=q=(f=eA)+Y|0),(Y=f>>>0>R>>>0?I+1|0:I)^k,63),f=h,$=o,I=w+u|0,I=(I=(S=o+V|0)>>>0<o>>>0?I+1|0:I)+(cA=i[g+244>>2])|0,I=(o=(q=i[g+240>>2])+(u=S)|0)>>>0<u>>>0?I+1|0:I,u=l,l=I,S=pA(o^J,u^I,32),I=(I=j)+(j=h)|0,J=u=S+fA|0,V=pA($^u,(I=u>>>0<S>>>0?I+1|0:I)^w,24),w=I,u=j,fA=i[g+252>>2],tA=V,EA=J,J=S,I=l+($=h)|0,I=(I=(S=o+V|0)>>>0<o>>>0?I+1|0:I)+fA|0,I=(o=(j=i[g+248>>2])+(l=S)|0)>>>0<l>>>0?I+1|0:I,l=o,S=u,u=I,V=pA(J^o,S^I,16),I=(S=h)+w|0,J=pA(tA^(EA=o=EA+(J=V)|0),(o=o>>>0<J>>>0?I+1|0:I)^$,63),$=I=h,w=I,tA=_,I=P+cA|0,P=_=q+Z|0,I=(I=_>>>0<q>>>0?I+1|0:I)+w|0,Z=pA(tA^(w=_=_+J|0),(_=w>>>0<P>>>0?I+1|0:I)^r,32),I=Y+(P=h)|0,R=I=(r=R+Z|0)>>>0<R>>>0?I+1|0:I,J=pA(J^r,$^I,24),$=I=h,Y=I,yA=J,I=_+iA|0,_=J=w+L|0,I=(I=J>>>0<w>>>0?I+1|0:I)+Y|0,J=Z,Z=w=yA+_|0,tA=pA(J^w,(Y=P)^(P=w>>>0<_>>>0?I+1|0:I),16),I=R+(Y=h)|0,R=I=(w=r+tA|0)>>>0<r>>>0?I+1|0:I,J=pA(yA^(r=w),I^$,63),_=h,I=p+QA|0,I=(I=(w=U+x|0)>>>0<U>>>0?I+1|0:I)+N|0,U=I=(w=w+m|0)>>>0<m>>>0?I+1|0:I,N=pA(w^eA,I^F,32),I=(I=o)+(o=h)|0,I=(F=(m=N)+EA|0)>>>0<m>>>0?I+1|0:I,m=p,p=I,x=pA(F^x,m^I,24),QA=I=h,m=I,$=N,I=U+W|0,I=(I=(N=w+CA|0)>>>0<w>>>0?I+1|0:I)+m|0,I=(w=(U=N)+x|0)>>>0<U>>>0?I+1|0:I,U=w,m=I,eA=pA($^w,I^o,16),I=p+(N=h)|0,$=o=F+eA|0,x=pA(o^x,(w=o>>>0<F>>>0?I+1|0:I)^QA,63),o=h,I=c+aA|0,I=(I=(p=b+d|0)>>>0<b>>>0?I+1|0:I)+v|0,S=pA((b=p=p+M|0)^V,(p=p>>>0<M>>>0?I+1|0:I)^S,32),I=y+(v=h)|0,y=c,c=I=(F=D+S|0)>>>0<D>>>0?I+1|0:I,y=pA(F^d,y^I,24),D=I=h,d=y,I=p+fA|0,I=(I=(y=b+j|0)>>>0<j>>>0?I+1|0:I)+D|0,aA=p=d+y|0,EA=pA(p^S,(b=v)^(v=p>>>0<y>>>0?I+1|0:I),16),I=c+(M=h)|0,b=p=F+EA|0,S=pA(d^p,(c=p>>>0<F>>>0?I+1|0:I)^D,63),p=h,D=k,I=f+z|0,I=(I=(F=k+BA|0)>>>0<k>>>0?I+1|0:I)+u|0,I=(k=F+l|0)>>>0<l>>>0?I+1|0:I,l=k,k=I,y=pA(l^oA,I^e,32),I=(I=G)+(G=h)|0,u=F=y+rA|0,e=pA(D^F,(I=y>>>0>F>>>0?I+1|0:I)^f,24),D=f=h,F=I,I=k+E|0,I=(I=(l=l+X|0)>>>0<X>>>0?I+1|0:I)+f|0,I=(k=l+e|0)>>>0<l>>>0?I+1|0:I,f=u,l=k,u=k^y,y=I,G=f+(k=u=pA(u,I^G,16))|0,I=(f=h)+F|0,V=G,d=pA(G^e,(k=G>>>0<k>>>0?I+1|0:I)^D,63),G=h,D=b,e=u,I=P+B|0,u=F=K+Z|0,I=(I=F>>>0<K>>>0?I+1|0:I)+o|0,I=(F=F+x|0)>>>0<u>>>0?I+1|0:I,u=f,f=I,b=pA(e^F,u^I,32),I=(I=c)+(c=h)|0,P=u=D+b|0,e=pA(u^x,(I=u>>>0<b>>>0?I+1|0:I)^o,24),D=o=h,u=I,x=b,I=f+a|0,I=(I=(b=F+T|0)>>>0<F>>>0?I+1|0:I)+o|0,I=(f=(F=b)+e|0)>>>0<F>>>0?I+1|0:I,F=f,b=I,oA=pA(x^f,I^c,16),I=(I=u)+(u=h)|0,P=o=(c=oA)+P|0,QA=pA(f=o^e,(e=o>>>0<c>>>0?I+1|0:I)^D,63),c=h,I=p+m|0,I=(o=U+S|0)>>>0<U>>>0?I+1|0:I,U=o,I=I+(f=rA=i[g+132>>2])|0,f=I=(o=(D=i[g+128>>2])+o|0)>>>0<U>>>0?I+1|0:I,m=pA(o^tA,I^Y,32),I=(I=k)+(k=h)|0,Y=U=m+V|0,S=pA(U^S,(I=U>>>0<m>>>0?I+1|0:I)^p,24),x=p=h,U=I,V=m,I=f+gA|0,I=(I=(m=o+H|0)>>>0<o>>>0?I+1|0:I)+p|0,m=o=(f=m)+S|0,o=pA(V^o,(p=k)^(k=o>>>0<f>>>0?I+1|0:I),16),I=(I=U)+(U=h)|0,Y=p=o+Y|0,V=pA(f=p^S,(S=o>>>0>p>>>0?I+1|0:I)^x,63),p=h,Z=d,I=v+AA|0,v=f=t+aA|0,I=(I=f>>>0<t>>>0?I+1|0:I)+G|0,d=pA((x=f=f+d|0)^eA,(f=f>>>0<v>>>0?I+1|0:I)^N,32),I=R+(v=h)|0,I=r>>>0>(N=r+d|0)>>>0?I+1|0:I,R=pA(Z^(r=N),I^G,24),aA=G=h,N=I,tA=R,Z=r,I=f+nA|0,I=(I=(r=x+O|0)>>>0<O>>>0?I+1|0:I)+G|0,I=r>>>0>(f=r+R|0)>>>0?I+1|0:I,r=f,G=v,v=I,eA=pA(f^d,G^I,16),I=(G=h)+N|0,N=f=Z+(R=eA)|0,aA=pA(tA^f,(I=f>>>0<R>>>0?I+1|0:I)^aA,63),f=h,R=I,x=o,I=_+C|0,I=(I=(o=J+IA|0)>>>0<IA>>>0?I+1|0:I)+y|0,I=(o=o+l|0)>>>0<l>>>0?I+1|0:I,l=o,y=M,M=I,d=pA(o^EA,y^I,32),I=(o=h)+w|0,Z=pA((y=d+$|0)^J,(I=y>>>0<d>>>0?I+1|0:I)^_,24),w=I,_=o,J=i[g+156>>2],tA=y,I=M+($=h)|0,I=(I=(y=l+Z|0)>>>0<l>>>0?I+1|0:I)+J|0,l=I=y>>>0>(M=(o=i[g+152>>2])+y|0)>>>0?I+1|0:I,EA=pA(M^d,I^_,16),I=(I=w)+(w=h)|0,d=I=(y=EA)>>>0>(_=tA+y|0)>>>0?I+1|0:I,Z=pA((y=_)^Z,I^$,63),$=I=h,_=I,tA=N,I=b+AA|0,I=(I=(N=t+F|0)>>>0<F>>>0?I+1|0:I)+_|0,_=F=N+Z|0,x=pA(F^x,(b=U)^(U=F>>>0<N>>>0?I+1|0:I),32),I=(F=h)+R|0,b=I=(b=x)>>>0>(N=tA+b|0)>>>0?I+1|0:I,Z=pA(Z^N,$^I,24),$=I=h,R=I,tA=x,I=U+W|0,I=(I=(x=_+CA|0)>>>0<_>>>0?I+1|0:I)+R|0,I=(_=(U=x)+Z|0)>>>0<U>>>0?I+1|0:I,U=_,R=F,F=I,CA=pA(tA^_,R^I,16),I=b+(R=h)|0,I=(_=N+CA|0)>>>0<N>>>0?I+1|0:I,N=_,b=I,x=pA(_^Z,I^$,63),_=h,Z=QA,I=c+a|0,I=(I=(W=T+QA|0)>>>0<T>>>0?I+1|0:I)+k|0,k=G,G=I=m>>>0>(W=m+W|0)>>>0?I+1|0:I,QA=pA(W^eA,k^I,32),I=d+(k=h)|0,I=y>>>0>(m=y+QA|0)>>>0?I+1|0:I,y=c,c=I,d=pA(Z^m,y^I,24),Z=I=h,y=I,$=d,I=G+rA|0,I=(I=(d=D+W|0)>>>0<D>>>0?I+1|0:I)+y|0,W=G=$+(D=d)|0,QA=pA(G^QA,(y=G>>>0<D>>>0?I+1|0:I)^k,16),I=c+(D=h)|0,rA=G=m+QA|0,d=pA($^G,(k=G>>>0<m>>>0?I+1|0:I)^Z,63),G=h,Z=V,I=p+C|0,I=(I=(c=IA+V|0)>>>0<IA>>>0?I+1|0:I)+v|0,I=(c=c+r|0)>>>0<r>>>0?I+1|0:I,r=c,m=w,w=I,V=pA(c^EA,m^I,32),I=e+(c=h)|0,e=p,p=I=(v=P+V|0)>>>0<P>>>0?I+1|0:I,P=pA(Z^v,e^I,24),e=I=h,$=P,I=w+gA|0,I=(I=(P=r+H|0)>>>0<H>>>0?I+1|0:I)+e|0,r=V,V=w=$+P|0,Z=pA(r^w,(m=w>>>0<P>>>0?I+1|0:I)^c,16),I=p+(P=h)|0,eA=w=v+Z|0,e=pA($^w,(p=w>>>0<v>>>0?I+1|0:I)^e,63),w=h,I=f+fA|0,I=(I=(c=j+aA|0)>>>0<j>>>0?I+1|0:I)+l|0,v=I=(c=c+M|0)>>>0<M>>>0?I+1|0:I,r=pA(c^oA,I^u,32),I=S+(M=h)|0,u=f,f=I=(l=Y+r|0)>>>0<Y>>>0?I+1|0:I,Y=pA(l^aA,u^I,24),S=I=h,u=I,$=r,I=v+z|0,I=(I=(r=c+BA|0)>>>0<c>>>0?I+1|0:I)+u|0,u=c=r+Y|0,r=pA($^c,(v=M)^(M=c>>>0<r>>>0?I+1|0:I),16),I=f+(v=h)|0,aA=c=l+r|0,Y=pA(c^Y,(f=c>>>0<l>>>0?I+1|0:I)^S,63),c=h,I=F+iA|0,I=(I=(l=U+L|0)>>>0<U>>>0?I+1|0:I)+G|0,l=U=(F=l)+d|0,r=pA(U^r,(S=v)^(v=F>>>0>U>>>0?I+1|0:I),32),I=(I=p)+(p=h)|0,F=G,G=I=r>>>0>(U=r+eA|0)>>>0?I+1|0:I,S=pA(U^d,F^I,24),d=I=h,F=I,I=v+cA|0,I=(I=(l=l+q|0)>>>0<q>>>0?I+1|0:I)+F|0,oA=v=l+S|0,eA=pA(v^r,(F=v>>>0<l>>>0?I+1|0:I)^p,16),I=G+(l=h)|0,$=p=U+eA|0,S=pA(p^S,(G=p>>>0<U>>>0?I+1|0:I)^d,63),p=h,d=e,I=y+J|0,I=(I=(v=o+W|0)>>>0<o>>>0?I+1|0:I)+w|0,e=pA((y=v=(U=v)+e|0)^CA,(v=y>>>0<U>>>0?I+1|0:I)^R,32),I=(I=f)+(f=h)|0,R=pA(d^(r=U=e+aA|0),(I=e>>>0>r>>>0?I+1|0:I)^w,24),d=w=h,U=I,W=R,I=v+E|0,I=(I=(y=y+X|0)>>>0<X>>>0?I+1|0:I)+w|0,I=y>>>0>(v=y+R|0)>>>0?I+1|0:I,w=r,r=(y=v)^e,e=I,r=pA(r,I^f,16),I=(R=h)+U|0,f=pA(W^(EA=w=w+r|0),(w=w>>>0<r>>>0?I+1|0:I)^d,63),v=h,W=Y,I=m+nA|0,m=U=O+V|0,I=(I=U>>>0<O>>>0?I+1|0:I)+c|0,d=pA((Y=U=U+Y|0)^QA,(U=U>>>0<m>>>0?I+1|0:I)^D,32),I=b+(m=h)|0,b=D=N+d|0,D=pA(W^D,(I=D>>>0<N>>>0?I+1|0:I)^c,24),W=c=h,N=I,V=b,I=U+B|0,I=(I=(b=Y+K|0)>>>0<K>>>0?I+1|0:I)+c|0,I=(U=b+D|0)>>>0<b>>>0?I+1|0:I,b=U,c=m,m=I,tA=pA(U^d,c^I,16),I=(I=N)+(N=h)|0,d=pA((c=V+(U=tA)|0)^D,(I=c>>>0<U>>>0?I+1|0:I)^W,63),U=h,D=c,Y=I,I=_+M|0,M=c=u+x|0,I=(I=c>>>0<u>>>0?I+1|0:I)+(W=i[g+204>>2])|0,M=I=(c=(CA=i[g+200>>2])+c|0)>>>0<M>>>0?I+1|0:I,P=pA(c^Z,I^P,32),I=(I=k)+(k=h)|0,x=pA((u=P+rA|0)^x,(I=u>>>0<P>>>0?I+1|0:I)^_,24),_=I,QA=i[g+164>>2],rA=u,I=M+(aA=h)|0,I=(I=(u=c+x|0)>>>0<c>>>0?I+1|0:I)+QA|0,M=c=(V=i[g+160>>2])+u|0,u=I=c>>>0<u>>>0?I+1|0:I,Z=pA(c^P,I^k,16),I=(P=h)+_|0,x=pA((rA=c=rA+(k=Z)|0)^x,(c=c>>>0<k>>>0?I+1|0:I)^aA,63),aA=I=h,k=I,I=F+nA|0,I=(I=(_=O+oA|0)>>>0<O>>>0?I+1|0:I)+k|0,R=pA((k=_=(F=_)+x|0)^r,(_=F>>>0>k>>>0?I+1|0:I)^R,32),I=(F=h)+Y|0,Y=D=(r=R)+D|0,x=pA(x^D,aA^(I=r>>>0>D>>>0?I+1|0:I),24),aA=D=h,r=I,yA=x,oA=R,I=_+W|0,I=(I=(R=k+CA|0)>>>0<k>>>0?I+1|0:I)+D|0,R=k=(_=R)+x|0,x=pA(oA^k,(D=F)^(F=_>>>0>k>>>0?I+1|0:I),16),I=(D=h)+r|0,aA=pA(yA^(oA=k=(_=x)+Y|0),(k=_>>>0>k>>>0?I+1|0:I)^aA,63),_=h,I=p+J|0,I=(I=(r=o+S|0)>>>0<o>>>0?I+1|0:I)+e|0,r=pA((e=o=r+y|0)^tA,(o=o>>>0<y>>>0?I+1|0:I)^N,32),I=(I=c)+(c=h)|0,N=p,p=I=(y=r+rA|0)>>>0<r>>>0?I+1|0:I,Y=pA(y^S,N^I,24),S=I=h,N=I,I=o+B|0,I=(I=(e=e+K|0)>>>0<K>>>0?I+1|0:I)+N|0,J=o=e+Y|0,rA=pA(o^r,(N=o>>>0<e>>>0?I+1|0:I)^c,16),I=p+(e=h)|0,tA=o=y+rA|0,r=pA(o^Y,(c=o>>>0<y>>>0?I+1|0:I)^S,63),o=h,Y=f,I=v+z|0,I=(I=(p=f+BA|0)>>>0<f>>>0?I+1|0:I)+m|0,f=I=(p=p+b|0)>>>0<b>>>0?I+1|0:I,y=pA(p^Z,I^P,32),I=(I=G)+(G=h)|0,b=m=y+$|0,P=pA(Y^m,(I=y>>>0>m>>>0?I+1|0:I)^v,24),m=I,S=b,Y=y,I=f+a|0,f=y=p+T|0,I=(I=y>>>0<p>>>0?I+1|0:I)+(v=h)|0,Z=pA(Y^(y=p=y+P|0),(b=y>>>0<f>>>0?I+1|0:I)^G,16),I=(I=m)+(m=h)|0,f=P,P=G=S+(p=Z)|0,Y=pA(f^G,(p=p>>>0>G>>>0?I+1|0:I)^v,63),G=h,I=U+AA|0,I=(I=(f=t+d|0)>>>0<t>>>0?I+1|0:I)+u|0,l=pA((u=f=f+M|0)^eA,(f=f>>>0<M>>>0?I+1|0:I)^l,32),I=(I=w)+(w=h)|0,M=U,U=I=(v=l+EA|0)>>>0<l>>>0?I+1|0:I,S=pA(v^d,M^I,24),d=I=h,M=I,z=l,I=f+cA|0,I=(I=(l=u+q|0)>>>0<q>>>0?I+1|0:I)+M|0,M=f=l+S|0,u=pA(z^f,(l=f>>>0<l>>>0?I+1|0:I)^w,16),I=U+(f=h)|0,I=(w=v+u|0)>>>0<v>>>0?I+1|0:I,v=w,U=I,S=pA(w^S,I^d,63),w=h,z=P,d=u,I=F+gA|0,I=(I=(u=H+R|0)>>>0<H>>>0?I+1|0:I)+o|0,I=(F=u+r|0)>>>0<u>>>0?I+1|0:I,u=F,P=f,f=I,P=pA(d^F,P^I,32),I=(I=p)+(p=h)|0,R=pA((R=r)^(r=F=z+P|0),(I=r>>>0<P>>>0?I+1|0:I)^o,24),d=o=h,F=I,I=f+E|0,I=(I=(u=u+X|0)>>>0<X>>>0?I+1|0:I)+o|0,I=(f=u+R|0)>>>0<u>>>0?I+1|0:I,u=f,o=f^P,P=I,eA=pA(o,I^p,16),I=(I=F)+(F=h)|0,r=o=(p=eA)+r|0,d=pA(f=o^R,(R=o>>>0<p>>>0?I+1|0:I)^d,63),f=h,z=Y,I=N+C|0,p=o=J+IA|0,I=(I=o>>>0<IA>>>0?I+1|0:I)+G|0,D=pA((Y=o=o+Y|0)^x,(o=o>>>0<p>>>0?I+1|0:I)^D,32),I=U+(p=h)|0,N=pA(z^(U=N=v+D|0),(I=v>>>0>U>>>0?I+1|0:I)^G,24),x=G=h,v=I,J=N,z=U,I=o+iA|0,I=(I=(U=Y+L|0)>>>0<L>>>0?I+1|0:I)+G|0,N=o=U+N|0,G=pA(G=o^D,(D=o>>>0<U>>>0?I+1|0:I)^p,16),I=(U=h)+v|0,$=o=z+G|0,z=pA(J^o,(p=o>>>0<G>>>0?I+1|0:I)^x,63),v=h,Y=S,I=b+QA|0,I=(o=y+V|0)>>>0<y>>>0?I+1|0:I,y=o,I=I+w|0,I=(o=o+S|0)>>>0<y>>>0?I+1|0:I,y=o,b=I,S=pA(o^rA,I^e,32),I=(o=h)+k|0,x=e=S+oA|0,Y=pA(Y^e,(I=e>>>0<S>>>0?I+1|0:I)^w,24),k=I,e=o,BA=i[g+132>>2],J=Y,I=b+(w=h)|0,I=(I=(Y=y+Y|0)>>>0<y>>>0?I+1|0:I)+BA|0,b=I=(y=(o=i[g+128>>2])+(b=Y)|0)>>>0<b>>>0?I+1|0:I,oA=pA(y^S,I^e,16),I=(e=h)+k|0,J=pA(J^(Y=(S=oA)+x|0),(I=S>>>0>Y>>>0?I+1|0:I)^w,63),k=h,S=I,x=G,I=_+fA|0,I=(I=(G=j+aA|0)>>>0<j>>>0?I+1|0:I)+l|0,m=pA((w=G=G+M|0)^Z,(M=w>>>0<M>>>0?I+1|0:I)^m,32),I=(G=h)+c|0,Z=pA((l=m+tA|0)^aA,(I=l>>>0<m>>>0?I+1|0:I)^_,24),c=I,_=G,aA=i[g+196>>2],tA=Z,EA=l,I=M+(rA=h)|0,I=(I=(l=w+Z|0)>>>0<w>>>0?I+1|0:I)+aA|0,M=w=(G=i[g+192>>2])+l|0,l=I=w>>>0<l>>>0?I+1|0:I,Z=pA(w^m,I^_,16),I=(I=c)+(c=h)|0,m=pA(tA^(EA=w=EA+(_=Z)|0),(w=w>>>0<_>>>0?I+1|0:I)^rA,63),rA=I=h,_=I,tA=Y,I=P+W|0,I=(I=(Y=u+CA|0)>>>0<u>>>0?I+1|0:I)+_|0,I=(u=(P=Y)+m|0)>>>0<P>>>0?I+1|0:I,P=u,_=I,Y=pA(u^x,I^U,32),I=(U=h)+S|0,S=u=tA+Y|0,x=pA(m^u,rA^(I=u>>>0<Y>>>0?I+1|0:I),24),W=m=h,u=I,I=_+BA|0,I=(I=(P=o+P|0)>>>0<o>>>0?I+1|0:I)+m|0,CA=_=P+x|0,rA=pA(_^Y,(m=_>>>0<P>>>0?I+1|0:I)^U,16),I=(I=u)+(u=h)|0,P=_=(U=rA)+S|0,W=pA(_^x,(Y=_>>>0<U>>>0?I+1|0:I)^W,63),U=h,I=f+C|0,I=(I=(_=d+IA|0)>>>0<IA>>>0?I+1|0:I)+D|0,N=I=(_=_+N|0)>>>0<N>>>0?I+1|0:I,S=pA(_^oA,I^e,32),I=(I=w)+(w=h)|0,I=(e=(D=S)+EA|0)>>>0<D>>>0?I+1|0:I,D=f,f=I,x=pA(e^d,D^I,24),d=I=h,D=I,EA=S,I=N+nA|0,I=(I=(S=_+O|0)>>>0<_>>>0?I+1|0:I)+D|0,N=_=S+x|0,D=I=_>>>0<S>>>0?I+1|0:I,oA=pA(EA^_,I^w,16),I=f+(S=h)|0,EA=w=e+oA|0,x=pA(w^x,(f=w>>>0<e>>>0?I+1|0:I)^d,63),w=h,I=v+gA|0,I=(I=(_=H+z|0)>>>0<H>>>0?I+1|0:I)+b|0,e=c,c=I=y>>>0>(_=y+_|0)>>>0?I+1|0:I,d=pA(_^Z,e^I,32),I=R+(y=h)|0,I=r>>>0>(b=r+d|0)>>>0?I+1|0:I,r=v,v=I,r=pA(b^z,r^I,24),R=I=h,e=I,Z=r,I=c+QA|0,I=(I=(r=_+V|0)>>>0<_>>>0?I+1|0:I)+e|0,_=d,d=c=Z+r|0,z=pA(_^c,(e=y)^(y=c>>>0<r>>>0?I+1|0:I),16),I=v+(e=h)|0,b=pA(Z^(r=c=b+z|0),(_=r>>>0<b>>>0?I+1|0:I)^R,63),c=h,I=k+iA|0,I=(I=(v=L+J|0)>>>0<L>>>0?I+1|0:I)+l|0,I=(v=v+M|0)>>>0<M>>>0?I+1|0:I,M=v,v=I,l=pA(M^eA,I^F,32),I=(I=p)+(p=h)|0,R=F=l+$|0,J=pA(F^J,(I=F>>>0<l>>>0?I+1|0:I)^k,24),QA=k=h,F=I,I=v+fA|0,I=(I=(M=M+j|0)>>>0<j>>>0?I+1|0:I)+k|0,M=I=(v=M+J|0)>>>0<M>>>0?I+1|0:I,k=(p=l=pA(v^l,I^p,16))+R|0,I=(I=F)+(F=h)|0,R=J,J=k,R=pA(R^k,(p=p>>>0>k>>>0?I+1|0:I)^QA,63),k=h,Z=r,V=l,I=m+cA|0,m=l=q+CA|0,I=(I=l>>>0<q>>>0?I+1|0:I)+w|0,I=(l=l+x|0)>>>0<m>>>0?I+1|0:I,m=l,r=F,F=I,r=pA(V^l,r^I,32),I=(I=_)+(_=h)|0,V=x,x=l=Z+r|0,CA=pA(V^l,(I=r>>>0>l>>>0?I+1|0:I)^w,24),QA=w=h,l=I,I=F+B|0,I=(I=(m=m+K|0)>>>0<K>>>0?I+1|0:I)+w|0,V=F=m+CA|0,Z=pA(F^r,(w=_)^(_=F>>>0<m>>>0?I+1|0:I),16),I=(F=h)+l|0,l=w=(m=Z)+x|0,CA=pA(w^CA,(m=w>>>0<m>>>0?I+1|0:I)^QA,63),w=h,x=b,I=D+AA|0,I=(I=(b=t+N|0)>>>0<N>>>0?I+1|0:I)+c|0,r=pA((D=N=x+b|0)^rA,(r=u)^(u=b>>>0>D>>>0?I+1|0:I),32),I=(I=p)+(p=h)|0,b=c,c=I=r>>>0>(N=r+J|0)>>>0?I+1|0:I,x=pA(x^N,b^I,24),J=I=h,b=I,I=u+a|0,I=(I=(D=D+T|0)>>>0<T>>>0?I+1|0:I)+b|0,b=I=(u=D+x|0)>>>0<D>>>0?I+1|0:I,p=pA(u^r,I^p,16),I=c+(D=h)|0,I=(r=N+p|0)>>>0<N>>>0?I+1|0:I,N=r,r=I,J=pA(N^x,I^J,63),c=h,$=R,I=y+E|0,I=(I=(R=d+X|0)>>>0<X>>>0?I+1|0:I)+k|0,d=pA((x=y=$+R|0)^oA,(y=y>>>0<R>>>0?I+1|0:I)^S,32),I=Y+(R=h)|0,Y=k,k=I=(S=P+d|0)>>>0<P>>>0?I+1|0:I,S=pA($^(P=S),Y^I,24),QA=I=h,Y=I,$=S,I=y+aA|0,I=(I=(S=G+x|0)>>>0<G>>>0?I+1|0:I)+Y|0,Y=R,R=I=(y=$+S|0)>>>0<S>>>0?I+1|0:I,oA=pA(y^d,Y^I,16),I=k+(Y=h)|0,I=(S=P+oA|0)>>>0<P>>>0?I+1|0:I,QA=pA($^(P=S),I^QA,63),k=h,S=I,I=U+M|0,I=(I=(d=v+W|0)>>>0<v>>>0?I+1|0:I)+(rA=i[g+156>>2])|0,M=I=(v=(x=i[g+152>>2])+(M=d)|0)>>>0<M>>>0?I+1|0:I,d=pA(v^z,I^e,32),I=(I=f)+(f=h)|0,z=pA((e=d+EA|0)^W,(I=e>>>0<d>>>0?I+1|0:I)^U,24),U=I,eA=i[g+236>>2],EA=e,$=d,I=M+(W=h)|0,I=(I=(d=v+z|0)>>>0<v>>>0?I+1|0:I)+eA|0,I=(v=(e=i[g+232>>2])+(M=d)|0)>>>0<M>>>0?I+1|0:I,M=f,f=I,$=pA($^v,M^I,16),I=(I=U)+(U=h)|0,d=I=(M=EA+(d=$)|0)>>>0<d>>>0?I+1|0:I,W=pA(M^z,I^W,63),z=I=h,EA=P,P=p,I=_+gA|0,I=(I=(p=H+V|0)>>>0<H>>>0?I+1|0:I)+z|0,D=pA(P^(gA=H=p+W|0),(H=p>>>0>H>>>0?I+1|0:I)^D,32),I=(p=h)+S|0,S=_=EA+D|0,z=pA(W^_,z^(I=_>>>0<D>>>0?I+1|0:I),24),W=_=h,P=I,V=D,I=H+a|0,I=(I=(D=T+gA|0)>>>0<T>>>0?I+1|0:I)+_|0,V=pA(V^(_=H=D+z|0),(D=_>>>0<D>>>0?I+1|0:I)^p,16),I=(I=P)+(P=h)|0,S=H=(p=V)+S|0,gA=pA(gA=H^z,(z=p>>>0>H>>>0?I+1|0:I)^W,63),p=h,I=w+E|0,I=(I=(H=X+CA|0)>>>0<X>>>0?I+1|0:I)+b|0,Y=pA((W=H=H+u|0)^oA,(H=H>>>0<u>>>0?I+1|0:I)^Y,32),I=d+(u=h)|0,I=(b=M+Y|0)>>>0<M>>>0?I+1|0:I,M=b,d=w,w=I,d=pA(b^CA,d^I,24),CA=I=h,b=I,EA=Y,I=H+iA|0,I=(I=(Y=L+W|0)>>>0<L>>>0?I+1|0:I)+b|0,W=H=Y+d|0,oA=pA(EA^H,(b=u)^(u=H>>>0<Y>>>0?I+1|0:I),16),I=w+(b=h)|0,I=(H=M+oA|0)>>>0<M>>>0?I+1|0:I,M=H,Y=I,d=pA(H^d,I^CA,63),w=h,I=c+BA|0,I=(I=(H=o+J|0)>>>0<o>>>0?I+1|0:I)+R|0,I=y>>>0>(H=y+H|0)>>>0?I+1|0:I,y=H,H=I,R=pA(y^$,I^U,32),I=m+(o=h)|0,I=l>>>0>(U=l+R|0)>>>0?I+1|0:I,l=c,c=I,m=pA(U^J,l^I,24),BA=I=h,l=I,J=m,I=H+AA|0,I=(I=(m=t+y|0)>>>0<t>>>0?I+1|0:I)+l|0,y=R,R=H=J+(t=m)|0,AA=pA(y^H,(l=t>>>0>H>>>0?I+1|0:I)^o,16),I=c+(m=h)|0,CA=H=U+AA|0,y=pA(J^H,(o=H>>>0<U>>>0?I+1|0:I)^BA,63),H=h,I=k+aA|0,I=(I=(t=G+QA|0)>>>0<G>>>0?I+1|0:I)+f|0,I=(t=t+v|0)>>>0<v>>>0?I+1|0:I,v=t,t=I,U=pA(v^Z,I^F,32),I=r+(G=h)|0,f=k,k=I=(c=N+U|0)>>>0<N>>>0?I+1|0:I,F=pA(c^QA,f^I,24),N=I=h,f=I,r=F,I=t+rA|0,I=(I=(v=v+x|0)>>>0<x>>>0?I+1|0:I)+f|0,f=t=v+F|0,F=pA(t^U,(v=t>>>0<v>>>0?I+1|0:I)^G,16),I=k+(U=h)|0,BA=t=c+F|0,r=pA(r^t,(G=t>>>0<c>>>0?I+1|0:I)^N,63),t=h,I=w+D|0,I=(c=_+d|0)>>>0<_>>>0?I+1|0:I,_=c,I=I+(k=i[g+164>>2])|0,U=pA((k=F)^(F=c=c+i[g+160>>2]|0),(c=c>>>0<_>>>0?I+1|0:I)^U,32),I=(I=o)+(o=h)|0,N=w,w=I=(_=U)>>>0>(k=_+CA|0)>>>0?I+1|0:I,N=pA(k^d,N^I,24),D=I=h,_=I,d=U,I=c+eA|0,I=(I=(U=F+e|0)>>>0<e>>>0?I+1|0:I)+_|0,J=pA(d^(CA=c=U+N|0),(c=c>>>0<U>>>0?I+1|0:I)^o,16),I=w+(_=h)|0,I=(o=k+J|0)>>>0<k>>>0?I+1|0:I,k=o,U=I,x=pA(o^N,I^D,63),o=h,D=y,I=u+nA|0,F=w=O+W|0,I=(I=w>>>0<O>>>0?I+1|0:I)+H|0,N=pA((u=w=w+y|0)^V,(w=w>>>0<F>>>0?I+1|0:I)^P,32),I=(I=G)+(G=h)|0,e=H,H=I=(y=N)>>>0>(F=y+BA|0)>>>0?I+1|0:I,P=pA(D^F,e^I,24),e=I=h,y=I,I=w+C|0,I=(I=(u=u+IA|0)>>>0<IA>>>0?I+1|0:I)+y|0,w=pA((y=w=u+P|0)^N,(u=y>>>0<u>>>0?I+1|0:I)^G,16),I=H+(N=h)|0,I=F>>>0>(G=F+w|0)>>>0?I+1|0:I,G=(F=G)^P,P=I,d=pA(G,I^e,63),H=h,V=r,I=l+fA|0,I=(I=(G=R+j|0)>>>0<j>>>0?I+1|0:I)+t|0,r=pA((D=G=(l=G)+r|0)^oA,(G=D>>>0<l>>>0?I+1|0:I)^b,32),I=z+(l=h)|0,e=t,t=I=(b=S+r|0)>>>0<S>>>0?I+1|0:I,R=pA(V^b,e^I,24),S=I=h,e=I,I=G+cA|0,I=(I=(D=D+q|0)>>>0<q>>>0?I+1|0:I)+e|0,z=pA((e=G=D+R|0)^r,(G=l)^(l=e>>>0<D>>>0?I+1|0:I),16),I=t+(D=h)|0,S=pA((t=G=b+z|0)^R,(I=t>>>0<b>>>0?I+1|0:I)^S,63),G=h,b=I,I=p+B|0,I=(I=(r=K+gA|0)>>>0<K>>>0?I+1|0:I)+v|0,f=I=(r=r+f|0)>>>0<f>>>0?I+1|0:I,R=pA(r^AA,I^m,32),I=Y+(v=h)|0,I=(m=M+R|0)>>>0<M>>>0?I+1|0:I,M=m,Y=p,p=I,I=pA(m^gA,Y^I,24),gA=i[g+204>>2],V=I,m=I,r=I+r|0,I=(Y=h)+f|0,I=(I=r>>>0<m>>>0?I+1|0:I)+gA|0,I=(f=r+i[g+200>>2]|0)>>>0<r>>>0?I+1|0:I,r=v,v=I,gA=pA(f^R,r^I,16),I=p+(m=h)|0,p=r=M+gA|0,R=pA(V^r,(M=r>>>0<M>>>0?I+1|0:I)^Y,63),r=I=h,Z=t,V=w,I=c+a|0,w=t=T+CA|0,I=(I=t>>>0<T>>>0?I+1|0:I)+r|0,AA=pA(V^(Y=t=t+R|0),(t=t>>>0<w>>>0?I+1|0:I)^N,32),I=(w=h)+b|0,N=I=(c=Z+(N=AA)|0)>>>0<N>>>0?I+1|0:I,r=pA(R^c,r^I,24),BA=I=h,b=I,V=r,I=t+C|0,I=(I=(r=Y+IA|0)>>>0<IA>>>0?I+1|0:I)+b|0,b=t=V+r|0,AA=pA(t^AA,(r=t>>>0<r>>>0?I+1|0:I)^w,16),I=N+(R=h)|0,N=t=c+AA|0,w=pA(V^t,(Y=t>>>0<c>>>0?I+1|0:I)^BA,63),c=h,V=x,I=o+B|0,I=(I=(t=K+x|0)>>>0<K>>>0?I+1|0:I)+u|0,D=pA((x=t=t+y|0)^z,(t=t>>>0<y>>>0?I+1|0:I)^D,32),I=M+(y=h)|0,I=p>>>0>(u=p+D|0)>>>0?I+1|0:I,p=u,u=o,o=I,u=pA(V^p,u^I,24),z=I=h,M=I,V=u,I=t+fA|0,I=(I=(u=x+j|0)>>>0<j>>>0?I+1|0:I)+M|0,BA=t=V+u|0,W=pA(t^D,(M=t>>>0<u>>>0?I+1|0:I)^y,16),I=o+(y=h)|0,I=(t=p+W|0)>>>0<p>>>0?I+1|0:I,p=t,u=I,D=pA(V^t,I^z,63),o=h,I=H+cA|0,I=(I=(t=d+q|0)>>>0<q>>>0?I+1|0:I)+l|0,I=(t=t+e|0)>>>0<e>>>0?I+1|0:I,e=t,t=I,x=pA(e^gA,I^m,32),I=U+(l=h)|0,U=H,H=I=k>>>0>(m=k+x|0)>>>0?I+1|0:I,I=pA((k=m)^d,U^I,24),d=i[g+236>>2],V=I,m=I,e=I+e|0,I=(U=h)+t|0,I=(I=e>>>0<m>>>0?I+1|0:I)+d|0,I=(t=e+i[g+232>>2]|0)>>>0<e>>>0?I+1|0:I,m=t,e=l,l=I,z=pA(t^x,e^I,16),I=H+(e=h)|0,x=pA(V^(d=t=k+z|0),(t=t>>>0<k>>>0?I+1|0:I)^U,63),H=h,V=S,I=G+v|0,I=(I=(k=f+S|0)>>>0<f>>>0?I+1|0:I)+(U=i[g+164>>2])|0,S=pA((U=k=(f=k)+i[g+160>>2]|0)^J,(k=f>>>0>k>>>0?I+1|0:I)^_,32),I=P+(f=h)|0,I=F>>>0>(_=F+S|0)>>>0?I+1|0:I,F=G,G=I,F=pA(V^_,F^I,24),P=I=h,v=I,I=k+iA|0,I=(I=(U=U+L|0)>>>0<L>>>0?I+1|0:I)+v|0,U=pA((gA=k=U+F|0)^S,(k=k>>>0<U>>>0?I+1|0:I)^f,16),I=G+(f=h)|0,I=(v=_+U|0)>>>0<_>>>0?I+1|0:I,_=v,v=I,S=pA(_^F,I^P,63),G=h,P=U,I=o+r|0,I=(U=D+b|0)>>>0<b>>>0?I+1|0:I,b=U,I=I+(F=i[g+132>>2])|0,I=(U=U+i[g+128>>2]|0)>>>0<b>>>0?I+1|0:I,b=U,r=f,f=I,P=pA(P^U,r^I,32),I=(I=t)+(t=h)|0,r=o,o=I=(F=P)>>>0>(U=F+d|0)>>>0?I+1|0:I,D=pA(U^D,r^I,24),r=I=h,I=f+nA|0,I=(I=(b=b+O|0)>>>0<O>>>0?I+1|0:I)+r|0,J=pA((CA=f=b+D|0)^P,(f=f>>>0<b>>>0?I+1|0:I)^t,16),I=o+(F=h)|0,I=(t=U+J|0)>>>0<U>>>0?I+1|0:I,U=t,b=I,d=pA(t^D,I^r,63),t=h,I=M+E|0,M=o=X+BA|0,I=(I=o>>>0<X>>>0?I+1|0:I)+H|0,r=pA((D=o=o+x|0)^AA,(o=o>>>0<M>>>0?I+1|0:I)^R,32),I=v+(M=h)|0,I=_>>>0>(P=_+r|0)>>>0?I+1|0:I,_=P,P=H,H=I,I=pA(_^x,P^I,24),R=i[g+156>>2],x=I,P=I,D=I+D|0,I=(v=h)+o|0,I=(I=D>>>0<P>>>0?I+1|0:I)+R|0,I=(o=D+i[g+152>>2]|0)>>>0<D>>>0?I+1|0:I,P=o,D=M,M=I,AA=pA(o^r,D^I,16),I=H+(D=h)|0,I=(o=_+AA|0)>>>0<_>>>0?I+1|0:I,_=o,r=v,v=I,x=pA(x^o,r^I,63),o=h,I=G+l|0,l=H=m+S|0,I=(I=H>>>0<m>>>0?I+1|0:I)+(r=i[g+204>>2])|0,l=I=(H=H+i[g+200>>2]|0)>>>0<l>>>0?I+1|0:I,R=pA(H^W,I^y,32),I=Y+(m=h)|0,r=G,G=I=(y=N+R|0)>>>0<N>>>0?I+1|0:I,r=pA(y^S,r^I,24),N=I=h,S=r,I=I+l|0,I=(I=(r=r+H|0)>>>0<H>>>0?I+1|0:I)+(Y=i[g+148>>2])|0,I=(H=r+i[g+144>>2]|0)>>>0<r>>>0?I+1|0:I,l=H,r=m,m=I,BA=pA(H^R,r^I,16),I=G+(r=h)|0,G=N,N=I=y>>>0>(H=y+BA|0)>>>0?I+1|0:I,Y=pA(S^(y=H),G^I,63),G=h,S=w,I=c+k|0,I=(I=(H=w+gA|0)>>>0<w>>>0?I+1|0:I)+(R=i[g+196>>2])|0,R=H=(w=H)+i[g+192>>2]|0,e=pA(H^z,(w=w>>>0>H>>>0?I+1|0:I)^e,32),I=u+(k=h)|0,u=H=p+e|0,H=pA(S^H,(I=p>>>0>H>>>0?I+1|0:I)^c,24),p=I,z=i[g+220>>2],$=H,Z=u,V=e,I=(c=h)+w|0,I=(I=(e=H+R|0)>>>0<H>>>0?I+1|0:I)+(S=z)|0,gA=pA(V^(e=H=(u=i[g+216>>2])+(w=e)|0),(H=k)^(k=w>>>0>e>>>0?I+1|0:I),16),I=(I=p)+(p=h)|0,R=I=(w=gA)>>>0>(H=Z+w|0)>>>0?I+1|0:I,I=pA($^H,I^c,63),W=i[g+236>>2],V=I,c=I,S=I+CA|0,I=(w=h)+f|0,I=(I=c>>>0>S>>>0?I+1|0:I)+W|0,AA=pA((S=c=(f=S)+i[g+232>>2]|0)^AA,(c=c>>>0<f>>>0?I+1|0:I)^D,32),I=N+(f=h)|0,N=w,w=I=y>>>0>(D=y+AA|0)>>>0?I+1|0:I,D=I=pA(V^(y=D),N^I,24),S=I+S|0,I=(N=h)+c|0,I=z+(D>>>0>S>>>0?I+1|0:I)|0,z=c=u+S|0,AA=pA(c^AA,(S=f)^(f=c>>>0<u>>>0?I+1|0:I),16),I=w+(u=h)|0,w=N,N=I=(c=y+AA|0)>>>0<y>>>0?I+1|0:I,w=pA(D^(y=c),w^I,63),c=h,I=t+nA|0,I=(I=(D=d+O|0)>>>0<O>>>0?I+1|0:I)+M|0,S=D=D+P|0,r=pA(D^BA,(M=D>>>0<P>>>0?I+1|0:I)^r,32),I=R+(P=h)|0,I=H>>>0>(D=H+r|0)>>>0?I+1|0:I,H=D,R=t,t=I,R=pA(D^d,R^I,24),d=I=h,D=I,V=r,I=M+cA|0,I=(I=(r=S+q|0)>>>0<q>>>0?I+1|0:I)+D|0,W=pA(V^(BA=M=r+R|0),(M=r>>>0>M>>>0?I+1|0:I)^P,16),I=t+(P=h)|0,r=I=H>>>0>(D=H+W|0)>>>0?I+1|0:I,R=pA(D^R,I^d,63),H=h,I=o+a|0,I=(I=(t=x+T|0)>>>0<T>>>0?I+1|0:I)+m|0,S=pA((m=t=t+l|0)^gA,(t=t>>>0<l>>>0?I+1|0:I)^p,32),I=b+(p=h)|0,I=(l=U+S|0)>>>0<U>>>0?I+1|0:I,U=l,l=o,o=I,b=pA(U^x,l^I,24),x=I=h,l=I,I=t+B|0,I=(I=(m=m+K|0)>>>0<K>>>0?I+1|0:I)+l|0,l=t=m+b|0,d=pA(t^S,(d=p)^(p=t>>>0<m>>>0?I+1|0:I),16),I=o+(m=h)|0,I=(t=U+d|0)>>>0<U>>>0?I+1|0:I,U=t,o=t^b,b=I,S=pA(o,I^x,63),t=h,V=Y,I=G+k|0,k=o=e+Y|0,I=(I=o>>>0<e>>>0?I+1|0:I)+(x=i[g+156>>2])|0,k=I=(o=o+i[g+152>>2]|0)>>>0<k>>>0?I+1|0:I,Y=pA(o^J,I^F,32),I=v+(F=h)|0,I=(e=_+Y|0)>>>0<_>>>0?I+1|0:I,_=e,v=G,G=I,e=pA(V^e,v^I,24),v=I=h,J=e,I=I+k|0,I=(I=(e=o+e|0)>>>0<o>>>0?I+1|0:I)+(x=i[g+204>>2])|0,gA=o=e+i[g+200>>2]|0,e=pA(o^Y,(k=o>>>0<e>>>0?I+1|0:I)^F,16),I=G+(F=h)|0,G=o=_+e|0,Y=pA(J^o,(_=o>>>0<_>>>0?I+1|0:I)^v,63),o=h,x=R,I=f+C|0,I=(I=(v=z+IA|0)>>>0<IA>>>0?I+1|0:I)+H|0,v=I=(f=v+R|0)>>>0<v>>>0?I+1|0:I,R=pA(f^e,I^F,32),I=b+(F=h)|0,I=(e=U+R|0)>>>0<U>>>0?I+1|0:I,U=e,b=H,H=I,e=pA(x^e,b^I,24),b=I=h,J=e,I=I+v|0,I=(I=(e=f+e|0)>>>0<f>>>0?I+1|0:I)+(x=i[g+132>>2])|0,CA=pA((z=f=e+i[g+128>>2]|0)^R,(f=f>>>0<e>>>0?I+1|0:I)^F,16),I=H+(v=h)|0,I=(F=U+CA|0)>>>0<U>>>0?I+1|0:I,U=F,F=I,x=pA(J^U,I^b,63),H=h,I=M+fA|0,I=(I=(b=j+BA|0)>>>0<j>>>0?I+1|0:I)+t|0,R=pA((e=M=b+S|0)^AA,(M=b>>>0>e>>>0?I+1|0:I)^u,32),I=_+(u=h)|0,I=G>>>0>(b=G+R|0)>>>0?I+1|0:I,G=b,b=t,t=I,I=pA(G^S,b^I,24),S=i[g+164>>2],J=I,b=I,e=I+e|0,I=(_=h)+M|0,I=(I=e>>>0<b>>>0?I+1|0:I)+S|0,I=e>>>0>(M=e+i[g+160>>2]|0)>>>0?I+1|0:I,e=u,u=I,b=pA(M^R,e^I,16),I=t+(e=h)|0,t=_,_=I=G>>>0>(R=G+b|0)>>>0?I+1|0:I,t=pA(J^R,t^I,63),G=h,J=Y,I=o+p|0,I=(I=(Y=l+Y|0)>>>0<l>>>0?I+1|0:I)+(S=i[g+196>>2])|0,S=pA((Y=p=(l=Y)+i[g+192>>2]|0)^W,(p=p>>>0<l>>>0?I+1|0:I)^P,32),I=N+(l=h)|0,N=o,o=I=y>>>0>(P=y+S|0)>>>0?I+1|0:I,P=pA(J^(y=P),N^I,24),AA=I=h,N=I,J=P,I=p+E|0,I=(I=(P=Y+X|0)>>>0<X>>>0?I+1|0:I)+N|0,W=pA((BA=p=J+P|0)^S,(p=p>>>0<P>>>0?I+1|0:I)^l,16),I=o+(l=h)|0,I=y>>>0>(N=y+W|0)>>>0?I+1|0:I,Y=pA(J^(y=N),I^AA,63),o=h,N=I,J=w,I=c+k|0,I=(I=(P=w+gA|0)>>>0<w>>>0?I+1|0:I)+(S=i[g+148>>2])|0,d=pA((S=w=(k=P)+i[g+144>>2]|0)^d,(w=w>>>0<k>>>0?I+1|0:I)^m,32),I=r+(k=h)|0,r=c,c=I=D>>>0>(m=D+d|0)>>>0?I+1|0:I,D=pA(J^m,r^I,24),r=I=h,J=D,I=w+iA|0,I=(I=(D=S+L|0)>>>0<L>>>0?I+1|0:I)+r|0,P=w=J+D|0,d=pA(w^d,(S=k)^(k=w>>>0<D>>>0?I+1|0:I),16),I=c+(D=h)|0,r=pA(J^(c=w=m+d|0),(m=c>>>0<m>>>0?I+1|0:I)^r,63),S=I=h,w=I,J=y,I=f+E|0,I=(I=(y=X+z|0)>>>0<X>>>0?I+1|0:I)+w|0,z=f=y+r|0,e=pA(f^b,(w=f>>>0<y>>>0?I+1|0:I)^e,32),I=(f=h)+N|0,N=I=(y=J+e|0)>>>0<e>>>0?I+1|0:I,r=pA(r^y,S^I,24),S=I=h,b=I,J=e,I=w+fA|0,I=(I=(e=j+z|0)>>>0<j>>>0?I+1|0:I)+b|0,z=w=e+r|0,gA=pA(J^w,(b=f)^(f=w>>>0<e>>>0?I+1|0:I),16),I=N+(b=h)|0,N=I=(w=y+gA|0)>>>0<y>>>0?I+1|0:I,S=pA((y=w)^r,I^S,63),w=h,I=H+cA|0,I=(I=(e=x+q|0)>>>0<q>>>0?I+1|0:I)+u|0,M=I=(e=e+M|0)>>>0<M>>>0?I+1|0:I,r=pA(e^W,I^l,32),I=m+(l=h)|0,I=c>>>0>(u=c+r|0)>>>0?I+1|0:I,c=u,u=H,H=I,I=pA(c^x,u^I,24),x=i[g+204>>2],J=I,u=I,e=I+e|0,I=(m=h)+M|0,I=(I=u>>>0>e>>>0?I+1|0:I)+x|0,W=pA((AA=M=e+i[g+200>>2]|0)^r,(M=e>>>0>M>>>0?I+1|0:I)^l,16),I=H+(l=h)|0,r=m,m=I=c>>>0>(u=c+W|0)>>>0?I+1|0:I,r=pA(J^u,r^I,63),H=h,x=t,I=p+G|0,I=(I=(c=t+BA|0)>>>0<t>>>0?I+1|0:I)+(e=i[g+220>>2])|0,D=pA((e=t=c+i[g+216>>2]|0)^d,(t=t>>>0<c>>>0?I+1|0:I)^D,32),I=F+(c=h)|0,I=(p=U+D|0)>>>0<U>>>0?I+1|0:I,U=G,G=I,I=pA(x^p,U^I,24),x=i[g+156>>2],d=I,F=I,e=I+e|0,I=(U=h)+t|0,I=(I=F>>>0>e>>>0?I+1|0:I)+x|0,BA=t=e+i[g+152>>2]|0,J=pA(t^D,(F=t>>>0<e>>>0?I+1|0:I)^c,16),I=G+(e=h)|0,I=(t=p+J|0)>>>0<p>>>0?I+1|0:I,p=t,c=U,U=I,G=pA(d^t,c^I,63),c=h,d=Y,I=o+k|0,k=t=P+Y|0,I=(I=t>>>0<P>>>0?I+1|0:I)+(D=i[g+132>>2])|0,k=I=(t=t+i[g+128>>2]|0)>>>0<k>>>0?I+1|0:I,Y=pA(t^CA,I^v,32),I=_+(v=h)|0,D=pA(d^(_=P=R+Y|0),(P=o)^(o=_>>>0<R>>>0?I+1|0:I),24),P=I=h,d=D,I=I+k|0,k=D=t+D|0,I=(I=D>>>0<t>>>0?I+1|0:I)+(R=i[g+196>>2])|0,D=t=D+i[g+192>>2]|0,R=pA(t^Y,(R=v)^(v=t>>>0<k>>>0?I+1|0:I),16),I=o+(k=h)|0,I=(t=_+R|0)>>>0<_>>>0?I+1|0:I,_=t,o=P,P=I,x=pA(d^t,o^I,63),t=h,Y=r,I=f+a|0,f=o=T+z|0,I=(I=o>>>0<T>>>0?I+1|0:I)+H|0,I=(o=o+r|0)>>>0<f>>>0?I+1|0:I,f=k,k=I,R=pA(o^R,f^I,32),I=U+(f=h)|0,U=r=p+R|0,r=pA(Y^r,(I=p>>>0>r>>>0?I+1|0:I)^H,24),p=I,z=i[g+148>>2],V=r,d=U,I=k+(H=h)|0,I=(I=(r=o+r|0)>>>0<o>>>0?I+1|0:I)+(Y=z)|0,CA=o=(U=i[g+144>>2])+r|0,QA=pA(o^R,(k=f)^(f=o>>>0<r>>>0?I+1|0:I),16),I=(r=h)+p|0,R=o=d+(k=QA)|0,o=pA(V^o,(Y=o>>>0<k>>>0?I+1|0:I)^H,63),k=h,d=G,I=c+M|0,I=(H=G+AA|0)>>>0<G>>>0?I+1|0:I,G=H,I=I+(p=i[g+236>>2])|0,b=pA((M=H=H+i[g+232>>2]|0)^gA,(H=H>>>0<G>>>0?I+1|0:I)^b,32),I=P+(G=h)|0,I=(p=_+b|0)>>>0<_>>>0?I+1|0:I,_=c,c=I,P=pA(d^p,_^I,24),d=I=h,_=I,I=H+nA|0,I=(I=(M=M+O|0)>>>0<O>>>0?I+1|0:I)+_|0,gA=H=M+P|0,H=pA(H^b,(_=H>>>0<M>>>0?I+1|0:I)^G,16),I=c+(M=h)|0,b=G=p+H|0,d=pA(c=G^P,(P=p>>>0>G>>>0?I+1|0:I)^d,63),G=h,V=x,I=F+B|0,p=c=K+BA|0,I=(I=c>>>0<K>>>0?I+1|0:I)+t|0,p=I=(c=c+x|0)>>>0<p>>>0?I+1|0:I,x=pA(c^W,I^l,32),I=N+(F=h)|0,I=y>>>0>(l=y+x|0)>>>0?I+1|0:I,N=pA(V^(y=l),I^t,24),l=I,AA=i[g+164>>2],$=N,Z=y,I=p+(t=h)|0,I=(I=(N=c+N|0)>>>0<c>>>0?I+1|0:I)+AA|0,N=c=(y=i[g+160>>2])+(p=N)|0,BA=pA(c^x,(V=F)^(F=c>>>0<p>>>0?I+1|0:I),16),I=(I=l)+(l=h)|0,I=(c=Z+(p=BA)|0)>>>0<p>>>0?I+1|0:I,p=c,x=t,t=I,x=pA($^c,x^I,63),c=h,V=S,I=w+iA|0,I=(I=(S=S+L|0)>>>0<L>>>0?I+1|0:I)+v|0,v=I=D>>>0>(S=D+S|0)>>>0?I+1|0:I,W=pA(S^J,I^e,32),I=m+(e=h)|0,m=D=u+W|0,D=pA(V^D,(J=w)^(w=u>>>0>D>>>0?I+1|0:I),24),J=I=h,u=I,V=D,I=v+C|0,I=(I=(D=S+IA|0)>>>0<IA>>>0?I+1|0:I)+u|0,u=I=(v=V+D|0)>>>0<D>>>0?I+1|0:I,W=pA(v^W,I^e,16),I=w+(e=h)|0,I=(D=m+W|0)>>>0<m>>>0?I+1|0:I,m=D,D=I,S=pA(V^m,I^J,63),J=I=h,w=I,V=H,I=f+iA|0,I=(I=(H=L+CA|0)>>>0<L>>>0?I+1|0:I)+w|0,M=pA(V^(f=L=H+S|0),(H=H>>>0>f>>>0?I+1|0:I)^M,32),I=t+(w=h)|0,iA=L=p+M|0,p=I=p>>>0>L>>>0?I+1|0:I,J=L=pA(S^L,J^I,24),I=(t=h)+H|0,I=(I=(f=f+L|0)>>>0<L>>>0?I+1|0:I)+z|0,z=pA((S=L=f+U|0)^M,(f=U>>>0>S>>>0?I+1|0:I)^w,16),I=(U=h)+p|0,iA=L=(H=z)+iA|0,w=pA(J^L,(H=H>>>0>L>>>0?I+1|0:I)^t,63),p=h,J=o,I=_+k|0,I=(I=(L=o+gA|0)>>>0<o>>>0?I+1|0:I)+(t=i[g+196>>2])|0,l=pA((M=L=(o=L)+i[g+192>>2]|0)^BA,(L=o>>>0>M>>>0?I+1|0:I)^l,32),I=D+(t=h)|0,_=k,k=I=(o=m+l|0)>>>0<m>>>0?I+1|0:I,D=I=pA(J^o,_^I,24),m=l,l=M,M=I,l=l+I|0,I=(_=h)+L|0,I=AA+(l>>>0<M>>>0?I+1|0:I)|0,gA=L=y+l|0,AA=pA(m^L,(M=y>>>0>L>>>0?I+1|0:I)^t,16),I=k+(l=h)|0,D=pA(D^(k=L=o+AA|0),(t=_)^(_=o>>>0>k>>>0?I+1|0:I),63),L=h,I=G+nA|0,I=(I=(t=d+O|0)>>>0<O>>>0?I+1|0:I)+F|0,N=pA((y=t=t+N|0)^W,(t=t>>>0<N>>>0?I+1|0:I)^e,32),I=Y+(o=h)|0,e=G,G=I=(F=R+N|0)>>>0<R>>>0?I+1|0:I,e=pA(F^d,e^I,24),R=I=h,m=I,I=t+E|0,I=(I=(y=y+X|0)>>>0<X>>>0?I+1|0:I)+m|0,m=t=y+e|0,d=pA(t^N,(y=t>>>0<y>>>0?I+1|0:I)^o,16),I=G+(N=h)|0,o=pA((o=e)^(e=t=F+d|0),(t=t>>>0<F>>>0?I+1|0:I)^R,63),G=h,I=c+B|0,I=(I=(F=K+x|0)>>>0<K>>>0?I+1|0:I)+u|0,R=F=F+v|0,r=pA(F^QA,(v=F>>>0<v>>>0?I+1|0:I)^r,32),I=P+(F=h)|0,I=(u=b+r|0)>>>0<b>>>0?I+1|0:I,b=c,c=I,P=pA(u^x,b^I,24),Y=I=h,b=I,x=P,I=v+C|0,I=(I=(P=R+IA|0)>>>0<IA>>>0?I+1|0:I)+b|0,P=pA((R=v=x+P|0)^r,(v=v>>>0<P>>>0?I+1|0:I)^F,16),I=c+(F=h)|0,I=u>>>0>(b=u+P|0)>>>0?I+1|0:I,u=b,b=I,r=pA(x^u,I^Y,63),c=h,J=D,x=e,Y=P,I=f+fA|0,I=(I=(P=S+j|0)>>>0<j>>>0?I+1|0:I)+L|0,D=pA(Y^(e=f=P+D|0),(f=e>>>0<P>>>0?I+1|0:I)^F,32),I=(I=t)+(t=h)|0,P=L,L=I=(F=x+D|0)>>>0<D>>>0?I+1|0:I,I=pA(J^F,P^I,24),Y=i[g+220>>2],J=I,x=D,P=e,e=I,D=P+I|0,I=(P=h)+f|0,I=(I=e>>>0>D>>>0?I+1|0:I)+Y|0,x=pA(x^(S=f=(e=D)+i[g+216>>2]|0),(f=f>>>0<e>>>0?I+1|0:I)^t,16),I=L+(e=h)|0,I=(t=F+x|0)>>>0<F>>>0?I+1|0:I,F=t,D=P,P=I,L=pA(J^t,D^I,63),t=h,J=o,I=G+M|0,M=D=o+gA|0,I=(I=D>>>0<o>>>0?I+1|0:I)+(Y=i[g+204>>2])|0,Y=pA((D=o=D+i[g+200>>2]|0)^z,(o=o>>>0<M>>>0?I+1|0:I)^U,32),I=b+(U=h)|0,I=u>>>0>(M=u+Y|0)>>>0?I+1|0:I,u=G,G=I,b=pA(J^M,u^I,24),z=I=h,u=I,J=b,I=o+cA|0,I=(I=(b=D+q|0)>>>0<q>>>0?I+1|0:I)+u|0,gA=o=J+b|0,BA=pA(o^Y,(u=U)^(U=o>>>0<b>>>0?I+1|0:I),16),I=G+(u=h)|0,I=(o=M+BA|0)>>>0<M>>>0?I+1|0:I,M=o,b=I,o=pA(J^o,I^z,63),G=h,J=r,I=c+y|0,y=r=r+m|0,I=(I=r>>>0<m>>>0?I+1|0:I)+(Y=z=i[g+156>>2])|0,Y=pA((r=m=(D=i[g+152>>2])+r|0)^AA,(m=l)^(l=y>>>0>r>>>0?I+1|0:I),32),I=(I=H)+(H=h)|0,I=(y=Y)>>>0>(m=y+iA|0)>>>0?I+1|0:I,y=c,c=I,iA=pA(J^m,y^I,24),AA=I=h,y=I,J=iA,I=l+a|0,I=(I=(r=r+T|0)>>>0<T>>>0?I+1|0:I)+y|0,W=pA((iA=l=r+iA|0)^Y,(l=r>>>0>l>>>0?I+1|0:I)^H,16),I=c+(y=h)|0,Y=pA(J^(c=H=m+W|0),(m=c>>>0<m>>>0?I+1|0:I)^AA,63),H=h,J=w,I=p+v|0,v=r=w+R|0,I=(I=r>>>0<w>>>0?I+1|0:I)+(AA=i[g+236>>2])|0,R=pA((r=w=r+i[g+232>>2]|0)^d,(v=r>>>0<v>>>0?I+1|0:I)^N,32),I=_+(N=h)|0,_=w=k+R|0,w=pA(J^w,(I=w>>>0<k>>>0?I+1|0:I)^p,24),p=I,d=i[g+132>>2],V=w,J=_,I=(k=h)+v|0,I=(I=(r=w+r|0)>>>0<w>>>0?I+1|0:I)+d|0,I=(w=(_=i[g+128>>2])+r|0)>>>0<r>>>0?I+1|0:I,v=w,r=N,N=I,AA=pA(w^R,r^I,16),I=(I=p)+(p=h)|0,I=(w=J+(r=AA)|0)>>>0<r>>>0?I+1|0:I,r=w,w=k,k=I,J=I=pA(V^r,w^I,63),R=I,S=I+S|0,I=(w=h)+f|0,I=d+(S>>>0<R>>>0?I+1|0:I)|0,S=pA((R=f=_+S|0)^BA,(f=f>>>0<_>>>0?I+1|0:I)^u,32),I=m+(_=h)|0,I=c>>>0>(u=c+S|0)>>>0?I+1|0:I,c=u,u=w,w=I,u=pA(J^c,u^I,24),d=I=h,m=I,J=u,I=f+B|0,I=(I=(u=R+K|0)>>>0<K>>>0?I+1|0:I)+m|0,BA=pA((R=f=J+u|0)^S,(f=f>>>0<u>>>0?I+1|0:I)^_,16),I=w+(_=h)|0,u=I=c>>>0>(m=c+BA|0)>>>0?I+1|0:I,S=pA(J^m,I^d,63),w=h,J=L,I=t+U|0,I=(I=(c=L+gA|0)>>>0<L>>>0?I+1|0:I)+(d=i[g+148>>2])|0,y=pA((d=L=c+i[g+144>>2]|0)^W,(L=c>>>0>L>>>0?I+1|0:I)^y,32),I=k+(c=h)|0,V=I=pA(J^(k=U=r+y|0),(U=t)^(t=r>>>0>k>>>0?I+1|0:I),24),J=y,y=I,r=I+d|0,I=(U=h)+L|0,I=z+(r>>>0<y>>>0?I+1|0:I)|0,d=pA(J^(r=L=r+D|0),(y=D>>>0>r>>>0?I+1|0:I)^c,16),I=t+(D=h)|0,t=U,U=I=k>>>0>(L=k+d|0)>>>0?I+1|0:I,t=pA(V^(k=L),t^I,63),c=h,J=o,I=G+l|0,I=(I=(L=o+iA|0)>>>0<o>>>0?I+1|0:I)+(z=i[g+164>>2])|0,z=pA((l=L=(o=L)+i[g+160>>2]|0)^AA,(L=o>>>0>l>>>0?I+1|0:I)^p,32),I=P+(o=h)|0,I=(p=F+z|0)>>>0<F>>>0?I+1|0:I,F=G,G=I,P=pA(J^p,F^I,24),iA=I=h,F=I,I=L+C|0,I=(I=(l=l+IA|0)>>>0<IA>>>0?I+1|0:I)+F|0,J=z,z=L=l+P|0,gA=pA(J^L,(F=l>>>0>L>>>0?I+1|0:I)^o,16),I=G+(l=h)|0,I=p>>>0>(L=p+gA|0)>>>0?I+1|0:I,o=(p=L)^P,P=I,o=pA(o,I^iA,63),G=h,J=Y,I=H+E|0,I=(I=(L=Y+X|0)>>>0<X>>>0?I+1|0:I)+N|0,e=pA((Y=L=v+L|0)^x,(L=v>>>0>L>>>0?I+1|0:I)^e,32),I=b+(v=h)|0,I=M>>>0>(N=M+e|0)>>>0?I+1|0:I,M=N,N=H,H=I,b=pA(J^M,N^I,24),x=I=h,N=I,J=b,I=L+nA|0,I=(I=(b=Y+O|0)>>>0<O>>>0?I+1|0:I)+N|0,e=pA((N=L=J+b|0)^e,(Y=v)^(v=b>>>0>N>>>0?I+1|0:I),16),I=H+(b=h)|0,iA=L=M+e|0,Y=pA(J^L,(H=M>>>0>L>>>0?I+1|0:I)^x,63),L=h,J=t,I=c+f|0,f=M=t+R|0,I=(I=M>>>0<t>>>0?I+1|0:I)+(x=i[g+196>>2])|0,b=pA((M=e)^(e=t=f+i[g+192>>2]|0),(t=t>>>0<f>>>0?I+1|0:I)^b,32),I=P+(f=h)|0,P=c,c=I=p>>>0>(M=p+b|0)>>>0?I+1|0:I,I=pA(J^(p=M),P^I,24),R=i[g+204>>2],V=I,J=b,b=I,P=I+e|0,I=(M=h)+t|0,I=(I=b>>>0>P>>>0?I+1|0:I)+R|0,x=t=(b=P)+i[g+200>>2]|0,AA=pA(J^t,(e=f)^(f=t>>>0<b>>>0?I+1|0:I),16),I=c+(b=h)|0,I=(t=p+AA|0)>>>0<p>>>0?I+1|0:I,p=t,c=M,M=I,t=pA(V^t,c^I,63),c=h,J=o,I=y+G|0,y=e=o+r|0,I=(I=e>>>0<o>>>0?I+1|0:I)+(R=W=i[g+212>>2])|0,r=pA((e=o=(P=i[g+208>>2])+e|0)^BA,(o=o>>>0<y>>>0?I+1|0:I)^_,32),I=(I=H)+(H=h)|0,y=G,G=I=r>>>0>(_=r+iA|0)>>>0?I+1|0:I,I=pA(J^_,y^I,24),R=i[g+220>>2],V=I,J=r,r=e,e=I,r=r+I|0,I=(y=h)+o|0,I=(I=r>>>0<e>>>0?I+1|0:I)+R|0,iA=o=r+i[g+216>>2]|0,r=pA(J^o,(e=o>>>0<r>>>0?I+1|0:I)^H,16),I=G+(R=h)|0,o=y,y=I=(H=_+r|0)>>>0<_>>>0?I+1|0:I,H=pA(V^(_=H),o^I,63),o=h,J=Y,I=F+a|0,I=(I=(G=T+z|0)>>>0<T>>>0?I+1|0:I)+L|0,F=I=(F=G)>>>0>(G=F+Y|0)>>>0?I+1|0:I,d=pA(G^d,I^D,32),I=u+(D=h)|0,u=L,L=I=m>>>0>(Y=m+d|0)>>>0?I+1|0:I,Y=pA(J^(m=Y),u^I,24),u=I=h,J=Y,I=I+F|0,F=Y=G+Y|0,I=(I=Y>>>0<G>>>0?I+1|0:I)+(z=i[g+236>>2])|0,Y=d,d=G=F+i[g+232>>2]|0,z=pA(Y^G,(F=F>>>0>G>>>0?I+1|0:I)^D,16),I=L+(D=h)|0,m=I=(G=m+z|0)>>>0<m>>>0?I+1|0:I,Y=pA(J^G,I^u,63),L=h,J=S,I=w+cA|0,I=(I=(u=S+q|0)>>>0<q>>>0?I+1|0:I)+v|0,I=(u=u+N|0)>>>0<N>>>0?I+1|0:I,N=u,v=I,S=pA(u^gA,I^l,32),I=U+(l=h)|0,I=(u=k+S|0)>>>0<k>>>0?I+1|0:I,k=u,u=w,w=I,u=pA(J^k,u^I,24),gA=I=h,U=I,J=u,I=v+fA|0,I=(I=(u=N+j|0)>>>0<j>>>0?I+1|0:I)+U|0,U=I=u>>>0>(v=J+u|0)>>>0?I+1|0:I,S=pA(v^S,I^l,16),I=w+(l=h)|0,I=(u=k+S|0)>>>0<k>>>0?I+1|0:I,k=u,u=I,N=pA(J^k,I^gA,63),gA=I=h,w=I,J=r,I=f+cA|0,f=r=x+q|0,I=(I=r>>>0<q>>>0?I+1|0:I)+w|0,R=pA(J^(r=q=r+N|0),(q=f>>>0>r>>>0?I+1|0:I)^R,32),I=m+(w=h)|0,I=(f=G+R|0)>>>0<G>>>0?I+1|0:I,G=f,f=I,x=I=pA(N^G,gA^I,24),N=I,r=I+r|0,I=(m=h)+q|0,I=W+(r>>>0<N>>>0?I+1|0:I)|0,R=pA((r=q=r+P|0)^R,(N=P>>>0>r>>>0?I+1|0:I)^w,16),I=f+(P=h)|0,G=pA(x^(f=q=G+R|0),(w=m)^(m=G>>>0>f>>>0?I+1|0:I),63),w=h,J=t,I=c+e|0,I=(I=(q=t+iA|0)>>>0<t>>>0?I+1|0:I)+(x=i[g+164>>2])|0,D=pA((x=q=(t=q)+i[g+160>>2]|0)^z,(q=t>>>0>x>>>0?I+1|0:I)^D,32),I=u+(t=h)|0,I=(e=k+D|0)>>>0<k>>>0?I+1|0:I,k=e,u=c,c=I,I=pA(J^e,u^I,24),z=i[g+196>>2],V=I,J=D,e=I,D=I+x|0,I=(u=h)+q|0,I=(I=e>>>0>D>>>0?I+1|0:I)+z|0,x=pA(J^(D=q=(e=D)+i[g+192>>2]|0),(x=t)^(t=e>>>0>D>>>0?I+1|0:I),16),I=c+(z=h)|0,u=pA(V^(c=q=k+x|0),(k=k>>>0>c>>>0?I+1|0:I)^u,63),q=h,J=H,I=o+F|0,F=e=H+d|0,I=(I=e>>>0<H>>>0?I+1|0:I)+(cA=i[g+204>>2])|0,S=pA((e=H=e+i[g+200>>2]|0)^S,(H=F>>>0>e>>>0?I+1|0:I)^l,32),I=M+(F=h)|0,I=p>>>0>(l=p+S|0)>>>0?I+1|0:I,p=l,l=o,o=I,l=pA(J^p,l^I,24),d=I=h,M=I,J=l,I=H+fA|0,I=(I=(l=e+j|0)>>>0<j>>>0?I+1|0:I)+M|0,S=pA((e=j=J+(H=l)|0)^S,(l=F)^(F=H>>>0>e>>>0?I+1|0:I),16),I=o+(M=h)|0,j=pA(J^(o=j=p+S|0),(p=p>>>0>o>>>0?I+1|0:I)^d,63),H=h,J=Y,I=U+L|0,I=(I=(l=v+Y|0)>>>0<v>>>0?I+1|0:I)+(d=i[g+236>>2])|0,b=pA((Y=v=l+i[g+232>>2]|0)^AA,(v=v>>>0<l>>>0?I+1|0:I)^b,32),I=y+(U=h)|0,I=_>>>0>(l=_+b|0)>>>0?I+1|0:I,_=l,l=L,L=I,y=pA(J^_,l^I,24),l=I=h,d=y,I=v+E|0,I=(I=(y=Y+X|0)>>>0<X>>>0?I+1|0:I)+l|0,I=y>>>0>(X=d+y|0)>>>0?I+1|0:I,y=U,U=I,b=pA((v=X)^b,y^I,16),I=L+(Y=h)|0,y=l,l=I=_>>>0>(X=_+b|0)>>>0?I+1|0:I,X=pA(d^(_=X),y^I,63),L=h,I=N+B|0,I=(I=(y=r+K|0)>>>0<K>>>0?I+1|0:I)+q|0,I=y>>>0>(K=y+u|0)>>>0?I+1|0:I,N=K,y=T+K|0,K=I,I=a+I|0,T=(r=y)>>>0<T>>>0?I+1|0:I,y=u,u=pA(b^N,Y^K,32),I=p+(N=h)|0,q=(o=b=pA(y^(p=K=o+u|0),(K=o>>>0>p>>>0?I+1|0:I)^q,24))+r|0,I=(r=h)+T|0,I=o>>>0>q>>>0?I+1|0:I,o=q,i[g>>2]=o,i[g+4>>2]=I,q=I,I=pA(o^u,I^N,16),y=T=h,i[g+120>>2]=I,i[g+124>>2]=y,T=I,p=I+p|0,I=y+K|0,i[g+80>>2]=p,I=p>>>0<T>>>0?I+1|0:I,i[g+84>>2]=I,sA=g,wA=pA(b^p,I^r,63),i[sA+40>>2]=wA,i[g+44>>2]=h,r=j,I=t+H|0,I=(K=D+j|0)>>>0<j>>>0?I+1|0:I,j=K,I=I+(T=i[g+132>>2])|0,j=I=(K=K+i[g+128>>2]|0)>>>0<j>>>0?I+1|0:I,t=pA(K^R,I^P,32),I=l+(p=h)|0,I=_>>>0>(T=_+t|0)>>>0?I+1|0:I,_=T,T=I,l=pA(r^_,I^H,24),I=j+(y=h)|0,I=(H=l+K|0)>>>0<K>>>0?I+1|0:I,K=(j=i[g+144>>2])+H|0,I=i[g+148>>2]+I|0,I=K>>>0<j>>>0?I+1|0:I,i[g+8>>2]=K,i[g+12>>2]=I,I=pA(t^K,I^p,16),H=K=h,i[g+96>>2]=I,i[g+100>>2]=H,K=I,j=I+_|0,I=H+T|0,I=K>>>0>j>>>0?I+1|0:I,K=j,i[g+88>>2]=K,i[g+92>>2]=I,sA=g,wA=pA(l^K,I^y,63),i[sA+48>>2]=wA,i[g+52>>2]=h,r=O,I=F+L|0,O=K=e+X|0,I=(I=K>>>0<X>>>0?I+1|0:I)+(j=i[g+220>>2])|0,T=K=K+i[g+216>>2]|0,j=r+K|0,K=I=K>>>0<O>>>0?I+1|0:I,I=I+nA|0,j=(H=j)>>>0<T>>>0?I+1|0:I,r=H,T=pA(x^T,K^z,32),I=m+(H=h)|0,L=pA((t=K=f+T|0)^X,(K=f>>>0>t>>>0?I+1|0:I)^L,24),I=(p=h)+j|0,I=L>>>0>(X=r+L|0)>>>0?I+1|0:I,i[g+16>>2]=X,i[g+20>>2]=I,I=pA(X^T,I^H,16),O=X=h,i[g+104>>2]=I,i[g+108>>2]=X,X=I,j=I+t|0,I=K+O|0,K=j,i[g+64>>2]=K,I=X>>>0>K>>>0?I+1|0:I,i[g+68>>2]=I,sA=g,wA=pA(L^K,I^p,63),i[sA+56>>2]=wA,i[g+60>>2]=h,I=w+C|0,I=(I=(K=G+IA|0)>>>0<G>>>0?I+1|0:I)+U|0,X=I=v>>>0>(K=v+K|0)>>>0?I+1|0:I,T=pA(K^S,I^M,32),I=k+(L=h)|0,IA=I=c>>>0>(j=c+T|0)>>>0?I+1|0:I,H=pA(j^G,I^w,24),I=X+(t=h)|0,I=K>>>0>(O=K+H|0)>>>0?I+1|0:I,K=(X=i[g+152>>2])+O|0,I=i[g+156>>2]+I|0,I=K>>>0<X>>>0?I+1|0:I,i[g+24>>2]=K,i[g+28>>2]=I,I=pA(K^T,I^L,16),i[g+112>>2]=I,X=h,i[g+116>>2]=X,K=I+j|0,I=X+IA|0,I=K>>>0<j>>>0?I+1|0:I,i[g+72>>2]=K,i[g+76>>2]=I,sA=g,wA=pA(H^K,I^t,63),i[sA+32>>2]=wA,i[g+36>>2]=h,I=i[g+68>>2]^(n[A+4|0]|n[A+5|0]<<8|n[A+6|0]<<16|n[A+7|0]<<24)^q,K=i[g+64>>2]^(n[0|A]|n[A+1|0]<<8|n[A+2|0]<<16|n[A+3|0]<<24)^o,Q[0|A]=K,Q[A+1|0]=K>>>8,Q[A+2|0]=K>>>16,Q[A+3|0]=K>>>24,Q[A+4|0]=I,Q[A+5|0]=I>>>8,Q[A+6|0]=I>>>16,Q[A+7|0]=I>>>24,X=1;I=(K=X<<3)+A|0,q=i[(K=g+K|0)>>2]^(n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24),IA=i[(j=K- -64|0)>>2],K=i[j+4>>2]^i[K+4>>2]^(n[I+4|0]|n[I+5|0]<<8|n[I+6|0]<<16|n[I+7|0]<<24),q^=IA,Q[0|I]=q,Q[I+1|0]=q>>>8,Q[I+2|0]=q>>>16,Q[I+3|0]=q>>>24,Q[I+4|0]=K,Q[I+5|0]=K>>>8,Q[I+6|0]=K>>>16,Q[I+7|0]=K>>>24,8!=(0|(X=X+1|0)););s=g+256|0}function u(A,I,g,B,C,E,a){var r,o,t,e,f,c,y,w,D,p,u,F,_,k,H,G,U,S,b,m,v,M,P,Y,N,R,d,J,x,L,K,X,T,V,q,j,W,O,Z,$,AA,IA=0,gA=0,CA=0,QA=0,EA=0,iA=0,nA=0,aA=0,rA=0,oA=0,tA=0,eA=0,fA=0,cA=0,yA=0,sA=0,wA=0,DA=0,hA=0,pA=0,uA=0,FA=0,lA=0,_A=0,kA=0,HA=0,GA=0,UA=0,SA=0,bA=0,mA=0,vA=0,PA=0,YA=0,NA=0,RA=0,dA=0,JA=0,xA=0,LA=0,KA=0,XA=0,TA=0,VA=0,zA=0,jA=0,WA=0,OA=0,ZA=0,$A=0,AI=0,gI=0,BI=0;return s=R=s-560|0,WI(rA=R+352|0,a),_I(d=R+288|0,E,32,0),z(rA,R+320|0,32,0),z(rA,g,B,C),MA(rA,r=R+224|0),IA=n[E+32|0]|n[E+33|0]<<8|n[E+34|0]<<16|n[E+35|0]<<24,QA=n[E+36|0]|n[E+37|0]<<8|n[E+38|0]<<16|n[E+39|0]<<24,nA=n[E+40|0]|n[E+41|0]<<8|n[E+42|0]<<16|n[E+43|0]<<24,gA=n[E+44|0]|n[E+45|0]<<8|n[E+46|0]<<16|n[E+47|0]<<24,EA=n[E+48|0]|n[E+49|0]<<8|n[E+50|0]<<16|n[E+51|0]<<24,iA=n[E+52|0]|n[E+53|0]<<8|n[E+54|0]<<16|n[E+55|0]<<24,oA=n[E+60|0]|n[E+61|0]<<8|n[E+62|0]<<16|n[E+63|0]<<24,E=n[E+56|0]|n[E+57|0]<<8|n[E+58|0]<<16|n[E+59|0]<<24,Q[A+56|0]=E,Q[A+57|0]=E>>>8,Q[A+58|0]=E>>>16,Q[A+59|0]=E>>>24,Q[A+60|0]=oA,Q[A+61|0]=oA>>>8,Q[A+62|0]=oA>>>16,Q[A+63|0]=oA>>>24,E=EA,Q[A+48|0]=E,Q[A+49|0]=E>>>8,Q[A+50|0]=E>>>16,Q[A+51|0]=E>>>24,E=iA,Q[A+52|0]=E,Q[A+53|0]=E>>>8,Q[A+54|0]=E>>>16,Q[A+55|0]=E>>>24,E=nA,Q[A+40|0]=E,Q[A+41|0]=E>>>8,Q[A+42|0]=E>>>16,Q[A+43|0]=E>>>24,E=gA,Q[A+44|0]=E,Q[A+45|0]=E>>>8,Q[A+46|0]=E>>>16,Q[A+47|0]=E>>>24,Q[0|(E=A+32|0)]=IA,Q[E+1|0]=IA>>>8,Q[E+2|0]=IA>>>16,Q[E+3|0]=IA>>>24,IA=QA,Q[E+4|0]=IA,Q[E+5|0]=IA>>>8,Q[E+6|0]=IA>>>16,Q[E+7|0]=IA>>>24,l(r),BA(R,r),II(A,R),WI(rA,a),z(rA,A,64,0),z(rA,g,B,C),MA(rA,A=R+160|0),l(A),Q[0|d]=248&n[0|d],Q[d+31|0]=63&n[d+31|0]|64,TA=uI(A),nA=n[A+2|0]|n[A+3|0]<<8|n[A+4|0]<<16|n[A+5|0]<<24,SA=uI(A+5|0),EA=h,gA=n[A+7|0]|n[A+8|0]<<8|n[A+9|0]<<16|n[A+10|0]<<24,rA=n[A+10|0]|n[A+11|0]<<8|n[A+12|0]<<16|n[A+13|0]<<24,LA=uI(A+13|0),oA=h,aA=n[A+15|0]|n[A+16|0]<<8|n[A+17|0]<<16|n[A+18|0]<<24,bA=uI(A+18|0),cA=h,NA=uI(A+21|0),B=n[A+23|0]|n[A+24|0]<<8|n[A+25|0]<<16|n[A+26|0]<<24,iA=uI(A+26|0),g=h,C=n[A+28|0]|n[A+29|0]<<8|n[A+30|0]<<16|n[A+31|0]<<24,KA=uI(d),uA=n[(A=d)+2|0]|n[A+3|0]<<8|n[A+4|0]<<16|n[A+5|0]<<24,RA=uI(A+5|0),kA=h,fA=n[A+7|0]|n[A+8|0]<<8|n[A+9|0]<<16|n[A+10|0]<<24,tA=n[A+10|0]|n[A+11|0]<<8|n[A+12|0]<<16|n[A+13|0]<<24,jA=uI(A+13|0),FA=h,sA=n[A+15|0]|n[A+16|0]<<8|n[A+17|0]<<16|n[A+18|0]<<24,VA=uI(A+18|0),hA=h,dA=uI(A+21|0),a=n[A+23|0]|n[A+24|0]<<8|n[A+25|0]<<16|n[A+26|0]<<24,eA=uI(A+26|0),IA=h,QA=n[A+28|0]|n[A+29|0]<<8|n[A+30|0]<<16|n[A+31|0]<<24,W=uI(r),O=n[(A=r)+2|0]|n[A+3|0]<<8|n[A+4|0]<<16|n[A+5|0]<<24,Z=uI(A+5|0),$=h,AA=n[A+7|0]|n[A+8|0]<<8|n[A+9|0]<<16|n[A+10|0]<<24,PA=n[A+10|0]|n[A+11|0]<<8|n[A+12|0]<<16|n[A+13|0]<<24,$A=uI(A+13|0),HA=h,DA=n[A+15|0]|n[A+16|0]<<8|n[A+17|0]<<16|n[A+18|0]<<24,AI=uI(A+18|0),yA=h,JA=uI(A+21|0),A=qA(o=QA>>>7|0,0,t=2097151&((3&(A=g))<<30|(g=iA)>>>2),0),g=h,QA=A,C=qA(e=2097151&((3&(A=IA))<<30|(IA=eA)>>>2),0,f=C>>>7|0,0),g=h+g|0,QA=A=QA+C|0,IA=A>>>0<C>>>0?g+1|0:g,A=qA(t,CA,e,CA),C=h,g=(a=qA(c=a>>>5&2097151,0,f,0))+A|0,A=h+C|0,A=g>>>0<a>>>0?A+1|0:A,C=qA(o,0,y=B>>>5&2097151,0),B=h+A|0,B=(g=C+g|0)>>>0<C>>>0?B+1|0:B,C=g,mA=B,wA=A=B-((g>>>0<4293918720)-1|0)|0,a=(2097151&A)<<11|(iA=g- -1048576|0)>>>21,A=(A>>21)+IA|0,A=(B=a+QA|0)>>>0<a>>>0?A+1|0:A,a=B,GA=A,vA=IA=A-((B>>>0<4293918720)-1|0)|0,g=IA>>21,UA=(A=qA(o,0,f,0))-(lA=-2097152&(pA=A- -1048576|0))|0,A=((eA=h)-((A>>>0<lA>>>0)+(B=eA-((A>>>0<4293918720)-1|0)|0)|0)|0)+g|0,T=IA=UA+((2097151&IA)<<11|(QA=a- -1048576|0)>>>21)|0,eA=A=IA>>>0<UA>>>0?A+1|0:A,g=qA(IA,A,-683901,-1),IA=h,J=(2097151&B)<<11|pA>>>21,pA=A=B>>21,A=(B=qA(J,A,136657,0))+g|0,g=h+IA|0,UA=A,lA=A>>>0<B>>>0?g+1|0:g,A=qA(w=2097151&((1&(A=FA))<<31|jA>>>1),0,t,CA),g=h,IA=qA(D=tA>>>4&2097151,0,f,0),B=h+g|0,B=(A=IA+A|0)>>>0<IA>>>0?B+1|0:B,IA=qA(p=sA>>>6&2097151,0,y,0),g=h+B|0,g=(A=IA+A|0)>>>0<IA>>>0?g+1|0:g,FA=A,IA=qA(u=2097151&dA,B=0,F=2097151&((7&(A=cA))<<29|bA>>>3),0),A=h+g|0,g=A=(B=FA+IA|0)>>>0<IA>>>0?A+1|0:A,A=(IA=qA(_=2097151&((7&(A=hA))<<29|VA>>>3),0,k=2097151&NA,0))+B|0,B=h+g|0,B=A>>>0<IA>>>0?B+1|0:B,IA=qA(c,0,H=aA>>>6&2097151,0),g=h+B|0,g=(A=IA+A|0)>>>0<IA>>>0?g+1|0:g,B=A,IA=qA(e,CA,G=2097151&((1&(A=oA))<<31|LA>>>1),0),A=h+g|0,A=(B=B+IA|0)>>>0<IA>>>0?A+1|0:A,g=(IA=qA(o,0,U=rA>>>4&2097151,0))+B|0,B=h+A|0,cA=g,rA=g>>>0<IA>>>0?B+1|0:B,A=qA(t,CA,D,0),g=h,B=qA(S=fA>>>7&2097151,0,f,0),g=h+g|0,g=(A=B+A|0)>>>0<B>>>0?g+1|0:g,B=(IA=qA(y,0,w,CA))+A|0,A=h+g|0,A=B>>>0<IA>>>0?A+1|0:A,g=(IA=qA(p,0,k,CA))+B|0,B=h+A|0,B=g>>>0<IA>>>0?B+1|0:B,A=(IA=qA(u,CA,H,0))+g|0,g=h+B|0,g=A>>>0<IA>>>0?g+1|0:g,B=(IA=qA(F,CA,_,CA))+A|0,A=h+g|0,A=B>>>0<IA>>>0?A+1|0:A,IA=qA(c,0,G,CA),g=h+A|0,g=(B=IA+B|0)>>>0<IA>>>0?g+1|0:g,IA=qA(e,CA,U,0),A=h+g|0,A=(B=IA+B|0)>>>0<IA>>>0?A+1|0:A,g=(IA=qA(o,0,b=gA>>>7&2097151,0))+B|0,B=h+A|0,B=g>>>0<IA>>>0?B+1|0:B,IA=g,oA=B,A=B-((g>>>0<4293918720)-1|0)|0,B=g- -1048576|0,aA=A,g=cA,cA=(2097151&A)<<11|B>>>21,A=(A>>21)+rA|0,A=(gA=(g=gA=g+cA|0)>>>0<cA>>>0?A+1|0:A)+lA|0,A=g>>>0>(rA=g+UA|0)>>>0?A+1|0:A,gA=gA-((g>>>0<4293918720)-1|0)|0,tA=rA-(g=-2097152&(fA=g- -1048576|0))|0,rA=A-((g>>>0>rA>>>0)+gA|0)|0,cA=GA-(((A=-2097152&QA)>>>0>a>>>0)+vA|0)|0,x=a-A|0,a=qA(J,pA,-997805,-1),g=h+oA|0,g=(A=a+IA|0)>>>0<a>>>0?g+1|0:g,a=(IA=qA(T,eA,136657,0))+A|0,A=h+g|0,A=a>>>0<IA>>>0?A+1|0:A,g=a,a=qA(x,cA,-683901,-1),A=h+A|0,QA=(g=g+a|0)-(B&=-2097152)|0,oA=(A=g>>>0<a>>>0?A+1|0:A)-((g>>>0<B>>>0)+aA|0)|0,A=qA(t,CA,S,0),B=h,g=A,a=qA(m=2097151&((3&(A=kA))<<30|RA>>>2),0,f,0),A=h+B|0,A=(g=g+a|0)>>>0<a>>>0?A+1|0:A,a=qA(y,0,D,0),B=h+A|0,B=(g=a+g|0)>>>0<a>>>0?B+1|0:B,A=(a=qA(w,CA,k,CA))+g|0,g=h+B|0,g=A>>>0<a>>>0?g+1|0:g,B=(a=qA(p,0,F,CA))+A|0,A=h+g|0,A=B>>>0<a>>>0?A+1|0:A,a=qA(u,CA,G,CA),g=h+A|0,g=(B=a+B|0)>>>0<a>>>0?g+1|0:g,a=qA(_,CA,H,0),A=h+g|0,A=(B=a+B|0)>>>0<a>>>0?A+1|0:A,g=(a=qA(c,0,U,0))+B|0,B=h+A|0,B=g>>>0<a>>>0?B+1|0:B,A=(a=qA(e,CA,b,0))+g|0,g=h+B|0,g=A>>>0<a>>>0?g+1|0:g,B=A,a=qA(o,0,v=2097151&((3&(A=EA))<<30|SA>>>2),0),A=h+g|0,EA=B=B+a|0,IA=B>>>0<a>>>0?A+1|0:A,A=qA(t,CA,m,0),g=h,B=qA(M=uA>>>5&2097151,0,f,0),g=h+g|0,g=(A=B+A|0)>>>0<B>>>0?g+1|0:g,B=qA(y,0,S,0),g=h+g|0,g=(A=B+A|0)>>>0<B>>>0?g+1|0:g,B=(a=qA(D,0,k,CA))+A|0,A=h+g|0,A=B>>>0<a>>>0?A+1|0:A,g=B,B=qA(w,CA,F,CA),A=h+A|0,A=(g=g+B|0)>>>0<B>>>0?A+1|0:A,a=qA(p,0,H,0),B=h+A|0,B=(g=a+g|0)>>>0<a>>>0?B+1|0:B,A=(a=qA(u,CA,U,0))+g|0,g=h+B|0,g=A>>>0<a>>>0?g+1|0:g,B=qA(_,CA,G,CA),g=h+g|0,g=(A=B+A|0)>>>0<B>>>0?g+1|0:g,B=(a=qA(c,0,b,0))+A|0,A=h+g|0,A=B>>>0<a>>>0?A+1|0:A,g=B,B=qA(e,CA,v,0),A=h+A|0,A=(g=g+B|0)>>>0<B>>>0?A+1|0:A,a=qA(o,0,P=nA>>>5&2097151,0),B=h+A|0,B=(g=a+g|0)>>>0<a>>>0?B+1|0:B,a=g,SA=B,LA=g=B-((g>>>0<4293918720)-1|0)|0,A=(A=g>>21)+IA|0,IA=g=(B=(2097151&g)<<11|(hA=a- -1048576|0)>>>21)+EA|0,bA=A=g>>>0<B>>>0?A+1|0:A,NA=g=A-((g>>>0<4293918720)-1|0)|0,A=g>>21,g=(B=QA)+(QA=(2097151&g)<<11|(GA=IA- -1048576|0)>>>21)|0,B=A+oA|0,B=g>>>0<QA>>>0?B+1|0:B,QA=g,RA=B,jA=g=B-((g>>>0<4293918720)-1|0)|0,A=(A=g>>21)+rA|0,nA=g=(B=(2097151&g)<<11|(vA=QA- -1048576|0)>>>21)+tA|0,lA=A=g>>>0<B>>>0?A+1|0:A,VA=g=A-((g>>>0<4293918720)-1|0)|0,uA=(2097151&g)<<11|(aA=nA- -1048576|0)>>>21,rA=g>>21,A=qA(t,CA,p,0),g=h,EA=qA(f,0,w,CA),B=h+g|0,B=(A=EA+A|0)>>>0<EA>>>0?B+1|0:B,EA=qA(u,CA,k,CA),g=h+B|0,g=(A=EA+A|0)>>>0<EA>>>0?g+1|0:g,B=(EA=qA(y,0,_,CA))+A|0,A=h+g|0,A=B>>>0<EA>>>0?A+1|0:A,EA=qA(c,0,F,CA),g=h+A|0,g=(B=EA+B|0)>>>0<EA>>>0?g+1|0:g,EA=qA(e,CA,H,0),A=h+g|0,A=(B=EA+B|0)>>>0<EA>>>0?A+1|0:A,g=(EA=qA(o,0,G,CA))+B|0,B=h+A|0,B=g>>>0<EA>>>0?B+1|0:B,A=g,oA=qA(J,pA,-683901,-1),g=h+B|0,g=(EA=A+oA|0)>>>0<oA>>>0?g+1|0:g,oA=EA,EA=B-((A>>>0<4293918720)-1|0)|0,B=oA-(A=-2097152&(kA=A- -1048576|0))|0,oA=g-((A>>>0>oA>>>0)+EA|0)|0,g=(A=B)+(B=(2097151&gA)<<11|fA>>>21)|0,A=(gA>>21)+oA|0,A=g>>>0<B>>>0?A+1|0:A,B=uA,fA=g-(uA=-2097152&(oA=g- -1048576|0))|0,g=(A-((gA=A-((g>>>0<4293918720)-1|0)|0)+(g>>>0<uA>>>0)|0)|0)+rA|0,V=B=B+fA|0,uA=g=B>>>0<fA>>>0?g+1|0:g,rA=qA(B,g,-683901,-1),fA=h,A=qA(y,0,u,CA),B=h,g=(tA=qA(f,0,p,0))+A|0,A=h+B|0,A=g>>>0<tA>>>0?A+1|0:A,B=(tA=qA(t,CA,_,CA))+g|0,g=h+A|0,g=B>>>0<tA>>>0?g+1|0:g,tA=qA(c,0,k,CA),A=h+g|0,A=(B=tA+B|0)>>>0<tA>>>0?A+1|0:A,g=(tA=qA(e,CA,F,CA))+B|0,B=h+A|0,B=g>>>0<tA>>>0?B+1|0:B,A=(tA=qA(o,0,H,0))+g|0,g=h+B|0,g=A>>>0<tA>>>0?g+1|0:g,B=A,A=(A=EA>>21)+g|0,FA=B=(A=(g=B=B+(EA=(2097151&EA)<<11|kA>>>21)|0)>>>0<EA>>>0?A+1|0:A)-((g>>>0<4293918720)-1|0)|0,kA=g-(EA=-2097152&(UA=g- -1048576|0))|0,B=A-((g>>>0<EA>>>0)+B|0)|0,g=(g=(A=gA)>>21)+B|0,q=A=(gA=(2097151&A)<<11|(gA=oA)>>>21)+kA|0,kA=g=A>>>0<gA>>>0?g+1|0:g,B=qA(A,g,136657,0),A=h+fA|0,gI=g=B+rA|0,dA=g>>>0<B>>>0?A+1|0:A,A=qA(k,CA,M,0),B=h,g=(gA=qA(Y=2097151&KA,0,y,0))+A|0,A=h+B|0,A=g>>>0<gA>>>0?A+1|0:A,gA=qA(F,CA,m,0),B=h+A|0,B=(g=gA+g|0)>>>0<gA>>>0?B+1|0:B,A=(gA=qA(H,0,S,0))+g|0,g=h+B|0,g=A>>>0<gA>>>0?g+1|0:g,B=(gA=qA(D,0,G,CA))+A|0,A=h+g|0,A=B>>>0<gA>>>0?A+1|0:A,gA=qA(w,CA,U,0),g=h+A|0,g=(B=gA+B|0)>>>0<gA>>>0?g+1|0:g,gA=qA(p,0,b,0),A=h+g|0,A=(B=gA+B|0)>>>0<gA>>>0?A+1|0:A,g=(gA=qA(u,CA,P,0))+B|0,B=h+A|0,B=g>>>0<gA>>>0?B+1|0:B,A=(gA=qA(_,CA,v,0))+g|0,g=h+B|0,g=A>>>0<gA>>>0?g+1|0:g,B=(gA=qA(c,0,N=2097151&TA,0))+A|0,A=h+g|0,A=B>>>0<gA>>>0?A+1|0:A,rA=B=(gA=(n[r+23|0]|n[r+24|0]<<8|n[r+25|0]<<16|n[r+26|0]<<24)>>>5&2097151)+B|0,EA=B>>>0<gA>>>0?A+1|0:A,A=qA(F,CA,M,0),g=h,gA=qA(k,CA,Y,0),B=h+g|0,B=(A=gA+A|0)>>>0<gA>>>0?B+1|0:B,gA=qA(H,0,m,0),g=h+B|0,g=(A=gA+A|0)>>>0<gA>>>0?g+1|0:g,B=(gA=qA(G,CA,S,0))+A|0,A=h+g|0,A=B>>>0<gA>>>0?A+1|0:A,g=B,B=qA(D,0,U,0),A=h+A|0,A=(g=g+B|0)>>>0<B>>>0?A+1|0:A,B=(gA=qA(w,CA,b,0))+g|0,g=h+A|0,g=B>>>0<gA>>>0?g+1|0:g,A=(gA=qA(p,0,v,0))+B|0,B=h+g|0,B=A>>>0<gA>>>0?B+1|0:B,gA=qA(N,0,u,CA),g=h+B|0,g=(A=gA+A|0)>>>0<gA>>>0?g+1|0:g,B=(gA=qA(_,CA,P,0))+A|0,A=h+g|0,A=B>>>0<gA>>>0?A+1|0:A,gA=g=(g=B)+(B=2097151&JA)|0,sA=A=g>>>0<B>>>0?A+1|0:A,TA=A=A-((g>>>0<4293918720)-1|0)|0,oA=g- -1048576|0,g=(B=A>>>21|0)+EA|0,EA=A=(tA=rA)+(rA=(2097151&A)<<11|oA>>>21)|0,KA=A>>>0<rA>>>0?g+1|0:g,fA=C-(A=-2097152&iA)|0,WA=mA-((A>>>0>C>>>0)+wA|0)|0,A=qA(t,CA,c,0),B=h,g=(C=qA(f,0,u,CA))+A|0,A=h+B|0,A=g>>>0<C>>>0?A+1|0:A,C=qA(e,CA,y,0),B=h+A|0,B=(g=C+g|0)>>>0<C>>>0?B+1|0:B,A=(C=qA(o,0,k,CA))+g|0,g=h+B|0,tA=A,iA=A>>>0<C>>>0?g+1|0:g,A=qA(f,0,_,CA),g=h,B=qA(t,CA,u,CA),g=h+g|0,g=(A=B+A|0)>>>0<B>>>0?g+1|0:g,B=(C=qA(c,0,y,0))+A|0,A=h+g|0,A=B>>>0<C>>>0?A+1|0:A,g=B,B=qA(e,CA,k,CA),A=h+A|0,A=(g=g+B|0)>>>0<B>>>0?A+1|0:A,C=qA(o,0,F,CA),B=h+A|0,B=(g=C+g|0)>>>0<C>>>0?B+1|0:B,C=g,mA=B,wA=g=B-((g>>>0<4293918720)-1|0)|0,A=tA,tA=(2097151&g)<<11|(rA=C- -1048576|0)>>>21,g=(g>>21)+iA|0,iA=B=A+tA|0,JA=g=B>>>0<tA>>>0?g+1|0:g,tA=B- -1048576|0,B=(A=(g=g-((B>>>0<4293918720)-1|0)|0)>>21)+WA|0,L=fA=(ZA=(2097151&g)<<11|tA>>>21)+fA|0,fA=B=fA>>>0<ZA>>>0?B+1|0:B,A=qA(L,B,470296,0),B=h,tA=JA-((YA=g)+((g=-2097152&tA)>>>0>iA>>>0)|0)|0,K=iA-g|0,iA=qA(x,cA,666643,0),g=h+B|0,g=(A=iA+A|0)>>>0<iA>>>0?g+1|0:g,B=(iA=qA(K,tA,654183,0))+A|0,A=h+g|0,A=B>>>0<iA>>>0?A+1|0:A,iA=B,B=A,rA=mA-(((A=-2097152&rA)>>>0>C>>>0)+wA|0)|0,C=g=C-A|0,FA=(2097151&(g=FA))<<11|UA>>>21,g=(A=g>>21)+rA|0,j=C=C+FA|0,FA=g=C>>>0<FA>>>0?g+1|0:g,rA=KA-(((A=EA)>>>0<4293918720)-1|0)|0,XA=A- -1048576|0,C=qA(C,g,-997805,-1),g=h+B|0,g=(A=C+iA|0)>>>0<C>>>0?g+1|0:g,C=A,B=EA+A|0,A=g+KA|0,A=B>>>0<C>>>0?A+1|0:A,UA=(g=B)-(B=-2097152&XA)|0,WA=A-((g>>>0<B>>>0)+rA|0)|0,A=qA(K,tA,470296,0),g=h,B=qA(L,fA,666643,0),g=h+g|0,g=(A=B+A|0)>>>0<B>>>0?g+1|0:g,B=(C=qA(j,FA,654183,0))+A|0,A=h+g|0,g=B+gA|0,B=sA+(B>>>0<C>>>0?A+1|0:A)|0,B=g>>>0<gA>>>0?B+1|0:B,oA=(A=g)-(g=-2097152&oA)|0,sA=B-((A>>>0<g>>>0)+TA|0)|0,A=qA(H,0,M,0),B=h,g=(C=qA(F,CA,Y,0))+A|0,A=h+B|0,A=g>>>0<C>>>0?A+1|0:A,B=qA(G,CA,m,0),A=h+A|0,A=(g=B+g|0)>>>0<B>>>0?A+1|0:A,C=qA(U,0,S,0),B=h+A|0,B=(g=C+g|0)>>>0<C>>>0?B+1|0:B,A=(C=qA(D,0,b,0))+g|0,g=h+B|0,g=A>>>0<C>>>0?g+1|0:g,B=qA(w,CA,v,0),g=h+g|0,g=(A=B+A|0)>>>0<B>>>0?g+1|0:g,B=(C=qA(p,0,P,0))+A|0,A=h+g|0,A=B>>>0<C>>>0?A+1|0:A,g=B,B=qA(N,0,_,CA),A=h+A|0,A=(g=g+B|0)>>>0<B>>>0?A+1|0:A,B=g,g=A,iA=A=(C=2097151&((7&(A=yA))<<29|AI>>>3))+B|0,C=A>>>0<C>>>0?g+1|0:g,A=qA(G,CA,M,0),g=h,B=qA(H,0,Y,0),g=h+g|0,g=(A=B+A|0)>>>0<B>>>0?g+1|0:g,B=(gA=qA(U,0,m,0))+A|0,A=h+g|0,A=B>>>0<gA>>>0?A+1|0:A,gA=qA(S,0,b,0),g=h+A|0,g=(B=gA+B|0)>>>0<gA>>>0?g+1|0:g,gA=qA(D,0,v,0),A=h+g|0,A=(B=gA+B|0)>>>0<gA>>>0?A+1|0:A,g=(gA=qA(w,CA,P,0))+B|0,B=h+A|0,B=g>>>0<gA>>>0?B+1|0:B,A=(gA=qA(N,0,p,0))+g|0,g=h+B|0,B=A,A=A>>>0<gA>>>0?g+1|0:g,gA=g=(g=B)+(B=DA>>>6&2097151)|0,yA=A=g>>>0<B>>>0?A+1|0:A,mA=A=A-((g>>>0<4293918720)-1|0)|0,EA=g- -1048576|0,g=(B=A>>>21|0)+C|0,C=A=(wA=iA)+(iA=(2097151&A)<<11|EA>>>21)|0,wA=g=A>>>0<iA>>>0?g+1|0:g,TA=A=g-((A>>>0<4293918720)-1|0)|0,g=oA,oA=(2097151&A)<<11|(iA=C- -1048576|0)>>>21,A=(A>>>21|0)+sA|0,sA=g=g+oA|0,KA=A=g>>>0<oA>>>0?A+1|0:A,JA=A=A-((g>>>0<4293918720)-1|0)|0,DA=g- -1048576|0,g=(B=A>>21)+WA|0,g=(A=(oA=(2097151&A)<<11|DA>>>21)+UA|0)>>>0<oA>>>0?g+1|0:g,B=A,oA=A+gI|0,A=g+dA|0,A=B>>>0>oA>>>0?A+1|0:A,dA=oA,oA=g-((B>>>0<4293918720)-1|0)|0,OA=dA-(g=-2097152&(zA=B- -1048576|0))|0,xA=A-((g>>>0>dA>>>0)+oA|0)|0,g=qA(q,kA,-997805,-1),B=h+KA|0,YA=A=g+sA|0,dA=A>>>0<g>>>0?B+1|0:B,A=qA(j,FA,470296,0),B=h,g=(sA=qA(K,tA,666643,0))+A|0,A=h+B|0,A=(A=g>>>0<sA>>>0?A+1|0:A)+wA|0,sA=(g=g+C|0)-(B=-2097152&iA)|0,wA=(A=g>>>0<C>>>0?A+1|0:A)-((g>>>0<B>>>0)+TA|0)|0,B=qA(j,FA,666643,0),g=h+yA|0,yA=A=B+gA|0,iA=A>>>0<B>>>0?g+1|0:g,A=qA(U,0,M,0),B=h,g=(C=qA(G,CA,Y,0))+A|0,A=h+B|0,A=g>>>0<C>>>0?A+1|0:A,B=qA(b,0,m,0),A=h+A|0,A=(g=B+g|0)>>>0<B>>>0?A+1|0:A,C=qA(S,0,v,0),B=h+A|0,B=(g=C+g|0)>>>0<C>>>0?B+1|0:B,A=(C=qA(D,0,P,0))+g|0,g=h+B|0,g=A>>>0<C>>>0?g+1|0:g,B=qA(N,0,w,CA),g=h+g|0,g=(A=B+A|0)>>>0<B>>>0?g+1|0:g,B=A,C=2097151&((1&(A=HA))<<31|$A>>>1),A=g,HA=B=B+C|0,gA=B>>>0<C>>>0?A+1|0:A,A=qA(b,0,M,0),B=h,g=(C=qA(U,0,Y,0))+A|0,A=h+B|0,A=g>>>0<C>>>0?A+1|0:A,B=(C=qA(m,0,v,0))+g|0,g=h+A|0,g=B>>>0<C>>>0?g+1|0:g,A=(C=qA(S,0,P,0))+B|0,B=h+g|0,B=A>>>0<C>>>0?B+1|0:B,C=qA(N,0,D,0),g=h+B|0,B=A=C+A|0,A=A>>>0<C>>>0?g+1|0:g,C=g=(g=B)+(B=PA>>>4&2097151)|0,TA=A=g>>>0<B>>>0?A+1|0:A,KA=A=A-((g>>>0<4293918720)-1|0)|0,PA=g- -1048576|0,g=(B=A>>>21|0)+gA|0,gA=A=(UA=HA)+(HA=(2097151&A)<<11|PA>>>21)|0,UA=g=A>>>0<HA>>>0?g+1|0:g,$A=A=g-((A>>>0<4293918720)-1|0)|0,g=yA,yA=(2097151&A)<<11|(HA=gA- -1048576|0)>>>21,A=(A>>>21|0)+iA|0,AI=A=(A=(g=g+yA|0)>>>0<yA>>>0?A+1|0:A)-(((B=-2097152&EA)>>>0>g>>>0)+mA|0)|0,gI=A=A-(((EA=g-B|0)>>>0<4293918720)-1|0)|0,B=(g=A>>21)+wA|0,mA=A=(iA=(2097151&A)<<11|(yA=EA- -1048576|0)>>>21)+sA|0,WA=B=A>>>0<iA>>>0?B+1|0:B,ZA=A=B-((A>>>0<4293918720)-1|0)|0,sA=lA-(((g=-2097152&aA)>>>0>nA>>>0)+VA|0)|0,X=nA-g|0,nA=(2097151&A)<<11|(wA=mA- -1048576|0)>>>21,A=(A>>21)+dA|0,A=(B=nA+YA|0)>>>0<nA>>>0?A+1|0:A,g=(iA=qA(V,uA,136657,0))+(B-(nA=-2097152&DA)|0)|0,B=h+(A-((B>>>0<nA>>>0)+JA|0)|0)|0,B=g>>>0<iA>>>0?B+1|0:B,nA=qA(X,sA,-683901,-1),A=h+B|0,A=(g=nA+g|0)>>>0<nA>>>0?A+1|0:A,nA=g,VA=A,dA=A=A-((g>>>0<4293918720)-1|0)|0,B=(g=A>>21)+xA|0,B=(A=(iA=(2097151&A)<<11|(DA=nA- -1048576|0)>>>21)+OA|0)>>>0<iA>>>0?B+1|0:B,iA=A,JA=B,OA=A=B-((A>>>0<4293918720)-1|0)|0,BI=(2097151&A)<<11|(lA=iA- -1048576|0)>>>21,xA=A>>21,A=qA(y,0,M,0),B=h,g=(aA=qA(t,CA,Y,0))+A|0,A=h+B|0,A=g>>>0<aA>>>0?A+1|0:A,B=(aA=qA(k,CA,m,0))+g|0,g=h+A|0,g=B>>>0<aA>>>0?g+1|0:g,A=(aA=qA(F,CA,S,0))+B|0,B=h+g|0,B=A>>>0<aA>>>0?B+1|0:B,g=(aA=qA(D,0,H,0))+A|0,A=h+B|0,A=g>>>0<aA>>>0?A+1|0:A,B=(aA=qA(w,CA,G,CA))+g|0,g=h+A|0,g=B>>>0<aA>>>0?g+1|0:g,aA=qA(p,0,U,0),A=h+g|0,A=(B=aA+B|0)>>>0<aA>>>0?A+1|0:A,aA=qA(u,CA,v,0),g=h+A|0,g=(B=aA+B|0)>>>0<aA>>>0?g+1|0:g,A=(aA=qA(_,CA,b,0))+B|0,B=h+g|0,B=A>>>0<aA>>>0?B+1|0:B,g=(aA=qA(c,0,P,0))+A|0,A=h+B|0,A=g>>>0<aA>>>0?A+1|0:A,B=(aA=qA(N,0,e,CA))+g|0,g=h+A|0,g=B>>>0<aA>>>0?g+1|0:g,YA=B,B=uI(r+26|0),aA=2097151&((3&(A=h))<<30|B>>>2),A=g,A=(B=YA+aA|0)>>>0<aA>>>0?A+1|0:A,aA=B,YA=A,A=qA(x,cA,470296,0),g=h,B=qA(T,eA,666643,0),g=h+g|0,g=(A=B+A|0)>>>0<B>>>0?g+1|0:g,_A=qA(L,fA,654183,0),B=h+g|0,B=(A=_A+A|0)>>>0<_A>>>0?B+1|0:B,_A=qA(K,tA,-997805,-1),g=h+B|0,g=(A=_A+A|0)>>>0<_A>>>0?g+1|0:g,B=(_A=qA(j,FA,136657,0))+A|0,A=h+g|0,A=(A=B>>>0<_A>>>0?A+1|0:A)+YA|0,A=(g=B+aA|0)>>>0<B>>>0?A+1|0:A,B=g,aA=YA-(((g=aA)>>>0<4293918720)-1|0)|0,YA=g- -1048576|0,g=A+(g=rA>>>21|0)|0,g=(B=(rA=(2097151&rA)<<11|XA>>>21)+B|0)>>>0<rA>>>0?g+1|0:g,B=(A=B)-(XA=-2097152&YA)|0,_A=qA(q,kA,-683901,-1),A=(g=g-((A>>>0<XA>>>0)+aA|0)|0)+h|0,A=(rA=B+_A|0)>>>0<_A>>>0?A+1|0:A,_A=rA,rA=g-((B>>>0<4293918720)-1|0)|0,XA=B- -1048576|0,g=A+(g=oA>>21)|0,g=(B=(oA=(2097151&oA)<<11|zA>>>21)+_A|0)>>>0<oA>>>0?g+1|0:g,B=(A=B)-(zA=-2097152&XA)|0,A=(_A=xA)+(xA=g-((A>>>0<zA>>>0)+rA|0)|0)|0,A=B>>>0>(oA=B+BI|0)>>>0?A+1|0:A,g=oA,oA=xA-((B>>>0<4293918720)-1|0)|0,zA=g-(B=-2097152&(xA=B- -1048576|0))|0,BI=A-((g>>>0<B>>>0)+oA|0)|0,_A=iA-(A=-2097152&lA)|0,JA=JA-((A>>>0>iA>>>0)+OA|0)|0,OA=nA-(A=-2097152&DA)|0,VA=VA-((A>>>0>nA>>>0)+dA|0)|0,B=qA(q,kA,654183,0),A=h+WA|0,A=(g=B+mA|0)>>>0<B>>>0?A+1|0:A,B=(iA=qA(V,uA,-997805,-1))+(g-(nA=-2097152&wA)|0)|0,g=h+(A-((g>>>0<nA>>>0)+ZA|0)|0)|0,g=B>>>0<iA>>>0?g+1|0:g,nA=qA(X,sA,136657,0),A=h+g|0,lA=B=nA+B|0,DA=B>>>0<nA>>>0?A+1|0:A,iA=QA-(A=-2097152&vA)|0,RA=RA-((A>>>0>QA>>>0)+jA|0)|0,A=qA(T,eA,-997805,-1),g=h,QA=qA(J,pA,654183,0),B=h+g|0,B=(A=QA+A|0)>>>0<QA>>>0?B+1|0:B,QA=qA(x,cA,136657,0),g=h+B|0,g=(A=QA+A|0)>>>0<QA>>>0?g+1|0:g,B=(QA=qA(L,fA,-683901,-1))+A|0,A=h+g|0,g=(A=B>>>0<QA>>>0?A+1|0:A)+bA|0,g=(B=B+IA|0)>>>0<IA>>>0?g+1|0:g,QA=(A=B)-(B=-2097152&GA)|0,bA=g-((A>>>0<B>>>0)+NA|0)|0,A=qA(T,eA,654183,0),g=h,IA=qA(J,pA,470296,0),B=h+g|0,B=(A=IA+A|0)>>>0<IA>>>0?B+1|0:B,g=(IA=qA(x,cA,-997805,-1))+A|0,A=h+B|0,B=g+a|0,g=SA+(g>>>0<IA>>>0?A+1|0:A)|0,g=B>>>0<a>>>0?g+1|0:g,A=B,B=qA(L,fA,136657,0),g=h+g|0,g=(A=A+B|0)>>>0<B>>>0?g+1|0:g,B=(a=qA(K,tA,-683901,-1))+A|0,A=h+g|0,A=B>>>0<a>>>0?A+1|0:A,IA=(g=B)-(B=-2097152&hA)|0,hA=A-((g>>>0<B>>>0)+LA|0)|0,A=qA(t,CA,M,0),B=h,g=(a=qA(f,0,Y,0))+A|0,A=h+B|0,A=g>>>0<a>>>0?A+1|0:A,B=(a=qA(y,0,m,0))+g|0,g=h+A|0,g=B>>>0<a>>>0?g+1|0:g,a=qA(k,CA,S,0),A=h+g|0,A=(B=a+B|0)>>>0<a>>>0?A+1|0:A,a=qA(D,0,F,CA),g=h+A|0,g=(B=a+B|0)>>>0<a>>>0?g+1|0:g,A=(a=qA(w,CA,H,0))+B|0,B=h+g|0,B=A>>>0<a>>>0?B+1|0:B,g=(a=qA(p,0,G,CA))+A|0,A=h+B|0,A=g>>>0<a>>>0?A+1|0:A,B=(a=qA(u,CA,b,0))+g|0,g=h+A|0,g=B>>>0<a>>>0?g+1|0:g,a=qA(_,CA,U,0),A=h+g|0,A=(B=a+B|0)>>>0<a>>>0?A+1|0:A,a=qA(c,0,v,0),g=h+A|0,g=(B=a+B|0)>>>0<a>>>0?g+1|0:g,A=(a=qA(N,0,o,0))+B|0,B=h+g|0,B=A>>>0<a>>>0?B+1|0:B,g=(a=qA(e,CA,P,0))+A|0,A=h+B|0,A=g>>>0<a>>>0?A+1|0:A,A=(aA>>>21|0)+(g=(B=(a=(n[r+28|0]|n[r+29|0]<<8|n[r+30|0]<<16|n[r+31|0]<<24)>>>7|0)+g|0)>>>0<a>>>0?A+1|0:A)|0,A=(B=(a=(2097151&aA)<<11|YA>>>21)+B|0)>>>0<a>>>0?A+1|0:A,a=B,GA=A,vA=A=A-((B>>>0<4293918720)-1|0)|0,g=IA,IA=(2097151&A)<<11|(nA=B- -1048576|0)>>>21,A=(A>>21)+hA|0,A=(B=g+IA|0)>>>0<IA>>>0?A+1|0:A,IA=B,mA=A,wA=A=A-((B>>>0<4293918720)-1|0)|0,g=QA,QA=(2097151&A)<<11|(CA=B- -1048576|0)>>>21,A=(A>>21)+bA|0,aA=A=(B=g+QA|0)>>>0<QA>>>0?A+1|0:A,hA=A=A-((B>>>0<4293918720)-1|0)|0,SA=(2097151&A)<<11|(QA=B- -1048576|0)>>>21,A=(A>>21)+RA|0,bA=iA=SA+iA|0,iA=A=iA>>>0<SA>>>0?A+1|0:A,A=(g=lA)+(lA=qA(bA,A,-683901,-1))|0,g=h+DA|0,SA=A,DA=A>>>0<lA>>>0?g+1|0:g,aA=aA-(((A=-2097152&QA)>>>0>B>>>0)+hA|0)|0,NA=B-A|0,g=qA(q,kA,470296,0)+EA|0,A=AI+h|0,A=g>>>0<EA>>>0?A+1|0:A,B=(EA=qA(V,uA,654183,0))+(g-(QA=-2097152&yA)|0)|0,g=h+(A-((g>>>0<QA>>>0)+gI|0)|0)|0,g=B>>>0<EA>>>0?g+1|0:g,A=B,B=qA(X,sA,-997805,-1),g=h+g|0,g=(A=A+B|0)>>>0<B>>>0?g+1|0:g,B=(QA=qA(bA,iA,136657,0))+A|0,A=h+g|0,A=B>>>0<QA>>>0?A+1|0:A,g=(QA=qA(NA,aA,-683901,-1))+B|0,B=h+A|0,yA=B=g>>>0<QA>>>0?B+1|0:B,lA=B=B-((g>>>0<4293918720)-1|0)|0,A=(A=B>>21)+DA|0,A=(B=(QA=(2097151&B)<<11|(EA=g- -1048576|0)>>>21)+SA|0)>>>0<QA>>>0?A+1|0:A,QA=B,DA=A,SA=B=A-((B>>>0<4293918720)-1|0)|0,RA=(2097151&B)<<11|(hA=QA- -1048576|0)>>>21,B=(B>>21)+VA|0,B=RA>>>0>(LA=RA+OA|0)>>>0?B+1|0:B,RA=LA,LA=B,jA=QA-(A=-2097152&hA)|0,SA=DA-((A>>>0>QA>>>0)+SA|0)|0,DA=g-(A=-2097152&EA)|0,yA=yA-((A>>>0>g>>>0)+lA|0)|0,A=(B=qA(q,kA,666643,0))+(gA-(g=-2097152&HA)|0)|0,g=h+(UA-((g>>>0>gA>>>0)+$A|0)|0)|0,g=A>>>0<B>>>0?g+1|0:g,QA=qA(V,uA,470296,0),B=h+g|0,B=(A=QA+A|0)>>>0<QA>>>0?B+1|0:B,g=(QA=qA(X,sA,654183,0))+A|0,A=h+B|0,hA=g,QA=g>>>0<QA>>>0?A+1|0:A,gA=IA-(A=-2097152&CA)|0,IA=mA-((A>>>0>IA>>>0)+wA|0)|0,A=qA(T,eA,470296,0),B=h,g=(EA=qA(J,pA,666643,0))+A|0,A=h+B|0,A=g>>>0<EA>>>0?A+1|0:A,EA=qA(x,cA,654183,0),B=h+A|0,B=(g=EA+g|0)>>>0<EA>>>0?B+1|0:B,EA=qA(L,fA,-997805,-1),A=h+B|0,A=(g=EA+g|0)>>>0<EA>>>0?A+1|0:A,B=(EA=qA(K,tA,136657,0))+g|0,g=h+A|0,g=B>>>0<EA>>>0?g+1|0:g,A=B,B=qA(j,FA,-683901,-1),g=h+g|0,g=(A=A+B|0)>>>0<B>>>0?g+1|0:g,B=A+a|0,A=g+GA|0,A=B>>>0<a>>>0?A+1|0:A,a=(g=B)-(B=-2097152&nA)|0,B=A-((g>>>0<B>>>0)+vA|0)|0,g=(A=a)+(a=(2097151&rA)<<11|XA>>>21)|0,A=(rA>>21)+B|0,A=g>>>0<a>>>0?A+1|0:A,a=g,kA=A,fA=g=A-((g>>>0<4293918720)-1|0)|0,nA=(2097151&g)<<11|(EA=a- -1048576|0)>>>21,g=(g>>21)+IA|0,HA=B=nA+gA|0,gA=g=B>>>0<nA>>>0?g+1|0:g,g=qA(B,g,-683901,-1),B=h+QA|0,B=(A=g+hA|0)>>>0<g>>>0?B+1|0:B,g=(IA=qA(bA,iA,-997805,-1))+A|0,A=h+B|0,A=g>>>0<IA>>>0?A+1|0:A,B=(IA=qA(NA,aA,136657,0))+g|0,g=h+A|0,vA=B,cA=B>>>0<IA>>>0?g+1|0:g,A=qA(v,0,M,0),B=h,g=(IA=qA(b,0,Y,0))+A|0,A=h+B|0,A=g>>>0<IA>>>0?A+1|0:A,B=(IA=qA(m,0,P,0))+g|0,g=h+A|0,g=B>>>0<IA>>>0?g+1|0:g,A=(IA=qA(N,0,S,0))+B|0,B=h+g|0,g=A,A=A>>>0<IA>>>0?B+1|0:B,CA=g=(B=AA>>>7&2097151)+g|0,QA=g>>>0<B>>>0?A+1|0:A,A=qA(M,0,P,0),g=h,B=qA(v,0,Y,0),g=h+g|0,g=(A=B+A|0)>>>0<B>>>0?g+1|0:g,IA=qA(N,0,m,0),B=h+g|0,B=(A=IA+A|0)>>>0<IA>>>0?B+1|0:B,g=A,IA=2097151&((3&(A=$))<<30|Z>>>2),A=B,A=(g=g+IA|0)>>>0<IA>>>0?A+1|0:A,IA=g,nA=A,tA=A=A-((g>>>0<4293918720)-1|0)|0,g=A>>>21|0,A=(B=CA)+(CA=(2097151&A)<<11|(rA=IA- -1048576|0)>>>21)|0,B=g+QA|0,QA=A,FA=B=A>>>0<CA>>>0?B+1|0:B,hA=A=B-((A>>>0<4293918720)-1|0)|0,B=C+((2097151&A)<<11|(CA=QA- -1048576|0)>>>21)|0,A=TA+(A>>>21|0)|0,A=B>>>0<C>>>0?A+1|0:A,g=(eA=qA(V,uA,666643,0))+(B-(C=-2097152&PA)|0)|0,B=h+(A-((B>>>0<C>>>0)+KA|0)|0)|0,A=(C=qA(X,sA,470296,0))+g|0,g=h+(g>>>0<eA>>>0?B+1|0:B)|0,g=A>>>0<C>>>0?g+1|0:g,B=(C=qA(HA,gA,136657,0))+A|0,A=h+g|0,A=B>>>0<C>>>0?A+1|0:A,g=B,B=qA(bA,iA,654183,0),A=h+A|0,A=(g=g+B|0)>>>0<B>>>0?A+1|0:A,B=(C=qA(NA,aA,-997805,-1))+g|0,g=h+A|0,eA=B,uA=g=B>>>0<C>>>0?g+1|0:g,GA=g=g-((B>>>0<4293918720)-1|0)|0,C=(2097151&g)<<11|(pA=B- -1048576|0)>>>21,g=(g>>21)+cA|0,C=g=(B=C+vA|0)>>>0<C>>>0?g+1|0:g,vA=g=g-((B>>>0<4293918720)-1|0)|0,PA=(2097151&g)<<11|(cA=B- -1048576|0)>>>21,g=(g>>21)+yA|0,mA=DA=PA+DA|0,DA=DA>>>0<PA>>>0?g+1|0:g,PA=C,g=a-(A=-2097152&EA)|0,C=kA-((A>>>0>a>>>0)+fA|0)|0,A=(a=(2097151&oA)<<11|xA>>>21)+g|0,g=(oA>>21)+C|0,C=A,kA=g=A>>>0<a>>>0?g+1|0:g,fA=A=g-((A>>>0<4293918720)-1|0)|0,EA=g=A>>21,a=B,B=qA(yA=(2097151&A)<<11|(oA=C- -1048576|0)>>>21,g,-683901,-1),A=h+PA|0,A=(g=a+B|0)>>>0<B>>>0?A+1|0:A,PA=g-(B=-2097152&cA)|0,vA=A-((g>>>0<B>>>0)+vA|0)|0,B=qA(yA,EA,136657,0),g=h+uA|0,g=(A=B+eA|0)>>>0<B>>>0?g+1|0:g,wA=A-(B=-2097152&pA)|0,lA=g-((A>>>0<B>>>0)+GA|0)|0,a=qA(X,sA,666643,0),B=h+(FA-(((g=-2097152&CA)>>>0>QA>>>0)+hA|0)|0)|0,B=(A=a+(QA-g|0)|0)>>>0<a>>>0?B+1|0:B,g=(a=qA(HA,gA,-997805,-1))+A|0,A=h+B|0,A=g>>>0<a>>>0?A+1|0:A,B=(a=qA(bA,iA,470296,0))+g|0,g=h+A|0,g=B>>>0<a>>>0?g+1|0:g,A=B,B=qA(NA,aA,654183,0),g=h+g|0,hA=A=A+B|0,CA=A>>>0<B>>>0?g+1|0:g,eA=IA,pA=nA,A=qA(N,0,M,0),B=h,g=(a=qA(P,0,Y,0))+A|0,A=h+B|0,A=g>>>0<a>>>0?A+1|0:A,B=(g=(a=O>>>5&2097151)+g|0)>>>0<a>>>0?A+1|0:A,IA=g,a=2097151&W,g=qA(N,0,Y,0)+a|0,A=h,A=g>>>0<a>>>0?A+1|0:A,a=g,cA=A,uA=A=A-((g>>>0<4293918720)-1|0)|0,g=(g=A>>>21|0)+B|0,g=(A=(nA=IA)+(IA=(2097151&A)<<11|(QA=a- -1048576|0)>>>21)|0)>>>0<IA>>>0?g+1|0:g,IA=A,FA=g,sA=A=g-((A>>>0<4293918720)-1|0)|0,g=eA,eA=(2097151&A)<<11|(nA=IA- -1048576|0)>>>21,A=(A>>>21|0)+pA|0,A=(B=g+eA|0)>>>0<eA>>>0?A+1|0:A,B=(eA=qA(HA,gA,654183,0))+((g=B)-(rA&=-2097152)|0)|0,g=h+(A-((16383&tA)+(g>>>0<rA>>>0)|0)|0)|0,g=B>>>0<eA>>>0?g+1|0:g,A=B,B=qA(bA,iA,666643,0),g=h+g|0,g=(A=A+B|0)>>>0<B>>>0?g+1|0:g,B=(iA=qA(NA,aA,470296,0))+A|0,A=h+g|0,A=B>>>0<iA>>>0?A+1|0:A,iA=B,eA=A,pA=A=A-((B>>>0<4293918720)-1|0)|0,tA=(2097151&A)<<11|(rA=B- -1048576|0)>>>21,A=(A>>21)+CA|0,tA=A=(B=tA+hA|0)>>>0<tA>>>0?A+1|0:A,hA=A=A-((B>>>0<4293918720)-1|0)|0,g=wA,wA=(2097151&A)<<11|(CA=B- -1048576|0)>>>21,A=(A>>21)+lA|0,A=wA>>>0>(GA=g+wA|0)>>>0?A+1|0:A,wA=GA,GA=A,A=(g=qA(yA,EA,-997805,-1))+B|0,B=h+tA|0,B=A>>>0<g>>>0?B+1|0:B,CA=A-(g=-2097152&CA)|0,tA=B-((A>>>0<g>>>0)+hA|0)|0,B=qA(yA,EA,654183,0),g=h+eA|0,g=(A=B+iA|0)>>>0<B>>>0?g+1|0:g,eA=A-(B=-2097152&rA)|0,pA=g-((A>>>0<B>>>0)+pA|0)|0,g=(B=qA(HA,gA,470296,0))+(IA-(A=-2097152&nA)|0)|0,A=h+(FA-((16383&sA)+(A>>>0>IA>>>0)|0)|0)|0,A=g>>>0<B>>>0?A+1|0:A,B=(IA=qA(NA,aA,666643,0))+g|0,g=h+A|0,iA=B,IA=B>>>0<IA>>>0?g+1|0:g,A=(B=qA(HA,gA,666643,0))+(a-(g=-2097152&QA)|0)|0,g=h+(cA-((4095&uA)+(g>>>0>a>>>0)|0)|0)|0,g=A>>>0<B>>>0?g+1|0:g,B=A,nA=g,gA=g=g-((A>>>0<4293918720)-1|0)|0,QA=iA,iA=(2097151&g)<<11|(a=A- -1048576|0)>>>21,g=(g>>21)+IA|0,iA=g=(IA=QA=QA+iA|0)>>>0<iA>>>0?g+1|0:g,rA=g=g-((IA>>>0<4293918720)-1|0)|0,A=eA,eA=(2097151&g)<<11|(QA=IA- -1048576|0)>>>21,g=(g>>21)+pA|0,g=(aA=A+eA|0)>>>0<eA>>>0?g+1|0:g,eA=aA,aA=g,g=(A=IA)+(IA=qA(yA,EA,470296,0))|0,A=h+iA|0,A=g>>>0<IA>>>0?A+1|0:A,QA=g-(IA=-2097152&QA)|0,IA=A-((g>>>0<IA>>>0)+rA|0)|0,iA=QA,A=(B-(g=-2097152&a)|0)+(a=qA(yA,EA,666643,0))|0,g=h+(nA-((g>>>0>B>>>0)+gA|0)|0)|0,QA=A,B=A,A=(A=(g=A>>>0<a>>>0?g+1|0:g)>>21)+IA|0,A=(g=iA+(B=(2097151&g)<<11|B>>>21)|0)>>>0<B>>>0?A+1|0:A,nA=g,B=g,g=(g=A>>21)+aA|0,EA=A=(B=(2097151&A)<<11|B>>>21)+eA|0,a=(2097151&(g=A>>>0<B>>>0?g+1|0:g))<<11|(B=A)>>>21,B=(A=g>>21)+tA|0,iA=g=a+CA|0,a=(2097151&(B=(A=g)>>>0<a>>>0?B+1|0:B))<<11|A>>>21,A=(g=B>>21)+GA|0,rA=B=a+wA|0,a=(2097151&(A=(g=B)>>>0<a>>>0?A+1|0:A))<<11|g>>>21,g=(B=A>>21)+vA|0,aA=A=a+PA|0,B=A,A=(A=(g=A>>>0<a>>>0?g+1|0:g)>>21)+DA|0,A=(g=(B=(2097151&g)<<11|B>>>21)+mA|0)>>>0<B>>>0?A+1|0:A,CA=g,B=g,g=(g=A>>21)+SA|0,eA=A=(B=(2097151&A)<<11|B>>>21)+jA|0,a=(2097151&(g=A>>>0<B>>>0?g+1|0:g))<<11|(B=A)>>>21,B=(A=g>>21)+LA|0,pA=g=a+RA|0,a=(2097151&(B=(A=g)>>>0<a>>>0?B+1|0:B))<<11|A>>>21,A=(g=B>>21)+JA|0,cA=B=a+_A|0,a=(2097151&(A=(g=B)>>>0<a>>>0?A+1|0:A))<<11|g>>>21,g=(B=A>>21)+BI|0,uA=A=a+zA|0,B=A,A=(g=A>>>0<a>>>0?g+1|0:g)>>21,B=(2097151&g)<<11|B>>>21,a=C-(g=-2097152&oA)|0,g=(kA-((g>>>0>C>>>0)+fA|0)|0)+A|0,oA=B=B+a|0,a=B=(g=(A=B)>>>0<a>>>0?g+1|0:g)>>21,A=qA(gA=(2097151&g)<<11|A>>>21,B,666643,0),g=h,IA=A=A+(B=2097151&QA)|0,C=g=A>>>0<B>>>0?g+1|0:g,Q[0|E]=A,Q[E+1|0]=(255&g)<<24|A>>>8,B=2097151&nA,g=qA(gA,a,470296,0)+B|0,A=h,QA=(nA=(2097151&C)<<11|IA>>>21)+g|0,g=(C>>21)+(A=g>>>0<B>>>0?A+1|0:A)|0,g=QA>>>0<nA>>>0?g+1|0:g,Q[E+4|0]=(2047&g)<<21|QA>>>11,A=g,Q[E+3|0]=(7&A)<<29|QA>>>3,nA=2097151&EA,B=qA(gA,a,654183,0)+nA|0,g=h,EA=(2097151&A)<<11|QA>>>21,A=(A>>21)+(g=B>>>0<nA>>>0?g+1|0:g)|0,g=A=EA>>>0>(B=nA=EA+B|0)>>>0?A+1|0:A,Q[E+6|0]=(63&A)<<26|B>>>6,nA=0,A=QA&=2097151,Q[E+2|0]=31&((65535&C)<<16|IA>>>16)|A<<5,IA=2097151&iA,C=qA(gA,a,-997805,-1)+IA|0,A=h,EA=(2097151&g)<<11|B>>>21,g=(g>>21)+(A=C>>>0<IA>>>0?A+1|0:A)|0,g=(A=IA=EA+C|0)>>>0<EA>>>0?g+1|0:g,Q[E+9|0]=(511&g)<<23|A>>>9,Q[E+8|0]=(1&g)<<31|A>>>1,C=0,IA=(B=EA=2097151&B)<<2,B=nA,Q[E+5|0]=IA|(524287&B)<<13|QA>>>19,QA=2097151&rA,IA=qA(gA,a,136657,0)+QA|0,B=h,B=IA>>>0<QA>>>0?B+1|0:B,QA=IA,IA=B,B=g,g=(g>>=21)+IA|0,g=(B=(iA=QA)+(QA=(2097151&B)<<11|A>>>21)|0)>>>0<QA>>>0?g+1|0:g,Q[E+12|0]=(4095&g)<<20|B>>>12,Q[E+11|0]=(15&g)<<28|B>>>4,IA=0,QA=(A=nA=2097151&A)<<7,A=C,C=EA,Q[E+7|0]=QA|(16383&A)<<18|C>>>14,C=(A=qA(gA,a,-683901,-1))+(a=2097151&aA)|0,A=h,A=C>>>0<a>>>0?A+1|0:A,a=C,C=A,QA=(2097151&(A=g))<<11|B>>>21,A=(g=A>>21)+C|0,A=(a=QA+a|0)>>>0<QA>>>0?A+1|0:A,Q[E+14|0]=(127&A)<<25|a>>>7,QA=0,B=(g=gA=2097151&B)<<4,g=IA,Q[E+10|0]=B|(131071&g)<<15|nA>>>17,g=A,A>>=21,C=B=(IA=(2097151&g)<<11|a>>>21)+(2097151&CA)|0,g=B>>>0<IA>>>0?A+1|0:A,Q[E+17|0]=(1023&g)<<22|B>>>10,Q[E+16|0]=(3&g)<<30|B>>>2,IA=0,a=(A=nA=2097151&a)<<1,A=QA,Q[E+13|0]=a|(1048575&A)<<12|gA>>>20,A=g>>21,B=(g=(a=(2097151&g)<<11|B>>>21)+(2097151&eA)|0)>>>0<a>>>0?A+1|0:A,a=g,Q[E+20|0]=(8191&B)<<19|g>>>13,Q[E+19|0]=(31&B)<<27|g>>>5,g=(A=gA=2097151&C)<<6,A=IA,Q[E+15|0]=g|(32767&A)<<17|nA>>>15,g=B>>21,nA=C=(IA=(2097151&B)<<11|a>>>21)+(2097151&pA)|0,C=C>>>0<IA>>>0?g+1|0:g,Q[E+21|0]=nA,g=(A=a)<<3,A=QA,Q[E+18|0]=g|(262143&A)<<14|gA>>>18,A=nA,Q[E+22|0]=(255&C)<<24|A>>>8,g=C>>21,g=(A=(a=(2097151&C)<<11|A>>>21)+(2097151&cA)|0)>>>0<a>>>0?g+1|0:g,a=A,Q[E+25|0]=(2047&g)<<21|A>>>11,Q[E+24|0]=(7&g)<<29|A>>>3,A=g>>21,B=(g=(IA=(2097151&g)<<11|a>>>21)+(2097151&uA)|0)>>>0<IA>>>0?A+1|0:A,IA=g,Q[E+27|0]=(63&B)<<26|g>>>6,A=a&=2097151,Q[E+23|0]=31&((65535&C)<<16|nA>>>16)|A<<5,A=B>>21,A=(g=(B=(2097151&B)<<11|g>>>21)+(2097151&oA)|0)>>>0<B>>>0?A+1|0:A,Q[E+31|0]=(131071&A)<<15|g>>>17,Q[E+30|0]=(511&A)<<23|g>>>9,Q[E+29|0]=(1&A)<<31|g>>>1,C=0,A=(B=IA&=2097151)<<2,B=QA,Q[E+26|0]=A|(524287&B)<<13|a>>>19,A=C,Q[E+28|0]=(16383&A)<<18|IA>>>14|g<<7,Dg(d,64),Dg(r,64),I&&(i[I>>2]=64,i[I+4>>2]=0),s=R+560|0,0}function F(A,I,g,B){for(var C=0,Q=0,E=0,a=0,r=0,o=0,t=0,e=0,f=0,c=0,y=0,s=0,w=0,D=0,p=0,u=0,F=0,l=0,_=0,k=0,H=0,G=0,U=0,S=0,b=0,m=0,v=0,M=0,P=0,Y=0,N=0,R=0,d=0,J=0,x=0,L=0,K=0,X=0,T=0,V=0;a=(C=t<<3)+g|0,k=n[4+(C=I+C|0)|0]|n[C+5|0]<<8|n[C+6|0]<<16|n[C+7|0]<<24,E=(o=c=n[0|C]|n[C+1|0]<<8|n[C+2|0]<<16|n[C+3|0]<<24)<<24|o<<8&16711680,i[a>>2]=-16777216&((255&k)<<24|o>>>8)|16711680&((16777215&k)<<8|o>>>24)|k>>>8&65280|k>>>24,C=0,i[a+4>>2]=65280&(k<<24|o>>>8)|255&(k<<8|o>>>24)|E|C|C,16!=(0|(t=t+1|0)););for(I=eI(B,A,64);;){if(C=i[(B=k=(H=L<<3)+g|0)>>2],B=i[B+4>>2],a=pA(w=i[I+32>>2],e=i[I+36>>2],14),E=h,a=pA(w,e,18)^a,E^=h,a=pA(w,e,41)^a,B=(h^E)+B|0,B=(C=a+C|0)>>>0<a>>>0?B+1|0:B,Q=i[I+48>>2],C=(E=i[(a=H+34144|0)>>2])+C|0,B=i[a+4>>2]+B|0,B=C>>>0<E>>>0?B+1|0:B,a=(E=Q^((s=i[I+40>>2])^Q)&w)+C|0,C=(((D=i[I+52>>2])^(p=i[I+44>>2]))&e^D)+B|0,C=E>>>0>a>>>0?C+1|0:C,a=(E=i[I+56>>2])+a|0,B=i[I+60>>2]+C|0,B=E>>>0>a>>>0?B+1|0:B,E=a+(t=i[I+24>>2])|0,C=i[I+28>>2]+B|0,o=E,f=C=E>>>0<t>>>0?C+1|0:C,i[I+24>>2]=E,i[I+28>>2]=C,C=pA(F=i[I>>2],t=i[I+4>>2],28),c=h,C=pA(F,t,34)^C,E=h^c,c=a+(pA(F,t,39)^C)|0,C=B+(h^E)|0,C=a>>>0>c>>>0?C+1|0:C,c=(u=F&((a=i[I+16>>2])|(r=i[I+8>>2]))|a&r)+c|0,B=(B=C)+(t&((C=i[I+20>>2])|(E=i[I+12>>2]))|C&E)|0,B=c>>>0<u>>>0?B+1|0:B,u=c,c=B,i[I+56>>2]=u,i[I+60>>2]=B,B=C,C=pA(o,f,14),y=h,l=pA(o,f,18)^C,y^=h,S=a,a=(C=Q)+(Q=(s^w)&o^s)|0,C=((e^p)&f^p)+D|0,C=a>>>0<Q>>>0?C+1|0:C,Q=pA(o,f,41)^l,C=(h^y)+C|0,C=(a=Q+a|0)>>>0<Q>>>0?C+1|0:C,a=(y=i[(D=v=(Q=8|H)+g|0)>>2])+a|0,C=i[D+4>>2]+C|0,C=a>>>0<y>>>0?C+1|0:C,a=(D=i[(Q=Q+34144|0)>>2])+a|0,C=i[Q+4>>2]+C|0,C=a>>>0<D>>>0?C+1|0:C,y=a,D=B,B=C,C=D+C|0,C=(a=S+(Q=a)|0)>>>0<Q>>>0?C+1|0:C,Q=a,D=C,i[I+16>>2]=Q,i[I+20>>2]=C,C=pA(u,c,28),a=h,l=pA(u,c,34)^C,_=h^a,a=(C=y)+(y=(r|F)&u|r&F)|0,C=((E|t)&c|E&t)+B|0,C=a>>>0<y>>>0?C+1|0:C,y=pA(u,c,39)^l,B=(h^_)+C|0,B=(a=y+a|0)>>>0<y>>>0?B+1|0:B,y=a,a=B,i[I+48>>2]=y,i[I+52>>2]=B,B=pA(Q,D,14),C=h,l=pA(Q,D,18)^B,_=h^C,S=r,C=((e^f)&D^e)+p|0,C=(B=(r=(o^w)&Q^w)+s|0)>>>0<r>>>0?C+1|0:C,r=pA(Q,D,41)^l,C=(h^_)+C|0,C=(B=r+B|0)>>>0<r>>>0?C+1|0:C,r=(r=B)+(p=i[(B=M=(s=16|H)+g|0)>>2])|0,B=i[B+4>>2]+C|0,B=r>>>0<p>>>0?B+1|0:B,r=(s=i[(C=s+34144|0)>>2])+r|0,C=i[C+4>>2]+B|0,C=r>>>0<s>>>0?C+1|0:C,p=r,s=r,B=C,C=C+E|0,s=C=(r=S+r|0)>>>0<s>>>0?C+1|0:C,i[I+8>>2]=r,i[I+12>>2]=C,C=pA(y,a,28),E=h,l=pA(y,a,34)^C,E^=h,B=((t|c)&a|t&c)+B|0,B=(C=(C=p)+(p=(u|F)&y|u&F)|0)>>>0<p>>>0?B+1|0:B,p=pA(y,a,39)^l,B=(h^E)+B|0,B=(C=p+C|0)>>>0<p>>>0?B+1|0:B,p=C,E=B,i[I+40>>2]=C,i[I+44>>2]=B,B=pA(r,s,14),C=h,l=pA(r,s,18)^B,_=h^C,S=F,C=(f^(f^D)&s)+e|0,C=(B=(F=o^(Q^o)&r)+w|0)>>>0<F>>>0?C+1|0:C,e=(F=pA(r,s,41)^l)+B|0,B=(h^_)+C|0,B=e>>>0<F>>>0?B+1|0:B,e=(w=i[(C=P=(F=24|H)+g|0)>>2])+e|0,C=i[C+4>>2]+B|0,C=e>>>0<w>>>0?C+1|0:C,B=(B=e)+(F=i[(e=F+34144|0)>>2])|0,C=i[e+4>>2]+C|0,w=B,e=S+B|0,B=(C=B>>>0<F>>>0?C+1|0:C)+t|0,F=B=e>>>0<w>>>0?B+1|0:B,i[I>>2]=e,i[I+4>>2]=B,B=pA(p,E,28),t=h,l=pA(p,E,34)^B,_=h^t,C=((a|c)&E|a&c)+C|0,C=(B=(t=(y|u)&p|y&u)+w|0)>>>0<t>>>0?C+1|0:C,t=(w=pA(p,E,39)^l)+B|0,B=(h^_)+C|0,B=t>>>0<w>>>0?B+1|0:B,w=t,t=B,i[I+32>>2]=w,i[I+36>>2]=B,B=pA(e,F,14),C=h,l=pA(e,F,18)^B,_=h^C,b=u,C=f+(D^(s^D)&F)|0,C=(B=o+(Q^(Q^r)&e)|0)>>>0<o>>>0?C+1|0:C,o=pA(e,F,41)^l,C=(h^_)+C|0,C=(B=o+B|0)>>>0<o>>>0?C+1|0:C,B=(u=i[(f=S=(o=32|H)+g|0)>>2])+B|0,C=i[f+4>>2]+C|0,C=B>>>0<u>>>0?C+1|0:C,B=(f=i[(o=o+34144|0)>>2])+B|0,C=i[o+4>>2]+C|0,C=B>>>0<f>>>0?C+1|0:C,u=B,f=B,o=b+B|0,B=C,C=C+c|0,f=C=o>>>0<f>>>0?C+1|0:C,i[I+56>>2]=o,i[I+60>>2]=C,C=pA(w,t,28),c=h,l=pA(w,t,34)^C,_=h^c,c=(C=u)+(u=(y|p)&w|y&p)|0,C=((E|a)&t|E&a)+B|0,C=c>>>0<u>>>0?C+1|0:C,u=pA(w,t,39)^l,B=(h^_)+C|0,B=(c=u+c|0)>>>0<u>>>0?B+1|0:B,u=c,c=B,i[I+24>>2]=u,i[I+28>>2]=B,B=pA(o,f,14),C=h,l=pA(o,f,18)^B,_=h^C,b=y,C=D+(s^(s^F)&f)|0,C=(B=Q+(r^(r^e)&o)|0)>>>0<Q>>>0?C+1|0:C,Q=pA(o,f,41)^l,C=(h^_)+C|0,C=(B=Q+B|0)>>>0<Q>>>0?C+1|0:C,Q=(Q=B)+(y=i[(B=U=(D=40|H)+g|0)>>2])|0,B=i[B+4>>2]+C|0,B=Q>>>0<y>>>0?B+1|0:B,Q=(D=i[(C=D+34144|0)>>2])+Q|0,C=i[C+4>>2]+B|0,y=Q,B=C=Q>>>0<D>>>0?C+1|0:C,C=C+a|0,D=C=(Q=b+Q|0)>>>0<y>>>0?C+1|0:C,i[I+48>>2]=Q,i[I+52>>2]=C,C=pA(u,c,28),a=h,l=pA(u,c,34)^C,a^=h,B=((E|t)&c|E&t)+B|0,B=(C=(C=y)+(y=(p|w)&u|p&w)|0)>>>0<y>>>0?B+1|0:B,y=pA(u,c,39)^l,B=(h^a)+B|0,B=(C=y+C|0)>>>0<y>>>0?B+1|0:B,y=C,a=B,i[I+16>>2]=C,i[I+20>>2]=B,B=pA(Q,D,14),C=h,l=pA(Q,D,18)^B,_=h^C,G=p,C=s+(F^(f^F)&D)|0,C=(B=r+(e^(o^e)&Q)|0)>>>0<r>>>0?C+1|0:C,r=(s=pA(Q,D,41)^l)+B|0,B=(h^_)+C|0,B=r>>>0<s>>>0?B+1|0:B,r=(p=i[(C=b=(s=48|H)+g|0)>>2])+r|0,C=i[C+4>>2]+B|0,C=r>>>0<p>>>0?C+1|0:C,B=(B=r)+(s=i[(r=s+34144|0)>>2])|0,C=i[r+4>>2]+C|0,C=B>>>0<s>>>0?C+1|0:C,p=B,s=B,r=G+B|0,B=C+E|0,s=B=r>>>0<s>>>0?B+1|0:B,i[I+40>>2]=r,i[I+44>>2]=B,B=pA(y,a,28),E=h,l=pA(y,a,34)^B,_=h^E,C=((t|c)&a|t&c)+C|0,C=(B=(E=(u|w)&y|u&w)+p|0)>>>0<E>>>0?C+1|0:C,E=(p=pA(y,a,39)^l)+B|0,B=(h^_)+C|0,B=E>>>0<p>>>0?B+1|0:B,p=E,E=B,i[I+8>>2]=p,i[I+12>>2]=B,B=pA(r,s,14),C=h,l=pA(r,s,18)^B,_=h^C,G=w,C=F+(f^(f^D)&s)|0,C=(B=e+(o^(Q^o)&r)|0)>>>0<e>>>0?C+1|0:C,e=pA(r,s,41)^l,C=(h^_)+C|0,C=(B=e+B|0)>>>0<e>>>0?C+1|0:C,B=(w=i[(F=R=(e=56|H)+g|0)>>2])+B|0,C=i[F+4>>2]+C|0,C=B>>>0<w>>>0?C+1|0:C,B=(F=i[(e=e+34144|0)>>2])+B|0,C=i[e+4>>2]+C|0,w=B,e=G+B|0,B=C=B>>>0<F>>>0?C+1|0:C,C=C+t|0,F=C=e>>>0<w>>>0?C+1|0:C,i[I+32>>2]=e,i[I+36>>2]=C,C=pA(p,E,28),t=h,l=pA(p,E,34)^C,_=h^t,t=(C=w)+(w=(y|u)&p|y&u)|0,C=((a|c)&E|a&c)+B|0,C=t>>>0<w>>>0?C+1|0:C,w=pA(p,E,39)^l,B=(h^_)+C|0,B=(t=w+t|0)>>>0<w>>>0?B+1|0:B,w=t,t=B,i[I>>2]=w,i[I+4>>2]=B,B=pA(e,F,14),C=h,l=pA(e,F,18)^B,_=h^C,G=u,C=f+(D^(s^D)&F)|0,C=(B=o+(Q^(Q^r)&e)|0)>>>0<o>>>0?C+1|0:C,o=pA(e,F,41)^l,C=(h^_)+C|0,C=(B=o+B|0)>>>0<o>>>0?C+1|0:C,o=(o=B)+(u=i[(B=K=(f=64|H)+g|0)>>2])|0,B=i[B+4>>2]+C|0,B=o>>>0<u>>>0?B+1|0:B,o=(f=i[(C=f+34144|0)>>2])+o|0,C=i[C+4>>2]+B|0,C=o>>>0<f>>>0?C+1|0:C,f=o,B=C,C=C+c|0,u=C=(o=G+o|0)>>>0<f>>>0?C+1|0:C,i[I+24>>2]=o,i[I+28>>2]=C,C=pA(w,t,28),c=h,l=pA(w,t,34)^C,c^=h,B=((E|a)&t|E&a)+B|0,B=(C=(C=f)+(f=(y|p)&w|y&p)|0)>>>0<f>>>0?B+1|0:B,f=pA(w,t,39)^l,B=(h^c)+B|0,l=C=f+C|0,c=B=C>>>0<f>>>0?B+1|0:B,i[I+56>>2]=C,i[I+60>>2]=B,B=pA(o,u,14),C=h,f=pA(o,u,18)^B,_=h^C,C=D+(s^(s^F)&u)|0,C=(B=Q+(r^(r^e)&o)|0)>>>0<Q>>>0?C+1|0:C,Q=(f=pA(o,u,41)^f)+B|0,B=(h^_)+C|0,B=Q>>>0<f>>>0?B+1|0:B,Q=(D=i[(C=G=(f=72|H)+g|0)>>2])+Q|0,C=i[C+4>>2]+B|0,C=Q>>>0<D>>>0?C+1|0:C,B=(B=Q)+(f=i[(Q=f+34144|0)>>2])|0,C=i[Q+4>>2]+C|0,C=B>>>0<f>>>0?C+1|0:C,f=B,Q=B+y|0,B=C+a|0,y=B=Q>>>0<f>>>0?B+1|0:B,i[I+16>>2]=Q,i[I+20>>2]=B,B=pA(l,c,28),a=h,D=pA(l,c,34)^B,_=h^a,C=((E|t)&c|E&t)+C|0,C=(B=(a=(p|w)&l|p&w)+f|0)>>>0<a>>>0?C+1|0:C,a=(f=pA(l,c,39)^D)+B|0,B=(h^_)+C|0,_=a,a=B=a>>>0<f>>>0?B+1|0:B,i[I+48>>2]=_,i[I+52>>2]=B,B=pA(Q,y,14),C=h,f=pA(Q,y,18)^B,D=h^C,C=s+(F^(u^F)&y)|0,C=(B=r+(e^(o^e)&Q)|0)>>>0<r>>>0?C+1|0:C,r=pA(Q,y,41)^f,C=(h^D)+C|0,C=(B=r+B|0)>>>0<r>>>0?C+1|0:C,B=(D=i[(f=m=(r=80|H)+g|0)>>2])+B|0,C=i[f+4>>2]+C|0,C=B>>>0<D>>>0?C+1|0:C,B=(f=i[(r=r+34144|0)>>2])+B|0,C=i[r+4>>2]+C|0,C=B>>>0<f>>>0?C+1|0:C,f=B,r=B+p|0,B=C,C=C+E|0,s=C=r>>>0<f>>>0?C+1|0:C,i[I+8>>2]=r,i[I+12>>2]=C,C=pA(_,a,28),E=h,D=pA(_,a,34)^C,p=h^E,E=(C=f)+(f=(w|l)&_|w&l)|0,C=((t|c)&a|t&c)+B|0,C=E>>>0<f>>>0?C+1|0:C,f=pA(_,a,39)^D,B=(h^p)+C|0,f=B=(E=f+E|0)>>>0<f>>>0?B+1|0:B,i[I+40>>2]=E,i[I+44>>2]=B,B=pA(r,s,14),C=h,D=pA(r,s,18)^B,p=h^C,C=F+(u^(y^u)&s)|0,C=(B=e+(o^(Q^o)&r)|0)>>>0<e>>>0?C+1|0:C,e=pA(r,s,41)^D,C=(h^p)+C|0,C=(B=e+B|0)>>>0<e>>>0?C+1|0:C,e=(e=B)+(F=i[(B=N=(D=88|H)+g|0)>>2])|0,B=i[B+4>>2]+C|0,B=e>>>0<F>>>0?B+1|0:B,e=(D=i[(C=D+34144|0)>>2])+e|0,C=i[C+4>>2]+B|0,C=e>>>0<D>>>0?C+1|0:C,D=e,B=C,C=C+t|0,F=C=(e=e+w|0)>>>0<D>>>0?C+1|0:C,i[I>>2]=e,i[I+4>>2]=C,C=pA(E,f,28),t=h,p=pA(E,f,34)^C,t^=h,B=((a|c)&f|a&c)+B|0,B=(C=(C=D)+(D=(l|_)&E|l&_)|0)>>>0<D>>>0?B+1|0:B,D=pA(E,f,39)^p,B=(h^t)+B|0,t=C=D+C|0,D=B=C>>>0<D>>>0?B+1|0:B,i[I+32>>2]=C,i[I+36>>2]=B,B=pA(e,F,14),C=h,p=pA(e,F,18)^B,w=h^C,C=u+(y^(s^y)&F)|0,C=(B=o+(Q^(Q^r)&e)|0)>>>0<o>>>0?C+1|0:C,o=(u=pA(e,F,41)^p)+B|0,B=(h^w)+C|0,B=o>>>0<u>>>0?B+1|0:B,o=(p=i[(C=X=(u=96|H)+g|0)>>2])+o|0,C=i[C+4>>2]+B|0,C=o>>>0<p>>>0?C+1|0:C,B=(B=o)+(u=i[(o=u+34144|0)>>2])|0,C=i[o+4>>2]+C|0,C=B>>>0<u>>>0?C+1|0:C,u=B,o=B+l|0,B=C+c|0,p=o,o=B=o>>>0<u>>>0?B+1|0:B,i[I+56>>2]=p,i[I+60>>2]=B,B=pA(t,D,28),c=h,w=pA(t,D,34)^B,l=h^c,C=((a|f)&D|a&f)+C|0,C=(B=(c=(E|_)&t|E&_)+u|0)>>>0<c>>>0?C+1|0:C,c=(u=pA(t,D,39)^w)+B|0,B=(h^l)+C|0,B=c>>>0<u>>>0?B+1|0:B,u=c,c=B,i[I+24>>2]=u,i[I+28>>2]=B,B=pA(p,o,14),C=h,w=pA(p,o,18)^B,l=h^C,C=y+(s^(s^F)&o)|0,C=(B=Q+(r^(r^e)&p)|0)>>>0<Q>>>0?C+1|0:C,Q=pA(p,o,41)^w,C=(h^l)+C|0,C=(B=Q+B|0)>>>0<Q>>>0?C+1|0:C,B=(w=i[(y=T=(Q=104|H)+g|0)>>2])+B|0,C=i[y+4>>2]+C|0,C=B>>>0<w>>>0?C+1|0:C,B=(y=i[(Q=Q+34144|0)>>2])+B|0,C=i[Q+4>>2]+C|0,C=B>>>0<y>>>0?C+1|0:C,y=B,Q=B+_|0,B=C,C=C+a|0,w=Q,Q=C=Q>>>0<y>>>0?C+1|0:C,i[I+48>>2]=w,i[I+52>>2]=C,C=pA(u,c,28),a=h,l=pA(u,c,34)^C,_=h^a,a=(C=y)+(y=(E|t)&u|E&t)|0,C=((f|D)&c|f&D)+B|0,C=a>>>0<y>>>0?C+1|0:C,y=pA(u,c,39)^l,B=(h^_)+C|0,B=(a=y+a|0)>>>0<y>>>0?B+1|0:B,y=a,a=B,i[I+16>>2]=y,i[I+20>>2]=B,B=pA(w,Q,14),C=h,l=pA(w,Q,18)^B,_=h^C,C=s+(F^(o^F)&Q)|0,C=(B=r+(e^(e^p)&w)|0)>>>0<r>>>0?C+1|0:C,r=pA(w,Q,41)^l,C=(h^_)+C|0,C=(B=r+B|0)>>>0<r>>>0?C+1|0:C,r=(r=B)+(_=i[(B=l=(s=112|H)+g|0)>>2])|0,B=i[B+4>>2]+C|0,B=r>>>0<_>>>0?B+1|0:B,r=(s=i[(C=s+34144|0)>>2])+r|0,C=i[C+4>>2]+B|0,C=r>>>0<s>>>0?C+1|0:C,s=r,B=C,C=f+C|0,f=r=E+r|0,E=C=E>>>0>r>>>0?C+1|0:C,i[I+40>>2]=r,i[I+44>>2]=C,C=pA(y,a,28),r=h,_=pA(y,a,34)^C,r^=h,B=((c|D)&a|c&D)+B|0,B=(C=(C=s)+(s=(t|u)&y|t&u)|0)>>>0<s>>>0?B+1|0:B,s=pA(y,a,39)^_,B=(h^r)+B|0,B=(C=s+C|0)>>>0<s>>>0?B+1|0:B,s=C,r=B,i[I+8>>2]=C,i[I+12>>2]=B,B=pA(f,E,14),C=h,_=pA(f,E,18)^B,Y=h^C,C=F+(o^(Q^o)&E)|0,C=(B=e+(p^(p^w)&f)|0)>>>0<e>>>0?C+1|0:C,E=(o=pA(f,E,41)^_)+B|0,B=(h^Y)+C|0,B=E>>>0<o>>>0?B+1|0:B,E=(e=i[(C=o=(Q=120|H)+g|0)>>2])+E|0,C=i[C+4>>2]+B|0,C=E>>>0<e>>>0?C+1|0:C,B=(B=E)+(Q=i[(E=Q+34144|0)>>2])|0,C=i[E+4>>2]+C|0,C=B>>>0<Q>>>0?C+1|0:C,Q=B,E=t+B|0,B=C+D|0,i[I+32>>2]=E,i[I+36>>2]=E>>>0<t>>>0?B+1|0:B,B=pA(s,r,28),E=h,t=pA(s,r,34)^B,E^=h,C=((a|c)&r|a&c)+C|0,c=(B=(B=Q)+(Q=(y|u)&s|y&u)|0)+(a=pA(s,r,39)^t)|0,B=(h^E)+(B>>>0<Q>>>0?C+1|0:C)|0,i[I>>2]=c,i[I+4>>2]=a>>>0>c>>>0?B+1|0:B,64==(0|L)){for(;g=(B=V<<3)+A|0,B=(k=i[(C=I+B|0)>>2])+i[g>>2]|0,C=i[g+4>>2]+i[C+4>>2]|0,i[g>>2]=B,i[g+4>>2]=B>>>0<k>>>0?C+1|0:C,8!=(0|(V=V+1|0)););break}t=((L=L+16|0)<<3)+g|0,f=B=i[l+4>>2],C=B>>>6|0,B=((63&B)<<26|(Y=i[l>>2])>>>6)^pA(Y,B,19),C^=h,B=(B=pA(Y,f,61)^B)+(c=d=i[G>>2])|0,C=(w=i[G+4>>2])+(h^C)|0,C=B>>>0<c>>>0?C+1|0:C,B=(c=i[k>>2])+B|0,C=i[k+4>>2]+C|0,Q=B,B=B>>>0<c>>>0?C+1|0:C,C=(a=c=i[v+4>>2])>>>7|0,c=((127&a)<<25|(E=i[v>>2])>>>7)^pA(E,a,1),C^=h,r=Q,Q=pA(E,a,8)^c,C=(h^C)+B|0,G=c=r+Q|0,c=C=Q>>>0>c>>>0?C+1|0:C,i[t>>2]=G,i[t+4>>2]=C,B=(B=E)+(E=J=i[m>>2])|0,C=(l=i[m+4>>2])+a|0,C=B>>>0<E>>>0?C+1|0:C,E=B,B=C,D=a=i[o+4>>2],C=a>>>6|0,a=((63&a)<<26|(m=i[o>>2])>>>6)^pA(m,a,19),t=h^C,a=pA(m,D,61)^a,B=(h^t)+B|0,o=C=a+E|0,C=C>>>0<a>>>0?B+1|0:B,B=(E=a=i[M+4>>2])>>>7|0,a=((127&E)<<25|(t=i[M>>2])>>>7)^pA(t,E,1),Q=h^B,a=pA(t,E,8)^a,C=(h^Q)+C|0,p=B=a+o|0,a=C=B>>>0<a>>>0?C+1|0:C,i[k+136>>2]=B,i[k+140>>2]=C,B=(_=i[N+4>>2])+E|0,E=C=(C=t)+(t=x=i[N>>2])|0,C=C>>>0<t>>>0?B+1|0:B,B=pA(G,c,19),t=h,o=pA(G,c,61)^((63&c)<<26|G>>>6)^B,C=(h^c>>>6^t)+C|0,Q=E=o+E|0,B=E>>>0<o>>>0?C+1|0:C,t=E=i[P+4>>2],C=E>>>7|0,E=((127&E)<<25|(o=i[P>>2])>>>7)^pA(o,E,1),C^=h,r=Q,Q=pA(o,t,8)^E,C=(h^C)+B|0,s=E=r+Q|0,E=C=E>>>0<Q>>>0?C+1|0:C,i[k+144>>2]=s,i[k+148>>2]=C,B=(v=i[X+4>>2])+t|0,t=C=(C=o)+(o=N=i[X>>2])|0,C=C>>>0<o>>>0?B+1|0:B,B=pA(p,a,19),o=h,Q=pA(p,a,61)^((63&a)<<26|p>>>6)^B,C=(h^a>>>6^o)+C|0,B=Q>>>0>(r=t=Q+t|0)>>>0?C+1|0:C,C=(o=t=i[S+4>>2])>>>7|0,t=((127&o)<<25|(Q=i[S>>2])>>>7)^pA(Q,o,1),C^=h,y=r,r=pA(Q,o,8)^t,C=(h^C)+B|0,F=t=y+r|0,t=C=t>>>0<r>>>0?C+1|0:C,i[k+152>>2]=F,i[k+156>>2]=C,B=(P=i[T+4>>2])+o|0,o=C=(C=Q)+(Q=M=i[T>>2])|0,C=C>>>0<Q>>>0?B+1|0:B,B=pA(s,E,19),Q=h,r=pA(s,E,61)^((63&E)<<26|s>>>6)^B,B=(h^E>>>6^Q)+C|0,e=o=r+o|0,C=o>>>0<r>>>0?B+1|0:B,r=o=i[U+4>>2],B=o>>>7|0,o=((127&o)<<25|(Q=i[U>>2])>>>7)^pA(Q,o,1),u=h^B,o=pA(Q,r,8)^o,C=(h^u)+C|0,u=B=o+e|0,o=C=B>>>0<o>>>0?C+1|0:C,i[k+160>>2]=B,i[k+164>>2]=C,B=r+f|0,B=(C=Q+Y|0)>>>0<Q>>>0?B+1|0:B,Q=C,C=B,B=pA(F,t,19),r=h,e=pA(F,t,61)^((63&t)<<26|F>>>6)^B,C=(h^t>>>6^r)+C|0,C=(Q=e+Q|0)>>>0<e>>>0?C+1|0:C,e=Q,Q=C,C=(r=i[b+4>>2])>>>7|0,y=((127&r)<<25|(B=i[b>>2])>>>7)^pA(B,r,1),C^=h,y=pA(B,r,8)^y,C=(h^C)+Q|0,C=(e=y+e|0)>>>0<y>>>0?C+1|0:C,y=e,Q=C,i[k+168>>2]=e,i[k+172>>2]=C,C=B,B=r+D|0,C=C>>>0>(r=e=C+m|0)>>>0?B+1|0:B,B=pA(u,o,19),e=h,H=pA(u,o,61)^((63&o)<<26|u>>>6)^B,C=(h^o>>>6^e)+C|0,S=r=H+r|0,B=r>>>0<H>>>0?C+1|0:C,H=r=i[R+4>>2],C=r>>>7|0,r=((127&r)<<25|(e=i[R>>2])>>>7)^pA(e,r,1),U=h^C,r=pA(e,H,8)^r,B=(h^U)+B|0,S=C=r+S|0,r=B=C>>>0<r>>>0?B+1|0:B,i[k+176>>2]=C,i[k+180>>2]=B,B=c+H|0,B=(C=e+G|0)>>>0<e>>>0?B+1|0:B,e=C,C=B,B=pA(y,Q,19),H=h,U=pA(y,Q,61)^((63&Q)<<26|y>>>6)^B,C=(h^Q>>>6^H)+C|0,b=e=U+e|0,e=e>>>0<U>>>0?C+1|0:C,U=H=i[K+4>>2],C=H>>>7|0,H=((127&H)<<25|(B=i[K>>2])>>>7)^pA(B,H,1),C^=h,R=b,b=pA(B,U,8)^H,C=(h^C)+e|0,e=C=(H=R+b|0)>>>0<b>>>0?C+1|0:C,i[k+184>>2]=H,i[k+188>>2]=C,C=B,B=a+U|0,C=C>>>0>(a=p=C+p|0)>>>0?B+1|0:B,B=pA(S,r,19),p=h,U=pA(S,r,61)^((63&r)<<26|S>>>6)^B,B=(h^r>>>6^p)+C|0,C=B=(a=U+a|0)>>>0<U>>>0?B+1|0:B,B=pA(d,w,1),p=h,U=pA(d,w,8)^((127&w)<<25|d>>>7)^B,C=(h^w>>>7^p)+C|0,p=a=U+a|0,a=C=a>>>0<U>>>0?C+1|0:C,i[k+192>>2]=p,i[k+196>>2]=C,B=E+w|0,E=C=s+d|0,C=B=C>>>0<s>>>0?B+1|0:B,B=pA(H,e,19),s=h,w=pA(H,e,61)^((63&e)<<26|H>>>6)^B,B=(h^e>>>6^s)+C|0,C=B=(E=w+E|0)>>>0<w>>>0?B+1|0:B,B=pA(J,l,1),s=h,w=pA(J,l,8)^((127&l)<<25|J>>>7)^B,C=(h^l>>>7^s)+C|0,s=E=w+E|0,E=C=E>>>0<w>>>0?C+1|0:C,i[k+200>>2]=s,i[k+204>>2]=C,B=t+l|0,t=C=F+J|0,C=B=C>>>0<F>>>0?B+1|0:B,B=pA(p,a,19),F=h,w=pA(p,a,61)^((63&a)<<26|p>>>6)^B,B=(h^a>>>6^F)+C|0,C=B=(t=w+t|0)>>>0<w>>>0?B+1|0:B,B=pA(x,_,1),F=h,w=pA(x,_,8)^((127&_)<<25|x>>>7)^B,C=(h^_>>>7^F)+C|0,F=t=w+t|0,t=C=t>>>0<w>>>0?C+1|0:C,i[k+208>>2]=F,i[k+212>>2]=C,B=o+_|0,o=C=u+x|0,C=B=C>>>0<u>>>0?B+1|0:B,B=pA(s,E,19),u=h,w=o,o=B,B=E>>>6|0,o=pA(s,E,61)^o^((63&E)<<26|s>>>6),B=(h^B^u)+C|0,C=B=(E=w+o|0)>>>0<o>>>0?B+1|0:B,B=pA(N,v,1),o=h,s=pA(N,v,8)^((127&v)<<25|N>>>7)^B,C=(h^v>>>7^o)+C|0,o=E=s+E|0,E=C=E>>>0<s>>>0?C+1|0:C,i[k+216>>2]=o,i[k+220>>2]=C,B=Q+v|0,Q=C=y+N|0,C=B=C>>>0<y>>>0?B+1|0:B,B=pA(F,t,19),s=h,y=Q,Q=B,B=t>>>6|0,Q=pA(F,t,61)^Q^((63&t)<<26|F>>>6),B=(h^B^s)+C|0,C=B=Q>>>0>(t=y+Q|0)>>>0?B+1|0:B,B=pA(M,P,1),Q=h,s=pA(M,P,8)^((127&P)<<25|M>>>7)^B,C=(h^P>>>7^Q)+C|0,t=C=(Q=t=s+t|0)>>>0<s>>>0?C+1|0:C,i[k+224>>2]=Q,i[k+228>>2]=C,B=r+P|0,r=C=S+M|0,C=B=C>>>0<M>>>0?B+1|0:B,B=pA(o,E,19),s=h,y=B,B=E>>>6|0,o=pA(o,E,61)^y^((63&E)<<26|o>>>6),B=(h^B^s)+C|0,C=B=(E=o+r|0)>>>0<o>>>0?B+1|0:B,B=pA(Y,f,1),o=h,r=pA(Y,f,8)^((127&f)<<25|Y>>>7)^B,C=(h^f>>>7^o)+C|0,o=E=r+E|0,E=C=E>>>0<r>>>0?C+1|0:C,i[k+232>>2]=o,i[k+236>>2]=C,B=e+f|0,r=C=H+Y|0,C=B=C>>>0<H>>>0?B+1|0:B,B=pA(Q,t,19),e=h,f=B,B=t>>>6|0,Q=pA(Q,t,61)^f^((63&t)<<26|Q>>>6),B=(h^B^e)+C|0,B=Q>>>0>(t=Q+r|0)>>>0?B+1|0:B,Q=t,C=B,B=pA(m,D,1),r=h,Q=(e=pA(m,D,8)^((127&D)<<25|m>>>7)^B)+Q|0,C=(h^D>>>7^r)+C|0,i[(t=k)+240>>2]=Q,i[t+244>>2]=Q>>>0<e>>>0?C+1|0:C,B=a+D|0,a=C=p+m|0,C=B=C>>>0<p>>>0?B+1|0:B,B=pA(o,E,19),t=h,Q=B,B=E>>>6|0,E=pA(o,E,61)^Q^((63&E)<<26|o>>>6),B=(h^B^t)+C|0,C=B=E>>>0>(a=E+a|0)>>>0?B+1|0:B,B=pA(G,c,1),E=h,t=B,B=c>>>7|0,c=(Q=a)+(a=pA(G,c,8)^t^((127&c)<<25|G>>>7))|0,C=(h^B^E)+C|0,i[k+248>>2]=c,i[k+252>>2]=a>>>0>c>>>0?C+1|0:C}}function l(A){var I,g,B,C,E,i,a,r,o,t,e,f,c,y,s,w,D,p=0,u=0,F=0,l=0,_=0,k=0,H=0,G=0,U=0,S=0,b=0,m=0,v=0,M=0,P=0,Y=0,N=0,R=0,d=0,J=0,x=0,L=0,K=0,X=0,T=0,V=0,q=0,z=0,j=0,W=0,O=0,Z=0,$=0,AA=0,IA=0,gA=0,BA=0,CA=0,QA=0,EA=0;f=uI(A),gA=n[A+2|0]|n[A+3|0]<<8|n[A+4|0]<<16|n[A+5|0]<<24,c=uI(A+5|0),z=h,BA=n[A+7|0]|n[A+8|0]<<8|n[A+9|0]<<16|n[A+10|0]<<24,Z=n[A+10|0]|n[A+11|0]<<8|n[A+12|0]<<16|n[A+13|0]<<24,y=uI(A+13|0),O=h,L=n[A+15|0]|n[A+16|0]<<8|n[A+17|0]<<16|n[A+18|0]<<24,j=uI(A+18|0),M=h,G=uI(A+21|0),k=n[A+23|0]|n[A+24|0]<<8|n[A+25|0]<<16|n[A+26|0]<<24,F=uI(A+26|0),p=h,K=n[A+28|0]|n[A+29|0]<<8|n[A+30|0]<<16|n[A+31|0]<<24,$=n[A+31|0]|n[A+32|0]<<8|n[A+33|0]<<16|n[A+34|0]<<24,s=uI(A+34|0),q=h,X=n[A+36|0]|n[A+37|0]<<8|n[A+38|0]<<16|n[A+39|0]<<24,W=uI(A+39|0),Y=h,H=uI(A+42|0),l=n[A+44|0]|n[A+45|0]<<8|n[A+46|0]<<16|n[A+47|0]<<24,_=uI(A+47|0),F=2097151&((3&p)<<30|F>>>2),p=qA(I=2097151&((3&(u=h))<<30|_>>>2),0,136657,0)+F|0,u=h,u=p>>>0<F>>>0?u+1|0:u,F=(_=qA(g=(n[A+49|0]|n[A+50|0]<<8|n[A+51|0]<<16|n[A+52|0]<<24)>>>7&2097151,0,-997805,-1))+p|0,p=h+u|0,p=F>>>0<_>>>0?p+1|0:p,u=(_=qA(B=(n[A+52|0]|n[A+53|0]<<8|n[A+54|0]<<16|n[A+55|0]<<24)>>>4&2097151,0,654183,0))+F|0,F=h+p|0,F=u>>>0<_>>>0?F+1|0:F,m=u,u=uI(A+55|0),_=qA(C=2097151&((1&(p=h))<<31|u>>>1),0,470296,0),p=h+F|0,p=(u=m+_|0)>>>0<_>>>0?p+1|0:p,F=(_=qA(E=(n[A+57|0]|n[A+58|0]<<8|n[A+59|0]<<16|n[A+60|0]<<24)>>>6&2097151,0,666643,0))+u|0,u=h+p|0,u=F>>>0<_>>>0?u+1|0:u,_=F,U=u,F=u,b=l>>>5&2097151,l=2097151&H,u=qA(i=(n[A+60|0]|n[A+61|0]<<8|n[A+62|0]<<16|n[A+63|0]<<24)>>>3|0,0,-683901,-1)+l|0,p=h,p=u>>>0<l>>>0?p+1|0:p,l=u,d=p,T=u=p-((u>>>0<4293918720)-1|0)|0,p=b,b=(2097151&u)<<11|(m=l- -1048576|0)>>>21,u>>=21,r=H=p+b|0,S=u=H>>>0<b>>>0?u+1|0:u,H=qA(H,u,-683901,-1),u=h+F|0,J=p=H+_|0,b=p>>>0<H>>>0?u+1|0:u,u=qA(I,x,-997805,-1),p=h,p=(u=(F=k>>>5&2097151)+u|0)>>>0<F>>>0?p+1|0:p,k=qA(g,0,654183,0),F=h+p|0,F=(u=k+u|0)>>>0<k>>>0?F+1|0:F,p=(k=qA(B,0,470296,0))+u|0,u=h+F|0,u=p>>>0<k>>>0?u+1|0:u,F=(k=qA(C,P,666643,0))+p|0,p=h+u|0,H=F,F=F>>>0<k>>>0?p+1|0:p,k=2097151&G,p=qA(I,x,654183,0)+k|0,u=h,u=p>>>0<k>>>0?u+1|0:u,k=(G=qA(g,0,470296,0))+p|0,p=h+u|0,p=k>>>0<G>>>0?p+1|0:p,G=qA(B,0,666643,0),u=h+p|0,G=u=(k=G+k|0)>>>0<G>>>0?u+1|0:u,V=u=u-((k>>>0<4293918720)-1|0)|0,F=(p=u>>>21|0)+F|0,F=(u=(N=H)+(H=(2097151&u)<<11|(v=k- -1048576|0)>>>21)|0)>>>0<H>>>0?F+1|0:F,H=u,N=F,R=u=F-((u>>>0<4293918720)-1|0)|0,U=U-((_>>>0<4293918720)-1|0)|0,t=_- -1048576|0,p=J,J=(2097151&u)<<11|(F=H- -1048576|0)>>>21,u=(u>>21)+b|0,u=((p=_=p+J|0)>>>0<J>>>0?u+1|0:u)-(((_=-2097152&t)>>>0>p>>>0)+U|0)|0,CA=(p=p-_|0)-(_=-2097152&(e=p- -1048576|0))|0,QA=u-((b=u-((p>>>0<4293918720)-1|0)|0)+(p>>>0<_>>>0)|0)|0,u=qA(r,S,136657,0)+H|0,p=N+h|0,J=u-(F&=-2097152)|0,R=(p=u>>>0<H>>>0?p+1|0:p)-((u>>>0<F>>>0)+R|0)|0,m=l-(p=-2097152&m)|0,AA=d-((p>>>0>l>>>0)+T|0)|0,F=2097151&((7&(p=Y))<<29|W>>>3),p=qA(i,0,136657,0)+F|0,u=h,u=p>>>0<F>>>0?u+1|0:u,F=(_=qA(E,0,-683901,-1))+p|0,p=h+u|0,H=F,l=F>>>0<_>>>0?p+1|0:p,p=qA(C,P,-683901,-1),u=h,u=(p=(F=X>>>6&2097151)+p|0)>>>0<F>>>0?u+1|0:u,_=qA(i,0,-997805,-1),F=h+u|0,F=(p=_+p|0)>>>0<_>>>0?F+1|0:F,u=(_=qA(E,0,136657,0))+p|0,p=h+F|0,p=u>>>0<_>>>0?p+1|0:p,_=u,d=p,T=p=p-((u>>>0<4293918720)-1|0)|0,X=u- -1048576|0,u=(F=p>>21)+l|0,l=p=(Y=H)+(H=(2097151&p)<<11|X>>>21)|0,Y=u=p>>>0<H>>>0?u+1|0:u,N=p=u-((p>>>0<4293918720)-1|0)|0,u=m,m=(2097151&p)<<11|(H=l- -1048576|0)>>>21,p=(p>>21)+AA|0,o=u=u+m|0,m=p=u>>>0<m>>>0?p+1|0:p,F=qA(u,p,-683901,-1),p=h+R|0,EA=u=F+J|0,R=u>>>0<F>>>0?p+1|0:p,W=k,J=G,F=2097151&((7&(p=M))<<29|j>>>3),p=qA(I,x,470296,0)+F|0,u=h,u=p>>>0<F>>>0?u+1|0:u,F=qA(g,0,666643,0),u=h+u|0,G=p=F+p|0,F=p>>>0<F>>>0?u+1|0:u,u=qA(I,x,666643,0),p=h,p=(u=(k=L>>>6&2097151)+u|0)>>>0<k>>>0?p+1|0:p,k=u,j=p,AA=p=p-((u>>>0<4293918720)-1|0)|0,u=(u=p>>>21|0)+F|0,F=p=(M=G)+(G=(2097151&p)<<11|(L=k- -1048576|0)>>>21)|0,IA=u=p>>>0<G>>>0?u+1|0:u,w=p=u-((p>>>0<4293918720)-1|0)|0,G=Y-(((u=-2097152&H)>>>0>l>>>0)+N|0)|0,a=l-u|0,H=(2097151&p)<<11|(M=F- -1048576|0)>>>21,p=(p>>>21|0)+J|0,p=(l=H+W|0)>>>0<H>>>0?p+1|0:p,l=((u=l)-(H=-2097152&v)|0)+(v=qA(r,S,-997805,-1))|0,u=h+(p-((8191&V)+(u>>>0<H>>>0)|0)|0)|0,u=l>>>0<v>>>0?u+1|0:u,p=l,l=qA(o,m,136657,0),u=h+u|0,u=(p=p+l|0)>>>0<l>>>0?u+1|0:u,l=(H=qA(a,G,-683901,-1))+p|0,p=h+u|0,V=p=l>>>0<H>>>0?p+1|0:p,N=u=p-((l>>>0<4293918720)-1|0)|0,Y=(2097151&u)<<11|(v=l- -1048576|0)>>>21,u=(u>>21)+R|0,R=u=(H=Y+EA|0)>>>0<Y>>>0?u+1|0:u,p=(p=(u=u-((H>>>0<4293918720)-1|0)|0)>>21)+QA|0,p=(J=(2097151&u)<<11|(Y=H- -1048576|0)>>>21)>>>0>(W=J+CA|0)>>>0?p+1|0:p,J=W,W=p,CA=H-(p=-2097152&Y)|0,QA=R-((p>>>0>H>>>0)+u|0)|0,EA=l-(p=-2097152&v)|0,D=V-((p>>>0>l>>>0)+N|0)|0,p=(l=qA(r,S,654183,0))+(F-(u=-2097152&M)|0)|0,F=h+(IA-((8191&w)+(u>>>0>F>>>0)|0)|0)|0,F=p>>>0<l>>>0?F+1|0:F,u=(l=qA(o,m,-997805,-1))+p|0,p=h+F|0,p=u>>>0<l>>>0?p+1|0:p,F=(l=qA(a,G,136657,0))+u|0,u=h+p|0,V=F,M=F>>>0<l>>>0?u+1|0:u,H=_-(p=-2097152&X)|0,T=d-((p>>>0>_>>>0)+T|0)|0,_=2097151&((1&(p=q))<<31|s>>>1),u=qA(B,0,-683901,-1)+_|0,p=h,p=u>>>0<_>>>0?p+1|0:p,F=qA(C,P,136657,0),p=h+p|0,p=(u=F+u|0)>>>0<F>>>0?p+1|0:p,F=(_=qA(i,0,654183,0))+u|0,u=h+p|0,u=F>>>0<_>>>0?u+1|0:u,p=F,F=qA(E,0,-997805,-1),u=h+u|0,v=p=p+F|0,l=p>>>0<F>>>0?u+1|0:u,p=qA(g,0,-683901,-1),F=h,F=(p=(u=$>>>4&2097151)+p|0)>>>0<u>>>0?F+1|0:F,u=(_=qA(B,0,136657,0))+p|0,p=h+F|0,p=u>>>0<_>>>0?p+1|0:p,F=(_=qA(C,P,-997805,-1))+u|0,u=h+p|0,u=F>>>0<_>>>0?u+1|0:u,_=qA(i,0,470296,0),p=h+u|0,p=(F=_+F|0)>>>0<_>>>0?p+1|0:p,_=qA(E,0,654183,0),u=h+p|0,u=(F=_+F|0)>>>0<_>>>0?u+1|0:u,_=F,Y=u,$=u=u-((F>>>0<4293918720)-1|0)|0,p=(p=u>>21)+l|0,l=u=(F=(2097151&u)<<11|(X=F- -1048576|0)>>>21)+v|0,q=p=u>>>0<F>>>0?p+1|0:p,d=u=p-((u>>>0<4293918720)-1|0)|0,p=H,H=(2097151&u)<<11|(v=l- -1048576|0)>>>21,u=(u>>21)+T|0,N=F=p+H|0,H=u=F>>>0<H>>>0?u+1|0:u,u=qA(F,u,-683901,-1),F=h+M|0,T=p=u+V|0,M=p>>>0<u>>>0?F+1|0:F,v=q-(((p=-2097152&v)>>>0>l>>>0)+d|0)|0,R=l-p|0,p=(F=qA(r,S,470296,0))+(k-(u=-2097152&L)|0)|0,u=h+(j-((2047&AA)+(u>>>0>k>>>0)|0)|0)|0,u=p>>>0<F>>>0?u+1|0:u,F=qA(o,m,654183,0),u=h+u|0,u=(p=F+p|0)>>>0<F>>>0?u+1|0:u,l=qA(a,G,-997805,-1),F=h+u|0,F=(p=l+p|0)>>>0<l>>>0?F+1|0:F,u=(l=qA(N,H,136657,0))+p|0,p=h+F|0,p=u>>>0<l>>>0?p+1|0:p,F=(l=qA(R,v,-683901,-1))+u|0,u=h+p|0,q=u=F>>>0<l>>>0?u+1|0:u,d=u=u-((F>>>0<4293918720)-1|0)|0,p=(p=u>>21)+M|0,p=(u=(l=(2097151&u)<<11|(k=F- -1048576|0)>>>21)+T|0)>>>0<l>>>0?p+1|0:p,l=u,M=p,T=u=p-((u>>>0<4293918720)-1|0)|0,j=(2097151&u)<<11|(L=l- -1048576|0)>>>21,u=(u>>21)+D|0,u=(V=j+EA|0)>>>0<j>>>0?u+1|0:u,j=V,V=u,AA=l-(p=-2097152&L)|0,T=M-((p>>>0>l>>>0)+T|0)|0,IA=F-(p=-2097152&k)|0,q=q-((p>>>0>F>>>0)+d|0)|0,l=2097151&((1&(p=O))<<31|y>>>1),u=qA(r,S,666643,0)+l|0,p=h,p=u>>>0<l>>>0?p+1|0:p,F=(l=qA(o,m,470296,0))+u|0,u=h+p|0,u=F>>>0<l>>>0?u+1|0:u,l=qA(a,G,654183,0),p=h+u|0,p=(F=l+F|0)>>>0<l>>>0?p+1|0:p,u=(l=qA(N,H,-997805,-1))+F|0,F=h+p|0,F=u>>>0<l>>>0?F+1|0:F,p=(l=qA(R,v,136657,0))+u|0,u=h+F|0,k=p,l=p>>>0<l>>>0?u+1|0:u,S=_-(p=-2097152&X)|0,M=Y-((p>>>0>_>>>0)+$|0)|0,p=qA(I,x,-683901,-1),u=h,u=(p=(F=K>>>7&2097151)+p|0)>>>0<F>>>0?u+1|0:u,_=qA(g,0,136657,0),F=h+u|0,F=(p=_+p|0)>>>0<_>>>0?F+1|0:F,u=(_=qA(B,0,-997805,-1))+p|0,p=h+F|0,p=u>>>0<_>>>0?p+1|0:p,F=(_=qA(C,P,654183,0))+u|0,u=h+p|0,u=F>>>0<_>>>0?u+1|0:u,_=qA(i,0,666643,0),p=h+u|0,p=(F=_+F|0)>>>0<_>>>0?p+1|0:p,_=qA(E,0,470296,0),u=h+p|0,p=u=(F=_+F|0)>>>0<_>>>0?u+1|0:u,u=U>>21,_=(U=(2097151&U)<<11|t>>>21)+F|0,F=p+u|0,X=F=_>>>0<U>>>0?F+1|0:F,L=p=F-((_>>>0<4293918720)-1|0)|0,U=(2097151&p)<<11|(x=_- -1048576|0)>>>21,p=(p>>21)+M|0,O=F=U+S|0,U=p=F>>>0<U>>>0?p+1|0:p,F=qA(F,p,-683901,-1),u=h+l|0,k=p=F+k|0,l=p>>>0<F>>>0?u+1|0:u,p=qA(o,m,666643,0),F=h,F=(p=(u=Z>>>4&2097151)+p|0)>>>0<u>>>0?F+1|0:F,u=(P=qA(a,G,470296,0))+p|0,p=h+F|0,p=u>>>0<P>>>0?p+1|0:p,F=(P=qA(N,H,654183,0))+u|0,u=h+p|0,u=F>>>0<P>>>0?u+1|0:u,p=F,F=qA(R,v,-997805,-1),u=h+u|0,u=(p=p+F|0)>>>0<F>>>0?u+1|0:u,F=(P=qA(O,U,136657,0))+p|0,p=h+u|0,m=p=F>>>0<P>>>0?p+1|0:p,M=p=p-((F>>>0<4293918720)-1|0)|0,S=(2097151&p)<<11|(P=F- -1048576|0)>>>21,p=(p>>21)+l|0,k=p=(l=k=S+k|0)>>>0<S>>>0?p+1|0:p,Y=p=p-((l>>>0<4293918720)-1|0)|0,K=(2097151&p)<<11|(S=l- -1048576|0)>>>21,p=(p>>21)+q|0,$=Z=K+IA|0,Z=K>>>0>Z>>>0?p+1|0:p,u=_-(p=-2097152&x)|0,_=X-((p>>>0>_>>>0)+L|0)|0,p=(p=b>>21)+_|0,_=u=(b=(2097151&b)<<11|e>>>21)+u|0,X=p=u>>>0<b>>>0?p+1|0:p,L=u=p-((u>>>0<4293918720)-1|0)|0,b=p=u>>21,d=l,l=qA(K=(2097151&u)<<11|(x=_- -1048576|0)>>>21,p,-683901,-1),u=h+k|0,u=(p=d+l|0)>>>0<l>>>0?u+1|0:u,q=p-(l=-2097152&S)|0,Y=u-((p>>>0<l>>>0)+Y|0)|0,u=qA(K,b,136657,0)+F|0,p=m+h|0,p=u>>>0<F>>>0?p+1|0:p,d=u-(F=-2097152&P)|0,IA=p-((u>>>0<F>>>0)+M|0)|0,p=qA(a,G,666643,0),u=h,u=(p=(F=BA>>>7&2097151)+p|0)>>>0<F>>>0?u+1|0:u,l=qA(N,H,470296,0),F=h+u|0,F=(p=l+p|0)>>>0<l>>>0?F+1|0:F,u=(l=qA(R,v,654183,0))+p|0,p=h+F|0,p=u>>>0<l>>>0?p+1|0:p,F=qA(O,U,-997805,-1),p=h+p|0,S=u=F+u|0,F=u>>>0<F>>>0?p+1|0:p,l=2097151&((3&(p=z))<<30|c>>>2),p=qA(N,H,666643,0)+l|0,u=h,u=p>>>0<l>>>0?u+1|0:u,l=qA(R,v,470296,0),u=h+u|0,u=(p=l+p|0)>>>0<l>>>0?u+1|0:u,l=(k=qA(O,U,654183,0))+p|0,p=h+u|0,G=p=l>>>0<k>>>0?p+1|0:p,P=p=p-((l>>>0<4293918720)-1|0)|0,u=S,S=(2097151&p)<<11|(k=l- -1048576|0)>>>21,p=(p>>21)+F|0,S=p=(F=H=u+S|0)>>>0<S>>>0?p+1|0:p,m=p=p-((F>>>0<4293918720)-1|0)|0,z=(2097151&p)<<11|(H=F- -1048576|0)>>>21,p=(p>>21)+IA|0,p=(M=z+d|0)>>>0<z>>>0?p+1|0:p,z=M,M=p,p=(u=qA(K,b,-997805,-1))+F|0,F=h+S|0,F=p>>>0<u>>>0?F+1|0:F,BA=p-(u=-2097152&H)|0,d=F-((p>>>0<u>>>0)+m|0)|0,p=qA(K,b,654183,0)+l|0,u=G+h|0,m=p-(F=-2097152&k)|0,N=(u=p>>>0<l>>>0?u+1|0:u)-((p>>>0<F>>>0)+P|0)|0,p=qA(R,v,666643,0),F=h,F=(p=(u=gA>>>5&2097151)+p|0)>>>0<u>>>0?F+1|0:F,u=(l=qA(O,U,470296,0))+p|0,p=h+F|0,k=u,F=u>>>0<l>>>0?p+1|0:p,l=2097151&f,u=qA(O,U,666643,0)+l|0,p=h,p=u>>>0<l>>>0?p+1|0:p,l=u,G=p,U=p=p-((u>>>0<4293918720)-1|0)|0,F=(u=p>>21)+F|0,F=(p=(S=k)+(k=(2097151&p)<<11|(H=l- -1048576|0)>>>21)|0)>>>0<k>>>0?F+1|0:F,k=p,P=F,S=p=F-((p>>>0<4293918720)-1|0)|0,v=(2097151&p)<<11|(F=k- -1048576|0)>>>21,p=(p>>21)+N|0,p=(m=v+m|0)>>>0<v>>>0?p+1|0:p,v=m,m=p,p=qA(K,b,470296,0)+k|0,u=P+h|0,u=p>>>0<k>>>0?u+1|0:u,k=p-(F&=-2097152)|0,F=u-((p>>>0<F>>>0)+S|0)|0,S=k,u=(k=qA(K,b,666643,0))+(l-(p=-2097152&H)|0)|0,p=h+(G-((p>>>0>l>>>0)+U|0)|0)|0,p=u>>>0<k>>>0?p+1|0:p,k=u,l=u,u=(u=p>>21)+F|0,H=p=S+(l=(2097151&p)<<11|l>>>21)|0,l=(2097151&(u=p>>>0<l>>>0?u+1|0:u))<<11|(F=p)>>>21,F=(p=u>>21)+m|0,G=u=l+v|0,l=(2097151&(F=(p=u)>>>0<l>>>0?F+1|0:F))<<11|p>>>21,p=(u=F>>21)+d|0,P=F=l+BA|0,l=(2097151&(p=(u=F)>>>0<l>>>0?p+1|0:p))<<11|u>>>21,u=(F=p>>21)+M|0,S=p=l+z|0,F=p,p=(p=(u=p>>>0<l>>>0?u+1|0:u)>>21)+Y|0,p=(u=(F=(2097151&u)<<11|F>>>21)+q|0)>>>0<F>>>0?p+1|0:p,m=u,F=u,u=(u=p>>21)+Z|0,v=p=(F=(2097151&p)<<11|F>>>21)+$|0,l=(2097151&(u=p>>>0<F>>>0?u+1|0:u))<<11|(F=p)>>>21,F=(p=u>>21)+T|0,M=u=l+AA|0,l=(2097151&(F=(p=u)>>>0<l>>>0?F+1|0:F))<<11|p>>>21,p=(u=F>>21)+V|0,Y=F=l+j|0,l=(2097151&(p=(u=F)>>>0<l>>>0?p+1|0:p))<<11|u>>>21,u=(F=p>>21)+QA|0,gA=p=l+CA|0,F=p,p=(p=(u=p>>>0<l>>>0?u+1|0:u)>>21)+W|0,p=(u=(F=(2097151&u)<<11|F>>>21)+J|0)>>>0<F>>>0?p+1|0:p,z=u,F=u,u=p>>21,p=(2097151&p)<<11|F>>>21,l=_-(F=-2097152&x)|0,F=(X-((F>>>0>_>>>0)+L|0)|0)+u|0,x=p=p+l|0,b=(2097151&(F=p>>>0<l>>>0?F+1|0:F))<<11|p>>>21,l=p=F>>21,F=2097151&k,u=qA(b,p,666643,0)+F|0,p=h,k=u,_=p=u>>>0<F>>>0?p+1|0:p,Q[0|A]=u,Q[A+1|0]=(255&p)<<24|u>>>8,F=2097151&H,p=qA(b,l,470296,0)+F|0,u=h,F=(_>>21)+(u=p>>>0<F>>>0?u+1|0:u)|0,F=(H=(U=(2097151&_)<<11|k>>>21)+p|0)>>>0<U>>>0?F+1|0:F,Q[A+4|0]=(2047&F)<<21|H>>>11,Q[A+3|0]=(7&F)<<29|H>>>3,G&=2097151,u=qA(b,l,654183,0)+G|0,p=h,p=u>>>0<G>>>0?p+1|0:p,G=u,u=p,u=(p=F>>21)+u|0,u=(F=(U=G)+(G=(2097151&F)<<11|H>>>21)|0)>>>0<G>>>0?u+1|0:u,G=F,p=u,Q[A+6|0]=(63&p)<<26|F>>>6,U=0,F=31&((65535&_)<<16|k>>>16),u=k=2097151&H,Q[A+2|0]=F|u<<5,_=2097151&P,F=qA(b,l,-997805,-1)+_|0,u=h,u=F>>>0<_>>>0?u+1|0:u,_=F,F=u,F=(u=p>>21)+F|0,u=p=(H=_)+(_=(2097151&p)<<11|G>>>21)|0,F=p>>>0<_>>>0?F+1|0:F,Q[A+9|0]=(511&F)<<23|p>>>9,Q[A+8|0]=(1&F)<<31|p>>>1,_=0,H=(p=G&=2097151)<<2,p=U,Q[A+5|0]=H|(524287&p)<<13|k>>>19,H=2097151&S,k=qA(b,l,136657,0)+H|0,p=h,p=k>>>0<H>>>0?p+1|0:p,H=k,k=p,U=(2097151&(p=F))<<11|u>>>21,p=(F=p>>21)+k|0,p=(F=H=U+H|0)>>>0<U>>>0?p+1|0:p,Q[A+12|0]=(4095&p)<<20|F>>>12,Q[A+11|0]=(15&p)<<28|F>>>4,k=0,S=(u=H=2097151&u)<<7,u=_,_=G,Q[A+7|0]=S|(16383&u)<<18|_>>>14,_=(u=qA(b,l,-683901,-1))+(l=2097151&m)|0,u=h,u=l>>>0>_>>>0?u+1|0:u,l=_,_=u,G=(2097151&(u=p))<<11|F>>>21,u=(p>>=21)+_|0,u=(p=l=G+l|0)>>>0<G>>>0?u+1|0:u,Q[A+14|0]=(127&u)<<25|p>>>7,l=(F=G=2097151&F)<<4,F=k,Q[A+10|0]=l|(131071&F)<<15|H>>>17,k=(2097151&(F=u))<<11|p>>>21,F=(u>>=21)+(l=0)|0,F=(_=k+(2097151&v)|0)>>>0<k>>>0?F+1|0:F,Q[A+17|0]=(1023&F)<<22|_>>>10,Q[A+16|0]=(3&F)<<30|_>>>2,k=0,u=(p=U=2097151&p)<<1,p=l,Q[A+13|0]=u|(1048575&p)<<12|G>>>20,p=u=F>>21,p=(F=(l=(2097151&F)<<11|_>>>21)+(2097151&M)|0)>>>0<l>>>0?p+1|0:p,l=F,Q[A+20|0]=(8191&p)<<19|F>>>13,F=p,Q[A+19|0]=(31&p)<<27|l>>>5,H=0,u=(p=b=2097151&_)<<6,p=k,Q[A+15|0]=u|(32767&p)<<17|U>>>15,p=F>>21,G=_=(k=(2097151&F)<<11|l>>>21)+(2097151&Y)|0,_=_>>>0<k>>>0?p+1|0:p,Q[A+21|0]=G,u=(p=l)<<3,p=H,Q[A+18|0]=u|(262143&p)<<14|b>>>18,u=G,Q[A+22|0]=(255&_)<<24|u>>>8,F=_>>21,F=(u=(l=(2097151&_)<<11|u>>>21)+(2097151&gA)|0)>>>0<l>>>0?F+1|0:F,l=u,Q[A+25|0]=(2047&F)<<21|u>>>11,Q[A+24|0]=(7&F)<<29|u>>>3,p=u=F>>21,p=(F=(k=(2097151&F)<<11|l>>>21)+(2097151&z)|0)>>>0<k>>>0?p+1|0:p,Q[A+27|0]=(63&p)<<26|F>>>6,k=0,u=l&=2097151,Q[A+23|0]=31&((65535&_)<<16|G>>>16)|u<<5,u=p>>21,u=(p=(H=(2097151&p)<<11|F>>>21)+(2097151&x)|0)>>>0<H>>>0?u+1|0:u,Q[A+31|0]=(131071&u)<<15|p>>>17,Q[A+30|0]=(511&u)<<23|p>>>9,Q[A+29|0]=(1&u)<<31|p>>>1,_=0,u=(F=H=2097151&F)<<2,F=k,Q[A+26|0]=u|(524287&F)<<13|l>>>19,u=A,A=_,Q[u+28|0]=p<<7|(16383&A)<<18|H>>>14}function _(A,I,g,B,C,E,t,e,f,c,y,p){var u,F,l=0,_=0,H=0,G=0,U=0,m=0,M=0,P=0,Y=0,N=0,d=0,J=0,x=0,L=0,K=0,X=0,T=0,V=0,q=0,z=0,j=0,W=0,O=0,$=0,AA=0,IA=0,gA=0,BA=0,CA=0,QA=0,EA=0,iA=0,aA=0,rA=0,oA=0,tA=0,eA=0,fA=0,cA=0,yA=0,sA=0,wA=0,DA=0,hA=0,uA=0;if(s=u=s+-64|0,F=k(f)){if(i[u+32>>2]=0,i[u+36>>2]=0,i[u+24>>2]=0,i[u+28>>2]=0,i[u+20>>2]=t,i[u+16>>2]=E,i[u+12>>2]=C,i[u+8>>2]=B,i[u+4>>2]=f,i[u>>2]=F,i[u+56>>2]=0,i[u+52>>2]=g,i[u+48>>2]=g,i[u+44>>2]=I,i[u+40>>2]=A,A=0,s=U=s-48|0,!((I=nA(u))||(I=-26,p-3>>>0<4294967294))){if(g=i[u+44>>2],I=i[u+48>>2],i[U>>2]=0,B=i[u+40>>2],i[U+28>>2]=I,i[U+12>>2]=-1,i[U+8>>2]=B,I=((B=g>>>0>(B=I<<3)>>>0?g:B)>>>0)/((g=I<<2)>>>0)|0,i[U+20>>2]=I,i[U+24>>2]=I<<2,i[U+16>>2]=r(I,g),I=i[u+52>>2],i[U+36>>2]=p,i[U+32>>2]=I,s=B=s-80|0,C=-25,!(!U|!u))if(I=k(i[U+20>>2]<<3),i[U+4>>2]=I,I){s=t=s-16|0,C=-22;A:if(!(!U|!(I=i[U+16>>2]))&&1024==(((E=I<<10)>>>0)/(I>>>0)|0)&&(I=k(12),i[U>>2]=I,I)){i[I>>2]=0,i[I+4>>2]=0,E>>>0>4294967168?I=48:(E>>>0>=4294967168?(i[8952]=48,g=0):(g=0,(I=k(76+(x=E>>>0<11?16:E+11&-8)|0))&&(g=I-8|0,63&I?(d=(-8&(M=i[(H=I-4|0)>>2]))-(m=(I=((I=(I+63&-64)-8|0)-g>>>0>15?0:64)+I|0)-g|0)|0,3&M?(i[I+4>>2]=d|1&i[I+4>>2]|2,i[4+(d=I+d|0)>>2]=1|i[d+4>>2],i[H>>2]=m|1&i[H>>2]|2,i[4+(d=g+m|0)>>2]=1|i[d+4>>2],v(g,m)):(g=i[g>>2],i[I+4>>2]=d,i[I>>2]=g+m)):I=g,3&(g=i[I+4>>2])&&((m=-8&g)>>>0<=x+16>>>0||(i[I+4>>2]=x|1&g|2,g=I+x|0,x=m-x|0,i[g+4>>2]=3|x,i[4+(m=I+m|0)>>2]=1|i[m+4>>2],v(g,x))),g=I+8|0)),(I=g)?(i[t+12>>2]=I,I=0):I=48),i[8952]=I;I:{if(I)i[t+12>>2]=0;else if(I=i[t+12>>2])break I;b(i[U>>2]),i[U>>2]=0;break A}i[i[U>>2]>>2]=I,i[i[U>>2]+4>>2]=I,i[i[U>>2]+8>>2]=E,C=0}if(s=t+16|0,C)RA(U,i[u+56>>2]);else{if(E=i[U+36>>2],t=I=s,s=I=I-448&-64,!B|!u||(OA(C=I- -64|0,0,0,64),bI(g=I+60|0,i[u+48>>2]),Cg(C,g,4,0),bI(g,i[u+4>>2]),Cg(C,g,4,0),bI(g,i[u+44>>2]),Cg(C,g,4,0),bI(g,i[u+40>>2]),Cg(C,g,4,0),bI(g,19),Cg(C,g,4,0),bI(g,E),Cg(C,g,4,0),bI(g,i[u+12>>2]),Cg(C,g,4,0),(g=i[u+8>>2])&&(Cg(I- -64|0,g,i[u+12>>2],0),1&Q[u+56|0]&&(Dg(i[u+8>>2],i[u+12>>2]),i[u+12>>2]=0)),bI(g=I+60|0,i[u+20>>2]),Cg(I- -64|0,g,4,0),(g=i[u+16>>2])&&Cg(I- -64|0,g,i[u+20>>2],0),bI(g=I+60|0,i[u+28>>2]),Cg(I- -64|0,g,4,0),(g=i[u+24>>2])&&(Cg(I- -64|0,g,i[u+28>>2],0),2&n[u+56|0]&&(Dg(i[u+24>>2],i[u+28>>2]),i[u+28>>2]=0)),bI(g=I+60|0,i[u+36>>2]),Cg(I- -64|0,g,4,0),(g=i[u+32>>2])&&Cg(I- -64|0,g,i[u+36>>2],0),UI(I- -64|0,B,64)),s=t,Dg(B- -64|0,8),C=0,s=I=s-1024|0,i[U+28>>2])for(E=B+68|0,g=B- -64|0;bI(g,0),bI(E,C),R(I,1024,B,72),KA(i[i[U>>2]+4>>2]+(r(i[U+24>>2],C)<<10)|0,I),bI(g,1),R(I,1024,B,72),KA(1024+(i[i[U>>2]+4>>2]+(r(i[U+24>>2],C)<<10)|0)|0,I),(C=C+1|0)>>>0<a[U+28>>2];);Dg(I,1024),s=I+1024|0,Dg(B,72),C=0}}else C=-22;if(s=B+80|0,!(I=C)){if(i[U+8>>2])for(;;){if(B=A,cA=0,s=C=s-32|0,!(!U|!i[U+28>>2]))for(i[C+16>>2]=B,I=1;;){if(Q[C+24|0]=cA,yA=0,A=0,I)for(;;){i[C+28>>2]=0,A=i[C+28>>2],i[C+8>>2]=i[C+24>>2],i[C+12>>2]=A,i[C+20>>2]=yA,A=i[C+20>>2],i[C>>2]=i[C+16>>2],i[C+4>>2]=A,A=0;A:if(U){I:{if(2==i[U+36>>2]){if(sA=i[U+4>>2],wA=1,(t=i[C>>2])|(E=n[C+8|0])>>>0>1)break I}else sA=i[U+4>>2];if(s=I=s-4096|0,wg(I+3072|0),wg(I+2048|0),!(!U|!C)&&(i[I+2048>>2]=i[C>>2],i[I+2052>>2]=0,i[I+2056>>2]=i[C+4>>2],i[I+2060>>2]=0,i[I+2064>>2]=n[C+8|0],i[I+2068>>2]=0,i[I+2072>>2]=i[U+16>>2],i[I+2076>>2]=0,i[I+2080>>2]=i[U+8>>2],i[I+2084>>2]=0,i[I+2088>>2]=i[U+36>>2],i[I+2092>>2]=0,i[U+20>>2]))for(;(g=127&A)||(t=E=i[I+2100>>2],H=E+1|0,t=(E=i[I+2096>>2]+1|0)?t:H,i[I+2096>>2]=E,i[I+2100>>2]=t,wg(I),wg(E=I+1024|0),S(t=I+3072|0,I+2048|0,I),S(t,I,E)),E=i[4+(g=(I+1024|0)+(g<<3)|0)>>2],i[(t=(A<<3)+sA|0)>>2]=i[g>>2],i[t+4>>2]=E,(A=A+1|0)>>>0<a[U+20>>2];);s=I+4096|0,E=n[C+8|0],t=i[C>>2],wA=0}if(A=255&E,!((t=t?0:!A<<1)>>>0>=(g=i[U+20>>2])>>>0))for(I=i[U+24>>2],A=(E=(r(I,i[C+4>>2])+t|0)+r(A,g)|0)+((E>>>0)%(I>>>0)|0?-1:I-1|0)|0;;){DA=1==((E>>>0)%(I>>>0)|0)?E-1|0:A,x=i[U+28>>2],wA?(A=i[U>>2],m=i[A+4>>2]+(DA<<10)|0):(A=i[U>>2],m=(t<<3)+sA|0),g=i[m>>2],m=i[m+4>>2],i[C+12>>2]=t,x=(m>>>0)%(x>>>0)|0,m=i[C+4>>2],d=n[C+8|0]?x:m,_=i[A+4>>2],G=i[C>>2],Y=_+(r(I,A=G?x:d)<<10)|0,A=(0|A)==(0|m);I:if(i[C>>2])I=i[U+24>>2],x=i[U+20>>2],I=A?i[C+12>>2]+(I+(-1^x)|0)|0:(I-x|0)-!i[C+12>>2]|0,H=0,3!=(0|(A=n[C+8|0]))&&(H=r(x,A+1|0));else{if(!(I=n[C+8|0])){I=i[C+12>>2]-1|0,H=0;break I}if(I=r(I,i[U+20>>2]),x=i[C+12>>2],A){I=(I+x|0)-1|0,H=0;break I}I=I-!x|0,H=0}A=H+(d=I-1|0)|0,qA(g,0,g,0),qA(I,0,h,0),m=A-(I=h)|0,x=i[U+24>>2],l=0;I:{g:{B:{C:{Q:{E:{i:{n:{a:{r:{if(I=(A>>>0<d>>>0)-(A>>>0<I>>>0)|0){if(!x)break r;break a}w=m-r((m>>>0)/(x>>>0)|0,x)|0,D=0,h=0;break I}if(!m)break n;break i}if(!((A=x-1|0)&x))break E;H=0-(d=(o(x)+33|0)-o(I)|0)|0;break C}w=0,D=I,h=0;break I}if((A=32-o(I)|0)>>>0<31)break Q;break B}if(w=A&m,D=0,1==(0|x))break g;A=x?31-o(x-1^x)|0:32,h=(63&A)>>>0>=32?0:I>>>A|0;break I}d=A+1|0,H=63-A|0}if(g=31&(A=63&d),A>>>0>=32?(A=0,M=I>>>g|0):(A=I>>>g|0,M=((1<<g)-1&I)<<32-g|m>>>g),g=A,H=31&(A=63&H),A>>>0>=32?(A=m<<H,m=0):(A=(1<<H)-1&m>>>32-H|I<<H,m<<=H),I=A,d)for(N=-1!=(0|(H=x-1|0))?0:-1;M=(A=M<<1|I>>>31)-(X=x&(L=N-((g=g<<1|M>>>31)+(A>>>0>H>>>0)|0)>>31))|0,g=g-(A>>>0<X>>>0)|0,I=I<<1|m>>>31,m=l|m<<1,l=1&L,d=d-1|0;);w=M,D=g,h=I<<1|m>>>31;break I}w=m,D=I,I=0}h=I}if(h=D,A=(w<<10)+Y|0,x=_+(DA<<10)|0,g=_+(E<<10)|0,G)S(x,A,g);else{for(s=I=s-2048|0,yg(m=I+1024|0,A),AI(m,x),yg(I,m),x=0,m=0;H=i[(d=(A=(I+1024|0)+(m<<7)|0)- -64|0)>>2],M=i[A+100>>2],P=H,N=i[d+4>>2],J=i[A+96>>2],H=i[A+32>>2],_=i[A+36>>2],M=pA(J^(l=CI(i[A>>2],i[A+4>>2],H,_)),M^(G=h),32),_=pA(P=(N=CI(P,N,M,Y=h))^H,_^(H=h),24),P=H,AA=pA((X=CI(l,G,_,H=h))^M,(T=h)^Y,16),H=pA(_^(gA=CI(N,P,AA,IA=h)),(rA=h)^H,63),M=h,_=i[A+108>>2],K=i[A+72>>2],J=i[A+76>>2],P=i[A+104>>2],l=i[A+40>>2],G=i[A+44>>2],_=pA(P^(Y=CI(i[A+8>>2],i[A+12>>2],l,G)),_^(N=h),32),G=pA(P=(BA=CI(K,J,_,L=h))^l,G^(l=h),24),J=BA,tA=pA((P=_)^(BA=CI(Y,N,G,_=h)),(oA=h)^L,16),_=pA(G^(CA=CI(J,l,tA,eA=h)),(QA=h)^_,63),l=h,G=i[A+116>>2],K=i[A+80>>2],J=i[A+84>>2],P=i[A+112>>2],Y=i[A+48>>2],N=i[A+52>>2],G=pA(P^(L=CI(i[A+16>>2],i[A+20>>2],Y,N)),G^(j=h),32),N=pA(J=(P=CI(K,J,G,EA=h))^Y,N^(Y=h),24),K=P,J=Y,EA=pA(G^(j=CI(L,j,N,Y=h)),EA^(P=h),16),G=pA(N^(J=CI(K,J,EA,iA=h)),(W=h)^Y,63),Y=h,N=i[A+124>>2],aA=i[A+88>>2],O=i[A+92>>2],K=i[A+120>>2],L=i[A+56>>2],V=i[A+60>>2],N=pA(K^(q=CI(i[A+24>>2],i[A+28>>2],L,V)),N^(z=h),32),O=V=pA(K=(fA=CI(aA,O,N,$=h))^L,V^(L=h),24),z=pA((K=N)^(V=CI(q,z,V,N=h)),(q=h)^$,16),N=pA(O^(fA=CI(fA,L,z,$=h)),(aA=h)^N,63),L=h,O=J,K=W,J=pA(z^(X=CI(X,T,_,l)),$^(T=h),32),_=pA((z=CI(O,K,J,W=h))^_,(K=l)^(l=h),24),T=CI(K=X,T,_,X=h),i[A>>2]=T,$=h,i[A+4>>2]=$,T=pA(T^J,W^$,16),i[A+120>>2]=T,J=h,i[A+124>>2]=J,l=CI(z,l,T,J),i[A+80>>2]=l,T=h,i[A+84>>2]=T,hA=A,uA=pA(_^l,X^T,63),i[hA+40>>2]=uA,i[A+44>>2]=h,T=pA(AA^(l=CI(BA,oA,G,Y)),IA^(X=h),32),_=pA(J=G^(IA=CI(fA,aA,T,AA=h)),Y^(G=h),24),Y=CI(J=l,X,_,l=h),i[A+8>>2]=Y,X=h,i[A+12>>2]=X,Y=pA(Y^T,X^AA,16),i[A+96>>2]=Y,X=h,i[A+100>>2]=X,G=CI(IA,G,Y,X),i[A+88>>2]=G,Y=h,i[A+92>>2]=Y,hA=A,uA=pA(_^G,l^Y,63),i[hA+48>>2]=uA,i[A+52>>2]=h,Y=pA(tA^(l=CI(j,P,N,L)),eA^(G=h),32),_=pA(P=N^(T=CI(gA,rA,Y,X=h)),L^(N=h),24),G=CI(P=l,G,_,l=h),i[A+16>>2]=G,L=h,i[A+20>>2]=L,G=pA(G^Y,L^X,16),i[A+104>>2]=G,Y=h,i[A+108>>2]=Y,G=CI(T,N,G,Y),i[d>>2]=G,P=d,d=h,i[P+4>>2]=d,hA=A,uA=pA(_^G,l^d,63),i[hA+56>>2]=uA,i[A+60>>2]=h,_=CI(V,q,H,M),N=CI(CA,QA,G=pA(EA^_,iA^(l=h),32),Y=h),_=CI(_,l,d=pA(P=H^N,M^(H=h),24),M=h),i[A+24>>2]=_,l=h,i[A+28>>2]=l,_=pA(_^G,l^Y,16),i[A+112>>2]=_,l=h,i[A+116>>2]=l,H=CI(N,H,_,l),i[A+72>>2]=H,_=h,i[A+76>>2]=_,hA=A,uA=pA(H^d,_^M,63),i[hA+32>>2]=uA,i[A+36>>2]=h,8!=(0|(m=m+1|0)););for(;m=i[512+(A=(I+1024|0)+(x<<4)|0)>>2],d=i[A+772>>2],P=m,J=i[A+516>>2],l=i[A+768>>2],m=i[A+256>>2],H=i[A+260>>2],d=pA(l^(M=CI(i[A>>2],i[A+4>>2],m,H)),d^(_=h),32),H=pA(P=(G=CI(P,J,d,l=h))^m,H^(m=h),24),P=m,X=pA((N=CI(M,_,H,m=h))^d,(L=h)^l,16),m=pA(H^(AA=CI(G,P,X,T=h)),(IA=h)^m,63),d=h,H=i[A+780>>2],K=i[A+520>>2],J=i[A+524>>2],P=i[A+776>>2],M=i[A+264>>2],_=i[A+268>>2],H=pA(P^(l=CI(i[A+8>>2],i[A+12>>2],M,_)),H^(G=h),32),_=pA(P=(gA=CI(K,J,H,Y=h))^M,_^(M=h),24),J=gA,BA=pA((P=H)^(gA=CI(l,G,_,H=h)),(rA=h)^Y,16),H=pA(_^(tA=CI(J,M,BA,oA=h)),(eA=h)^H,63),M=h,_=i[A+900>>2],K=i[A+640>>2],J=i[A+644>>2],P=i[A+896>>2],l=i[A+384>>2],G=i[A+388>>2],_=pA(P^(Y=CI(i[A+128>>2],i[A+132>>2],l,G)),_^(CA=h),32),G=pA(P=(j=CI(K,J,_,QA=h))^l,G^(l=h),24),J=j,P=l,QA=pA(_^(CA=CI(Y,CA,G,l=h)),QA^(j=h),16),_=pA(G^(P=CI(J,P,QA,EA=h)),(iA=h)^l,63),l=h,G=i[A+908>>2],aA=i[A+648>>2],O=i[A+652>>2],K=i[A+904>>2],Y=i[A+392>>2],J=i[A+396>>2],G=pA(K^(W=CI(i[A+136>>2],i[A+140>>2],Y,J)),G^(V=h),32),O=J=pA(K=(z=CI(aA,O,G,q=h))^Y,J^(Y=h),24),V=pA((K=G)^(J=CI(W,V,J,G=h)),(W=h)^q,16),G=pA(O^(z=CI(z,Y,V,q=h)),($=h)^G,63),Y=h,O=P,K=iA,P=pA(V^(N=CI(N,L,H,M)),q^(L=h),32),H=pA((V=CI(O,K,P,iA=h))^H,(K=M)^(M=h),24),L=CI(K=N,L,H,N=h),i[A>>2]=L,q=h,i[A+4>>2]=q,L=pA(L^P,q^iA,16),i[A+904>>2]=L,P=h,i[A+908>>2]=P,M=CI(V,M,L,P),i[A+640>>2]=M,L=h,i[A+644>>2]=L,hA=A,uA=pA(H^M,N^L,63),i[hA+264>>2]=uA,i[A+268>>2]=h,L=pA(X^(M=CI(gA,rA,_,l)),T^(N=h),32),H=pA(H=_^(T=CI(z,$,L,X=h)),l^(_=h),24),l=CI(l=M,N,H,M=h),i[A+8>>2]=l,N=h,i[A+12>>2]=N,l=pA(l^L,N^X,16),i[A+768>>2]=l,N=h,i[A+772>>2]=N,_=CI(T,_,l,N),i[A+648>>2]=_,l=h,i[A+652>>2]=l,hA=A,uA=pA(_^H,l^M,63),i[hA+384>>2]=uA,i[A+388>>2]=h,M=CI(CA,j,G,Y),L=CI(AA,IA,l=pA(BA^M,oA^(_=h),32),N=h),_=CI(P=M,_,H=pA(H=G^L,Y^(G=h),24),M=h),i[A+128>>2]=_,Y=h,i[A+132>>2]=Y,_=pA(_^l,Y^N,16),i[A+776>>2]=_,l=h,i[A+780>>2]=l,_=CI(L,G,_,l),i[A+512>>2]=_,l=h,i[A+516>>2]=l,hA=A,uA=pA(_^H,l^M,63),i[hA+392>>2]=uA,i[A+396>>2]=h,_=pA(QA^(H=CI(J,W,m,d)),EA^(M=h),32),m=pA((G=CI(tA,eA,_,l=h))^m,(P=d)^(d=h),24),M=CI(P=H,M,m,H=h),i[A+136>>2]=M,Y=h,i[A+140>>2]=Y,M=pA(_^M,l^Y,16),i[A+896>>2]=M,_=h,i[A+900>>2]=_,d=CI(G,d,M,_),i[A+520>>2]=d,M=h,i[A+524>>2]=M,hA=A,uA=pA(m^d,H^M,63),i[hA+256>>2]=uA,i[A+260>>2]=h,8!=(0|(x=x+1|0)););yg(g,I),AI(g,I+1024|0),s=I+2048|0}if((t=t+1|0)>>>0>=a[U+20>>2])break A;E=E+1|0,A=DA+1|0,I=i[U+24>>2]}}if(!((A=i[U+28>>2])>>>0>(yA=yA+1|0)>>>0))break}if(I=A,4==(0|(cA=cA+1|0)))break}if(s=C+32|0,!((A=B+1|0)>>>0<a[U+8>>2]))break}if(s=I=s-2048|0,!(!u|!U)){if(yg(I+1024|0,(i[i[U>>2]+4>>2]+(i[U+24>>2]<<10)|0)-1024|0),a[U+28>>2]>=2)for(A=1;g=i[U+24>>2],AI(I+1024|0,(i[i[U>>2]+4>>2]+(r(g,A)+g<<10)|0)-1024|0),(A=A+1|0)>>>0<a[U+28>>2];);for(g=I+1024|0,A=0;QI(C=(B=A<<3)+I|0,i[(B=g+B|0)>>2],i[B+4>>2]),128!=(0|(A=A+1|0)););R(i[u>>2],i[u+4>>2],I,1024),Dg(g,1024),Dg(I,1024),RA(U,i[u+56>>2])}s=I+2048|0,I=0}}s=U+48|0,g=I;A:if(I)Dg(F,f);else{if(!(!c|!y)){s=A=s-16|0,I=-31;I:{g:{B:{C:switch(p-1|0){case 1:if(y>>>0<13)break g;I=n[1347]|n[1348]<<8|n[1349]<<16|n[1350]<<24,g=n[1343]|n[1344]<<8|n[1345]<<16|n[1346]<<24,Q[0|c]=g,Q[c+1|0]=g>>>8,Q[c+2|0]=g>>>16,Q[c+3|0]=g>>>24,Q[c+4|0]=I,Q[c+5|0]=I>>>8,Q[c+6|0]=I>>>16,Q[c+7|0]=I>>>24,I=n[1352]|n[1353]<<8|n[1354]<<16|n[1355]<<24,g=n[1348]|n[1349]<<8|n[1350]<<16|n[1351]<<24,Q[c+5|0]=g,Q[c+6|0]=g>>>8,Q[c+7|0]=g>>>16,Q[c+8|0]=g>>>24,Q[c+9|0]=I,Q[c+10|0]=I>>>8,Q[c+11|0]=I>>>16,Q[c+12|0]=I>>>24,B=-12,g=12;break B;case 0:break C;default:break I}if(y>>>0<12)break g;I=n[1335]|n[1336]<<8|n[1337]<<16|n[1338]<<24,g=n[1331]|n[1332]<<8|n[1333]<<16|n[1334]<<24,Q[0|c]=g,Q[c+1|0]=g>>>8,Q[c+2|0]=g>>>16,Q[c+3|0]=g>>>24,Q[c+4|0]=I,Q[c+5|0]=I>>>8,Q[c+6|0]=I>>>16,Q[c+7|0]=I>>>24,I=n[1339]|n[1340]<<8|n[1341]<<16|n[1342]<<24,Q[c+8|0]=I,Q[c+9|0]=I>>>8,Q[c+10|0]=I>>>16,Q[c+11|0]=I>>>24,B=-11,g=11}if(I=nA(u))break I;if(dA(I=A+5|0,19),!((B=B+y|0)>>>0<=(I=mA(I))>>>0)&&(g=eI(g+c|0,A+5|0,I+1|0),!((B=B-I|0)>>>0<4)&&(Q[0|(I=I+g|0)]=36,Q[I+1|0]=109,Q[I+2|0]=61,Q[I+3|0]=0,dA(g=A+5|0,i[u+44>>2]),!((B=B-3|0)>>>0<=(g=mA(g))>>>0)&&(I=eI(I+3|0,A+5|0,g+1|0),!((B=B-g|0)>>>0<4)&&(Q[0|(I=I+g|0)]=44,Q[I+1|0]=116,Q[I+2|0]=61,Q[I+3|0]=0,dA(g=A+5|0,i[u+40>>2]),!((B=B-3|0)>>>0<=(g=mA(g))>>>0)&&(I=eI(I+3|0,A+5|0,g+1|0),!((B=B-g|0)>>>0<4)&&(Q[0|(I=I+g|0)]=44,Q[I+1|0]=112,Q[I+2|0]=61,Q[I+3|0]=0,dA(g=A+5|0,i[u+48>>2]),!((B=B-3|0)>>>0<=(g=mA(g))>>>0)&&(I=eI(I+3|0,A+5|0,g+1|0),!((B=B-g|0)>>>0<2)&&(Q[0|(I=I+g|0)]=36,Q[I+1|0]=0,Z(g=I+1|0,B=B-1|0,i[u+16>>2],i[u+20>>2],3)))))))))){if(I=-31,(C=(C=B)-(B=mA(g))|0)>>>0<2)break I;Q[0|(I=g+B|0)]=36,Q[I+1|0]=0,I=Z(I+1|0,C-1|0,i[u>>2],i[u+4>>2],3)?0:-31;break I}}I=-31}if(s=A+16|0,I){Dg(F,f),Dg(c,y),g=-31;break A}}e&&eI(e,F,f),Dg(F,f),g=0}b(F)}else g=-22;return s=u- -64|0,g}function k(A){var I,g=0,B=0,C=0,Q=0,E=0,r=0,o=0,t=0,e=0,f=0,c=0,y=0;s=I=s-16|0;A:{I:{g:{B:{C:{Q:{E:{i:{n:{a:{r:{if((A|=0)>>>0<=244){if(3&(g=(Q=i[8965])>>>(B=(r=A>>>0<11?16:A+11&-8)>>>3|0)|0)){A=(E=i[35908+(g=(C=B+(1&(-1^g))|0)<<3)>>2])+8|0,(0|(B=i[E+8>>2]))!=(0|(g=g+35900|0))?(i[B+12>>2]=g,i[g+8>>2]=B):(c=35860,y=lI(-2,C)&Q,i[c>>2]=y),g=C<<3,i[E+4>>2]=3|g,i[4+(g=g+E|0)>>2]=1|i[g+4>>2];break A}if((f=i[8967])>>>0>=r>>>0)break r;if(g){B=A=(g=(0-(A=(0-(A=2<<B)|A)&g<<B)&A)-1|0)>>>12&16,B|=A=(g=g>>>A|0)>>>5&8,B|=A=(g=g>>>A|0)>>>2&4,e=i[35908+(A=(B=((B|=A=(g=g>>>A|0)>>>1&2)|(A=(g=g>>>A|0)>>>1&1))+(g>>>A|0)|0)<<3)>>2],(0|(g=i[e+8>>2]))!=(0|(A=A+35900|0))?(i[g+12>>2]=A,i[A+8>>2]=g):(Q=lI(-2,B)&Q,i[8965]=Q),A=e+8|0,i[e+4>>2]=3|r,E=(g=B<<3)-r|0,i[4+(C=r+e|0)>>2]=1|E,i[g+e>>2]=E,f&&(B=35900+((g=f>>>3|0)<<3)|0,e=i[8970],(g=1<<g)&Q?g=i[B+8>>2]:(i[8965]=g|Q,g=B),i[B+8>>2]=e,i[g+12>>2]=e,i[e+12>>2]=B,i[e+8>>2]=g),i[8970]=C,i[8967]=E;break A}if(!(o=i[8966]))break r;for(B=A=(g=(0-o&o)-1|0)>>>12&16,B|=A=(g=g>>>A|0)>>>5&8,B|=A=(g=g>>>A|0)>>>2&4,g=i[36164+(((B|=A=(g=g>>>A|0)>>>1&2)|(A=(g=g>>>A|0)>>>1&1))+(g>>>A|0)<<2)>>2],C=(-8&i[g+4>>2])-r|0,B=g;(A=i[B+16>>2])||(A=i[B+20>>2]);)C=(E=(B=(-8&i[A+4>>2])-r|0)>>>0<C>>>0)?B:C,g=E?A:g,B=A;if(t=i[g+24>>2],(0|(E=i[g+12>>2]))!=(0|g)){A=i[g+8>>2],i[A+12>>2]=E,i[E+8>>2]=A;break I}if(!(A=i[(B=g+20|0)>>2])){if(!(A=i[g+16>>2]))break a;B=g+16|0}for(;e=B,E=A,(A=i[(B=A+20|0)>>2])||(B=E+16|0,A=i[E+16>>2]););i[e>>2]=0;break I}if(r=-1,!(A>>>0>4294967231)&&(r=-8&(A=A+11|0),t=i[8966])){C=0-r|0,Q=0,r>>>0<256||(Q=31,r>>>0>16777215||(A=A>>>8|0,A<<=e=A+1048320>>>16&8,Q=28+((A=((A<<=B=A+520192>>>16&4)<<(g=A+245760>>>16&2)>>>15|0)-(g|B|e)|0)<<1|r>>>A+21&1)|0));o:{t:{if(B=i[36164+(Q<<2)>>2])for(A=0,g=r<<(31==(0|Q)?0:25-(Q>>>1|0)|0);;){if(!((e=(o=-8&i[B+4>>2])-r|0)>>>0>=C>>>0)&&(C=e,E=B,(0|r)==(0|o))){C=0,A=B;break t}if(e=i[B+20>>2],B=i[16+((g>>>29&4)+B|0)>>2],A=e?(0|e)==(0|B)?A:e:A,g<<=1,!B)break}else A=0;if(!(A|E)){if(E=0,!(A=(0-(A=2<<Q)|A)&t))break r;B=A=(g=(A&0-A)-1|0)>>>12&16,B|=A=(g=g>>>A|0)>>>5&8,B|=A=(g=g>>>A|0)>>>2&4,A=i[36164+(((B|=A=(g=g>>>A|0)>>>1&2)|(A=(g=g>>>A|0)>>>1&1))+(g>>>A|0)<<2)>>2]}if(!A)break o}for(;C=(B=(g=(-8&i[A+4>>2])-r|0)>>>0<C>>>0)?g:C,E=B?A:E,A=(g=i[A+16>>2])||i[A+20>>2];);}if(!(!E|i[8967]-r>>>0<=C>>>0)){if(Q=i[E+24>>2],(0|E)!=(0|(g=i[E+12>>2]))){A=i[E+8>>2],i[A+12>>2]=g,i[g+8>>2]=A;break g}if(!(A=i[(B=E+20|0)>>2])){if(!(A=i[E+16>>2]))break n;B=E+16|0}for(;e=B,g=A,(A=i[(B=A+20|0)>>2])||(B=g+16|0,A=i[g+16>>2]););i[e>>2]=0;break g}}}if((B=i[8967])>>>0>=r>>>0){C=i[8970],(g=B-r|0)>>>0>=16?(i[8967]=g,A=C+r|0,i[8970]=A,i[A+4>>2]=1|g,i[B+C>>2]=g,i[C+4>>2]=3|r):(i[8970]=0,i[8967]=0,i[C+4>>2]=3|B,i[4+(A=B+C|0)>>2]=1|i[A+4>>2]),A=C+8|0;break A}if((t=i[8968])>>>0>r>>>0){g=t-r|0,i[8968]=g,A=(B=i[8971])+r|0,i[8971]=A,i[A+4>>2]=1|g,i[B+4>>2]=3|r,A=B+8|0;break A}if(A=0,o=r+47|0,i[9083]?B=i[9085]:(i[9086]=-1,i[9087]=-1,i[9084]=4096,i[9085]=4096,i[9083]=I+12&-16^1431655768,i[9088]=0,i[9076]=0,B=4096),(B=(e=o+B|0)&(E=0-B|0))>>>0<=r>>>0)break A;if((C=i[9075])&&(Q=(g=i[9073])+B|0)>>>0>C>>>0|g>>>0>=Q>>>0)break A;if(4&n[36304])break Q;r:{o:{if(C=i[8971])for(A=36308;;){if((g=i[A>>2])>>>0<=C>>>0&C>>>0<g+i[A+4>>2]>>>0)break o;if(!(A=i[A+8>>2]))break}if(-1==(0|(g=$A(0))))break E;if(Q=B,(A=(C=i[9084])-1|0)&g&&(Q=(B-g|0)+(A+g&0-C)|0),Q>>>0<=r>>>0|Q>>>0>2147483646)break E;if((C=i[9075])&&C>>>0<(E=(A=i[9073])+Q|0)>>>0|A>>>0>=E>>>0)break E;if((0|g)!=(0|(A=$A(Q))))break r;break C}if((Q=E&e-t)>>>0>2147483646)break E;if((0|(g=$A(Q)))==(i[A>>2]+i[A+4>>2]|0))break i;A=g}if(!(-1==(0|A)|r+48>>>0<=Q>>>0)){if((g=(g=i[9085])+(o-Q|0)&0-g)>>>0>2147483646){g=A;break C}if(-1!=(0|$A(g))){Q=g+Q|0,g=A;break C}$A(0-Q|0);break E}if(g=A,-1!=(0|A))break C;break E}E=0;break I}g=0;break g}if(-1!=(0|g))break C}i[9076]=4|i[9076]}if(B>>>0>2147483646)break B;if(-1==(0|(g=$A(B)))|-1==(0|(A=$A(0)))|A>>>0<=g>>>0)break B;if((Q=A-g|0)>>>0<=r+40>>>0)break B}A=i[9073]+Q|0,i[9073]=A,A>>>0>a[9074]&&(i[9074]=A);C:{Q:{E:{if(o=i[8971]){for(A=36308;;){if(((C=i[A>>2])+(B=i[A+4>>2])|0)==(0|g))break E;if(!(A=i[A+8>>2]))break}break Q}for((A=i[8969])>>>0<=g>>>0&&A||(i[8969]=g),A=0,i[9078]=Q,i[9077]=g,i[8973]=-1,i[8974]=i[9083],i[9080]=0;B=35900+(C=A<<3)|0,i[C+35908>>2]=B,i[C+35912>>2]=B,32!=(0|(A=A+1|0)););B=(C=Q-40|0)-(A=g+8&7?-8-g&7:0)|0,i[8968]=B,A=A+g|0,i[8971]=A,i[A+4>>2]=1|B,i[4+(g+C|0)>>2]=40,i[8972]=i[9087];break C}if(!(8&n[A+12|0]|C>>>0>o>>>0|g>>>0<=o>>>0)){i[A+4>>2]=B+Q,B=(A=o+8&7?-8-o&7:0)+o|0,i[8971]=B,A=(g=i[8968]+Q|0)-A|0,i[8968]=A,i[B+4>>2]=1|A,i[4+(g+o|0)>>2]=40,i[8972]=i[9087];break C}}a[8969]>g>>>0&&(i[8969]=g),B=g+Q|0,A=36308;Q:{E:{i:{n:{a:{r:{for(;;){if((0|B)!=i[A>>2]){if(A=i[A+8>>2])continue;break r}break}if(!(8&n[A+12|0]))break a}for(A=36308;;){if((B=i[A>>2])>>>0<=o>>>0&&(E=B+i[A+4>>2]|0)>>>0>o>>>0)break n;A=i[A+8>>2]}}if(i[A>>2]=g,i[A+4>>2]=i[A+4>>2]+Q,i[4+(e=(g+8&7?-8-g&7:0)+g|0)>>2]=3|r,r=(Q=B+(B+8&7?-8-B&7:0)|0)-(t=r+e|0)|0,(0|Q)==(0|o)){i[8971]=t,A=i[8968]+r|0,i[8968]=A,i[t+4>>2]=1|A;break E}if(i[8970]==(0|Q)){i[8970]=t,A=i[8967]+r|0,i[8967]=A,i[t+4>>2]=1|A,i[A+t>>2]=A;break E}if(1==(3&(A=i[Q+4>>2]))){E=-8&A;a:if(A>>>0<=255){if(B=i[Q+8>>2],A=A>>>3|0,(0|(g=i[Q+12>>2]))==(0|B)){c=35860,y=i[8965]&lI(-2,A),i[c>>2]=y;break a}i[B+12>>2]=g,i[g+8>>2]=B}else{if(o=i[Q+24>>2],(0|Q)==(0|(g=i[Q+12>>2])))if((C=i[(A=Q+20|0)>>2])||(C=i[(A=Q+16|0)>>2])){for(;B=A,(C=i[(A=(g=C)+20|0)>>2])||(A=g+16|0,C=i[g+16>>2]););i[B>>2]=0}else g=0;else A=i[Q+8>>2],i[A+12>>2]=g,i[g+8>>2]=A;if(o){B=i[Q+28>>2];r:{if(i[(A=36164+(B<<2)|0)>>2]==(0|Q)){if(i[A>>2]=g,g)break r;c=35864,y=i[8966]&lI(-2,B),i[c>>2]=y;break a}if(i[o+(i[o+16>>2]==(0|Q)?16:20)>>2]=g,!g)break a}i[g+24>>2]=o,(A=i[Q+16>>2])&&(i[g+16>>2]=A,i[A+24>>2]=g),(A=i[Q+20>>2])&&(i[g+20>>2]=A,i[A+24>>2]=g)}}r=E+r|0,Q=Q+E|0}if(i[Q+4>>2]=-2&i[Q+4>>2],i[t+4>>2]=1|r,i[r+t>>2]=r,r>>>0<=255){g=35900+((A=r>>>3|0)<<3)|0,(B=i[8965])&(A=1<<A)?A=i[g+8>>2]:(i[8965]=A|B,A=g),i[g+8>>2]=t,i[A+12>>2]=t,i[t+12>>2]=g,i[t+8>>2]=A;break E}if(A=31,r>>>0<=16777215&&(A=r>>>8|0,A<<=C=A+1048320>>>16&8,A=28+((A=((A<<=B=A+520192>>>16&4)<<(g=A+245760>>>16&2)>>>15|0)-(g|B|C)|0)<<1|r>>>A+21&1)|0),i[t+28>>2]=A,i[t+16>>2]=0,i[t+20>>2]=0,C=36164+(A<<2)|0,(B=i[8966])&(g=1<<A)){for(A=r<<(31==(0|A)?0:25-(A>>>1|0)|0),g=i[C>>2];;){if(B=g,(-8&i[g+4>>2])==(0|r))break i;if(g=A>>>29|0,A<<=1,!(g=i[16+(C=B+(4&g)|0)>>2]))break}i[C+16>>2]=t,i[t+24>>2]=B}else i[8966]=g|B,i[C>>2]=t,i[t+24>>2]=C;i[t+12>>2]=t,i[t+8>>2]=t;break E}for(B=(C=Q-40|0)-(A=g+8&7?-8-g&7:0)|0,i[8968]=B,A=A+g|0,i[8971]=A,i[A+4>>2]=1|B,i[4+(g+C|0)>>2]=40,i[8972]=i[9087],i[(B=(A=(E+(E-39&7?39-E&7:0)|0)-47|0)>>>0<o+16>>>0?o:A)+4>>2]=27,A=i[9080],i[B+16>>2]=i[9079],i[B+20>>2]=A,A=i[9078],i[B+8>>2]=i[9077],i[B+12>>2]=A,i[9079]=B+8,i[9078]=Q,i[9077]=g,i[9080]=0,A=B+24|0;i[A+4>>2]=7,g=A+8|0,A=A+4|0,g>>>0<E>>>0;);if((0|B)==(0|o))break C;if(i[B+4>>2]=-2&i[B+4>>2],E=B-o|0,i[o+4>>2]=1|E,i[B>>2]=E,E>>>0<=255){g=35900+((A=E>>>3|0)<<3)|0,(B=i[8965])&(A=1<<A)?A=i[g+8>>2]:(i[8965]=A|B,A=g),i[g+8>>2]=o,i[A+12>>2]=o,i[o+12>>2]=g,i[o+8>>2]=A;break C}if(A=31,i[o+16>>2]=0,i[o+20>>2]=0,E>>>0<=16777215&&(A=E>>>8|0,A<<=C=A+1048320>>>16&8,A=28+((A=((A<<=B=A+520192>>>16&4)<<(g=A+245760>>>16&2)>>>15|0)-(g|B|C)|0)<<1|E>>>A+21&1)|0),i[o+28>>2]=A,C=36164+(A<<2)|0,(B=i[8966])&(g=1<<A)){for(A=E<<(31==(0|A)?0:25-(A>>>1|0)|0),g=i[C>>2];;){if(B=g,(0|E)==(-8&i[g+4>>2]))break Q;if(g=A>>>29|0,A<<=1,!(g=i[16+(C=B+(4&g)|0)>>2]))break}i[C+16>>2]=o,i[o+24>>2]=B}else i[8966]=g|B,i[C>>2]=o,i[o+24>>2]=C;i[o+12>>2]=o,i[o+8>>2]=o;break C}A=i[B+8>>2],i[A+12>>2]=t,i[B+8>>2]=t,i[t+24>>2]=0,i[t+12>>2]=B,i[t+8>>2]=A}A=e+8|0;break A}A=i[B+8>>2],i[A+12>>2]=o,i[B+8>>2]=o,i[o+24>>2]=0,i[o+12>>2]=B,i[o+8>>2]=A}if(!((A=i[8968])>>>0<=r>>>0)){g=A-r|0,i[8968]=g,A=(B=i[8971])+r|0,i[8971]=A,i[A+4>>2]=1|g,i[B+4>>2]=3|r,A=B+8|0;break A}}i[8952]=48,A=0;break A}g:if(Q){B=i[E+28>>2];B:{if(i[(A=36164+(B<<2)|0)>>2]==(0|E)){if(i[A>>2]=g,g)break B;t=lI(-2,B)&t,i[8966]=t;break g}if(i[Q+(i[Q+16>>2]==(0|E)?16:20)>>2]=g,!g)break g}i[g+24>>2]=Q,(A=i[E+16>>2])&&(i[g+16>>2]=A,i[A+24>>2]=g),(A=i[E+20>>2])&&(i[g+20>>2]=A,i[A+24>>2]=g)}g:if(C>>>0<=15)A=C+r|0,i[E+4>>2]=3|A,i[4+(A=A+E|0)>>2]=1|i[A+4>>2];else if(i[E+4>>2]=3|r,i[4+(Q=E+r|0)>>2]=1|C,i[Q+C>>2]=C,C>>>0<=255)g=35900+((A=C>>>3|0)<<3)|0,(B=i[8965])&(A=1<<A)?A=i[g+8>>2]:(i[8965]=A|B,A=g),i[g+8>>2]=Q,i[A+12>>2]=Q,i[Q+12>>2]=g,i[Q+8>>2]=A;else{A=31,C>>>0<=16777215&&(A=C>>>8|0,A<<=e=A+1048320>>>16&8,A=28+((A=((A<<=B=A+520192>>>16&4)<<(g=A+245760>>>16&2)>>>15|0)-(g|B|e)|0)<<1|C>>>A+21&1)|0),i[Q+28>>2]=A,i[Q+16>>2]=0,i[Q+20>>2]=0,g=36164+(A<<2)|0;B:{if((B=1<<A)&t){for(A=C<<(31==(0|A)?0:25-(A>>>1|0)|0),B=i[g>>2];;){if((-8&i[(g=B)+4>>2])==(0|C))break B;if(B=A>>>29|0,A<<=1,!(B=i[16+(e=(4&B)+g|0)>>2]))break}i[e+16>>2]=Q}else i[8966]=B|t,i[g>>2]=Q;i[Q+24>>2]=g,i[Q+12>>2]=Q,i[Q+8>>2]=Q;break g}A=i[g+8>>2],i[A+12>>2]=Q,i[g+8>>2]=Q,i[Q+24>>2]=0,i[Q+12>>2]=g,i[Q+8>>2]=A}A=E+8|0;break A}I:if(t){B=i[g+28>>2];g:{if(i[(A=36164+(B<<2)|0)>>2]==(0|g)){if(i[A>>2]=E,E)break g;c=35864,y=lI(-2,B)&o,i[c>>2]=y;break I}if(i[t+(i[t+16>>2]==(0|g)?16:20)>>2]=E,!E)break I}i[E+24>>2]=t,(A=i[g+16>>2])&&(i[E+16>>2]=A,i[A+24>>2]=E),(A=i[g+20>>2])&&(i[E+20>>2]=A,i[A+24>>2]=E)}C>>>0<=15?(A=C+r|0,i[g+4>>2]=3|A,i[4+(A=A+g|0)>>2]=1|i[A+4>>2]):(i[g+4>>2]=3|r,i[4+(E=g+r|0)>>2]=1|C,i[C+E>>2]=C,f&&(B=35900+((A=f>>>3|0)<<3)|0,e=i[8970],(A=1<<A)&Q?A=i[B+8>>2]:(i[8965]=A|Q,A=B),i[B+8>>2]=e,i[A+12>>2]=e,i[e+12>>2]=B,i[e+8>>2]=A),i[8970]=E,i[8967]=C),A=g+8|0}return s=I+16|0,0|A}function H(A,I,g){var B,C,Q,E,n,a,o,t,e,f,c,y,s,w,D,p,u,F,l,_,k,H,G,U,S,b,m,v,M,P,Y,N,R,d,J,x,L,K,X,T,V,q,z,j,W,O,Z,$,AA,IA,gA,BA,CA=0,QA=0,EA=0,iA=0,nA=0,aA=0,rA=0,oA=0,tA=0,eA=0,fA=0,cA=0,yA=0,sA=0,wA=0,DA=0,hA=0,pA=0,uA=0,FA=0,lA=0,_A=0,kA=0,HA=0,GA=0,UA=0;B=CA=GA=i[g+4>>2],e=CA>>31,d=CA=(FA=i[I+20>>2])<<1,CA=qA(B,e,CA,k=CA>>31),EA=h,QA=CA,C=CA=i[g>>2],Q=CA>>31,f=CA=i[I+24>>2],cA=qA(C,Q,CA,E=CA>>31),CA=h+EA|0,CA=(QA=QA+cA|0)>>>0<cA>>>0?CA+1|0:CA,EA=QA,J=QA=iA=i[g+8>>2],p=QA>>31,c=QA=i[I+16>>2],QA=EA+(cA=qA(iA,p,QA,n=QA>>31))|0,EA=h+CA|0,EA=QA>>>0<cA>>>0?EA+1|0:EA,x=CA=nA=i[g+12>>2],u=CA>>31,L=CA=(cA=i[I+12>>2])<<1,CA=(yA=qA(nA,u,CA,H=CA>>31))+QA|0,QA=h+EA|0,QA=CA>>>0<yA>>>0?QA+1|0:QA,EA=CA,W=CA=DA=i[g+16>>2],l=CA>>31,y=CA=i[I+8>>2],yA=qA(DA,l,CA,a=CA>>31),CA=h+QA|0,CA=(EA=EA+yA|0)>>>0<yA>>>0?CA+1|0:CA,lA=EA,O=QA=oA=i[g+20>>2],G=QA>>31,K=QA=(yA=i[I+4>>2])<<1,EA=qA(oA,G,QA,U=QA>>31),CA=h+CA|0,CA=(QA=lA+EA|0)>>>0<EA>>>0?CA+1|0:CA,EA=QA,Z=QA=tA=i[g+24>>2],X=QA>>31,s=QA=i[I>>2],uA=qA(tA,X,QA,o=QA>>31),QA=h+CA|0,QA=(EA=EA+uA|0)>>>0<uA>>>0?QA+1|0:QA,S=i[g+28>>2],sA=CA=r(S,19),F=CA>>31,T=CA=(uA=i[I+36>>2])<<1,CA=(wA=qA(sA,F,CA,b=CA>>31))+EA|0,EA=h+QA|0,EA=CA>>>0<wA>>>0?EA+1|0:EA,QA=CA,V=i[g+32>>2],eA=CA=r(V,19),aA=CA>>31,w=CA=i[I+32>>2],wA=qA(eA,aA,CA,t=CA>>31),CA=h+EA|0,CA=(QA=QA+wA|0)>>>0<wA>>>0?CA+1|0:CA,$=i[g+36>>2],fA=g=r($,19),D=g>>31,q=I=(wA=i[I+28>>2])<<1,g=qA(g,D,I,m=I>>31),CA=h+CA|0,HA=I=g+QA|0,I=I>>>0<g>>>0?CA+1|0:CA,g=qA(c,n,B,e),CA=h,QA=qA(C,Q,FA,v=FA>>31),EA=h+CA|0,EA=(g=QA+g|0)>>>0<QA>>>0?EA+1|0:EA,CA=qA(iA,p,cA,M=cA>>31),QA=h+EA|0,QA=(g=CA+g|0)>>>0<CA>>>0?QA+1|0:QA,EA=qA(y,a,nA,u),CA=h+QA|0,CA=(g=EA+g|0)>>>0<EA>>>0?CA+1|0:CA,QA=qA(DA,l,yA,P=yA>>31),CA=h+CA|0,CA=(g=QA+g|0)>>>0<QA>>>0?CA+1|0:CA,QA=qA(s,o,oA,G),CA=h+CA|0,CA=(g=QA+g|0)>>>0<QA>>>0?CA+1|0:CA,EA=g,_A=g=r(tA,19),g=EA+(QA=qA(g,_=g>>31,uA,Y=uA>>31))|0,EA=h+CA|0,EA=g>>>0<QA>>>0?EA+1|0:EA,CA=qA(w,t,sA,F),QA=h+EA|0,QA=(g=CA+g|0)>>>0<CA>>>0?QA+1|0:QA,EA=qA(eA,aA,wA,N=wA>>31),CA=h+QA|0,CA=(g=EA+g|0)>>>0<EA>>>0?CA+1|0:CA,QA=qA(fA,D,f,E),CA=h+CA|0,lA=g=QA+g|0,g=g>>>0<QA>>>0?CA+1|0:CA,CA=qA(B,e,L,H),EA=h,QA=(tA=qA(C,Q,c,n))+CA|0,CA=h+EA|0,CA=QA>>>0<tA>>>0?CA+1|0:CA,tA=qA(y,a,iA,p),EA=h+CA|0,EA=(QA=tA+QA|0)>>>0<tA>>>0?EA+1|0:EA,CA=(tA=qA(nA,u,K,U))+QA|0,QA=h+EA|0,QA=CA>>>0<tA>>>0?QA+1|0:QA,EA=(tA=qA(s,o,DA,l))+CA|0,CA=h+QA|0,CA=EA>>>0<tA>>>0?CA+1|0:CA,hA=EA,z=QA=r(oA,19),EA=qA(QA,R=QA>>31,T,b),CA=h+CA|0,CA=(QA=hA+EA|0)>>>0<EA>>>0?CA+1|0:CA,EA=qA(w,t,_A,_),CA=h+CA|0,CA=(QA=EA+QA|0)>>>0<EA>>>0?CA+1|0:CA,oA=qA(sA,F,q,m),EA=h+CA|0,EA=(QA=oA+QA|0)>>>0<oA>>>0?EA+1|0:EA,CA=(oA=qA(eA,aA,f,E))+QA|0,QA=h+EA|0,QA=CA>>>0<oA>>>0?QA+1|0:QA,EA=(oA=qA(fA,D,d,k))+CA|0,CA=h+QA|0,CA=EA>>>0<oA>>>0?CA+1|0:CA,oA=EA,IA=CA,tA=QA=EA+33554432|0,gA=CA=QA>>>0<33554432?CA+1|0:CA,EA=lA,lA=(67108863&CA)<<6|QA>>>26,CA=(CA>>26)+g|0,CA=(EA=EA+lA|0)>>>0<lA>>>0?CA+1|0:CA,BA=g=(lA=EA)+16777216|0,CA=I+(QA=(EA=g>>>0<16777216?CA+1|0:CA)>>25)|0,CA=(g=(EA=(33554431&EA)<<7|g>>>25)+HA|0)>>>0<EA>>>0?CA+1|0:CA,kA=I=g+33554432|0,I=CA=I>>>0<33554432?CA+1|0:CA,CA=-67108864&kA,i[A+24>>2]=g-CA,g=qA(B,e,K,U),CA=h,QA=qA(C,Q,y,a),EA=h+CA|0,EA=(g=QA+g|0)>>>0<QA>>>0?EA+1|0:EA,QA=qA(s,o,iA,p),CA=h+EA|0,CA=(g=QA+g|0)>>>0<QA>>>0?CA+1|0:CA,EA=g,nA=g=r(nA,19),QA=qA(g,HA=g>>31,T,b),CA=h+CA|0,CA=(g=EA+QA|0)>>>0<QA>>>0?CA+1|0:CA,QA=g,AA=g=r(DA,19),g=QA+(EA=qA(w,t,g,j=g>>31))|0,QA=h+CA|0,QA=g>>>0<EA>>>0?QA+1|0:QA,EA=qA(q,m,z,R),CA=h+QA|0,CA=(g=EA+g|0)>>>0<EA>>>0?CA+1|0:CA,QA=qA(f,E,_A,_),EA=h+CA|0,EA=(g=QA+g|0)>>>0<QA>>>0?EA+1|0:EA,QA=qA(sA,F,d,k),CA=h+EA|0,CA=(g=QA+g|0)>>>0<QA>>>0?CA+1|0:CA,QA=qA(eA,aA,c,n),CA=h+CA|0,CA=(g=QA+g|0)>>>0<QA>>>0?CA+1|0:CA,EA=qA(fA,D,L,H),QA=h+CA|0,hA=g=EA+g|0,g=g>>>0<EA>>>0?QA+1|0:QA,CA=qA(s,o,B,e),EA=h,QA=(DA=qA(C,Q,yA,P))+CA|0,CA=h+EA|0,CA=QA>>>0<DA>>>0?CA+1|0:CA,EA=QA,DA=QA=r(iA,19),QA=EA+(iA=qA(QA,rA=QA>>31,uA,Y))|0,EA=h+CA|0,EA=QA>>>0<iA>>>0?EA+1|0:EA,iA=qA(w,t,nA,HA),CA=h+EA|0,CA=(QA=iA+QA|0)>>>0<iA>>>0?CA+1|0:CA,EA=qA(AA,j,wA,N),CA=h+CA|0,CA=(QA=EA+QA|0)>>>0<EA>>>0?CA+1|0:CA,EA=(iA=qA(f,E,z,R))+QA|0,QA=h+CA|0,QA=EA>>>0<iA>>>0?QA+1|0:QA,iA=qA(_A,_,FA,v),CA=h+QA|0,CA=(EA=iA+EA|0)>>>0<iA>>>0?CA+1|0:CA,QA=(iA=qA(c,n,sA,F))+EA|0,EA=h+CA|0,EA=QA>>>0<iA>>>0?EA+1|0:EA,iA=qA(eA,aA,cA,M),CA=h+EA|0,CA=(QA=iA+QA|0)>>>0<iA>>>0?CA+1|0:CA,EA=qA(fA,D,y,a),CA=h+CA|0,UA=QA=EA+QA|0,iA=QA>>>0<EA>>>0?CA+1|0:CA,CA=qA(CA=r(B,19),CA>>31,T,b),QA=h,EA=qA(C,Q,s,o),QA=h+QA|0,QA=(CA=EA+CA|0)>>>0<EA>>>0?QA+1|0:QA,EA=(GA=qA(w,t,DA,rA))+CA|0,CA=h+QA|0,QA=(nA=qA(nA,HA,q,m))+EA|0,EA=h+(EA>>>0<GA>>>0?CA+1|0:CA)|0,EA=QA>>>0<nA>>>0?EA+1|0:EA,nA=qA(f,E,AA,j),CA=h+EA|0,CA=(QA=nA+QA|0)>>>0<nA>>>0?CA+1|0:CA,EA=qA(d,k,z,R),CA=h+CA|0,CA=(QA=EA+QA|0)>>>0<EA>>>0?CA+1|0:CA,EA=(nA=qA(c,n,_A,_))+QA|0,QA=h+CA|0,QA=EA>>>0<nA>>>0?QA+1|0:QA,nA=qA(sA,F,L,H),CA=h+QA|0,CA=(EA=nA+EA|0)>>>0<nA>>>0?CA+1|0:CA,QA=(nA=qA(eA,aA,y,a))+EA|0,EA=h+CA|0,EA=QA>>>0<nA>>>0?EA+1|0:EA,nA=qA(fA,D,K,U),CA=h+EA|0,CA=(QA=nA+QA|0)>>>0<nA>>>0?CA+1|0:CA,nA=QA,GA=CA,HA=QA=QA+33554432|0,DA=CA=QA>>>0<33554432?CA+1|0:CA,rA=(67108863&CA)<<6|QA>>>26,QA=(EA=CA>>26)+iA|0,iA=CA=rA+UA|0,CA=CA>>>0<rA>>>0?QA+1|0:QA,UA=QA=iA+16777216|0,EA=hA,hA=(33554431&(CA=QA>>>0<16777216?CA+1|0:CA))<<7|QA>>>25,CA=(CA>>25)+g|0,CA=(QA=EA+hA|0)>>>0<hA>>>0?CA+1|0:CA,hA=g=QA+33554432|0,g=CA=g>>>0<33554432?CA+1|0:CA,CA=-67108864&hA,i[A+8>>2]=QA-CA,CA=qA(f,E,B,e),EA=h,QA=(rA=qA(C,Q,wA,N))+CA|0,CA=h+EA|0,CA=QA>>>0<rA>>>0?CA+1|0:CA,EA=qA(J,p,FA,v),CA=h+CA|0,CA=(QA=EA+QA|0)>>>0<EA>>>0?CA+1|0:CA,EA=qA(c,n,x,u),CA=h+CA|0,CA=(QA=EA+QA|0)>>>0<EA>>>0?CA+1|0:CA,rA=qA(W,l,cA,M),EA=h+CA|0,EA=(QA=rA+QA|0)>>>0<rA>>>0?EA+1|0:EA,CA=(rA=qA(y,a,O,G))+QA|0,QA=h+EA|0,QA=CA>>>0<rA>>>0?QA+1|0:QA,EA=(rA=qA(yA,P,Z,X))+CA|0,CA=h+QA|0,CA=EA>>>0<rA>>>0?CA+1|0:CA,QA=EA,EA=qA(s,o,S,rA=S>>31),CA=h+CA|0,CA=(QA=QA+EA|0)>>>0<EA>>>0?CA+1|0:CA,EA=qA(eA,aA,uA,Y),CA=h+CA|0,CA=(QA=EA+QA|0)>>>0<EA>>>0?CA+1|0:CA,pA=qA(fA,D,w,t),EA=h+CA|0,CA=I>>26,I=(kA=(67108863&I)<<6|kA>>>26)+(QA=pA+QA|0)|0,QA=CA+(EA=QA>>>0<pA>>>0?EA+1|0:EA)|0,CA=QA=I>>>0<kA>>>0?QA+1|0:QA,kA=I=(EA=I)+16777216|0,I=CA=I>>>0<16777216?CA+1|0:CA,CA=-33554432&kA,i[A+28>>2]=EA-CA,CA=qA(y,a,B,e),QA=h,pA=qA(C,Q,cA,M),EA=h+QA|0,EA=(CA=pA+CA|0)>>>0<pA>>>0?EA+1|0:EA,pA=qA(J,p,yA,P),QA=h+EA|0,QA=(CA=pA+CA|0)>>>0<pA>>>0?QA+1|0:QA,EA=(pA=qA(s,o,x,u))+CA|0,CA=h+QA|0,CA=EA>>>0<pA>>>0?CA+1|0:CA,QA=EA,EA=qA(AA,j,uA,Y),CA=h+CA|0,CA=(QA=QA+EA|0)>>>0<EA>>>0?CA+1|0:CA,EA=qA(w,t,z,R),CA=h+CA|0,CA=(QA=EA+QA|0)>>>0<EA>>>0?CA+1|0:CA,QA=(_A=qA(_A,_,wA,N))+QA|0,EA=h+CA|0,CA=(sA=qA(f,E,sA,F))+QA|0,QA=h+(QA>>>0<_A>>>0?EA+1|0:EA)|0,EA=(eA=qA(eA,aA,FA,v))+CA|0,CA=h+(CA>>>0<sA>>>0?QA+1|0:QA)|0,CA=EA>>>0<eA>>>0?CA+1|0:CA,QA=EA,EA=qA(fA,D,c,n),CA=h+CA|0,eA=QA=QA+EA|0,CA=(CA=QA>>>0<EA>>>0?CA+1|0:CA)+(QA=g>>26)|0,CA=(g=eA+(EA=(67108863&g)<<6|hA>>>26)|0)>>>0<EA>>>0?CA+1|0:CA,eA=g=(QA=g)+16777216|0,g=EA=g>>>0<16777216?CA+1|0:CA,CA=-33554432&eA,i[A+12>>2]=QA-CA,CA=qA(B,e,q,m),EA=h,QA=(aA=qA(C,Q,w,t))+CA|0,CA=h+EA|0,CA=QA>>>0<aA>>>0?CA+1|0:CA,EA=qA(f,E,J,p),CA=h+CA|0,CA=(QA=EA+QA|0)>>>0<EA>>>0?CA+1|0:CA,aA=qA(x,u,d,k),EA=h+CA|0,EA=(QA=aA+QA|0)>>>0<aA>>>0?EA+1|0:EA,CA=(aA=qA(c,n,W,l))+QA|0,QA=h+EA|0,QA=CA>>>0<aA>>>0?QA+1|0:QA,EA=(aA=qA(L,H,O,G))+CA|0,CA=h+QA|0,CA=EA>>>0<aA>>>0?CA+1|0:CA,QA=EA,EA=qA(y,a,Z,X),CA=h+CA|0,CA=(QA=QA+EA|0)>>>0<EA>>>0?CA+1|0:CA,EA=qA(S,rA,K,U),CA=h+CA|0,CA=(QA=EA+QA|0)>>>0<EA>>>0?CA+1|0:CA,QA=(sA=qA(s,o,V,aA=V>>31))+QA|0,EA=h+CA|0,CA=(fA=qA(fA,D,T,b))+QA|0,QA=h+(QA>>>0<sA>>>0?EA+1|0:EA)|0,QA=CA>>>0<fA>>>0?QA+1|0:QA,hA=CA,CA=(CA=I>>25)+QA|0,CA=(I=hA+(EA=(33554431&I)<<7|kA>>>25)|0)>>>0<EA>>>0?CA+1|0:CA,fA=I=(QA=I)+33554432|0,I=CA=I>>>0<33554432?CA+1|0:CA,CA=-67108864&fA,i[A+32>>2]=QA-CA,EA=QA=oA-(CA=-67108864&tA)|0,CA=(CA=IA-((CA>>>0>oA>>>0)+gA|0)|0)+(QA=g>>25)|0,CA=(g=EA+(oA=(33554431&g)<<7|eA>>>25)|0)>>>0<oA>>>0?CA+1|0:CA,CA=(lA-(-33554432&BA)|0)+((67108863&(CA=(QA=g+33554432|0)>>>0<33554432?CA+1|0:CA))<<6|QA>>>26)|0,i[A+20>>2]=CA,CA=-67108864&QA,i[A+16>>2]=g-CA,g=qA(w,t,B,e),CA=h,QA=qA(C,Q,uA,Y),CA=h+CA|0,CA=(g=QA+g|0)>>>0<QA>>>0?CA+1|0:CA,EA=qA(J,p,wA,N),QA=h+CA|0,QA=(g=EA+g|0)>>>0<EA>>>0?QA+1|0:QA,CA=qA(f,E,x,u),EA=h+QA|0,EA=(g=CA+g|0)>>>0<CA>>>0?EA+1|0:EA,QA=qA(W,l,FA,v),CA=h+EA|0,CA=(g=QA+g|0)>>>0<QA>>>0?CA+1|0:CA,QA=qA(c,n,O,G),CA=h+CA|0,CA=(g=QA+g|0)>>>0<QA>>>0?CA+1|0:CA,QA=qA(cA,M,Z,X),CA=h+CA|0,CA=(g=QA+g|0)>>>0<QA>>>0?CA+1|0:CA,EA=qA(y,a,S,rA),QA=h+CA|0,QA=(g=EA+g|0)>>>0<EA>>>0?QA+1|0:QA,CA=qA(V,aA,yA,P),EA=h+QA|0,EA=(g=CA+g|0)>>>0<CA>>>0?EA+1|0:EA,QA=qA(s,o,$,$>>31),CA=h+EA|0,CA=(CA=(g=QA+g|0)>>>0<QA>>>0?CA+1|0:CA)+(QA=I>>26)|0,CA=(I=(EA=g)+(g=(67108863&I)<<6|fA>>>26)|0)>>>0<g>>>0?CA+1|0:CA,CA=(g=I+16777216|0)>>>0<16777216?CA+1|0:CA,QA=-33554432&g,i[A+36>>2]=I-QA,EA=iA-(-33554432&UA)|0,QA=nA-(I=-67108864&HA)|0,FA=GA-((I>>>0>nA>>>0)+DA|0)|0,I=(g=qA((33554431&(I=CA))<<7|g>>>25,CA>>=25,19,0))+QA|0,QA=h+FA|0,CA=QA=I>>>0<g>>>0?QA+1|0:QA,g=((67108863&(CA=(g=I+33554432|0)>>>0<33554432?CA+1|0:CA))<<6|(QA=g)>>>26)+EA|0,i[A+4>>2]=g,g=A,A=-67108864&QA,i[g>>2]=I-A}function G(A,I){var g,B,C,Q,E,n,a,o,t,e,f,c,y,w,D,p,u,F,l,_,k,H,G,S,b,m,v,M,P,Y,N,R,d,J,x,L,K,X,T,V,q,z=0,j=0,W=0,O=0,Z=0,$=0,AA=0,IA=0,gA=0,BA=0,CA=0,QA=0,EA=0,iA=0,nA=0,aA=0,rA=0,oA=0,tA=0,eA=0,fA=0;s=H=s-48|0,U(A,I),U(F=A+80|0,N=I+40|0),g=A+120|0,a=z=(rA=i[I+92>>2])<<1,o=z>>31,t=z=(CA=i[I+84>>2])<<1,z=qA(a,o,z,B=z>>31),Z=h,j=z,m=z=$=i[I+88>>2],W=qA(z,AA=z>>31,z,AA),z=h+Z|0,z=(j=j+W|0)>>>0<W>>>0?z+1|0:z,W=j,C=j=i[I+96>>2],e=j>>31,f=j=(EA=i[I+80>>2])<<1,Z=qA(C,e,j,Q=j>>31),z=h+z|0,z=(j=W+Z|0)>>>0<Z>>>0?z+1|0:z,O=j,Z=i[I+108>>2],G=j=r(Z,38),R=Z,W=qA(j,l=j>>31,Z,v=Z>>31),z=h+z|0,z=(j=O+W|0)>>>0<W>>>0?z+1|0:z,W=j,D=i[I+112>>2],oA=qA(c=j=r(D,19),y=j>>31,j=(gA=i[I+104>>2])<<1,j>>31),j=h+z|0,j=(W=W+oA|0)>>>0<oA>>>0?j+1|0:j,O=W,oA=i[I+116>>2],E=z=r(oA,38),n=z>>31,_=z=(W=i[I+100>>2])<<1,aA=qA(E,n,z,p=z>>31),j=h+j|0,j=(z=O+aA|0)>>>0<aA>>>0?j+1|0:j,aA=z,K=z=j<<1|z>>>31,d=j=33554432+(aA<<=1)|0,X=z=j>>>0<33554432?z+1|0:z,j=z>>26,z=(67108863&z)<<6|d>>>26,tA=j,j=qA(t,B,C,e),IA=h,O=z,k=z=$<<1,rA=qA(z,u=z>>31,$=rA,M=$>>31),z=h+IA|0,z=(j=rA+j|0)>>>0<rA>>>0?z+1|0:z,rA=W,IA=(BA=qA(W,S=W>>31,f,Q))+j|0,j=h+z|0,j=IA>>>0<BA>>>0?j+1|0:j,QA=IA,J=z=Z<<1,IA=qA(c,y,z,P=z>>31),z=h+j|0,z=(Z=QA+IA|0)>>>0<IA>>>0?z+1|0:z,j=Z,Z=qA(E,n,gA,w=gA>>31),z=h+z|0,z=(j=j+Z|0)>>>0<Z>>>0?z+1|0:z,Z=j,j=(j=z<<1|j>>>31)+tA|0,tA=z=O+(Z<<=1)|0,z=z>>>0<Z>>>0?j+1|0:j,T=j=tA+16777216|0,Z=j,j=(z=j>>>0<16777216?z+1|0:z)>>25,z=(33554431&z)<<7|Z>>>25,Z=j,j=qA(a,o,$,M),IA=h,O=z,BA=qA(C,e,k,u),z=h+IA|0,z=(j=BA+j|0)>>>0<BA>>>0?z+1|0:z,IA=qA(t,B,_,p),z=h+z|0,z=(j=IA+j|0)>>>0<IA>>>0?z+1|0:z,IA=(BA=qA(f,Q,gA,w))+j|0,j=h+z|0,j=IA>>>0<BA>>>0?j+1|0:j,BA=qA(c,y,D,b=D>>31),z=h+j|0,z=(IA=BA+IA|0)>>>0<BA>>>0?z+1|0:z,BA=qA(E,n,J,P),j=h+z|0,j=(IA=BA+IA|0)>>>0<BA>>>0?j+1|0:j,BA=(z=IA)<<1,z=(j<<1|z>>>31)+Z|0,z=(IA=O+BA|0)>>>0<BA>>>0?z+1|0:z,fA=Z=(j=IA)+33554432|0,Z=z=Z>>>0<33554432?z+1|0:z,z=-67108864&fA,i[g+24>>2]=j-z,z=qA(z=r(W,38),z>>31,W,S),j=h,O=z,W=qA(EA,z=EA>>31,EA,z),j=h+j|0,j=(z=O+W|0)>>>0<W>>>0?j+1|0:j,W=z,QA=z=r(gA,19),nA=z>>31,x=z=C<<1,EA=qA(QA,nA,z,Y=z>>31),z=h+j|0,z=(W=W+EA|0)>>>0<EA>>>0?z+1|0:z,j=W,W=qA(a,o,G,l),z=h+z|0,z=(j=j+W|0)>>>0<W>>>0?z+1|0:z,W=(EA=qA(c,y,k,u))+j|0,j=h+z|0,j=W>>>0<EA>>>0?j+1|0:j,EA=qA(t,B,E,n),z=h+j|0,z=(W=EA+W|0)>>>0<EA>>>0?z+1|0:z,EA=(j=W)<<1,q=z=z<<1|j>>>31,j=z,IA=z=EA+33554432|0,BA=j=z>>>0<33554432?j+1|0:j,z=j>>26,j=(67108863&j)<<6|IA>>>26,W=z,z=qA(QA,nA,_,p),iA=h,eA=j,j=(CA=qA(f,Q,O=CA,L=O>>31))+z|0,z=h+iA|0,z=j>>>0<CA>>>0?z+1|0:z,CA=(iA=qA(C,e,G,l))+j|0,j=h+z|0,j=CA>>>0<iA>>>0?j+1|0:j,iA=qA(a,o,c,y),z=h+j|0,z=(CA=iA+CA|0)>>>0<iA>>>0?z+1|0:z,iA=qA(E,n,m,AA),j=h+z|0,j=(CA=iA+CA|0)>>>0<iA>>>0?j+1|0:j,iA=(z=CA)<<1,z=(j<<1|z>>>31)+W|0,z=(CA=eA+iA|0)>>>0<iA>>>0?z+1|0:z,iA=j=CA+16777216|0,W=j,j=(z=j>>>0<16777216?z+1|0:z)>>25,z=(33554431&z)<<7|W>>>25,W=j,j=qA(f,Q,m,AA),V=h,eA=z,O=qA(O,L,t,B),z=h+V|0,z=(j=O+j|0)>>>0<O>>>0?z+1|0:z,O=(QA=qA(QA,nA,gA,w))+j|0,j=h+z|0,j=O>>>0<QA>>>0?j+1|0:j,QA=qA(_,p,G,l),z=h+j|0,z=(O=QA+O|0)>>>0<QA>>>0?z+1|0:z,j=O,O=qA(c,y,x,Y),z=h+z|0,z=(j=j+O|0)>>>0<O>>>0?z+1|0:z,O=(QA=qA(E,n,a,o))+j|0,j=h+z|0,z=(z=(j=O>>>0<QA>>>0?j+1|0:j)<<1|O>>>31)+W|0,z=(j=eA+(O<<=1)|0)>>>0<O>>>0?z+1|0:z,W=j,O=j,j=z,QA=z=W+33554432|0,W=j=z>>>0<33554432?j+1|0:j,z&=-67108864,i[g+8>>2]=O-z,z=qA(k,u,rA,S),j=h,O=qA(a,o,C,e),j=h+j|0,j=(z=O+z|0)>>>0<O>>>0?j+1|0:j,O=(nA=qA(t,B,gA,w))+z|0,z=h+j|0,z=O>>>0<nA>>>0?z+1|0:z,nA=qA(f,Q,R,v),j=h+z|0,j=(O=nA+O|0)>>>0<nA>>>0?j+1|0:j,nA=qA(E,n,D,b),z=h+j|0,eA=(j=O=nA+O|0)<<1,z=(z=(j>>>0<nA>>>0?z+1|0:z)<<1|j>>>31)+(j=Z>>26)|0,z=(Z=eA+(O=(67108863&Z)<<6|fA>>>26)|0)>>>0<O>>>0?z+1|0:z,O=Z,j=z,fA=z=Z+16777216|0,Z=j=z>>>0<16777216?j+1|0:j,z&=-33554432,i[g+28>>2]=O-z,z=qA(f,Q,$,M),$=h,j=(AA=qA(t,B,m,AA))+z|0,z=h+$|0,z=j>>>0<AA>>>0?z+1|0:z,AA=qA(gA,w,G,l),z=h+z|0,z=(j=AA+j|0)>>>0<AA>>>0?z+1|0:z,AA=($=qA(c,y,_,p))+j|0,j=h+z|0,j=$>>>0>AA>>>0?j+1|0:j,z=AA,AA=qA(E,n,C,e),j=h+j|0,j=(z=z+AA|0)>>>0<AA>>>0?j+1|0:j,AA=z,z=(z=j<<1|z>>>31)+(j=W>>26)|0,z=(W=(O=AA<<1)+(AA=(67108863&W)<<6|QA>>>26)|0)>>>0<AA>>>0?z+1|0:z,AA=W=(j=W)+16777216|0,W=z=W>>>0<16777216?z+1|0:z,z=-33554432&AA,i[g+12>>2]=j-z,z=qA(gA,w,k,u),$=h,j=(O=qA(C,e,C,e))+z|0,z=h+$|0,z=j>>>0<O>>>0?z+1|0:z,$=qA(a,o,_,p),z=h+z|0,z=(j=$+j|0)>>>0<$>>>0?z+1|0:z,$=qA(t,B,J,P),z=h+z|0,z=(j=$+j|0)>>>0<$>>>0?z+1|0:z,$=(O=qA(f,Q,D,b))+j|0,j=h+z|0,j=O>>>0>$>>>0?j+1|0:j,z=$,$=qA(E,n,oA,O=oA>>31),j=h+j|0,j=(z=z+$|0)>>>0<$>>>0?j+1|0:j,$=z,z=(z=j<<1|z>>>31)+(j=Z>>25)|0,z=(Z=(QA=$<<1)+($=(33554431&Z)<<7|fA>>>25)|0)>>>0<$>>>0?z+1|0:z,$=Z=(j=Z)+33554432|0,Z=z=Z>>>0<33554432?z+1|0:z,z=-67108864&$,i[g+32>>2]=j-z,j=aA-(z=-67108864&d)|0,aA=K-((z>>>0>aA>>>0)+X|0)|0,z=W>>25,W=(AA=(33554431&W)<<7|AA>>>25)+j|0,j=z+aA|0,z=j=W>>>0<AA>>>0?j+1|0:j,z=((67108863&(z=(j=W+33554432|0)>>>0<33554432?z+1|0:z))<<6|j>>>26)+(tA=tA-(-33554432&T)|0)|0,i[g+20>>2]=z,z=-67108864&j,i[g+16>>2]=W-z,z=qA(a,o,gA,w),j=h,W=qA(rA,S,x,Y),j=h+j|0,j=(z=W+z|0)>>>0<W>>>0?j+1|0:j,W=(gA=qA(k,u,R,v))+z|0,z=h+j|0,z=W>>>0<gA>>>0?z+1|0:z,gA=qA(t,B,D,b),j=h+z|0,j=(W=gA+W|0)>>>0<gA>>>0?j+1|0:j,gA=qA(f,Q,oA,O),z=h+j|0,O=(j=W=gA+W|0)<<1,z=(z=(j>>>0<gA>>>0?z+1|0:z)<<1|j>>>31)+(j=Z>>26)|0,j=z=(W=(67108863&Z)<<6|$>>>26)>>>0>(Z=O+W|0)>>>0?z+1|0:z,j=(z=Z+16777216|0)>>>0<16777216?j+1|0:j,W=-33554432&z,i[g+36>>2]=Z-W,gA=qA((33554431&j)<<7|z>>>25,j>>25,19,0),j=h+(q-(((W=-67108864&IA)>>>0>EA>>>0)+BA|0)|0)|0,j=(z=gA+(EA-W|0)|0)>>>0<gA>>>0?j+1|0:j,j=(CA-(-33554432&iA)|0)+((67108863&(j=(Z=z+33554432|0)>>>0<33554432?j+1|0:j))<<6|Z>>>26)|0,i[g+4>>2]=j,j=-67108864&Z,i[g>>2]=z-j,yA(z=A+40|0,I,N),U(H,z),yA(z,F,A),cA(F,F,A),cA(A,H,z),cA(g,g,F),s=H+48|0}function U(A,I){var g,B,C,Q,E,n,a,o,t,e,f,c,y,s,w,D,p,u,F,l,_,k,H,G,U,S,b,m,v,M,P,Y,N,R,d,J=0,x=0,L=0,K=0,X=0,T=0,V=0,q=0,z=0,j=0,W=0,O=0,Z=0,$=0,AA=0,IA=0,gA=0,BA=0,CA=0;e=x=(J=i[I+12>>2])<<1,z=J,J=qA(x,E=x>>31,J,U=J>>31),K=h,x=J,n=(J=g=i[I+16>>2])>>31,p=J=(V=i[I+8>>2])<<1,L=qA(g,n,J,y=J>>31),J=h+K|0,J=(x=x+L|0)>>>0<L>>>0?J+1|0:J,K=x,s=x=(L=i[I+20>>2])<<1,w=x>>31,a=x=(T=i[I+4>>2])<<1,W=qA(s,w,x,B=x>>31),x=h+J|0,x=(K=K+W|0)>>>0<W>>>0?x+1|0:x,l=J=X=i[I+24>>2],f=J>>31,o=J=(Z=i[I>>2])<<1,W=qA(X,f,J,C=J>>31),J=h+x|0,J=(K=W+K|0)>>>0<W>>>0?J+1|0:J,j=K,W=i[I+32>>2],D=x=r(W,19),K=qA(x,c=x>>31,W,_=W>>31),J=h+J|0,J=(x=j+K|0)>>>0<K>>>0?J+1|0:J,j=x,k=i[I+36>>2],t=x=r(k,38),Q=x>>31,M=I=(K=i[I+28>>2])<<1,gA=qA(x,Q,I,S=I>>31),I=h+J|0,j=x=j+gA|0,O=x>>>0<gA>>>0?I+1|0:I,I=qA(a,B,g,n),J=h,x=qA(p,y,z,U),J=h+J|0,J=(I=x+I|0)>>>0<x>>>0?J+1|0:J,gA=L,q=qA(L,H=L>>31,o,C),x=h+J|0,x=(I=q+I|0)>>>0<q>>>0?x+1|0:x,q=qA(D,c,M,S),J=h+x|0,J=(I=q+I|0)>>>0<q>>>0?J+1|0:J,x=qA(t,Q,X,f),J=h+J|0,$=I=x+I|0,BA=I>>>0<x>>>0?J+1|0:J,I=qA(a,B,e,E),x=h,J=(q=qA(V,u=V>>31,V,u))+I|0,I=h+x|0,I=J>>>0<q>>>0?I+1|0:I,x=(q=qA(o,C,g,n))+J|0,J=h+I|0,J=x>>>0<q>>>0?J+1|0:J,G=I=r(K,38),q=K,I=(K=qA(I,F=I>>31,K,b=K>>31))+x|0,x=h+J|0,x=I>>>0<K>>>0?x+1|0:x,I=(J=I)+(K=qA(D,c,I=X<<1,I>>31))|0,J=h+x|0,J=I>>>0<K>>>0?J+1|0:J,x=qA(t,Q,s,w),J=h+J|0,m=I=x+I|0,N=J=I>>>0<x>>>0?J+1|0:J,I=J,P=J=m+33554432|0,R=I=J>>>0<33554432?I+1|0:I,J=(J=I>>26)+BA|0,BA=I=(x=(67108863&I)<<6|P>>>26)+$|0,x=I>>>0<x>>>0?J+1|0:J,d=I=I+16777216|0,J=(J=(x=I>>>0<16777216?x+1|0:x)>>25)+O|0,J=(I=(x=(33554431&x)<<7|I>>>25)+j|0)>>>0<x>>>0?J+1|0:J,x=I,I=J,AA=J=x+33554432|0,K=I=J>>>0<33554432?I+1|0:I,I=-67108864&J,i[A+24>>2]=x-I,I=qA(o,C,V,u),J=h,j=qA(a,B,T,O=T>>31),x=h+J|0,x=(I=j+I|0)>>>0<j>>>0?x+1|0:x,J=I,j=I=r(X,19),I=J+(X=qA(I,$=I>>31,X,f))|0,J=h+x|0,J=I>>>0<X>>>0?J+1|0:J,x=(X=qA(s,w,G,F))+I|0,I=h+J|0,I=x>>>0<X>>>0?I+1|0:I,Y=J=g<<1,X=qA(D,c,J,v=J>>31),J=h+I|0,J=(x=X+x|0)>>>0<X>>>0?J+1|0:J,I=x,x=qA(t,Q,e,E),J=h+J|0,CA=I=I+x|0,X=I>>>0<x>>>0?J+1|0:J,I=qA(s,w,j,$),J=h,T=qA(o,C,T,O),x=h+J|0,x=(I=T+I|0)>>>0<T>>>0?x+1|0:x,T=qA(g,n,G,F),J=h+x|0,J=(I=T+I|0)>>>0<T>>>0?J+1|0:J,x=(T=qA(D,c,e,E))+I|0,I=h+J|0,I=x>>>0<T>>>0?I+1|0:I,T=qA(t,Q,V,u),J=h+I|0,IA=x=T+x|0,O=x>>>0<T>>>0?J+1|0:J,I=qA(I=r(L,38),I>>31,L,H),J=h,L=I,x=qA(Z,I=Z>>31,Z,I),J=h+J|0,J=(I=L+x|0)>>>0<x>>>0?J+1|0:J,L=qA(j,$,Y,v),x=h+J|0,x=(I=L+I|0)>>>0<L>>>0?x+1|0:x,L=qA(e,E,G,F),J=h+x|0,J=(I=L+I|0)>>>0<L>>>0?J+1|0:J,x=(L=qA(D,c,p,y))+I|0,I=h+J|0,I=x>>>0<L>>>0?I+1|0:I,L=qA(a,B,t,Q),J=h+I|0,T=x=L+x|0,j=J=x>>>0<L>>>0?J+1|0:J,Z=I=x+33554432|0,$=J=I>>>0<33554432?J+1|0:J,x=(I=J>>26)+O|0,O=J=(L=(67108863&J)<<6|Z>>>26)+IA|0,IA=CA,J=J>>>0<L>>>0?x+1|0:x,CA=I=O+16777216|0,L=(33554431&(J=I>>>0<16777216?J+1|0:J))<<7|I>>>25,J=(J>>25)+X|0,J=(x=IA+L|0)>>>0<L>>>0?J+1|0:J,X=x=(I=x)+33554432|0,L=J=x>>>0<33554432?J+1|0:J,J=-67108864&x,i[A+8>>2]=I-J,I=qA(p,y,gA,H),J=h,x=qA(g,n,e,E),J=h+J|0,J=(I=x+I|0)>>>0<x>>>0?J+1|0:J,x=qA(a,B,l,f),J=h+J|0,J=(I=x+I|0)>>>0<x>>>0?J+1|0:J,x=qA(o,C,q,b),J=h+J|0,J=(I=x+I|0)>>>0<x>>>0?J+1|0:J,x=(IA=qA(t,Q,W,_))+I|0,I=h+J|0,J=K>>26,K=(AA=(67108863&K)<<6|AA>>>26)+x|0,x=(I=x>>>0<IA>>>0?I+1|0:I)+J|0,J=(I=K)>>>0<AA>>>0?x+1|0:x,AA=x=I+16777216|0,K=J=x>>>0<16777216?J+1|0:J,J=-33554432&x,i[A+28>>2]=I-J,I=qA(o,C,z,U),x=h,J=(V=qA(a,B,V,u))+I|0,I=h+x|0,I=J>>>0<V>>>0?I+1|0:I,V=qA(l,f,G,F),x=h+I|0,x=(J=V+J|0)>>>0<V>>>0?x+1|0:x,I=(V=qA(D,c,s,w))+J|0,J=h+x|0,J=I>>>0<V>>>0?J+1|0:J,x=qA(t,Q,g,n),J=h+J|0,J=(J=(I=x+I|0)>>>0<x>>>0?J+1|0:J)+(x=L>>26)|0,x=I=(L=(67108863&L)<<6|X>>>26)+I|0,I=I>>>0<L>>>0?J+1|0:J,V=J=x+16777216|0,L=I=J>>>0<16777216?I+1|0:I,I=-33554432&J,i[A+12>>2]=x-I,I=qA(l,f,p,y),J=h,x=qA(g,n,g,n),J=h+J|0,J=(I=x+I|0)>>>0<x>>>0?J+1|0:J,x=qA(e,E,s,w),J=h+J|0,J=(I=x+I|0)>>>0<x>>>0?J+1|0:J,x=(z=qA(a,B,M,S))+I|0,I=h+J|0,I=x>>>0<z>>>0?I+1|0:I,J=(z=qA(o,C,W,_))+x|0,x=h+I|0,x=J>>>0<z>>>0?x+1|0:x,I=(z=qA(t,Q,k,X=k>>31))+J|0,J=h+x|0,J=I>>>0<z>>>0?J+1|0:J,x=I,J=(I=K>>25)+J|0,J=(x=x+(K=(33554431&K)<<7|AA>>>25)|0)>>>0<K>>>0?J+1|0:J,z=x=(I=x)+33554432|0,K=J=x>>>0<33554432?J+1|0:J,J=-67108864&x,i[A+32>>2]=I-J,J=L>>25,x=(L=(33554431&L)<<7|V>>>25)+(m-(I=-67108864&P)|0)|0,I=J+(N-((I>>>0>m>>>0)+R|0)|0)|0,J=I=x>>>0<L>>>0?I+1|0:I,L=I=x+33554432|0,I=((67108863&(J=I>>>0<33554432?J+1|0:J))<<6|I>>>26)+(BA=BA-(-33554432&d)|0)|0,i[A+20>>2]=I,I=-67108864&L,i[A+16>>2]=x-I,I=qA(e,E,l,f),x=h,J=(L=qA(gA,H,Y,v))+I|0,I=h+x|0,I=J>>>0<L>>>0?I+1|0:I,x=(L=qA(p,y,q,b))+J|0,J=h+I|0,J=x>>>0<L>>>0?J+1|0:J,I=(L=qA(a,B,W,_))+x|0,x=h+J|0,x=I>>>0<L>>>0?x+1|0:x,L=qA(o,C,k,X),J=h+x|0,x=I=L+I|0,J=(I=I>>>0<L>>>0?J+1|0:J)+(J=K>>26)|0,I=J=(x=(K=(67108863&K)<<6|z>>>26)+x|0)>>>0<K>>>0?J+1|0:J,I=(J=x+16777216|0)>>>0<16777216?I+1|0:I,K=-33554432&J,i[A+36>>2]=x-K,L=qA((33554431&I)<<7|J>>>25,I>>25,19,0),J=h+(j-(((x=-67108864&Z)>>>0>T>>>0)+$|0)|0)|0,x=I=L+(T-x|0)|0,I=I>>>0<L>>>0?J+1|0:J,I=(O-(-33554432&CA)|0)+((67108863&(I=(J=x+33554432|0)>>>0<33554432?I+1|0:I))<<6|J>>>26)|0,i[A+4>>2]=I,I=A,A=-67108864&J,i[I>>2]=x-A}function S(A,I,g){var B,C=0,Q=0,E=0,n=0,a=0,r=0,o=0,t=0,e=0,f=0,c=0,y=0,w=0,D=0,p=0,u=0,F=0,l=0,_=0,k=0,H=0,G=0,U=0,S=0,b=0,m=0,v=0,M=0,P=0,Y=0,N=0,R=0,d=0,J=0,x=0,L=0,K=0,X=0;for(s=B=s-2048|0,yg(w=B+1024|0,I),AI(w,A),yg(B,w),AI(B,g),I=0,w=0;r=i[(f=(A=(B+1024|0)+(w<<7)|0)- -64|0)>>2],Q=i[A+100>>2],a=r,t=i[f+4>>2],o=i[A+96>>2],r=i[A+32>>2],E=i[A+36>>2],n=pA(o^(C=CI(i[A>>2],i[A+4>>2],r,E)),(n=Q)^(Q=h),32),E=pA(t=(a=CI(a,t,n,o=h))^r,E^(r=h),24),t=r,U=pA((p=CI(C,Q,E,r=h))^n,(D=h)^o,16),r=pA(E^(b=CI(a,t,U,S=h)),(R=h)^r,63),Q=h,E=i[A+108>>2],t=i[A+72>>2],y=i[A+76>>2],c=i[A+104>>2],C=i[A+40>>2],n=i[A+44>>2],a=pA(c^(o=CI(i[A+8>>2],i[A+12>>2],C,n)),(a=E)^(E=h),32),n=pA(t=(m=CI(t,y,a,e=h))^C,n^(C=h),24),t=m,J=pA((m=CI(o,y=E,n,E=h))^a,(d=h)^e,16),E=pA(n^(v=CI(t,C,J,x=h)),(M=h)^E,63),C=h,n=i[A+116>>2],c=i[A+80>>2],u=i[A+84>>2],y=i[A+112>>2],o=i[A+48>>2],a=i[A+52>>2],y=pA(y^(e=CI(i[A+16>>2],i[A+20>>2],o,a)),(t=n)^(n=h),32),a=pA(t=(c=CI(c,u,y,P=h))^o,a^(o=h),24),t=c,c=pA((c=y)^(y=CI(e,y=n,a,n=h)),(e=P)^(P=h),16),n=pA(a^(t=CI(t,o,c,Y=h)),(k=h)^n,63),o=h,a=i[A+124>>2],H=i[A+88>>2],N=i[A+92>>2],F=i[A+120>>2],e=i[A+56>>2],u=i[A+60>>2],F=pA(F^(l=CI(i[A+24>>2],i[A+28>>2],e,u)),(_=a)^(a=h),32),_=u=pA(_=(N=CI(H,N,F,G=h))^e,u^(e=h),24),F=pA((u=CI(l,H=a,u,a=h))^F,(l=h)^G,16),a=pA(_^(N=CI(N,e,F,G=h)),(L=h)^a,63),e=h,_=t,H=k,t=pA(F^(p=CI(p,D,E,C)),G^(D=h),32),E=pA((F=CI(_,H,t,k=h))^E,(G=h)^C,24),C=CI(C=p,D,E,p=h),i[A>>2]=C,D=h,i[A+4>>2]=D,C=pA(C^t,D^k,16),i[A+120>>2]=C,D=h,i[A+124>>2]=D,C=CI(F,G,C,D),i[A+80>>2]=C,D=h,i[A+84>>2]=D,K=A,X=pA(C^E,D^p,63),i[K+40>>2]=X,i[A+44>>2]=h,E=n,p=pA(U^(C=CI(m,d,n,o)),S^(n=h),32),E=pA(E^(U=CI(N,L,p,D=h)),(t=o)^(o=h),24),C=CI(C,t=n,E,n=h),i[A+8>>2]=C,S=h,i[A+12>>2]=S,C=pA(C^p,D^S,16),i[A+96>>2]=C,p=h,i[A+100>>2]=p,C=CI(U,o,C,p),i[A+88>>2]=C,o=h,i[A+92>>2]=o,K=A,X=pA(C^E,n^o,63),i[K+48>>2]=X,i[A+52>>2]=h,E=a,o=pA(J^(C=CI(y,P,a,e)),x^(n=h),32),E=pA(E^(p=CI(b,R,o,a=h)),(t=e)^(e=h),24),C=CI(C,t=n,E,n=h),i[A+16>>2]=C,D=h,i[A+20>>2]=D,C=pA(C^o,a^D,16),i[A+104>>2]=C,o=h,i[A+108>>2]=o,C=CI(p,e,C,o),i[f>>2]=C,a=f,f=h,i[a+4>>2]=f,K=A,X=pA(C^E,n^f,63),i[K+56>>2]=X,i[A+60>>2]=h,a=r,C=pA(c^(r=CI(u,l,r,Q)),Y^(E=h),32),f=pA(a^(o=CI(v,M,C,n=h)),(f=Q)^(Q=h),24),r=CI(r,a=E,f,E=h),i[A+24>>2]=r,a=h,i[A+28>>2]=a,r=pA(C^r,n^a,16),i[A+112>>2]=r,C=h,i[A+116>>2]=C,r=CI(o,Q,r,C),i[A+72>>2]=r,Q=h,i[A+76>>2]=Q,K=A,X=pA(r^f,E^Q,63),i[K+32>>2]=X,i[A+36>>2]=h,8!=(0|(w=w+1|0)););for(;f=i[(w=512+(A=(B+1024|0)+(I<<4)|0)|0)>>2],r=i[A+772>>2],n=f,a=i[w+4>>2],o=i[A+768>>2],w=i[A+256>>2],f=i[A+260>>2],E=pA(o^(Q=CI(i[A>>2],i[A+4>>2],w,f)),(E=r)^(r=h),32),f=pA(a=(n=CI(n,a,E,C=h))^w,f^(w=h),24),o=w,p=pA((a=CI(Q,r,f,w=h))^E,(e=h)^C,16),w=pA(f^(U=CI(n,o,p,D=h)),(S=h)^w,63),f=h,r=i[A+780>>2],t=i[A+520>>2],y=i[A+524>>2],o=i[A+776>>2],Q=i[A+264>>2],E=i[A+268>>2],n=pA(o^(C=CI(i[A+8>>2],i[A+12>>2],Q,E)),(n=r)^(r=h),32),E=pA(t=(b=CI(t,y,n,o=h))^Q,E^(Q=h),24),t=b,m=pA((b=CI(C,y=r,E,r=h))^n,(R=h)^o,16),r=pA(E^(J=CI(t,Q,m,d=h)),(x=h)^r,63),Q=h,E=i[A+900>>2],y=i[A+640>>2],c=i[A+644>>2],u=i[A+896>>2],C=i[A+384>>2],n=i[A+388>>2],v=pA(u^(o=CI(i[A+128>>2],i[A+132>>2],C,n)),(t=E)^(E=h),32),n=pA(t=(y=CI(y,c,v,M=h))^C,n^(C=h),24),t=y,y=pA((y=v)^(v=CI(o,c=E,n,E=h)),(o=M)^(M=h),16),E=pA(n^(c=CI(t,C,y,P=h)),(Y=h)^E,63),C=h,n=i[A+908>>2],_=i[A+648>>2],H=i[A+652>>2],l=i[A+904>>2],o=i[A+392>>2],t=i[A+396>>2],u=pA(l^(k=CI(i[A+136>>2],i[A+140>>2],o,t)),(u=n)^(n=h),32),_=t=pA(_=(F=CI(_,H,u,l=h))^o,t^(o=h),24),u=pA((t=CI(k,H=n,t,n=h))^u,(k=h)^l,16),n=pA(_^(F=CI(F,o,u,l=h)),(G=h)^n,63),o=h,_=c,H=Y,c=pA(u^(a=CI(a,e,r,Q)),l^(e=h),32),r=pA((u=CI(_,H,c,Y=h))^r,(l=h)^Q,24),Q=CI(Q=a,e,r,a=h),i[A>>2]=Q,e=h,i[A+4>>2]=e,Q=pA(Q^c,e^Y,16),i[A+904>>2]=Q,e=h,i[A+908>>2]=e,Q=CI(u,l,Q,e),i[A+640>>2]=Q,e=h,i[A+644>>2]=e,K=A,X=pA(Q^r,a^e,63),i[K+264>>2]=X,i[A+268>>2]=h,r=E,a=pA(p^(Q=CI(b,R,E,C)),D^(E=h),32),r=pA(r^(p=CI(F,G,a,e=h)),(c=C)^(C=h),24),Q=CI(Q,c=E,r,E=h),i[A+8>>2]=Q,D=h,i[A+12>>2]=D,Q=pA(Q^a,e^D,16),i[A+768>>2]=Q,a=h,i[A+772>>2]=a,Q=CI(p,C,Q,a),i[A+648>>2]=Q,C=h,i[A+652>>2]=C,K=A,X=pA(Q^r,C^E,63),i[K+384>>2]=X,i[A+388>>2]=h,r=n,C=pA(m^(Q=CI(v,M,n,o)),d^(E=h),32),r=pA(r^(a=CI(U,S,C,n=h)),(c=o)^(o=h),24),Q=CI(Q,c=E,r,E=h),i[A+128>>2]=Q,e=h,i[A+132>>2]=e,Q=pA(C^Q,n^e,16),i[A+776>>2]=Q,C=h,i[A+780>>2]=C,Q=CI(a,o,Q,C),i[A+512>>2]=Q,C=h,i[A+516>>2]=C,K=A,X=pA(Q^r,C^E,63),i[K+392>>2]=X,i[A+396>>2]=h,r=CI(t,k,w,f),n=CI(J,x,E=pA(y^r,P^(Q=h),32),C=h),f=CI(a=r,Q,w=pA(n^w,(o=h)^f,24),r=h),i[A+136>>2]=f,Q=h,i[A+140>>2]=Q,f=pA(E^f,C^Q,16),i[A+896>>2]=f,Q=h,i[A+900>>2]=Q,f=CI(n,o,f,Q),i[A+520>>2]=f,Q=h,i[A+524>>2]=Q,K=A,X=pA(f^w,Q^r,63),i[K+256>>2]=X,i[A+260>>2]=h,8!=(0|(I=I+1|0)););yg(g,B),AI(g,B+1024|0),s=B+2048|0}function b(A){var I=0,g=0,B=0,C=0,Q=0,E=0,n=0,r=0,o=0;A:if(A|=0){Q=(B=A-8|0)+(A=-8&(I=i[A-4>>2]))|0;I:if(!(1&I)){if(!(3&I))break A;if((B=B-(I=i[B>>2])|0)>>>0<a[8969])break A;if(A=A+I|0,i[8970]==(0|B)){if(3==(3&(I=i[Q+4>>2])))return i[8967]=A,i[Q+4>>2]=-2&I,i[B+4>>2]=1|A,void(i[A+B>>2]=A)}else{if(I>>>0<=255){if(C=i[B+8>>2],I=I>>>3|0,(0|(g=i[B+12>>2]))==(0|C)){r=35860,o=i[8965]&lI(-2,I),i[r>>2]=o;break I}i[C+12>>2]=g,i[g+8>>2]=C;break I}if(n=i[B+24>>2],(0|B)==(0|(I=i[B+12>>2])))if((g=i[(C=B+20|0)>>2])||(g=i[(C=B+16|0)>>2])){for(;E=C,(g=i[(C=(I=g)+20|0)>>2])||(C=I+16|0,g=i[I+16>>2]););i[E>>2]=0}else I=0;else g=i[B+8>>2],i[g+12>>2]=I,i[I+8>>2]=g;if(!n)break I;C=i[B+28>>2];g:{if(i[(g=36164+(C<<2)|0)>>2]==(0|B)){if(i[g>>2]=I,I)break g;r=35864,o=i[8966]&lI(-2,C),i[r>>2]=o;break I}if(i[n+(i[n+16>>2]==(0|B)?16:20)>>2]=I,!I)break I}if(i[I+24>>2]=n,(g=i[B+16>>2])&&(i[I+16>>2]=g,i[g+24>>2]=I),!(g=i[B+20>>2]))break I;i[I+20>>2]=g,i[g+24>>2]=I}}if(!(B>>>0>=Q>>>0)&&1&(I=i[Q+4>>2])){I:{if(!(2&I)){if(i[8971]==(0|Q)){if(i[8971]=B,A=i[8968]+A|0,i[8968]=A,i[B+4>>2]=1|A,i[8970]!=(0|B))break A;return i[8967]=0,void(i[8970]=0)}if(i[8970]==(0|Q))return i[8970]=B,A=i[8967]+A|0,i[8967]=A,i[B+4>>2]=1|A,void(i[A+B>>2]=A);A=(-8&I)+A|0;g:if(I>>>0<=255){if(C=i[Q+8>>2],I=I>>>3|0,(0|(g=i[Q+12>>2]))==(0|C)){r=35860,o=i[8965]&lI(-2,I),i[r>>2]=o;break g}i[C+12>>2]=g,i[g+8>>2]=C}else{if(n=i[Q+24>>2],(0|Q)==(0|(I=i[Q+12>>2])))if((g=i[(C=Q+20|0)>>2])||(g=i[(C=Q+16|0)>>2])){for(;E=C,(g=i[(C=(I=g)+20|0)>>2])||(C=I+16|0,g=i[I+16>>2]););i[E>>2]=0}else I=0;else g=i[Q+8>>2],i[g+12>>2]=I,i[I+8>>2]=g;if(n){C=i[Q+28>>2];B:{if(i[(g=36164+(C<<2)|0)>>2]==(0|Q)){if(i[g>>2]=I,I)break B;r=35864,o=i[8966]&lI(-2,C),i[r>>2]=o;break g}if(i[n+(i[n+16>>2]==(0|Q)?16:20)>>2]=I,!I)break g}i[I+24>>2]=n,(g=i[Q+16>>2])&&(i[I+16>>2]=g,i[g+24>>2]=I),(g=i[Q+20>>2])&&(i[I+20>>2]=g,i[g+24>>2]=I)}}if(i[B+4>>2]=1|A,i[A+B>>2]=A,i[8970]!=(0|B))break I;return void(i[8967]=A)}i[Q+4>>2]=-2&I,i[B+4>>2]=1|A,i[A+B>>2]=A}if(A>>>0<=255)return I=35900+((A=A>>>3|0)<<3)|0,(g=i[8965])&(A=1<<A)?A=i[I+8>>2]:(i[8965]=A|g,A=I),i[I+8>>2]=B,i[A+12>>2]=B,i[B+12>>2]=I,void(i[B+8>>2]=A);C=31,i[B+16>>2]=0,i[B+20>>2]=0,A>>>0<=16777215&&(I=A>>>8|0,I<<=E=I+1048320>>>16&8,C=28+((I=((I<<=C=I+520192>>>16&4)<<(g=I+245760>>>16&2)>>>15|0)-(g|C|E)|0)<<1|A>>>I+21&1)|0),i[B+28>>2]=C,E=36164+(C<<2)|0;I:{g:{if((g=i[8966])&(I=1<<C)){for(C=A<<(31==(0|C)?0:25-(C>>>1|0)|0),I=i[E>>2];;){if(g=I,(-8&i[I+4>>2])==(0|A))break g;if(I=C>>>29|0,C<<=1,!(I=i[16+(E=g+(4&I)|0)>>2]))break}i[E+16>>2]=B,i[B+24>>2]=g}else i[8966]=I|g,i[E>>2]=B,i[B+24>>2]=E;i[B+12>>2]=B,i[B+8>>2]=B;break I}A=i[g+8>>2],i[A+12>>2]=B,i[g+8>>2]=B,i[B+24>>2]=0,i[B+12>>2]=g,i[B+8>>2]=A}A=i[8973]-1|0,i[8973]=A||-1}}}function m(A,I,g,B,C){var E,a,r,o,t,e,f,c,y,w,D,h,p,u,F,l=0,_=0,k=0,H=0,G=0,U=0,S=0,b=0,m=0,v=0,M=0,P=0,Y=0,N=0,R=0,d=0,J=0,x=0,L=0,K=0,X=0,T=0,V=0,q=0,z=0,j=0,W=0,O=0,Z=0,$=0,AA=0,IA=0,gA=0,BA=0;for(s=E=s+-64|0,a=i[A+60>>2],r=i[A+56>>2],L=i[A+52>>2],J=i[A+48>>2],o=i[A+44>>2],t=i[A+40>>2],e=i[A+36>>2],f=i[A+32>>2],c=i[A+28>>2],y=i[A+24>>2],w=i[A+20>>2],D=i[A+16>>2],h=i[A+12>>2],p=i[A+8>>2],u=i[A+4>>2],F=i[A>>2];;){if(!C&B>>>0>63|C)_=g;else{if(H=0,_=wI(E,0,64),B|C)for(;Q[_+H|0]=n[I+H|0],!C&(H=H+1|0)>>>0<B>>>0|C;);I=_,T=g}for(K=20,b=F,m=u,v=p,M=h,H=D,G=w,g=y,P=c,U=f,S=e,Y=t,N=a,d=r,l=L,k=J,x=o;R=H,b=cg((H=H+b|0)^k,16),k=cg(R^(U=b+U|0),12),R=U,U=cg((U=b)^(b=H+k|0),8),H=cg(k^(R=R+U|0),7),k=G,m=cg((G=G+m|0)^l,16),l=cg(k^(S=m+S|0),12),k=S,S=cg((S=m)^(m=G+l|0),8),G=cg(l^(X=k+S|0),7),l=g,v=cg((g=g+v|0)^d,16),l=d=cg(l^(Y=v+Y|0),12),d=cg((k=v)^(v=g+d|0),8),g=cg(l^(Y=d+Y|0),7),l=P,M=cg((P=P+M|0)^N,16),k=l=cg(l^(N=M+x|0),12),x=N,N=cg((N=M)^(M=P+l|0),8),P=cg(k^(l=x+N|0),7),k=Y,Y=cg((b=G+b|0)^N,16),G=cg((k=k+Y|0)^G,12),N=cg(Y^(b=G+b|0),8),G=cg(G^(Y=k+N|0),7),U=cg((m=g+m|0)^U,16),g=cg((l=U+l|0)^g,12),k=cg(U^(m=g+m|0),8),g=cg(g^(x=l+k|0),7),U=cg((v=P+v|0)^S,16),P=cg((S=U+R|0)^P,12),l=cg(U^(v=P+v|0),8),P=cg(P^(U=S+l|0),7),S=cg((M=H+M|0)^d,16),H=cg((R=S+X|0)^H,12),d=cg(S^(M=H+M|0),8),H=cg(H^(S=R+d|0),7),K=K-2|0;);if(K=n[I+4|0]|n[I+5|0]<<8|n[I+6|0]<<16|n[I+7|0]<<24,R=n[I+8|0]|n[I+9|0]<<8|n[I+10|0]<<16|n[I+11|0]<<24,X=n[I+12|0]|n[I+13|0]<<8|n[I+14|0]<<16|n[I+15|0]<<24,V=n[I+16|0]|n[I+17|0]<<8|n[I+18|0]<<16|n[I+19|0]<<24,q=n[I+20|0]|n[I+21|0]<<8|n[I+22|0]<<16|n[I+23|0]<<24,z=n[I+24|0]|n[I+25|0]<<8|n[I+26|0]<<16|n[I+27|0]<<24,j=n[I+28|0]|n[I+29|0]<<8|n[I+30|0]<<16|n[I+31|0]<<24,W=n[I+32|0]|n[I+33|0]<<8|n[I+34|0]<<16|n[I+35|0]<<24,O=n[I+36|0]|n[I+37|0]<<8|n[I+38|0]<<16|n[I+39|0]<<24,Z=n[I+40|0]|n[I+41|0]<<8|n[I+42|0]<<16|n[I+43|0]<<24,$=n[I+44|0]|n[I+45|0]<<8|n[I+46|0]<<16|n[I+47|0]<<24,AA=n[I+48|0]|n[I+49|0]<<8|n[I+50|0]<<16|n[I+51|0]<<24,IA=n[I+52|0]|n[I+53|0]<<8|n[I+54|0]<<16|n[I+55|0]<<24,gA=n[I+56|0]|n[I+57|0]<<8|n[I+58|0]<<16|n[I+59|0]<<24,BA=n[I+60|0]|n[I+61|0]<<8|n[I+62|0]<<16|n[I+63|0]<<24,bI(_,b+F^(n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24)),bI(_+4|0,m+u^K),bI(_+8|0,v+p^R),bI(_+12|0,M+h^X),bI(_+16|0,H+D^V),bI(_+20|0,G+w^q),bI(_+24|0,g+y^z),bI(_+28|0,P+c^j),bI(_+32|0,U+f^W),bI(_+36|0,S+e^O),bI(_+40|0,Z^Y+t),bI(_+44|0,$^x+o),bI(_+48|0,AA^k+J),bI(_+52|0,IA^l+L),bI(_+56|0,gA^d+r),bI(_+60|0,BA^N+a),L=((J=(g=J)+1|0)>>>0<g>>>0)+L|0,!C&B>>>0<=64){if(!(!B|!C&B>>>0>63|0!=(0|C)))for(G=0;Q[G+T|0]=n[_+G|0],(0|B)!=(0|(G=G+1|0)););i[A+52>>2]=L,i[A+48>>2]=J,s=E- -64|0;break}I=I- -64|0,g=_- -64|0,C=C-1|0,C=(B=B+-64|0)>>>0<4294967232?C+1|0:C}}function v(A,I){var g,B=0,C=0,Q=0,E=0,n=0,a=0,r=0;g=A+I|0;A:{I:if(!(1&(B=i[A+4>>2]))){if(!(3&B))break A;I=(B=i[A>>2])+I|0;g:{if((0|(A=A-B|0))!=i[8970]){if(B>>>0<=255){if(Q=i[A+8>>2],B=B>>>3|0,(0|(C=i[A+12>>2]))!=(0|Q))break g;a=35860,r=i[8965]&lI(-2,B),i[a>>2]=r;break I}if(n=i[A+24>>2],(0|(B=i[A+12>>2]))==(0|A))if((C=i[(Q=A+20|0)>>2])||(C=i[(Q=A+16|0)>>2])){for(;E=Q,(C=i[(Q=(B=C)+20|0)>>2])||(Q=B+16|0,C=i[B+16>>2]););i[E>>2]=0}else B=0;else C=i[A+8>>2],i[C+12>>2]=B,i[B+8>>2]=C;if(!n)break I;Q=i[A+28>>2];B:{if(i[(C=36164+(Q<<2)|0)>>2]==(0|A)){if(i[C>>2]=B,B)break B;a=35864,r=i[8966]&lI(-2,Q),i[a>>2]=r;break I}if(i[n+(i[n+16>>2]==(0|A)?16:20)>>2]=B,!B)break I}if(i[B+24>>2]=n,(C=i[A+16>>2])&&(i[B+16>>2]=C,i[C+24>>2]=B),!(C=i[A+20>>2]))break I;i[B+20>>2]=C,i[C+24>>2]=B;break I}if(3!=(3&(B=i[g+4>>2])))break I;return i[8967]=I,i[g+4>>2]=-2&B,i[A+4>>2]=1|I,void(i[g>>2]=I)}i[Q+12>>2]=C,i[C+8>>2]=Q}I:{if(!(2&(B=i[g+4>>2]))){if(i[8971]==(0|g)){if(i[8971]=A,I=i[8968]+I|0,i[8968]=I,i[A+4>>2]=1|I,i[8970]!=(0|A))break A;return i[8967]=0,void(i[8970]=0)}if(i[8970]==(0|g))return i[8970]=A,I=i[8967]+I|0,i[8967]=I,i[A+4>>2]=1|I,void(i[A+I>>2]=I);I=(-8&B)+I|0;g:if(B>>>0<=255){if(Q=i[g+8>>2],B=B>>>3|0,(0|(C=i[g+12>>2]))==(0|Q)){a=35860,r=i[8965]&lI(-2,B),i[a>>2]=r;break g}i[Q+12>>2]=C,i[C+8>>2]=Q}else{if(n=i[g+24>>2],(0|g)==(0|(B=i[g+12>>2])))if((Q=i[(C=g+20|0)>>2])||(Q=i[(C=g+16|0)>>2])){for(;E=C,(Q=i[(C=(B=Q)+20|0)>>2])||(C=B+16|0,Q=i[B+16>>2]););i[E>>2]=0}else B=0;else C=i[g+8>>2],i[C+12>>2]=B,i[B+8>>2]=C;if(n){Q=i[g+28>>2];B:{if(i[(C=36164+(Q<<2)|0)>>2]==(0|g)){if(i[C>>2]=B,B)break B;a=35864,r=i[8966]&lI(-2,Q),i[a>>2]=r;break g}if(i[n+(i[n+16>>2]==(0|g)?16:20)>>2]=B,!B)break g}i[B+24>>2]=n,(C=i[g+16>>2])&&(i[B+16>>2]=C,i[C+24>>2]=B),(C=i[g+20>>2])&&(i[B+20>>2]=C,i[C+24>>2]=B)}}if(i[A+4>>2]=1|I,i[A+I>>2]=I,i[8970]!=(0|A))break I;return void(i[8967]=I)}i[g+4>>2]=-2&B,i[A+4>>2]=1|I,i[A+I>>2]=I}if(I>>>0<=255)return B=35900+((I=I>>>3|0)<<3)|0,(C=i[8965])&(I=1<<I)?I=i[B+8>>2]:(i[8965]=I|C,I=B),i[B+8>>2]=A,i[I+12>>2]=A,i[A+12>>2]=B,void(i[A+8>>2]=I);Q=31,i[A+16>>2]=0,i[A+20>>2]=0,I>>>0<=16777215&&(B=I>>>8|0,B<<=E=B+1048320>>>16&8,Q=28+((B=((B<<=Q=B+520192>>>16&4)<<(C=B+245760>>>16&2)>>>15|0)-(C|Q|E)|0)<<1|I>>>B+21&1)|0),i[A+28>>2]=Q,E=36164+(Q<<2)|0;I:{if((C=i[8966])&(B=1<<Q)){for(Q=I<<(31==(0|Q)?0:25-(Q>>>1|0)|0),B=i[E>>2];;){if(C=B,(-8&i[B+4>>2])==(0|I))break I;if(B=Q>>>29|0,Q<<=1,!(B=i[16+(E=C+(4&B)|0)>>2]))break}i[E+16>>2]=A,i[A+24>>2]=C}else i[8966]=B|C,i[E>>2]=A,i[A+24>>2]=E;return i[A+12>>2]=A,void(i[A+8>>2]=A)}I=i[C+8>>2],i[I+12>>2]=A,i[C+8>>2]=A,i[A+24>>2]=0,i[A+12>>2]=C,i[A+8>>2]=I}}function M(A,I,g,B){var C=0,Q=0,E=0,a=0,o=0,t=0,e=0,f=0,c=0,y=0,s=0,w=0,D=0,p=0,u=0,F=0,l=0,_=0,k=0,H=0,G=0,U=0,S=0,b=0,m=0;if(c=i[A+36>>2],a=i[A+32>>2],E=i[A+28>>2],Q=i[A+24>>2],o=i[A+20>>2],!B&g>>>0>=16|B)for(G=!n[A+80|0]<<24,s=i[A+4>>2],U=r(s,5),p=i[A+8>>2],H=r(p,5),_=i[A+12>>2],k=r(_,5),C=i[A+16>>2],u=r(C,5),S=C,w=i[A>>2];C=qA(t=((n[I+3|0]|n[I+4|0]<<8|n[I+5|0]<<16|n[I+6|0]<<24)>>>2&67108863)+Q|0,0,_,0),e=h,Q=(y=qA(o=(67108863&(n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24))+o|0,0,S,0))+C|0,C=h+e|0,C=Q>>>0<y>>>0?C+1|0:C,f=Q,Q=qA(e=((n[I+6|0]|n[I+7|0]<<8|n[I+8|0]<<16|n[I+9|0]<<24)>>>4&67108863)+E|0,0,p,0),C=h+C|0,C=Q>>>0>(E=f+Q|0)>>>0?C+1|0:C,Q=E,E=qA(y=((n[I+9|0]|n[I+10|0]<<8|n[I+11|0]<<16|n[I+12|0]<<24)>>>6|0)+a|0,0,s,0),C=h+C|0,C=E>>>0>(a=Q+E|0)>>>0?C+1|0:C,Q=a,a=qA(D=c+G+((n[I+12|0]|n[I+13|0]<<8|n[I+14|0]<<16|n[I+15|0]<<24)>>>8)|0,0,w,0),C=h+C|0,b=c=Q+a|0,c=a>>>0>c>>>0?C+1|0:C,C=qA(t,0,p,0),E=h,a=(Q=qA(o,0,_,0))+C|0,C=h+E|0,C=Q>>>0>a>>>0?C+1|0:C,E=qA(e,0,s,0),C=h+C|0,C=E>>>0>(a=E+a|0)>>>0?C+1|0:C,E=qA(y,0,w,0),C=h+C|0,C=E>>>0>(a=E+a|0)>>>0?C+1|0:C,E=qA(D,0,u,0),C=h+C|0,m=a=E+a|0,a=E>>>0>a>>>0?C+1|0:C,C=qA(t,0,s,0),Q=h,E=(F=qA(o,0,p,0))+C|0,C=h+Q|0,C=E>>>0<F>>>0?C+1|0:C,Q=qA(e,0,w,0),C=h+C|0,C=Q>>>0>(E=Q+E|0)>>>0?C+1|0:C,Q=qA(y,0,u,0),C=h+C|0,C=Q>>>0>(E=Q+E|0)>>>0?C+1|0:C,Q=qA(D,0,k,0),C=h+C|0,F=E=Q+E|0,E=Q>>>0>E>>>0?C+1|0:C,C=qA(t,0,w,0),f=h,Q=(l=qA(o,0,s,0))+C|0,C=h+f|0,C=Q>>>0<l>>>0?C+1|0:C,f=qA(e,0,u,0),C=h+C|0,C=(Q=f+Q|0)>>>0<f>>>0?C+1|0:C,f=qA(y,0,k,0),C=h+C|0,C=(Q=f+Q|0)>>>0<f>>>0?C+1|0:C,f=qA(D,0,H,0),C=h+C|0,C=(Q=f+Q|0)>>>0<f>>>0?C+1|0:C,f=Q,Q=C,C=qA(t,0,u,0),l=h,t=(o=qA(o,0,w,0))+C|0,C=h+l|0,C=t>>>0<o>>>0?C+1|0:C,o=qA(e,0,k,0),C=h+C|0,C=(t=o+t|0)>>>0<o>>>0?C+1|0:C,o=qA(y,0,H,0),C=h+C|0,C=(t=o+t|0)>>>0<o>>>0?C+1|0:C,o=qA(D,0,U,0),C=h+C|0,C=(t=o+t|0)>>>0<o>>>0?C+1|0:C,o=t,e=(67108863&C)<<6|t>>>26,C=Q,e=(67108863&(C=(t=e+f|0)>>>0<e>>>0?C+1|0:C))<<6|(Q=t)>>>26,C=E,C=(Q=e+F|0)>>>0<e>>>0?C+1|0:C,e=Q,Q=(67108863&C)<<6|Q>>>26,C=a,y=E=Q+m|0,E=(67108863&(C=Q>>>0>E>>>0?C+1|0:C))<<6|E>>>26,C=c,c=a=E+b|0,Q=(67108863&t)+((C=r((67108863&(E>>>0>a>>>0?C+1|0:C))<<6|a>>>26,5)+(67108863&o)|0)>>>26|0)|0,E=67108863&e,a=67108863&y,c&=67108863,o=67108863&C,I=I+16|0,!(B=B-(g>>>0<16)|0)&(g=g-16|0)>>>0>15|B;);i[A+20>>2]=o,i[A+36>>2]=c,i[A+32>>2]=a,i[A+28>>2]=E,i[A+24>>2]=Q}function P(A,I,g){var B,C,E,i,a=0,r=0,o=0,t=0,e=0;return s=E=s-160|0,_I(I,g,32,0),Q[0|I]=248&n[0|I],Q[I+31|0]=63&n[I+31|0]|64,BA(E,I),II(A,E),r=n[(C=g)+8|0]|n[C+9|0]<<8|n[C+10|0]<<16|n[C+11|0]<<24,a=n[C+12|0]|n[C+13|0]<<8|n[C+14|0]<<16|n[C+15|0]<<24,o=n[C+16|0]|n[C+17|0]<<8|n[C+18|0]<<16|n[C+19|0]<<24,t=n[C+20|0]|n[C+21|0]<<8|n[C+22|0]<<16|n[C+23|0]<<24,e=n[0|C]|n[C+1|0]<<8|n[C+2|0]<<16|n[C+3|0]<<24,g=n[C+4|0]|n[C+5|0]<<8|n[C+6|0]<<16|n[C+7|0]<<24,i=n[C+28|0]|n[C+29|0]<<8|n[C+30|0]<<16|n[C+31|0]<<24,B=I,I=n[C+24|0]|n[C+25|0]<<8|n[C+26|0]<<16|n[C+27|0]<<24,Q[B+24|0]=I,Q[B+25|0]=I>>>8,Q[B+26|0]=I>>>16,Q[B+27|0]=I>>>24,Q[B+28|0]=i,Q[B+29|0]=i>>>8,Q[B+30|0]=i>>>16,Q[B+31|0]=i>>>24,Q[B+16|0]=o,Q[B+17|0]=o>>>8,Q[B+18|0]=o>>>16,Q[B+19|0]=o>>>24,Q[B+20|0]=t,Q[B+21|0]=t>>>8,Q[B+22|0]=t>>>16,Q[B+23|0]=t>>>24,Q[B+8|0]=r,Q[B+9|0]=r>>>8,Q[B+10|0]=r>>>16,Q[B+11|0]=r>>>24,Q[B+12|0]=a,Q[B+13|0]=a>>>8,Q[B+14|0]=a>>>16,Q[B+15|0]=a>>>24,Q[0|B]=e,Q[B+1|0]=e>>>8,Q[B+2|0]=e>>>16,Q[B+3|0]=e>>>24,Q[B+4|0]=g,Q[B+5|0]=g>>>8,Q[B+6|0]=g>>>16,Q[B+7|0]=g>>>24,o=n[(a=A)+8|0]|n[a+9|0]<<8|n[a+10|0]<<16|n[a+11|0]<<24,t=n[a+12|0]|n[a+13|0]<<8|n[a+14|0]<<16|n[a+15|0]<<24,e=n[a+16|0]|n[a+17|0]<<8|n[a+18|0]<<16|n[a+19|0]<<24,g=n[a+20|0]|n[a+21|0]<<8|n[a+22|0]<<16|n[a+23|0]<<24,I=n[0|a]|n[a+1|0]<<8|n[a+2|0]<<16|n[a+3|0]<<24,A=n[a+4|0]|n[a+5|0]<<8|n[a+6|0]<<16|n[a+7|0]<<24,r=n[a+28|0]|n[a+29|0]<<8|n[a+30|0]<<16|n[a+31|0]<<24,a=n[a+24|0]|n[a+25|0]<<8|n[a+26|0]<<16|n[a+27|0]<<24,Q[B+56|0]=a,Q[B+57|0]=a>>>8,Q[B+58|0]=a>>>16,Q[B+59|0]=a>>>24,Q[B+60|0]=r,Q[B+61|0]=r>>>8,Q[B+62|0]=r>>>16,Q[B+63|0]=r>>>24,Q[B+48|0]=e,Q[B+49|0]=e>>>8,Q[B+50|0]=e>>>16,Q[B+51|0]=e>>>24,Q[B+52|0]=g,Q[B+53|0]=g>>>8,Q[B+54|0]=g>>>16,Q[B+55|0]=g>>>24,Q[B+40|0]=o,Q[B+41|0]=o>>>8,Q[B+42|0]=o>>>16,Q[B+43|0]=o>>>24,Q[B+44|0]=t,Q[B+45|0]=t>>>8,Q[B+46|0]=t>>>16,Q[B+47|0]=t>>>24,Q[B+32|0]=I,Q[B+33|0]=I>>>8,Q[B+34|0]=I>>>16,Q[B+35|0]=I>>>24,Q[B+36|0]=A,Q[B+37|0]=A>>>8,Q[B+38|0]=A>>>16,Q[B+39|0]=A>>>24,s=E+160|0,0}function Y(A,I,g){var B,C=0,E=0;s=B=s+-64|0;A:{if((g-65&255)>>>0>191){if(C=-1,!(n[A+80|0]|n[A+81|0]<<8|n[A+82|0]<<16|n[A+83|0]<<24|n[A+84|0]|n[A+85|0]<<8|n[A+86|0]<<16|n[A+87|0]<<24)){if((C=n[A+352|0]|n[A+353|0]<<8|n[A+354|0]<<16|n[A+355|0]<<24)>>>0>=129){if(CA(A,128),p(A,E=A+96|0),C=(n[A+352|0]|n[A+353|0]<<8|n[A+354|0]<<16|n[A+355|0]<<24)-128|0,Q[A+352|0]=C,Q[A+353|0]=C>>>8,Q[A+354|0]=C>>>16,Q[A+355|0]=C>>>24,C>>>0>=129)break A;eI(E,A+224|0,C),C=n[A+352|0]|n[A+353|0]<<8|n[A+354|0]<<16|n[A+355|0]<<24}CA(A,C),n[A+356|0]&&(Q[A+88|0]=255,Q[A+89|0]=255,Q[A+90|0]=255,Q[A+91|0]=255,Q[A+92|0]=255,Q[A+93|0]=255,Q[A+94|0]=255,Q[A+95|0]=255),Q[A+80|0]=255,Q[A+81|0]=255,Q[A+82|0]=255,Q[A+83|0]=255,Q[A+84|0]=255,Q[A+85|0]=255,Q[A+86|0]=255,Q[A+87|0]=255,wI((C=A+96|0)+(E=n[A+352|0]|n[A+353|0]<<8|n[A+354|0]<<16|n[A+355|0]<<24)|0,0,256-E|0),p(A,C),QI(B,n[0|A]|n[A+1|0]<<8|n[A+2|0]<<16|n[A+3|0]<<24,n[A+4|0]|n[A+5|0]<<8|n[A+6|0]<<16|n[A+7|0]<<24),QI(8|B,n[A+8|0]|n[A+9|0]<<8|n[A+10|0]<<16|n[A+11|0]<<24,n[A+12|0]|n[A+13|0]<<8|n[A+14|0]<<16|n[A+15|0]<<24),QI(B+16|0,n[A+16|0]|n[A+17|0]<<8|n[A+18|0]<<16|n[A+19|0]<<24,n[A+20|0]|n[A+21|0]<<8|n[A+22|0]<<16|n[A+23|0]<<24),QI(B+24|0,n[A+24|0]|n[A+25|0]<<8|n[A+26|0]<<16|n[A+27|0]<<24,n[A+28|0]|n[A+29|0]<<8|n[A+30|0]<<16|n[A+31|0]<<24),QI(B+32|0,n[A+32|0]|n[A+33|0]<<8|n[A+34|0]<<16|n[A+35|0]<<24,n[A+36|0]|n[A+37|0]<<8|n[A+38|0]<<16|n[A+39|0]<<24),QI(B+40|0,n[A+40|0]|n[A+41|0]<<8|n[A+42|0]<<16|n[A+43|0]<<24,n[A+44|0]|n[A+45|0]<<8|n[A+46|0]<<16|n[A+47|0]<<24),QI(B+48|0,n[A+48|0]|n[A+49|0]<<8|n[A+50|0]<<16|n[A+51|0]<<24,n[A+52|0]|n[A+53|0]<<8|n[A+54|0]<<16|n[A+55|0]<<24),QI(B+56|0,n[A+56|0]|n[A+57|0]<<8|n[A+58|0]<<16|n[A+59|0]<<24,n[A+60|0]|n[A+61|0]<<8|n[A+62|0]<<16|n[A+63|0]<<24),eI(I,B,g),Dg(A,64),Dg(C,256),C=0}return s=B- -64|0,C}xI(),t()}e(1299,1161,306,1086),t()}function N(A,I){var g,B,C,Q,E,a,r,o,t,e=0,f=0,c=0,y=0,s=0,w=0,D=0,p=0,u=0,F=0;g=n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24,u=uI(I+4|0),e=h,w=uI(I+7|0),y=h,p=uI(I+10|0),f=h,B=uI(I+13|0),s=h,c=n[I+16|0]|n[I+17|0]<<8|n[I+18|0]<<16|n[I+19|0]<<24,C=uI(I+20|0),Q=h,E=uI(I+23|0),a=h,r=uI(I+26|0),o=h,t=uI(I+29|0),I=f<<3|p>>>29,F=f=p<<3,p=f=f+16777216|0,f=I=f>>>0<16777216?I+1|0:I,D=w<<5,y=I=y<<5|w>>>27,e=I=e<<6|(w=u)>>>26,u=I=16777216+(w<<=6)|0,I=(I=(e=I>>>0<16777216?e+1|0:e)>>25)+y|0,I=(e=D+(D=(33554431&e)<<7|u>>>25)|0)>>>0<D>>>0?I+1|0:I,I=(F-(-33554432&p)|0)+((67108863&(I=(y=e+33554432|0)>>>0<33554432?I+1|0:I))<<6|y>>>26)|0,i[A+12>>2]=I,I=-67108864&y,i[A+8>>2]=e-I,I=0,y=c=(e=c)+16777216|0,c=I=c>>>0<16777216?1:I,F=e-(-33554432&y)|0,I=s<<2|(e=B)>>>30,s=e<<2,e=I,I=(I=f>>25)+e|0,e=I=(f=(D=s)+(s=(33554431&f)<<7|p>>>25)|0)>>>0<s>>>0?I+1|0:I,s=I=f+33554432|0,I=((67108863&(e=I>>>0<33554432?e+1|0:e))<<6|I>>>26)+F|0,i[A+20>>2]=I,I=-67108864&s,i[A+16>>2]=f-I,f=(e=C)<<7,I=(I=Q<<7|e>>>25)+(e=c>>25)|0,I=(f=f+(c=(33554431&c)<<7|y>>>25)|0)>>>0<c>>>0?I+1|0:I,f=e=f,c=e=e+33554432|0,e=I=e>>>0<33554432?I+1|0:I,I=-67108864&c,i[A+24>>2]=f-I,I=a<<5|(f=E)>>>27,s=f<<=5,y=f=f+16777216|0,f=I=f>>>0<16777216?I+1|0:I,I=(s-(-33554432&y)|0)+((67108863&e)<<6|c>>>26)|0,i[A+28>>2]=I,c=(e=r)<<4,e=I=o<<4|e>>>28,I=(I=f>>25)+e|0,I=(f=(s=c)+(c=(33554431&f)<<7|y>>>25)|0)>>>0<c>>>0?I+1|0:I,f=e=f,c=e=e+33554432|0,e=I=e>>>0<33554432?I+1|0:I,I=-67108864&c,i[A+32>>2]=f-I,I=0,y=f=(f=t)<<2&33554428,I=(f=f+16777216|0)>>>0<16777216?I+1|0:I,e=(y-(33554432&f)|0)+((67108863&e)<<6|c>>>26)|0,i[A+36>>2]=e,f=qA((33554431&I)<<7|f>>>25,I>>>25|0,19,0),I=h,I=(e=f+g|0)>>>0<f>>>0?I+1|0:I,I=(w-(-33554432&u)|0)+((67108863&(I=(f=e+33554432|0)>>>0<33554432?I+1|0:I))<<6|f>>>26)|0,i[A+4>>2]=I,I=A,A=-67108864&f,i[I>>2]=e-A}function R(A,I,g,B){var C,E=0;C=E=s,s=E=E-576&-64,i[E+188>>2]=0,bI(E+188|0,I);A:if(I>>>0<=64){if((0|OA(E+192|0,0,0,I))<0)break A;if((0|Cg(E+192|0,E+188|0,4,0))<0)break A;if((0|Cg(E+192|0,g,B,0))<0)break A;UI(E+192|0,A,I)}else if(!((0|OA(E+192|0,0,0,64))<0||(0|Cg(E+192|0,E+188|0,4,0))<0||(0|Cg(E+192|0,g,B,0))<0||(0|UI(E+192|0,E+112|0,64))<0)){if(g=i[E+116>>2],B=i[E+112>>2],Q[0|A]=B,Q[A+1|0]=B>>>8,Q[A+2|0]=B>>>16,Q[A+3|0]=B>>>24,Q[A+4|0]=g,Q[A+5|0]=g>>>8,Q[A+6|0]=g>>>16,Q[A+7|0]=g>>>24,g=i[E+124>>2],B=i[E+120>>2],Q[A+8|0]=B,Q[A+9|0]=B>>>8,Q[A+10|0]=B>>>16,Q[A+11|0]=B>>>24,Q[A+12|0]=g,Q[A+13|0]=g>>>8,Q[A+14|0]=g>>>16,Q[A+15|0]=g>>>24,g=i[E+140>>2],B=i[E+136>>2],Q[A+24|0]=B,Q[A+25|0]=B>>>8,Q[A+26|0]=B>>>16,Q[A+27|0]=B>>>24,Q[A+28|0]=g,Q[A+29|0]=g>>>8,Q[A+30|0]=g>>>16,Q[A+31|0]=g>>>24,g=i[E+132>>2],B=i[E+128>>2],Q[A+16|0]=B,Q[A+17|0]=B>>>8,Q[A+18|0]=B>>>16,Q[A+19|0]=B>>>24,Q[A+20|0]=g,Q[A+21|0]=g>>>8,Q[A+22|0]=g>>>16,Q[A+23|0]=g>>>24,A=A+32|0,(I=I-32|0)>>>0>=65)for(;;){if(eI(g=E+48|0,B=E+112|0,64),(0|vA(B,64,g,64,0,0,0))<0)break A;if(g=i[E+116>>2],B=i[E+112>>2],Q[0|A]=B,Q[A+1|0]=B>>>8,Q[A+2|0]=B>>>16,Q[A+3|0]=B>>>24,Q[A+4|0]=g,Q[A+5|0]=g>>>8,Q[A+6|0]=g>>>16,Q[A+7|0]=g>>>24,g=i[E+124>>2],B=i[E+120>>2],Q[A+8|0]=B,Q[A+9|0]=B>>>8,Q[A+10|0]=B>>>16,Q[A+11|0]=B>>>24,Q[A+12|0]=g,Q[A+13|0]=g>>>8,Q[A+14|0]=g>>>16,Q[A+15|0]=g>>>24,g=i[E+140>>2],B=i[E+136>>2],Q[A+24|0]=B,Q[A+25|0]=B>>>8,Q[A+26|0]=B>>>16,Q[A+27|0]=B>>>24,Q[A+28|0]=g,Q[A+29|0]=g>>>8,Q[A+30|0]=g>>>16,Q[A+31|0]=g>>>24,g=i[E+132>>2],B=i[E+128>>2],Q[A+16|0]=B,Q[A+17|0]=B>>>8,Q[A+18|0]=B>>>16,Q[A+19|0]=B>>>24,Q[A+20|0]=g,Q[A+21|0]=g>>>8,Q[A+22|0]=g>>>16,Q[A+23|0]=g>>>24,A=A+32|0,!((I=I-32|0)>>>0>64))break}eI(g=E+48|0,B=E+112|0,64),(0|vA(B,I,g,64,0,0,0))<0||eI(A,E+112|0,I)}Dg(E+192|0,384),s=C}function d(A,I,g){var B,C,Q,E,i,a,r,o,t,e,f,c,y=0,s=0,w=0,D=0,h=0,p=0,u=0,F=0,l=0,_=0,k=0,H=0,G=0,U=0,S=0,b=0,m=0,v=0,M=0,P=0,Y=0;for(B=n[g+4|0]|n[g+5|0]<<8|n[g+6|0]<<16|n[g+7|0]<<24,C=n[g+8|0]|n[g+9|0]<<8|n[g+10|0]<<16|n[g+11|0]<<24,Q=n[g+12|0]|n[g+13|0]<<8|n[g+14|0]<<16|n[g+15|0]<<24,E=n[g+16|0]|n[g+17|0]<<8|n[g+18|0]<<16|n[g+19|0]<<24,i=n[g+20|0]|n[g+21|0]<<8|n[g+22|0]<<16|n[g+23|0]<<24,a=n[g+24|0]|n[g+25|0]<<8|n[g+26|0]<<16|n[g+27|0]<<24,r=n[g+28|0]|n[g+29|0]<<8|n[g+30|0]<<16|n[g+31|0]<<24,k=1634760805,g=o=n[0|g]|n[g+1|0]<<8|n[g+2|0]<<16|n[g+3|0]<<24,w=B,S=C,D=Q,H=857760878,h=t=n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24,p=e=n[I+4|0]|n[I+5|0]<<8|n[I+6|0]<<16|n[I+7|0]<<24,u=f=n[I+8|0]|n[I+9|0]<<8|n[I+10|0]<<16|n[I+11|0]<<24,_=c=n[I+12|0]|n[I+13|0]<<8|n[I+14|0]<<16|n[I+15|0]<<24,G=2036477234,I=E,F=1797285236,l=r,y=a,s=i;D=cg(s+k|0,7)^D,u=cg(D+k|0,9)^u,b=cg(u+D|0,13)^s,M=cg(u+b|0,18),s=cg(g+H|0,7)^_,U=cg(s+H|0,9)^y,g=cg(s+U|0,13)^g,_=cg(U+g|0,18),l=cg(h+G|0,7)^l,w=cg(l+G|0,9)^w,h=cg(l+w|0,13)^h,P=cg(w+h|0,18),y=cg(I+F|0,7)^S,p=cg(y+F|0,9)^p,m=cg(y+p|0,13)^I,Y=cg(p+m|0,18),g=cg((I=k^M)+y|0,7)^g,w=cg(g+I|0,9)^w,S=cg(g+w|0,13)^y,k=cg(w+S|0,18)^I,h=cg((I=H^_)+D|0,7)^h,p=cg(h+I|0,9)^p,D=cg(p+h|0,13)^D,H=cg(p+D|0,18)^I,I=cg((y=G^P)+s|0,7)^m,u=cg(I+y|0,9)^u,_=cg(I+u|0,13)^s,G=cg(u+_|0,18)^y,s=cg((F^=Y)+l|0,7)^b,y=cg(s+F|0,9)^U,l=cg(y+s|0,13)^l,F=cg(y+l|0,18)^F,U=v>>>0<18,v=v+2|0,U;);bI(A,k+1634760805|0),bI(A+4|0,g+o|0),bI(A+8|0,w+B|0),bI(A+12|0,S+C|0),bI(A+16|0,D+Q|0),bI(A+20|0,H+857760878|0),bI(A+24|0,h+t|0),bI(A+28|0,p+e|0),bI(A+32|0,u+f|0),bI(A+36|0,_+c|0),bI(A+40|0,G+2036477234|0),bI(A+44|0,I+E|0),bI(A+48|0,s+i|0),bI(A+52|0,y+a|0),bI(A+56|0,l+r|0),bI(A+60|0,F+1797285236|0)}function J(A,I,g,B,C,E){var i,a=0,o=0,t=0,e=0,f=0,c=0,y=0,w=0,D=0;for(s=i=s-592|0,e=-1,f=A+32|0,a=32,o=1;t=(c=n[f+(a=a-1|0)|0])-(y=n[a+2752|0])>>8&o|255&t,o&=65535+(c^y)>>>8,a;);if(t&&!sA(A)){for(a=127&(-1^n[C+31|0]),t=30;a=-1^n[C+t|0]|a,t=t-1|0;);if(((255&a)-1&236-n[0|C])<<23>>31!=-1&&!sA(C)&&!V(i+128|0,C)){WI(a=i+384|0,E),z(a,A,32,0),z(a,C,32,0),z(a,I,g,B),MA(a,I=i+320|0),l(I),s=B=s-2272|0,oA(B+2016|0,I),oA(B+1760|0,f),DI(g=B+480|0,C=i+128|0),fI(I=B+320|0,C),tI(B,I),xA(I,B,g),tI(g=B+160|0,I),DI(C=B+640|0,g),xA(I,B,C),tI(g,I),DI(C=B+800|0,g),xA(I,B,C),tI(g,I),DI(C=B+960|0,g),xA(I,B,C),tI(g,I),DI(C=B+1120|0,g),xA(I,B,C),tI(g,I),DI(C=B+1280|0,g),xA(I,B,C),tI(g,I),DI(C=B+1440|0,g),xA(I,B,C),tI(g,I),DI(B+1600|0,g),hg(E=i+8|0),ng(E+40|0),ng(E+80|0),C=255;A:{for(;;){if(!(n[(I=C)+(B+2016|0)|0]|n[(B+1760|0)+I|0])){if(C=I-1|0,I)continue;break A}break}if(!((0|I)<0))for(;G(B+320|0,E),g=I,(0|(I=Q[(B+2016|0)+I|0]))>0?(tI(C=B+160|0,a=B+320|0),xA(a,C,(B+480|0)+r((254&I)>>>1|0,160)|0)):(0|I)>=0||(tI(C=B+160|0,a=B+320|0),JA(a,C,(B+480|0)+r((0-I&254)>>>1|0,160)|0)),(0|(o=Q[g+(B+1760|0)|0]))>0?(tI(I=B+160|0,C=B+320|0),TA(C,I,r((254&o)>>>1|0,120)+1568|0)):(0|o)>=0||(tI(C=B+160|0,I=B+320|0),s=t=s-48|0,yA(I,e=C+40|0,C),cA(a=I+40|0,e,C),H(e=I+80|0,I,40+(f=r((0-o&254)>>>1|0,120)+1568|0)|0),H(a,a,f),H(o=I+120|0,f+80|0,C+120|0),yA(t,C=C+80|0,C),cA(I,e,a),yA(a,e,a),cA(e,t,o),yA(o,t,o),s=t+48|0),hI(E,B+320|0),I=g-1|0,(0|g)>0;);}s=B+2272|0,II(I=i+288|0,E),w=-1,D=eg(I,A),e=((0|A)==(0|I)?w:D)|zA(A,I,32)}}return s=i+592|0,e}function x(A,I,g){var B=0,C=0,Q=0,E=0,i=0,a=0,r=0,o=0,t=0,e=0,f=0,c=0,y=0,s=0,w=0,D=0,h=0,p=0,u=0;for(Q=2036477234,t=857760878,e=1634760805,E=1797285236,o=n[0|g]|n[g+1|0]<<8|n[g+2|0]<<16|n[g+3|0]<<24,B=n[g+4|0]|n[g+5|0]<<8|n[g+6|0]<<16|n[g+7|0]<<24,C=n[g+8|0]|n[g+9|0]<<8|n[g+10|0]<<16|n[g+11|0]<<24,a=n[g+12|0]|n[g+13|0]<<8|n[g+14|0]<<16|n[g+15|0]<<24,c=n[g+16|0]|n[g+17|0]<<8|n[g+18|0]<<16|n[g+19|0]<<24,y=n[g+20|0]|n[g+21|0]<<8|n[g+22|0]<<16|n[g+23|0]<<24,w=n[g+24|0]|n[g+25|0]<<8|n[g+26|0]<<16|n[g+27|0]<<24,D=n[g+28|0]|n[g+29|0]<<8|n[g+30|0]<<16|n[g+31|0]<<24,g=n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24,f=n[I+4|0]|n[I+5|0]<<8|n[I+6|0]<<16|n[I+7|0]<<24,i=n[I+8|0]|n[I+9|0]<<8|n[I+10|0]<<16|n[I+11|0]<<24,I=n[I+12|0]|n[I+13|0]<<8|n[I+14|0]<<16|n[I+15|0]<<24;r=o,e=cg((s=g)^(g=o+e|0),16),r=c=cg(r^(o=e+c|0),12),c=cg((s=e)^(e=g+c|0),8),o=cg(r^(h=c+o|0),7),r=B,t=cg((g=B+t|0)^f,16),r=f=cg(r^(B=t+y|0),12),f=cg((s=t)^(t=g+f|0),8),g=cg(r^(y=f+B|0),7),r=C,B=cg((Q=Q+C|0)^i,16),r=i=cg(r^(C=B+w|0),12),s=cg(B^(i=Q+i|0),8),Q=cg(r^(B=s+C|0),7),E=cg((C=I)^(I=E+a|0),16),a=cg((C=E+D|0)^a,12),I=cg(E^(p=I+a|0),8),E=cg(a^(C=I+C|0),7),r=B,B=cg((B=I)^(I=g+e|0),16),g=cg((a=r+B|0)^g,12),I=cg(B^(e=I+g|0),8),B=cg(g^(w=a+I|0),7),r=C,C=cg((g=Q+t|0)^c,16),Q=cg((a=r+C|0)^Q,12),g=cg(C^(t=g+Q|0),8),C=cg(Q^(D=a+g|0),7),a=cg((Q=E+i|0)^f,16),E=cg((i=a+h|0)^E,12),f=cg(a^(Q=Q+E|0),8),a=cg(E^(c=i+f|0),7),i=cg((E=o+p|0)^s,16),o=cg((y=i+y|0)^o,12),i=cg(i^(E=E+o|0),8),o=cg(o^(y=y+i|0),7),10!=(0|(u=u+1|0)););bI(A,e),bI(A+4|0,t),bI(A+8|0,Q),bI(A+12|0,E),bI(A+16|0,g),bI(A+20|0,f),bI(A+24|0,i),bI(A+28|0,I)}function L(A,I,g,B,C,E,n,a){A|=0,I|=0,g|=0,B|=0,C|=0,E|=0,n|=0;var r,o=0,t=0,e=0,f=0,c=0,y=0,w=0,D=0,h=0;s=r=s-16|0,ag(a|=0);A:{I:if(B){D=4&a;g:for(;;){for(t=f;;){o=Q[g+t|0];B:{if(D?(e=o+4&(o+65488>>>8^-1)&(57-o>>>8^-1)&255|((e=o-65|0)>>>8^-1)&e&(90-o>>>8^-1)&255|o+185&(o+65439>>>8^-1)&(122-o>>>8^-1)&255|63&(1+(16288^o)>>>8^-1)|62&(1+(16338^o)>>>8^-1),e|=(0-e>>>8^-1)&1+(65470^o)>>>8&255):(e=o+4&(o+65488>>>8^-1)&(57-o>>>8^-1)&255|((e=o-65|0)>>>8^-1)&e&(90-o>>>8^-1)&255|o+185&(o+65439>>>8^-1)&(122-o>>>8^-1)&255|63&(1+(16336^o)>>>8^-1)|62&(1+(16340^o)>>>8^-1),e|=(0-e>>>8^-1)&1+(65470^o)>>>8&255),255==(0|e)){if(!C)break I;if(DA(C,o))break B;f=t;break I}if(w=e+(w<<6)|0,(f=c+6|0)>>>0<8)c=f;else{if(c=c-2|0,I>>>0<=y>>>0){i[r+12>>2]=t,i[8952]=68,h=1;break A}Q[A+y|0]=w>>>c,y=y+1|0}if((f=t+1|0)>>>0<B>>>0)continue g;break I}if(!((t=t+1|0)>>>0<B>>>0))break}break}f=(A=f+1|0)>>>0<B>>>0?B:A}i[r+12>>2]=f}A:if(c>>>0>4)I=0,A=-1;else if(A=-1,I=0,!((-1<<c^-1)&w|h)){if(!(2&a)){I:{g:{if(a=c>>>1|0)for(A=i[r+12>>2];;){if(A>>>0>=B>>>0){t=68;break g}if(61!=(0|(f=Q[A+g|0]))){if(t=28,!C)break g;if(!DA(C,f))break g}else a=a-1|0;if(A=A+1|0,i[r+12>>2]=A,!a)break}A=0;break I}i[8952]=t,A=-1}if(A)break A}if(A=0,C){I:if(!((t=i[r+12>>2])>>>0>=B>>>0)){for(;;){if(!DA(C,Q[g+t|0]))break I;if((0|(t=t+1|0))==(0|B))break}t=B}i[r+12>>2]=t}I=y}return C=i[r+12>>2],n?i[n>>2]=g+C:(0|B)!=(0|C)&&(i[8952]=28,A=-1),E&&(i[E>>2]=I),s=r+16|0,0|A}function K(A,I,g){var B=0,C=0,Q=0,E=0,i=0,a=0,r=0,o=0,t=0,e=0,f=0,c=0,y=0,s=0,w=0,D=0,h=0,p=0,u=0,F=0,l=0;for(C=2036477234,Q=857760878,E=1634760805,i=1797285236,w=20,o=n[0|g]|n[g+1|0]<<8|n[g+2|0]<<16|n[g+3|0]<<24,s=n[g+4|0]|n[g+5|0]<<8|n[g+6|0]<<16|n[g+7|0]<<24,D=n[g+8|0]|n[g+9|0]<<8|n[g+10|0]<<16|n[g+11|0]<<24,c=n[g+12|0]|n[g+13|0]<<8|n[g+14|0]<<16|n[g+15|0]<<24,t=n[g+16|0]|n[g+17|0]<<8|n[g+18|0]<<16|n[g+19|0]<<24,a=n[g+20|0]|n[g+21|0]<<8|n[g+22|0]<<16|n[g+23|0]<<24,e=n[g+24|0]|n[g+25|0]<<8|n[g+26|0]<<16|n[g+27|0]<<24,f=n[g+28|0]|n[g+29|0]<<8|n[g+30|0]<<16|n[g+31|0]<<24,g=n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24,r=n[I+4|0]|n[I+5|0]<<8|n[I+6|0]<<16|n[I+7|0]<<24,B=n[I+8|0]|n[I+9|0]<<8|n[I+10|0]<<16|n[I+11|0]<<24,I=n[I+12|0]|n[I+13|0]<<8|n[I+14|0]<<16|n[I+15|0]<<24;h=B,B=cg(E+a|0,7)^c,y=h^cg(B+E|0,9),p=cg(B+y|0,13)^a,c=cg(y+p|0,18),I=cg(Q+o|0,7)^I,e=cg(I+Q|0,9)^e,o=cg(I+e|0,13)^o,F=cg(e+o|0,18),f=cg(g+C|0,7)^f,a=cg(f+C|0,9)^s,u=cg(a+f|0,13)^g,l=cg(a+u|0,18),g=cg(i+t|0,7)^D,r=cg(g+i|0,9)^r,t=cg(g+r|0,13)^t,h=cg(r+t|0,18),o=cg((E^=c)+g|0,7)^o,s=cg(o+E|0,9)^a,D=cg(o+s|0,13)^g,E=cg(s+D|0,18)^E,g=cg((Q^=F)+B|0,7)^u,r=cg(g+Q|0,9)^r,c=cg(g+r|0,13)^B,Q=cg(r+c|0,18)^Q,t=cg((C^=l)+I|0,7)^t,B=cg(t+C|0,9)^y,I=cg(B+t|0,13)^I,C=cg(I+B|0,18)^C,a=cg((i^=h)+f|0,7)^p,e=cg(a+i|0,9)^e,f=cg(a+e|0,13)^f,i=cg(e+f|0,18)^i,y=w>>>0>2,w=w-2|0,y;);return bI(A,E),bI(A+4|0,Q),bI(A+8|0,C),bI(A+12|0,i),bI(A+16|0,g),bI(A+20|0,r),bI(A+24|0,B),bI(A+28|0,I),0}function X(A){var I,g=0,B=0;s=I=s-48|0,g=n[28+(A|=0)|0]|n[A+29|0]<<8|n[A+30|0]<<16|n[A+31|0]<<24,i[I+24>>2]=n[A+24|0]|n[A+25|0]<<8|n[A+26|0]<<16|n[A+27|0]<<24,i[I+28>>2]=g,g=n[A+20|0]|n[A+21|0]<<8|n[A+22|0]<<16|n[A+23|0]<<24,i[I+16>>2]=n[A+16|0]|n[A+17|0]<<8|n[A+18|0]<<16|n[A+19|0]<<24,i[I+20>>2]=g,g=n[A+4|0]|n[A+5|0]<<8|n[A+6|0]<<16|n[A+7|0]<<24,i[I>>2]=n[0|A]|n[A+1|0]<<8|n[A+2|0]<<16|n[A+3|0]<<24,i[I+4>>2]=g,g=n[A+12|0]|n[A+13|0]<<8|n[A+14|0]<<16|n[A+15|0]<<24,i[I+8>>2]=n[A+8|0]|n[A+9|0]<<8|n[A+10|0]<<16|n[A+11|0]<<24,i[I+12>>2]=g,g=n[A+40|0]|n[A+41|0]<<8|n[A+42|0]<<16|n[A+43|0]<<24,i[I+32>>2]=n[A+36|0]|n[A+37|0]<<8|n[A+38|0]<<16|n[A+39|0]<<24,i[I+36>>2]=g,vg[i[8752]](I,I,40,0,A+32|0,0,A),g=i[I+28>>2],B=i[I+24>>2],Q[A+24|0]=B,Q[A+25|0]=B>>>8,Q[A+26|0]=B>>>16,Q[A+27|0]=B>>>24,Q[A+28|0]=g,Q[A+29|0]=g>>>8,Q[A+30|0]=g>>>16,Q[A+31|0]=g>>>24,g=i[I+20>>2],B=i[I+16>>2],Q[A+16|0]=B,Q[A+17|0]=B>>>8,Q[A+18|0]=B>>>16,Q[A+19|0]=B>>>24,Q[A+20|0]=g,Q[A+21|0]=g>>>8,Q[A+22|0]=g>>>16,Q[A+23|0]=g>>>24,g=i[I+12>>2],B=i[I+8>>2],Q[A+8|0]=B,Q[A+9|0]=B>>>8,Q[A+10|0]=B>>>16,Q[A+11|0]=B>>>24,Q[A+12|0]=g,Q[A+13|0]=g>>>8,Q[A+14|0]=g>>>16,Q[A+15|0]=g>>>24,g=i[I+4>>2],B=i[I>>2],Q[0|A]=B,Q[A+1|0]=B>>>8,Q[A+2|0]=B>>>16,Q[A+3|0]=B>>>24,Q[A+4|0]=g,Q[A+5|0]=g>>>8,Q[A+6|0]=g>>>16,Q[A+7|0]=g>>>24,g=i[I+36>>2],B=i[I+32>>2],Q[A+36|0]=B,Q[A+37|0]=B>>>8,Q[A+38|0]=B>>>16,Q[A+39|0]=B>>>24,Q[A+40|0]=g,Q[A+41|0]=g>>>8,Q[A+42|0]=g>>>16,Q[A+43|0]=g>>>24,YI(A),s=I+48|0}function T(A,I){var g,B,C,E,n,a,o,t,e=0,f=0;s=g=s-48|0,B=i[I+28>>2],C=i[I+24>>2],E=i[I+20>>2],n=i[I+16>>2],a=i[I+12>>2],o=i[I+8>>2],t=i[I+4>>2],e=i[I>>2],f=i[I+36>>2],I=i[I+32>>2],e=r(((B+(C+(E+(n+(a+(o+(t+(e+(r(f,19)+16777216>>>25|0)>>26)>>25)>>26)>>25)>>26)>>25)>>26)>>25)+I>>26)+f>>25,19)+e|0,i[g>>2]=67108863&e,e=t+(e>>26)|0,i[g+4>>2]=33554431&e,e=o+(e>>25)|0,i[g+8>>2]=67108863&e,e=a+(e>>26)|0,i[g+12>>2]=33554431&e,e=n+(e>>25)|0,i[g+16>>2]=67108863&e,e=E+(e>>26)|0,i[g+20>>2]=33554431&e,e=C+(e>>25)|0,i[g+24>>2]=67108863&e,e=B+(e>>26)|0,i[g+28>>2]=33554431&e,I=I+(e>>25)|0,i[g+32>>2]=67108863&I,i[g+36>>2]=f+(I>>26)&33554431,I=i[g>>2],Q[0|A]=I,Q[A+2|0]=I>>>16,Q[A+1|0]=I>>>8,f=i[g+4>>2],Q[A+5|0]=f>>>14,Q[A+4|0]=f>>>6,Q[A+3|0]=f<<2|I>>>24,I=i[g+8>>2],Q[A+8|0]=I>>>13,Q[A+7|0]=I>>>5,Q[A+6|0]=I<<3|f>>>22,f=i[g+12>>2],Q[A+11|0]=f>>>11,Q[A+10|0]=f>>>3,Q[A+9|0]=f<<5|I>>>21,I=i[g+16>>2],Q[A+15|0]=I>>>18,Q[A+14|0]=I>>>10,Q[A+13|0]=I>>>2,Q[A+12|0]=I<<6|f>>>19,I=i[g+20>>2],Q[A+16|0]=I,Q[A+18|0]=I>>>16,Q[A+17|0]=I>>>8,f=i[g+24>>2],Q[A+21|0]=f>>>15,Q[A+20|0]=f>>>7,Q[A+19|0]=f<<1|I>>>24,I=i[g+28>>2],Q[A+24|0]=I>>>13,Q[A+23|0]=I>>>5,Q[A+22|0]=I<<3|f>>>23,f=i[g+32>>2],Q[A+27|0]=f>>>12,Q[A+26|0]=f>>>4,Q[A+25|0]=f<<4|I>>>21,I=i[g+36>>2],Q[A+31|0]=I>>>18,Q[A+30|0]=I>>>10,Q[A+29|0]=I>>>2,Q[A+28|0]=I<<6|f>>>20,s=g+48|0}function V(A,I){var g,B,C,Q,E,i=0,a=0,r=0;for(s=g=s-288|0,N(E=A+40|0,I),ng(a=A+80|0),U(B=g+240|0,E),H(C=g+192|0,B,1424),cA(B,B,a),yA(C,C,a),U(Q=g+144|0,C),H(Q,Q,C),U(A,Q),H(A,A,C),H(A,A,B),s=a=s-144|0,U(i=a+96|0,A),U(r=a+48|0,i),U(r,r),H(r,A,r),H(i,i,r),U(i,i),H(i,r,i),U(r,i),i=1;U(r=a+48|0,r),5!=(0|(i=i+1|0)););for(H(i=a+96|0,r=a+48|0,i),U(r,i),i=1;U(r=a+48|0,r),10!=(0|(i=i+1|0)););for(H(i=a+48|0,i,a+96|0),U(a,i),i=1;U(a,a),20!=(0|(i=i+1|0)););for(H(i=a+48|0,a,i),i=1;U(r=a+48|0,r),11!=(0|(i=i+1|0)););for(H(i=a+96|0,r=a+48|0,i),U(r,i),i=1;U(r=a+48|0,r),50!=(0|(i=i+1|0)););for(H(i=a+48|0,i,a+96|0),U(a,i),i=1;U(a,a),100!=(0|(i=i+1|0)););for(H(i=a+48|0,a,i),i=1;U(r=a+48|0,r),51!=(0|(i=i+1|0)););H(i=a+96|0,a+48|0,i),U(i,i),U(i,i),H(A,i,A),s=a+144|0,H(A,A,Q),H(A,A,B),U(a=g+96|0,A),H(a,a,C),cA(i=g+48|0,a,B);A:{if(!mI(i)){if(yA(g,g+96|0,g+240|0),a=-1,!mI(g))break A;H(A,A,1472)}(0|vI(A))==(n[I+31|0]>>>7|0)&&kA(A,A),H(A+120|0,A,E),a=0}return s=g+288|0,a}function q(A,I,g,B,C){var E,a,r=0,o=0,t=0;for(s=E=(s=a=s-416|0)-192|0,GI(a),wI(E- -64|0,54,128),Q[E+64|0]=54^n[0|C],r=1;Q[0|(o=(E- -64|0)+r|0)]=n[0|o]^n[C+r|0],32!=(0|(r=r+1|0)););for(z(a,r=E- -64|0,128,0),GI(o=a+208|0),wI(r,92,128),Q[E+64|0]=92^n[0|C],r=1;Q[0|(t=(E- -64|0)+r|0)]=n[0|t]^n[C+r|0],32!=(0|(r=r+1|0)););return z(o,C=E- -64|0,128,0),Dg(C,128),Dg(E,64),s=E+192|0,z(a,I,g,B),s=g=(s=I=s+-64|0)-64|0,MA(a,g),z(B=a+208|0,g,64,0),MA(B,I),Dg(g,64),s=g- -64|0,g=i[I+28>>2],B=i[I+24>>2],Q[A+24|0]=B,Q[A+25|0]=B>>>8,Q[A+26|0]=B>>>16,Q[A+27|0]=B>>>24,Q[A+28|0]=g,Q[A+29|0]=g>>>8,Q[A+30|0]=g>>>16,Q[A+31|0]=g>>>24,g=i[I+20>>2],B=i[I+16>>2],Q[A+16|0]=B,Q[A+17|0]=B>>>8,Q[A+18|0]=B>>>16,Q[A+19|0]=B>>>24,Q[A+20|0]=g,Q[A+21|0]=g>>>8,Q[A+22|0]=g>>>16,Q[A+23|0]=g>>>24,g=i[I+12>>2],B=i[I+8>>2],Q[A+8|0]=B,Q[A+9|0]=B>>>8,Q[A+10|0]=B>>>16,Q[A+11|0]=B>>>24,Q[A+12|0]=g,Q[A+13|0]=g>>>8,Q[A+14|0]=g>>>16,Q[A+15|0]=g>>>24,g=i[I+4>>2],B=i[I>>2],Q[0|A]=B,Q[A+1|0]=B>>>8,Q[A+2|0]=B>>>16,Q[A+3|0]=B>>>24,Q[A+4|0]=g,Q[A+5|0]=g>>>8,Q[A+6|0]=g>>>16,Q[A+7|0]=g>>>24,s=I- -64|0,s=a+416|0,0}function z(A,I,g,B){var C,E=0,a=0,r=0,o=0,t=0,e=0;s=C=s-704|0;A:if(g|B){if(r=B<<3|(E=g)>>>29,a=(t=i[A+72>>2])+(e=E<<3)|0,E=r+(o=i[A+76>>2])|0,i[A+72>>2]=a,E=a>>>0<e>>>0?E+1|0:E,i[A+76>>2]=E,r=(e=(0|E)==(0|o)&a>>>0<t>>>0|E>>>0<o>>>0)+i[(a=A- -64|0)>>2]|0,E=i[a+4>>2],E=r>>>0<e>>>0?E+1|0:E,r=(e=B>>>29|0)+r|0,i[a>>2]=r,i[a+4>>2]=r>>>0<e>>>0?E+1|0:E,a=0,E=0,(0|(r=0-((o=127&((7&o)<<29|t>>>3))>>>0>128)|0))==(0|B)&g>>>0<(t=128-o|0)>>>0|B>>>0<r>>>0)for(;;)if(Q[80+(A+(t=a+o|0)|0)|0]=n[I+a|0],!((0|g)!=(0|(a=a+1|0))|(0|B)!=(0|(E=a?E:E+1|0))))break A;for(;Q[80+(A+(e=a+o|0)|0)|0]=n[I+a|0],(0|t)!=(0|(a=a+1|0))|(0|(E=a?E:E+1|0))!=(0|r););if(F(A,A+80|0,C,E=C+640|0),I=I+t|0,!(B=B-((g>>>0<t>>>0)+r|0)|0)&(g=g-t|0)>>>0>127|B)for(;F(A,I,C,E),I=I+128|0,!(B=B-(g>>>0<128)|0)&(g=g-128|0)>>>0>127|B;);if(g|B)for(a=0,E=0;Q[80+(A+a|0)|0]=n[I+a|0],(0|g)!=(0|(a=o=a+1|0))|(0|B)!=(0|(E=o?E:E+1|0)););Dg(C,704)}return s=C+704|0,0}function j(A,I,g){var B,C,Q,E=0;s=B=s-16|0,C=i[A+20>>2],i[A+20>>2]=0,Q=i[A+4>>2],i[A+4>>2]=0,E=-26;A:{I:{g:switch(g-1|0){case 1:if(E=-32,LA(I,1109,9))break A;I=I+9|0;break I;case 0:break g;default:break A}if(E=-32,LA(I,1100,8))break A;I=I+8|0}if(!LA(I,1352,3)&&(I=_A(I+3|0,B+12|0))){if(E=-26,19!=i[B+12>>2])break A;if(!LA(I,1364,3)&&(I=_A(I+3|0,B+12|0))&&(i[A+44>>2]=i[B+12>>2],!LA(I,1356,3)&&(I=_A(I+3|0,B+12|0))&&(i[A+40>>2]=i[B+12>>2],!LA(I,1360,3)&&(I=_A(I+3|0,B+12|0))&&(g=i[B+12>>2],i[A+48>>2]=g,i[A+52>>2]=g,36==(0|(g=n[0|I]))&&(i[B+12>>2]=C,I=I+(36==(0|g))|0,!L(i[A+16>>2],C,I,mA(I),0,B+12|0,B+8|0,3)&&(i[A+20>>2]=i[B+12>>2],I=i[B+8>>2],36==(0|(g=n[0|I]))&&(i[B+12>>2]=Q,I=I+(36==(0|g))|0,!L(i[A>>2],Q,I,mA(I),0,B+12|0,B+8|0,3)))))))){if(i[A+4>>2]=i[B+12>>2],I=i[B+8>>2],E=nA(A))break A;E=n[0|I]?-32:0;break A}}E=-32}return s=B+16|0,E}function W(A,I){var g,B,C,E,n,a,o,t,e,f,c,y=0,s=0,w=0,D=0,h=0,p=0;(s=i[A+56>>2])|(y=i[A+60>>2])&&(Q[(D=A+s|0)- -64|0]=1,!(y=(w=s+1|0)?y:y+1|0)&w>>>0<=15&&wI(D+65|0,0,15-s|0),Q[A+80|0]=1,M(A,A- -64|0,16,0)),e=i[A+52>>2],f=i[A+48>>2],c=i[A+44>>2],h=i[A+24>>2],w=i[A+28>>2]+(h>>>26|0)|0,s=i[A+32>>2]+(w>>>26|0)|0,C=i[A+36>>2]+(s>>>26|0)|0,a=67108863&s,w=(s=(67108863&h)+((y=i[A+20>>2]+r(C>>>26|0,5)|0)>>>26|0)|0)&(g=(E=(-67108864|C)+((o=a+((h=(p=67108863&w)+((y=s+((n=5+(D=67108863&y)|0)>>>26|0)|0)>>>26|0)|0)>>>26|0)|0)>>>26|0)|0)>>31)|(B=67108863&(t=(E>>>31|0)-1|0))&y,y=0,y=(s=w<<26|B&n|D&g)>>>0>(D=s+i[A+40>>2]|0)>>>0?1:y,bI(I,D),s=0,s=(w=(p=p&g|h&B)<<20|w>>>6)>>>0>(h=w+c|0)>>>0?1:s,w=y,h=y+h|0,y=s,y=w>>>0>h>>>0?y+1|0:y,bI(I+4|0,h),s=0,s=(w=(D=g&a|B&o)<<14|p>>>12)>>>0>(p=w+f|0)>>>0?1:s,w=y,p=y+p|0,y=s,y=w>>>0>p>>>0?y+1|0:y,bI(I+8|0,p),bI(s=I+12|0,y=y+(D=(I=(E&t|g&C)<<8|D>>>18)+e|0)|0),Dg(A,88)}function O(A,I){var g,B,C=0;for(s=g=s-192|0,U(B=g+144|0,I),U(C=g+96|0,B),U(C,C),H(C,I,C),H(B,B,C),U(I=g+48|0,B),H(C,C,I),U(I,C),I=1;U(C=g+48|0,C),5!=(0|(I=I+1|0)););for(H(I=g+96|0,C=g+48|0,I),U(C,I),I=1;U(C=g+48|0,C),10!=(0|(I=I+1|0)););for(H(I=g+48|0,I,g+96|0),U(g,I),I=1;U(g,g),20!=(0|(I=I+1|0)););for(H(I=g+48|0,g,I),I=1;U(C=g+48|0,C),11!=(0|(I=I+1|0)););for(H(I=g+96|0,C=g+48|0,I),U(C,I),I=1;U(C=g+48|0,C),50!=(0|(I=I+1|0)););for(H(I=g+48|0,I,g+96|0),U(g,I),I=1;U(g,g),100!=(0|(I=I+1|0)););for(H(I=g+48|0,g,I),I=1;U(C=g+48|0,C),51!=(0|(I=I+1|0)););for(H(I=g+96|0,g+48|0,I),I=1;U(C=g+96|0,C),6!=(0|(I=I+1|0)););H(A,g+96|0,g+144|0),s=g+192|0}function Z(A,I,g,B,C){A|=0,I|=0,g|=0,B|=0;var E=0,i=0,a=0,o=0,f=0,c=0,y=0,s=0;ag(C|=0),i=(E=(B>>>0)/3|0)<<2,(E=r(E,-3)+B|0)&&(i=2&C?(2|i)+(E>>>1|0)|0:i+4|0);A:{I:{g:{if(I>>>0>i>>>0){if(!(4&C)){if(C=0,!B)break A;E=0;break g}if(C=0,!B)break A;for(E=0;;){for(f=(o=n[g+a|0])|f<<8,E=E+8|0;c=E,y=A+C|0,s=Qg(f>>>(E=E-6|0)&63),Q[0|y]=s,C=C+1|0,E>>>0>5;);if((0|(a=a+1|0))==(0|B))break}if(!E)break A;g=Qg(o<<12-c&63);break I}xI(),t()}for(;;){for(f=(o=n[g+a|0])|f<<8,E=E+8|0;c=E,y=A+C|0,s=Eg(f>>>(E=E-6|0)&63),Q[0|y]=s,C=C+1|0,E>>>0>5;);if((0|(a=a+1|0))==(0|B))break}if(!E)break A;g=Eg(o<<12-c&63)}Q[A+C|0]=g,C=C+1|0}A:{I:{if(C>>>0<=i>>>0){if(C>>>0<i>>>0)break I;i=C;break A}e(1048,1145,230,1375),t()}wI(A+C|0,61,i-C|0)}return wI(A+i|0,0,(I>>>0>(g=i+1|0)>>>0?I:g)-i|0),0|A}function $(A,I,g,B){var C=0,E=0,a=0,r=0,o=0,t=0;A:{if((r=i[A+56>>2])|(o=i[A+60>>2])){if(t=C=(a=(0|(C=0-((r>>>0>16)+o|0)|0))==(0|B)&g>>>0>(E=16-r|0)>>>0|B>>>0>C>>>0)?C:B,C|(E=a?E:g))for(a=0,C=0;Q[(A+(o=a+r|0)|0)- -64|0]=n[I+a|0],r=i[A+56>>2],o=i[A+60>>2],(0|E)!=(0|(a=a+1|0))|(0|(C=a?C:C+1|0))!=(0|t););if(C=o+t|0,C=(r=E+r|0)>>>0<E>>>0?C+1|0:C,i[A+56>>2]=r,i[A+60>>2]=C,!C&r>>>0<16)break A;M(A,A- -64|0,16,0),i[A+56>>2]=0,i[A+60>>2]=0,g=(C=g)-E|0,B=B-((C>>>0<E>>>0)+t|0)|0,I=I+E|0}if(!B&g>>>0>=16|B&&(M(A,I,C=-16&g,B),g&=15,B=0,I=I+C|0),g|B){for(a=0,C=0;E=a+i[A+56>>2]|0,Q[(A+E|0)- -64|0]=n[I+a|0],a=E=a+1|0,(0|g)!=(0|E)|(0|B)!=(0|(C=E?C:C+1|0)););I=B+i[A+60>>2]|0,I=(C=g+i[A+56>>2]|0)>>>0<g>>>0?I+1|0:I,i[A+56>>2]=C,i[A+60>>2]=I}}}function AA(A,I,g){var B,C,Q,E,n,a,r,o,t,e,f,c,y=0,s=0,w=0,D=0,h=0,p=0,u=0,F=0,l=0;B=i[I+4>>2],C=i[A+4>>2],Q=i[I+8>>2],s=i[A+8>>2],E=i[I+12>>2],w=i[A+12>>2],n=i[I+16>>2],D=i[A+16>>2],a=i[I+20>>2],h=i[A+20>>2],r=i[I+24>>2],p=i[A+24>>2],o=i[I+28>>2],u=i[A+28>>2],t=i[I+32>>2],F=i[A+32>>2],e=i[I+36>>2],l=i[A+36>>2],c=(g=0-g|0)&((f=i[I>>2])^(y=i[A>>2])),i[A>>2]=c^y,y=l,l=g&(l^e),i[A+36>>2]=y^l,y=F,F=g&(F^t),i[A+32>>2]=y^F,y=u,u=g&(u^o),i[A+28>>2]=y^u,y=p,p=g&(p^r),i[A+24>>2]=y^p,y=h,h=g&(h^a),i[A+20>>2]=y^h,y=D,D=g&(D^n),i[A+16>>2]=y^D,y=w,w=g&(w^E),i[A+12>>2]=y^w,y=s,s=g&(s^Q),i[A+8>>2]=y^s,y=A,A=g&(B^C),i[y+4>>2]=A^C,i[I+36>>2]=l^e,i[I+32>>2]=F^t,i[I+28>>2]=u^o,i[I+24>>2]=p^r,i[I+20>>2]=h^a,i[I+16>>2]=D^n,i[I+12>>2]=w^E,i[I+8>>2]=s^Q,i[I+4>>2]=A^B,i[I>>2]=f^c}function IA(A,I){var g;i[A>>2]=67108863&(n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24),i[A+4>>2]=(n[I+3|0]|n[I+4|0]<<8|n[I+5|0]<<16|n[I+6|0]<<24)>>>2&67108611,i[A+8>>2]=(n[I+6|0]|n[I+7|0]<<8|n[I+8|0]<<16|n[I+9|0]<<24)>>>4&67092735,i[A+12>>2]=(n[I+9|0]|n[I+10|0]<<8|n[I+11|0]<<16|n[I+12|0]<<24)>>>6&66076671,g=n[I+12|0]|n[I+13|0]<<8|n[I+14|0]<<16|n[I+15|0]<<24,i[A+20>>2]=0,i[A+24>>2]=0,i[A+28>>2]=0,i[A+32>>2]=0,i[A+36>>2]=0,i[A+16>>2]=g>>>8&1048575,i[A+40>>2]=n[I+16|0]|n[I+17|0]<<8|n[I+18|0]<<16|n[I+19|0]<<24,i[A+44>>2]=n[I+20|0]|n[I+21|0]<<8|n[I+22|0]<<16|n[I+23|0]<<24,i[A+48>>2]=n[I+24|0]|n[I+25|0]<<8|n[I+26|0]<<16|n[I+27|0]<<24,I=n[I+28|0]|n[I+29|0]<<8|n[I+30|0]<<16|n[I+31|0]<<24,Q[A+80|0]=0,i[A+56>>2]=0,i[A+60>>2]=0,i[A+52>>2]=I}function gA(A,I,g,B){var C=0,E=0,i=0,a=0,r=0,o=0;if(g|B){if(!B&(E=256-(C=n[A+352|0]|n[A+353|0]<<8|n[A+354|0]<<16|n[A+355|0]<<24)|0)>>>0<g>>>0|B)for(o=A+224|0,a=A+96|0;eI(96+(A+C|0)|0,I,E),i=(n[A+352|0]|n[A+353|0]<<8|n[A+354|0]<<16|n[A+355|0]<<24)+E|0,Q[A+352|0]=i,Q[A+353|0]=i>>>8,Q[A+354|0]=i>>>16,Q[A+355|0]=i>>>24,CA(A,128),p(A,a),eI(a,o,128),C=(r=n[A+352|0]|n[A+353|0]<<8|n[A+354|0]<<16|n[A+355|0]<<24)-128|0,Q[A+352|0]=C,Q[A+353|0]=C>>>8,Q[A+354|0]=C>>>16,Q[A+355|0]=C>>>24,I=I+E|0,i=g,g=g-E|0,!(B=B-(E>>>0>i>>>0)|0)&(E=384-r|0)>>>0<g>>>0|B;);eI(96+(A+C|0)|0,I,g),I=g+(n[A+352|0]|n[A+353|0]<<8|n[A+354|0]<<16|n[A+355|0]<<24)|0,Q[A+352|0]=I,Q[A+353|0]=I>>>8,Q[A+354|0]=I>>>16,Q[A+355|0]=I>>>24}return 0}function BA(A,I){var g,B=0,C=0,E=0,i=0;for(s=g=s-464|0;C=(g+400|0)+(B<<1)|0,i=n[I+B|0],Q[C+1|0]=i>>>4,Q[0|C]=15&i,32!=(0|(B=B+1|0)););for(B=0;I=((C=(I=B)+n[0|(B=(g+400|0)+E|0)]|0)<<24)- -134217728|0,Q[0|B]=C-(I>>24&240),B=I>>28,63!=(0|(E=E+1|0)););for(Q[g+463|0]=n[g+463|0]+B,LI(A),B=1;FA(g,B>>>1|0,Q[(g+400|0)+B|0]),TA(I=g+240|0,A,g),tI(A,I),I=B>>>0<62,B=B+2|0,I;);for(fI(I=g+240|0,A),hI(B=g+120|0,I),G(I,B),hI(B,I),G(I,B),hI(B,I),G(I,B),tI(A,I),B=0;FA(g,B>>>1|0,Q[(g+400|0)+B|0]),TA(I=g+240|0,A,g),tI(A,I),I=B>>>0<62,B=B+2|0,I;);s=g+464|0}function CA(A,I){var g,B,C,E=0,i=0;C=1+(i=g=n[4+(E=A- -64|0)|0]|n[E+5|0]<<8|n[E+6|0]<<16|n[E+7|0]<<24)|0,i=(I=I+(i=B=n[0|E]|n[E+1|0]<<8|n[E+2|0]<<16|n[E+3|0]<<24)|0)>>>0<i>>>0?C:g,Q[0|E]=I,Q[E+1|0]=I>>>8,Q[E+2|0]=I>>>16,Q[E+3|0]=I>>>24,Q[E+4|0]=i,Q[E+5|0]=i>>>8,Q[E+6|0]=i>>>16,Q[E+7|0]=i>>>24,I=(E=(0|i)==(0|g)&I>>>0<B>>>0|i>>>0<g>>>0)+(n[A+72|0]|n[A+73|0]<<8|n[A+74|0]<<16|n[A+75|0]<<24)|0,i=n[A+76|0]|n[A+77|0]<<8|n[A+78|0]<<16|n[A+79|0]<<24,E=I>>>0<E>>>0?i+1|0:i,Q[A+72|0]=I,Q[A+73|0]=I>>>8,Q[A+74|0]=I>>>16,Q[A+75|0]=I>>>24,Q[A+76|0]=E,Q[A+77|0]=E>>>8,Q[A+78|0]=E>>>16,Q[A+79|0]=E>>>24}function QA(A,I){i[A>>2]=1634760805,i[A+4>>2]=857760878,i[A+8>>2]=2036477234,i[A+12>>2]=1797285236,i[A+16>>2]=n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24,i[A+20>>2]=n[I+4|0]|n[I+5|0]<<8|n[I+6|0]<<16|n[I+7|0]<<24,i[A+24>>2]=n[I+8|0]|n[I+9|0]<<8|n[I+10|0]<<16|n[I+11|0]<<24,i[A+28>>2]=n[I+12|0]|n[I+13|0]<<8|n[I+14|0]<<16|n[I+15|0]<<24,i[A+32>>2]=n[I+16|0]|n[I+17|0]<<8|n[I+18|0]<<16|n[I+19|0]<<24,i[A+36>>2]=n[I+20|0]|n[I+21|0]<<8|n[I+22|0]<<16|n[I+23|0]<<24,i[A+40>>2]=n[I+24|0]|n[I+25|0]<<8|n[I+26|0]<<16|n[I+27|0]<<24,i[A+44>>2]=n[I+28|0]|n[I+29|0]<<8|n[I+30|0]<<16|n[I+31|0]<<24}function EA(A,I,g,B,C,Q,E){var n,a,r,o,t,e=0;return s=n=s-352|0,K(n,Q,E),!((!C&B>>>0>A-g>>>0|0!=(0|C))&A>>>0>g>>>0)&(!C&B>>>0<=g-A>>>0|A>>>0>=g>>>0)||(g=gI(A,g,B)),i[n+56>>2]=0,i[n+60>>2]=0,i[n+48>>2]=0,i[n+52>>2]=0,i[n+40>>2]=0,i[n+44>>2]=0,i[n+32>>2]=0,i[n+36>>2]=0,(r=!((E=(e=!C&B>>>0<32)?B:32)|(e=e?C:0)))||eI(n- -64|0,g,E),o=Q+16|0,XI(a=n+32|0,a,t=E+32|0,Q=t>>>0<32?e+1|0:e,o,n),og(n+96|0,a),r||eI(A,n- -64|0,E),Dg(n+32|0,64),!C&B>>>0>=33|C&&KI(A+E|0,g+E|0,B-E|0,C-(e+(B>>>0<E>>>0)|0)|0,o,n),Dg(n,32),gg(g=n+96|0,A,B,C),tg(g,I),Dg(g,256),s=n+352|0,0}function iA(A,I,g,B,C,Q,E){var n,a,r=0,o=0,t=0;s=n=s-96|0,K(n,Q,E),E=n+32|0,a=Q+16|0,vg[i[8760]](E,32,0,a,n),Q=-1;A:{if(!(0|vg[i[8754]](g,I,B,C,E))){if(Q=0,!A)break A;!((!C&B>>>0>I-A>>>0|0!=(0|C))&A>>>0<I>>>0)&(!C&B>>>0<=A-I>>>0|A>>>0<=I>>>0)||(I=gI(A,I,B)),g=(Q=!C&B>>>0<32)?B:32,E=Q=Q?C:0,g|Q?(o=eI(n- -64|0,I,g),r=Q=n+32|0,Q=E,XI(r,r,t=g+32|0,Q=t>>>0<32?Q+1|0:Q,a,n),eI(A,o,g)):(r=Q=n+32|0,Q=E,XI(r,r,o=g+32|0,Q=o>>>0<32?Q+1|0:Q,a,n)),Q=0,!C&B>>>0<33||KI(A+g|0,I+g|0,B-g|0,C-(E+(g>>>0>B>>>0)|0)|0,a,n)}Dg(n,32)}return s=n+96|0,Q}function nA(A){var I=0,g=0,B=0;if(!A)return-25;if(!i[A>>2])return-1;if(I=-2,!(a[A+4>>2]<16)&&(i[A+8>>2]||(I=-18,!i[A+12>>2]))){if(g=i[A+20>>2],!i[A+16>>2])return g?-19:-6;if(I=-6,!(g>>>0<8)&&(i[A+24>>2]||(I=-20,!i[A+28>>2]))&&(i[A+32>>2]||(I=-21,!i[A+36>>2]))){if(!(g=i[A+48>>2]))return-16;if(I=-17,!(g>>>0>16777215||(I=-14,(B=i[A+44>>2])>>>0<8||(I=-15,B>>>0>2097152||(I=-14,g<<3>>>0>B>>>0))))){if(!i[A+40>>2])return-12;if(!(A=i[A+52>>2]))return-28;I=A>>>0>16777215?-29:0}}}return I}function aA(A,I,g){var B,C,Q,E,n,a,r,o,t,e,f,c,y,s,w,D,h,p,u,F;f=i[I+4>>2],B=i[A+4>>2],c=i[I+8>>2],C=i[A+8>>2],y=i[I+12>>2],Q=i[A+12>>2],s=i[I+16>>2],E=i[A+16>>2],w=i[I+20>>2],n=i[A+20>>2],D=i[I+24>>2],a=i[A+24>>2],h=i[I+28>>2],r=i[A+28>>2],p=i[I+32>>2],o=i[A+32>>2],u=i[I+36>>2],t=i[A+36>>2],e=i[A>>2],F=i[I>>2]^e,I=0-g|0,i[A>>2]=e^F&I,i[A+36>>2]=I&(t^u)^t,i[A+32>>2]=I&(o^p)^o,i[A+28>>2]=I&(r^h)^r,i[A+24>>2]=I&(a^D)^a,i[A+20>>2]=I&(n^w)^n,i[A+16>>2]=I&(E^s)^E,i[A+12>>2]=I&(Q^y)^Q,i[A+8>>2]=I&(C^c)^C,i[A+4>>2]=I&(B^f)^B}function rA(A,I,g,B,C,Q,E,a,r,o){var t,e,f,c;return s=t=s-48|0,i[t+4>>2]=0,x(e=t+16|0,r,o),o=n[r+20|0]|n[r+21|0]<<8|n[r+22|0]<<16|n[r+23|0]<<24,i[t+8>>2]=n[r+16|0]|n[r+17|0]<<8|n[r+18|0]<<16|n[r+19|0]<<24,i[t+12>>2]=o,s=o=s-352|0,$I(f=o+32|0,64,c=t+4|0,e),og(r=o+96|0,f),Dg(f,64),gg(r,Q,E,a),gg(r,34960,0-E&15,0),gg(r,I,g,B),gg(r,34960,0-g&15,0),QI(Q=o+24|0,E,a),gg(r,Q,8,0),QI(Q,g,B),gg(r,Q,8,0),tg(r,o),Dg(r,256),C=rg(o,C),Dg(o,16),A&&(C?(wI(A,0,g),C=-1):(kI(A,I,g,B,c,1,e),C=0)),s=o+352|0,Dg(e,32),s=t+48|0,C}function oA(A,I){for(var g=0,B=0,C=0,E=0,i=0,a=0,r=0,o=0;Q[A+g|0]=n[(g>>>3|0)+I|0]>>>(7&g)&1,256!=(0|(g=g+1|0)););for(;;){a=(I=a)+1|0;A:if(n[0|(i=A+I|0)]&&(g=a,C=1,!(I>>>0>254)))for(;;){I:if(E=Q[0|(B=A+g|0)])if((0|(o=(r=Q[0|i])+(E<<=C)|0))<=15)Q[0|i]=o,Q[0|B]=0;else{if((0|(B=r-E|0))<-15)break A;for(Q[0|i]=B;;){if(!n[0|(B=A+g|0)]){Q[0|B]=1;break I}if(Q[0|B]=0,B=g>>>0<255,g=g+1|0,!B)break}}if(C>>>0>5)break A;if(!((g=I+(C=C+1|0)|0)>>>0<256))break}if(256==(0|a))break}}function tA(A,I,g,B){var C,Q,E,n,a=0;s=C=s+-64|0,wI(C+8|0,0,52),a=mA(A),i[C+20>>2]=a,i[C+36>>2]=a,i[C+4>>2]=a,Q=k(a),i[C+32>>2]=Q,E=k(a),i[C+16>>2]=E,n=k(a),i[C>>2]=n;A:if(!n|!Q|!E||!(a=k(a)))b(Q),b(E),b(n),A=-22;else{if(A=j(C,A,B)){b(i[C+32>>2]),b(i[C+16>>2]),b(i[C>>2]),b(a);break A}A=0,I=_(i[C+40>>2],i[C+44>>2],i[C+52>>2],I,g,i[C+16>>2],i[C+20>>2],a,i[C+4>>2],0,0,B),b(i[C+32>>2]),b(i[C+16>>2]),(I||zA(a,i[C>>2],i[C+4>>2]))&&(A=-35),b(a),b(i[C>>2])}return s=C- -64|0,A}function eA(A,I,g,B,C){var Q,E=0,a=0;s=Q=s+-64|0;A:{I:{if(!g&(a=mA(A))>>>0<128){if(i[Q+56>>2]=0,i[Q+48>>2]=0,i[Q+52>>2]=0,i[Q+40>>2]=0,i[Q+44>>2]=0,g=0,a&&(g=a),!(E=k(g))|!(3&n[E-4|0])||wI(E,0,g),E)break I}else i[8952]=28;A=-1;break A}i[Q+32>>2]=0,i[Q+36>>2]=0,i[Q+8>>2]=E,i[Q+16>>2]=E,i[Q+20>>2]=a,i[Q>>2]=E,i[Q+12>>2]=a,i[Q+24>>2]=0,i[Q+28>>2]=0,i[Q+4>>2]=a,j(Q,A,C)?(i[8952]=28,A=-1):A=(0|I)!=i[Q+40>>2]|i[Q+44>>2]!=(B>>>10|0),b(E)}return s=Q- -64|0,A}function fA(A,I,g,B,C,Q,E,a,r,o,t){var e,f,c,y;return s=e=s-48|0,i[e+4>>2]=0,x(f=e+16|0,o,t),t=n[o+20|0]|n[o+21|0]<<8|n[o+22|0]<<16|n[o+23|0]<<24,i[e+8>>2]=n[o+16|0]|n[o+17|0]<<8|n[o+18|0]<<16|n[o+19|0]<<24,i[e+12>>2]=t,s=t=s-336|0,$I(c=t+16|0,64,y=e+4|0,f),og(o=t+80|0,c),Dg(c,64),gg(o,E,a,r),gg(o,34960,0-a&15,0),kI(A,B,C,Q,y,1,f),gg(o,A,C,Q),gg(o,34960,0-C&15,0),QI(A=t+8|0,a,r),gg(o,A,8,0),QI(A,C,Q),gg(o,A,8,0),tg(o,I),Dg(o,256),g&&(i[g>>2]=16,i[g+4>>2]=0),s=t+336|0,Dg(f,32),s=e+48|0,0}function cA(A,I,g){var B,C,Q,E,n,a,r,o,t,e,f,c,y,s,w,D,h,p;B=i[g+4>>2],C=i[I+4>>2],Q=i[g+8>>2],E=i[I+8>>2],n=i[g+12>>2],a=i[I+12>>2],r=i[g+16>>2],o=i[I+16>>2],t=i[g+20>>2],e=i[I+20>>2],f=i[g+24>>2],c=i[I+24>>2],y=i[g+28>>2],s=i[I+28>>2],w=i[g+32>>2],D=i[I+32>>2],h=i[g+36>>2],p=i[I+36>>2],i[A>>2]=i[I>>2]-i[g>>2],i[A+36>>2]=p-h,i[A+32>>2]=D-w,i[A+28>>2]=s-y,i[A+24>>2]=c-f,i[A+20>>2]=e-t,i[A+16>>2]=o-r,i[A+12>>2]=a-n,i[A+8>>2]=E-Q,i[A+4>>2]=C-B}function yA(A,I,g){var B,C,Q,E,n,a,r,o,t,e,f,c,y,s,w,D,h,p;B=i[g+4>>2],C=i[I+4>>2],Q=i[g+8>>2],E=i[I+8>>2],n=i[g+12>>2],a=i[I+12>>2],r=i[g+16>>2],o=i[I+16>>2],t=i[g+20>>2],e=i[I+20>>2],f=i[g+24>>2],c=i[I+24>>2],y=i[g+28>>2],s=i[I+28>>2],w=i[g+32>>2],D=i[I+32>>2],h=i[g+36>>2],p=i[I+36>>2],i[A>>2]=i[g>>2]+i[I>>2],i[A+36>>2]=h+p,i[A+32>>2]=w+D,i[A+28>>2]=y+s,i[A+24>>2]=f+c,i[A+20>>2]=t+e,i[A+16>>2]=r+o,i[A+12>>2]=n+a,i[A+8>>2]=Q+E,i[A+4>>2]=B+C}function sA(A){var I,g=0,B=0,C=0,E=0;for(Q[11+(I=s-16|0)|0]=0,Q[I+12|0]=0,Q[I+13|0]=0,Q[I+14|0]=0,i[I+8>>2]=0;;){for(C=n[A+B|0],g=0;Q[0|(E=(I+8|0)+g|0)]=n[0|E]|C^n[(2528+(g<<5)|0)+B|0],7!=(0|(g=g+1|0)););if(31==(0|(B=B+1|0)))break}for(B=127&n[A+31|0],A=0,g=0;Q[0|(C=(I+8|0)+g|0)]=n[0|C]|B^n[2559+(g<<5)|0],7!=(0|(g=g+1|0)););for(g=0;g=n[(I+8|0)+A|0]-1|g,7!=(0|(A=A+1|0)););return g>>>8&1}function wA(A,I){var g=0,B=0,C=0,E=0;for(wI(eI(A,33984,64)- -64|0,0,293);B=(g=E<<3)+A|0,C=n[0|(g=I+g|0)]|n[g+1|0]<<8|n[g+2|0]<<16|n[g+3|0]<<24,g=(n[g+4|0]|n[g+5|0]<<8|n[g+6|0]<<16|n[g+7|0]<<24)^(n[B+4|0]|n[B+5|0]<<8|n[B+6|0]<<16|n[B+7|0]<<24),C^=n[0|B]|n[B+1|0]<<8|n[B+2|0]<<16|n[B+3|0]<<24,Q[0|B]=C,Q[B+1|0]=C>>>8,Q[B+2|0]=C>>>16,Q[B+3|0]=C>>>24,Q[B+4|0]=g,Q[B+5|0]=g>>>8,Q[B+6|0]=g>>>16,Q[B+7|0]=g>>>24,8!=(0|(E=E+1|0)););}function DA(A,I){var g=0,B=0;A:if(B=255&I){if(3&A)for(;;){if(!(g=n[0|A])|(0|g)==(255&I))break A;if(!(3&(A=A+1|0)))break}I:if(!((-1^(g=i[A>>2]))&g-16843009&-2139062144))for(B=r(B,16843009);;){if((-1^(g^=B))&g-16843009&-2139062144)break I;if(g=i[A+4>>2],A=A+4|0,g-16843009&(-1^g)&-2139062144)break}for(;g=A,(B=n[0|A])&&(A=g+1|0,(0|B)!=(255&I)););A=g}else A=mA(A)+A|0;return n[0|A]==(255&I)?A:0}function hA(A,I,g){var B=0,C=0,E=0,n=0,a=0,r=0;if(g>>>0>=8)for(n=g>>>3|0,g=0;E=(B=g<<3)+A|0,a=(B=i[4+(C=I+B|0)>>2])<<24|(C=i[C>>2])>>>8,r=B<<8|C>>>24,B=-16777216&((255&B)<<24|C>>>8)|16711680&((16777215&B)<<8|C>>>24)|B>>>8&65280|B>>>24,Q[0|E]=B,Q[E+1|0]=B>>>8,Q[E+2|0]=B>>>16,Q[E+3|0]=B>>>24,B=C<<8&16711680|C<<24|65280&a|255&r,Q[E+4|0]=B,Q[E+5|0]=B>>>8,Q[E+6|0]=B>>>16,Q[E+7|0]=B>>>24,(0|n)!=(0|(g=g+1|0)););}function pA(A,I,g){var B,C,Q=0,E=0,i=0;return B=A,A=31&(Q=i=63&g),Q>>>0>=32?(A=-1<<A,Q=0):A=(Q=-1<<A)|(1<<A)-1&-1>>>32-A,C=Q&B,E=A&I,Q=31&i,i>>>0>=32?(A=0,i=E>>>Q|0):(A=E>>>Q|0,i=((1<<Q)-1&E)<<32-Q|C>>>Q),Q=A,g=31&(E=0-g&63),E>>>0>=32?(A=0,g=-1>>>g|0):g=(A=-1>>>g|0)|(1<<g)-1<<32-g,g&=B,I&=A,A=31&E,E>>>0>=32?(I=g<<A,A=0):(I=(1<<A)-1&g>>>32-A|I<<A,A=g<<A),h=I|Q,A|i}function uA(A,I,g){var B=0,C=0,Q=0,E=0;return E=A,A=0,C=31&(B=Q=63&g),B=B>>>0>=32?-1>>>C|0:(A=-1>>>C|0)|(1<<C)-1<<32-C,B&=E,A&=I,C=31&Q,Q>>>0>=32?(A=B<<C,B=0):(A=(1<<C)-1&B>>>32-C|A<<C,B<<=C),C=A,A=31&(g=0-g&63),g>>>0>=32?(A=-1<<A,Q=0):A=(Q=-1<<A)|(1<<A)-1&-1>>>32-A,E&=Q,I&=A,A=31&g,g>>>0>=32?(g=0,A=I>>>A|0):(g=I>>>A|0,A=((1<<A)-1&I)<<32-A|E>>>A),h=g|C,A|B}function FA(A,I,g){var B,C,Q,E;s=B=s-128|0,ng(A),ng(C=A+40|0),hg(Q=A+80|0),MI(A,I=r(I,960)+2784|0,Ag(g=g-((0-(E=(128&g)>>>7|0)&g)<<1)<<24>>24,1)),MI(A,I+120|0,Ag(g,2)),MI(A,I+240|0,Ag(g,3)),MI(A,I+360|0,Ag(g,4)),MI(A,I+480|0,Ag(g,5)),MI(A,I+600|0,Ag(g,6)),MI(A,I+720|0,Ag(g,7)),MI(A,I+840|0,Ag(g,8)),UA(I=B+8|0,C),UA(B+48|0,A),kA(B+88|0,Q),MI(A,I,E),s=B+128|0}function lA(A,I,g,B,C,Q,E,i,n,a){var r,o,t;return s=o=s-352|0,fg(t=o+32|0,64,n,a),og(r=o+96|0,t),Dg(t,64),gg(r,Q,E,i),gg(r,34064,0-E&15,0),gg(r,I,g,B),gg(r,34064,0-g&15,0),QI(Q=o+24|0,E,i),gg(r,Q,8,0),QI(Q,g,B),gg(r,Q,8,0),tg(r,o),Dg(r,256),C=rg(o,C),Dg(o,16),A&&(C?(wI(A,0,g),C=-1):(WA(A,I,g,B,n,1,a),C=0)),s=o+352|0,C}function _A(A,I){var g,B=0,C=0,Q=0,E=0,a=0;A:if(!(((g=n[0|A])-58&255)>>>0<246)){for(C=g,B=A;;){if(E=B,Q>>>0>429496729)break A;if((C=(255&C)-48|0)>>>0>(-1^(B=r(Q,10)))>>>0)break A;if(Q=B+C|0,!(((C=n[0|(B=E+1|0)])-58&255)>>>0>245))break}48==(0|g)&(0|A)!=(0|E)|(0|A)==(0|B)||(i[I>>2]=Q,a=B)}return a}function kA(A,I){var g,B,C,Q,E,n,a,r,o;g=i[I+4>>2],B=i[I+8>>2],C=i[I+12>>2],Q=i[I+16>>2],E=i[I+20>>2],n=i[I+24>>2],a=i[I+28>>2],r=i[I+32>>2],o=i[I+36>>2],i[A>>2]=0-i[I>>2],i[A+36>>2]=0-o,i[A+32>>2]=0-r,i[A+28>>2]=0-a,i[A+24>>2]=0-n,i[A+20>>2]=0-E,i[A+16>>2]=0-Q,i[A+12>>2]=0-C,i[A+8>>2]=0-B,i[A+4>>2]=0-g}function HA(A,I,g,B,C,Q,E,n,a,r,o){var t,e,f;return s=e=s-336|0,fg(f=e+16|0,64,r,o),og(t=e+80|0,f),Dg(f,64),gg(t,E,n,a),gg(t,34064,0-n&15,0),WA(A,B,C,Q,r,1,o),gg(t,A,C,Q),gg(t,34064,0-C&15,0),QI(A=e+8|0,n,a),gg(t,A,8,0),QI(A,C,Q),gg(t,A,8,0),tg(t,I),Dg(t,256),g&&(i[g>>2]=16,i[g+4>>2]=0),s=e+336|0,0}function GA(A,I,g,B,C,Q,E,i,n,a){var r,o,t;return s=r=s-352|0,Ig(t=r+32|0,n,a),og(o=r+96|0,t),Dg(t,64),gg(o,Q,E,i),QI(Q=r+24|0,E,i),gg(o,Q,8,0),gg(o,I,g,B),QI(Q,g,B),gg(o,Q,8,0),tg(o,r),Dg(o,256),C=rg(r,C),Dg(r,16),A&&(C?(wI(A,0,g),C=-1):(HI(A,I,g,B,n,a),C=0)),s=r+352|0,C}function UA(A,I){var g,B,C,Q,E,n,a,r,o;g=i[I+8>>2],B=i[I+12>>2],C=i[I+16>>2],Q=i[I+20>>2],E=i[I+24>>2],n=i[I+28>>2],a=i[I>>2],r=i[I+4>>2],o=i[I+36>>2],i[A+32>>2]=i[I+32>>2],i[A+36>>2]=o,i[A+24>>2]=E,i[A+28>>2]=n,i[A+16>>2]=C,i[A+20>>2]=Q,i[A+8>>2]=g,i[A+12>>2]=B,i[A>>2]=a,i[A+4>>2]=r}function SA(A,I,g){g?(i[A+48>>2]=n[0|g]|n[g+1|0]<<8|n[g+2|0]<<16|n[g+3|0]<<24,g=n[g+4|0]|n[g+5|0]<<8|n[g+6|0]<<16|n[g+7|0]<<24):(i[A+48>>2]=0,g=0),i[A+52>>2]=g,i[A+56>>2]=n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24,i[A+60>>2]=n[I+4|0]|n[I+5|0]<<8|n[I+6|0]<<16|n[I+7|0]<<24}function bA(A,I,g,B){var C;if(s=C=s-192|0,!(!g|(I-65&255)>>>0<=191|(B-65&255)>>>0<=191))return E[C+130>>1]=257,Q[C+129|0]=B,Q[C+128|0]=I,RI(4|(I=C+128|0)),QI(8|I,0,0),wI(C+144|0,0,48),wA(A,I),wI(B+C|0,0,B<<24>>24<0?0:128-B|0),gA(I=A,A=eI(C,g,B),128,0),Dg(A,128),s=A+192|0,0;xI(),t()}function mA(A){var I=0,g=0,B=0;A:{if(3&(I=A))for(;;){if(!n[0|I])break A;if(!(3&(I=I+1|0)))break}for(;g=I,I=I+4|0,!((-1^(B=i[g>>2]))&B-16843009&-2139062144););if(!(255&B))return g-A|0;for(;B=n[g+1|0],g=I=g+1|0,B;);}return I-A|0}function vA(A,I,g,B,C,Q,E){var i=0,n=0;return I-65>>>0<4294967232|E>>>0>64?A=-1:(n=i=s,s=i=i-384&-64,!(!(B|C)||g)|!A|((I&=255)-65&255)>>>0<=191|!(!(E&=255)||Q)|E>>>0>=65?(xI(),t()):(E?bA(i,I,Q,E):jA(i,I),gA(i,g,B,C),Y(i,A,I),s=n),A=0),A}function MA(A,I){var g,B,C=0;s=g=s-704|0,(B=i[A+72>>2]>>>3&127)>>>0<=111?eI(80+(A+B|0)|0,34784,112-B|0):(eI((C=A+80|0)+B|0,34784,128-B|0),F(A,C,g,g+640|0),wI(C,0,112)),hA(A+192|0,A- -64|0,16),F(A,A+80|0,g,g+640|0),hA(I,A,64),Dg(g,704),Dg(A,208),s=g+704|0}function PA(A,I,g,B,C,Q,E,n,a,r,o){var t,e,f;return s=e=s-336|0,Ig(f=e+16|0,r,o),og(t=e+80|0,f),Dg(f,64),gg(t,E,n,a),QI(E=e+8|0,n,a),gg(t,E,8,0),HI(A,B,C,Q,r,o),gg(t,A,C,Q),QI(E,C,Q),gg(t,E,8,0),tg(t,I),Dg(t,256),g&&(i[g>>2]=16,i[g+4>>2]=0),s=e+336|0,0}function YA(A,I,g){i[A+48>>2]=g?n[0|g]|n[g+1|0]<<8|n[g+2|0]<<16|n[g+3|0]<<24:0,i[A+52>>2]=n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24,i[A+56>>2]=n[I+4|0]|n[I+5|0]<<8|n[I+6|0]<<16|n[I+7|0]<<24,i[A+60>>2]=n[I+8|0]|n[I+9|0]<<8|n[I+10|0]<<16|n[I+11|0]<<24}function NA(A,I,g,B,C,Q,E){var n;return s=n=s-16|0,A=wI(A,0,128),!(B|Q)&E>>>0<2147483649?!!(C|Q)&E>>>0>8191?(EI(n,16),A=_(C,E>>>10|0,1,I,g,n,16,0,32,A,128,2)?-1:0):(i[8952]=28,A=-1):(i[8952]=22,A=-1),s=n+16|0,A}function RA(A,I){var g=0;4&I&&((I=i[A>>2])&&Dg(i[I+4>>2],i[A+16>>2]<<10),(I=i[A+4>>2])&&Dg(I,i[A+20>>2]<<3)),b(i[A+4>>2]),i[A+4>>2]=0,(I=i[A>>2])&&(g=i[I>>2])&&b(g),b(I),i[A>>2]=0}function dA(A,I){var g,B,C=0,E=0,i=0,n=0;for(s=g=s-16|0,C=10;n=C,i=(I>>>0)/10|0,Q[0|(E=(C=C-1|0)+(g+6|0)|0)]=I-r(i,10)|48,!(I>>>0<10)&&(I=i,C););B=eI(I=A,E,A=11-n|0)+A|0,Q[0|B]=0,s=g+16|0}function JA(A,I,g){var B,C,Q,E=0;s=C=s-48|0,yA(A,E=I+40|0,I),cA(B=A+40|0,E,I),H(E=A+80|0,A,g+40|0),H(B,B,g),H(Q=A+120|0,g+120|0,I+120|0),H(A,I+80|0,g+80|0),yA(C,A,A),cA(A,E,B),yA(B,E,B),cA(E,C,Q),yA(Q,C,Q),s=C+48|0}function xA(A,I,g){var B,C,Q,E=0;s=C=s-48|0,yA(A,E=I+40|0,I),cA(B=A+40|0,E,I),H(E=A+80|0,A,g),H(B,B,g+40|0),H(Q=A+120|0,g+120|0,I+120|0),H(A,I+80|0,g+80|0),yA(C,A,A),cA(A,E,B),yA(B,E,B),yA(E,C,Q),cA(Q,C,Q),s=C+48|0}function LA(A,I,g){var B=0,C=0,Q=0;if(!g)return 0;A:if(B=n[0|A]){for(;;){if((C=n[0|I])&&!(!(g=g-1|0)|(0|B)!=(0|C))){if(I=I+1|0,B=n[A+1|0],A=A+1|0,B)continue;break A}break}Q=B}return(255&Q)-n[0|I]|0}function KA(A,I){for(var g=0,B=0,C=0,Q=0;C=(g=B<<3)+A|0,Q=n[0|(g=I+g|0)]|n[g+1|0]<<8|n[g+2|0]<<16|n[g+3|0]<<24,g=n[g+4|0]|n[g+5|0]<<8|n[g+6|0]<<16|n[g+7|0]<<24,i[C>>2]=Q,i[C+4>>2]=g,128!=(0|(B=B+1|0)););}function XA(A,I,g){var B;if(i[12+(B=s-16|0)>>2]=A,i[B+8>>2]=I,I=0,i[B+4>>2]=0,(0|g)>0)for(;i[B+4>>2]=i[B+4>>2]|n[i[B+8>>2]+I|0]^n[i[B+12>>2]+I|0],(0|g)!=(0|(I=I+1|0)););return(i[B+4>>2]-1>>>8&1)-1|0}function TA(A,I,g){var B,C,Q,E=0;s=C=s-48|0,yA(A,E=I+40|0,I),cA(B=A+40|0,E,I),H(E=A+80|0,A,g),H(B,B,g+40|0),H(Q=A+120|0,g+80|0,I+120|0),yA(C,I=I+80|0,I),cA(A,E,B),yA(B,E,B),yA(E,C,Q),cA(Q,C,Q),s=C+48|0}function VA(A,I,g){var B,C=0,E=0;if(s=B=s-16|0,Q[B+15|0]=0,E=-1,!(0|vg[i[8758]](A,I,g))){for(;Q[B+15|0]=n[A+C|0]|n[B+15|0],32!=(0|(C=C+1|0)););E=(n[B+15|0]<<23)-8388608>>31}return s=B+16|0,E}function qA(A,I,g,B){var C,Q,E,i,n=0,a=0;return i=r(n=g>>>16|0,a=A>>>16|0),n=(65535&(a=((E=r(C=65535&g,Q=65535&A))>>>16|0)+r(a,C)|0))+r(n,Q)|0,h=(r(I,g)+i|0)+r(A,B)+(a>>>16)+(n>>>16)|0,65535&E|n<<16}function zA(A,I,g){var B;if(i[12+(B=s-16|0)>>2]=A,i[B+8>>2]=I,I=0,Q[B+7|0]=0,g)for(;Q[B+7|0]=n[B+7|0]|n[i[B+8>>2]+I|0]^n[i[B+12>>2]+I|0],(0|g)!=(0|(I=I+1|0)););return(n[B+7|0]-1>>>8&1)-1|0}function jA(A,I){var g;return s=g=s+-64|0,(I-65&255)>>>0<=191&&(xI(),t()),Q[g+3|0]=1,Q[g+1|0]=0,Q[g+2|0]=1,Q[0|g]=I,RI(4|g),QI(8|g,0,0),wI(g+16|0,0,48),wA(A,g),s=g- -64|0,0}function WA(A,I,g,B,C,Q,E){var i=0,n=0;i=B,1==(((i=(n=g+63|0)>>>0<63?i+1|0:i)>>>6|0)+(0!=(0|(i=(63&i)<<26|n>>>6)))|0)&Q>>>0>(n=0-i|0)>>>0&&(xI(),t()),kI(A,I,g,B,C,Q,E)}function OA(A,I,g,B){var C=0;C=-1;A:if(!(B-65>>>0<4294967232|g>>>0>64)){I:{if(!g||!I){if(!jA(A,255&B))break I;break A}if(bA(A,255&B,I,255&g))break A}C=0}return C}function ZA(A,I,g,B){return(B=(1+(A^B)>>>8^-1)&g|(1+(16321^A)>>>8^-1)&I|(I=A+65510>>>8&255)&A+65)|(g=A+65484>>>8|0)&A+71&(255^I)|A+252&A+65474>>>8&(-1^g)&255}function $A(A){var I,g;return(A=(I=i[8748])+(g=A+3&-4)|0)>>>0<=I>>>0&&g||A>>>0>Mg()<<16>>>0&&!(0|c(0|A))?(i[8952]=48,-1):(i[8748]=A,I)}function AI(A,I){for(var g=0,B=0,C=0,Q=0;B=(g=C<<3)+A|0,Q=i[(g=I+g|0)>>2],g=i[B+4>>2]^i[g+4>>2],i[B>>2]=i[B>>2]^Q,i[B+4>>2]=g,128!=(0|(C=C+1|0)););}function II(A,I){var g,B,C,E,i;s=g=s-144|0,O(B=g+96|0,I+80|0),H(C=g+48|0,I,B),H(g,I+40|0,B),T(A,g),E=A,i=vI(C)<<7^n[A+31|0],Q[E+31|0]=i,s=g+144|0}function gI(A,I,g){var B=0;if(A>>>0<I>>>0)return eI(A,I,g);if(g)for(B=A+g|0,I=I+g|0;I=I-1|0,Q[0|(B=B-1|0)]=n[0|I],g=g-1|0;);return A}function BI(A,I){var g,B=0;if(Q[15+(g=s-16|0)|0]=0,I)for(;Q[g+15|0]=n[A+B|0]|n[g+15|0],(0|(B=B+1|0))!=(0|I););return n[g+15|0]-1>>>8&1}function CI(A,I,g,B){var C;return B=I+B|0,B=(C=A+g|0)>>>0<g>>>0?B+1|0:B,g=qA(A<<1&-2,1&(I=I<<1|A>>>31),g,0),A=h+B|0,h=A=(I=g+C|0)>>>0<g>>>0?A+1|0:A,I}function QI(A,I,g){Q[0|A]=I,Q[A+1|0]=I>>>8,Q[A+2|0]=I>>>16,Q[A+3|0]=I>>>24,Q[A+4|0]=g,Q[A+5|0]=g>>>8,Q[A+6|0]=g>>>16,Q[A+7|0]=g>>>24}function EI(A,I){A|=0;var g=0,B=0,C=0;if(I|=0)for(;B=A+g|0,C=FI(),Q[0|B]=C,(0|(g=g+1|0))!=(0|I););}function iI(A,I,g,B,C){var Q,E;return A|=0,I|=0,g|=0,B|=0,s=Q=(E=s)-128&-64,IA(Q,C|=0),$(Q,I,g,B),W(Q,A),s=E,0}function nI(A){var I=0,g=0,B=0;for(I=1;I=n[0|(B=A+g|0)]+I|0,Q[0|B]=I,I=I>>>8|0,4!=(0|(g=g+1|0)););}function aI(A,I,g,B,C,Q,E,i){var n,a=0;return s=n=s-32|0,a=-1,oI(n,E,i)||(a=zI(A,I,g,B,C,Q,n),Dg(n,32)),s=n+32|0,a}function rI(A,I,g,B,C,Q,E,i){var n,a=0;return s=n=s-32|0,a=-1,oI(n,E,i)||(a=jI(A,I,g,B,C,Q,n),Dg(n,32)),s=n+32|0,a}function oI(A,I,g){A|=0;var B,C=0;return s=B=s-32|0,C=-1,VA(B,g|=0,I|=0)||(C=K(A,34976,B)),s=B+32|0,0|C}function tI(A,I){var g,B,C;H(A,I,g=I+120|0),H(A+40|0,B=I+40|0,C=I+80|0),H(A+80|0,C,g),H(A+120|0,I,B)}function eI(A,I,g){var B=0;if(g)for(B=A;Q[0|B]=n[0|I],B=B+1|0,I=I+1|0,g=g-1|0;);return A}function fI(A,I){var g,B;s=B=s-128|0,UA(g=B+8|0,I),UA(g+40|0,I+40|0),UA(g+80|0,I+80|0),G(A,g),s=B+128|0}function cI(A,I,g,B,C,Q,E){return!B&g>>>0>=16|B?rI(A,I+16|0,I,g-16|0,B-(g>>>0<16)|0,C,Q,E):-1}function yI(A,I){for(var g=0,B=0;Q[0|(B=A+g|0)]=n[0|B]^n[I+g|0],8!=(0|(g=g+1|0)););}function sI(A,I,g){var B,C;s=B=(C=s)-384&-64,PI(B,0,0,24),ig(B,I,32,0),ig(B,g,32,0),dI(B,A,24),s=C}function wI(A,I,g){var B=0;if(g)for(B=A;Q[0|B]=I,B=B+1|0,g=g-1|0;);return A}function DI(A,I){var g;yA(A,g=I+40|0,I),cA(A+40|0,g,I),UA(A+80|0,I+80|0),H(A+120|0,I+120|0,1520)}function hI(A,I){var g;H(A,I,g=I+120|0),H(A+40|0,I+40|0,I=I+80|0),H(A+80|0,I,g)}function pI(A,I,g,B,C,Q,E){return!B&g>>>0>=4294967280|B&&(xI(),t()),aI(A+16|0,A,I,g,B,C,Q,E)}function uI(A){var I;return I=n[0|A]|n[A+1|0]<<8,A=n[A+2|0],h=A>>>16|0,I|A<<16}function FI(){var A,I;return s=A=s-16|0,Q[A+15|0]=0,I=0|f(35048,A+15|0,0),s=A+16|0,0|I}function lI(A,I){var g=0;return(-1>>>(g=31&I)&A)<<g|((g=A)&-1<<(A=0-I&31))>>>A}function _I(A,I,g,B){var C;return s=C=s-208|0,GI(C),z(C,I,g,B),MA(C,A),s=C+208|0,0}function kI(A,I,g,B,C,Q,E){1==(0|B)|B>>>0>1&&(xI(),t()),vg[i[8752]](A,I,g,B,C,Q,E)}function HI(A,I,g,B,C,Q){1==(0|B)|B>>>0>1&&(xI(),t()),vg[i[8751]](A,I,g,B,C,1,0,Q)}function GI(A){i[A+64>>2]=0,i[A+68>>2]=0,i[A+72>>2]=0,i[A+76>>2]=0,eI(A,34080,64)}function UI(A,I,g){return g>>>0>=256&&(e(1279,1206,107,1067),t()),Y(A,I,255&g)}function SI(){var A;s=A=s-16|0,Q[A+15|0]=0,f(35084,A+15|0,0),s=A+16|0}function bI(A,I){Q[0|A]=I,Q[A+1|0]=I>>>8,Q[A+2|0]=I>>>16,Q[A+3|0]=I>>>24}function mI(A){var I;return s=I=s-32|0,T(I,A),A=BI(I,32),s=I+32|0,A}function vI(A){var I;return s=I=s-32|0,T(I,A),s=I+32|0,1&Q[0|I]}function MI(A,I,g){aA(A,I,g),aA(A+40|0,I+40|0,g),aA(A+80|0,I+80|0,g)}function PI(A,I,g,B){return 0|OA(A|=0,I|=0,g|=0,B|=0)}function YI(A){Q[A+32|0]=1,Q[A+33|0]=0,Q[A+34|0]=0,Q[A+35|0]=0}function NI(A){i[A>>2]=0,i[A+4>>2]=0,i[A+8>>2]=0,i[A+12>>2]=0}function RI(A){Q[0|A]=0,Q[A+1|0]=0,Q[A+2|0]=0,Q[A+3|0]=0}function dI(A,I,g){return 0|UI(A|=0,I|=0,g|=0)}function JI(A,I,g){return 0|VA(A|=0,I|=0,g|=0)}function xI(){var A;(A=i[9098])&&vg[0|A](),y(),t()}function LI(A){hg(A),ng(A+40|0),ng(A+80|0),hg(A+120|0)}function KI(A,I,g,B,C,Q){vg[i[8761]](A,I,g,B,C,1,0,Q)}function XI(A,I,g,B,C,Q){vg[i[8761]](A,I,g,B,C,0,0,Q)}function TI(A,I){return A|=0,EI(I|=0,32),0|Bg(A,I)}function VI(A,I,g,B,C,Q){return u(A,I,g,B,C,Q,0),0}function qI(A,I,g,B,C,Q,E){return vA(A,I,g,B,C,Q,E)}function zI(A,I,g,B,C,Q,E){return EA(A,I,g,B,C,Q,E)}function jI(A,I,g,B,C,Q,E){return iA(A,I,g,B,C,Q,E)}function WI(A,I){GI(A),I&&z(A,34912,34,0)}function OI(A,I,g,B,C){return J(A,I,g,B,C,0)}function ZI(A,I){return 0|Bg(A|=0,I|=0)}function $I(A,I,g,B){vg[i[8750]](A,I,0,g,B)}function Ag(A,I){return(255&(A^I))-1>>>31|0}function Ig(A,I,g){vg[i[8749]](A,64,0,I,g)}function gg(A,I,g,B){vg[i[8756]](A,I,g,B)}function Bg(A,I){return 0|vg[i[8759]](A,I)}function Cg(A,I,g,B){return gA(A,I,g,B)}function Qg(A){return ZA(A,45,95,32704)}function Eg(A){return ZA(A,43,47,16320)}function ig(A,I,g,B){return Cg(A,I,g,B)}function ng(A){i[A>>2]=1,wI(A+4|0,0,36)}function ag(A){1!=(-7&A)&&(xI(),t())}function rg(A,I){return XA(A,I,16)}function og(A,I){vg[i[8755]](A,I)}function tg(A,I){vg[i[8757]](A,I)}function eg(A,I){return XA(A,I,32)}function fg(A,I,g,B){$I(A,I,g,B)}function cg(A,I){return lI(A,I)}function yg(A,I){eI(A,I,1024)}function sg(A){EI(A|=0,32)}function wg(A){wI(A,0,1024)}function Dg(A,I){wI(A,0,I)}function hg(A){wI(A,0,40)}function pg(){return 32}function ug(){return 24}function Fg(){return-17}function lg(){return 64}function _g(){return 16}function kg(){return 1}function Hg(){return 2}function Gg(){return 8}function Ug(){return 3}function Sg(){return 0}function bg(){return-1}C(I=n,1024,"TGlic29kaXVtRFJHcmFuZG9tYnl0ZXMAYjY0X3BvcyA8PSBiNjRfbGVuAGNyeXB0b19nZW5lcmljaGFzaF9ibGFrZTJiX2ZpbmFsACRhcmdvbjJpACRhcmdvbjJpZAByYW5kb21ieXRlcy9yYW5kb21ieXRlcy5jAHNvZGl1bS9jb2RlY3MuYwBjcnlwdG9fZ2VuZXJpY2hhc2gvYmxha2UyYi9yZWYvYmxha2UyYi1yZWYuYwBjcnlwdG9fZ2VuZXJpY2hhc2gvYmxha2UyYi9yZWYvZ2VuZXJpY2hhc2hfYmxha2UyYi5jAGJ1Zl9sZW4gPD0gU0laRV9NQVgAb3V0bGVuIDw9IFVJTlQ4X01BWABTLT5idWZsZW4gPD0gQkxBS0UyQl9CTE9DS0JZVEVTACRhcmdvbjJpJHY9ACRhcmdvbjJpZCR2PQAsdD0ALHA9ACRtPQAxLjAuMTgAc29kaXVtX2JpbjJiYXNlNjQAJGFyZ29uMmkkACRhcmdvbjJpZCQ="),C(I,1424,"tnhZ/4Vy0wC9bhX/DwpqACnAAQCY6Hn/vDyg/5lxzv8At+L+tA1I/wAAAAAAAAAAsKAO/tPJhv+eGI8Af2k1AGAMvQCn1/v/n0yA/mpl4f8e/AQAkgyu"),C(I,1520,"WfGy/grlpv973Sr+HhTUAFKAAwAw0fMAd3lA/zLjnP8AbsUBZxuQ"),C(I,1568,"hTuMAb3xJP/4JcMBYNw3ALdMPv/DQj0AMkykAeGkTP9MPaP/dT4fAFGRQP92QQ4AonPW/waKLgB85vT/CoqPADQawgC49EwAgY8pAb70E/97qnr/YoFEAHnVkwBWZR7/oWebAIxZQ//v5b4BQwu1AMbwif7uRbz/Q5fuABMqbP/lVXEBMkSH/xFqCQAyZwH/UAGoASOYHv8QqLkBOFno/2XS/AAp+kcAzKpP/w4u7/9QTe8AvdZL/xGN+QAmUEz/vlV1AFbkqgCc2NABw8+k/5ZCTP+v4RD/jVBiAUzb8gDGonIALtqYAJsr8f6boGj/M7ulAAIRrwBCVKAB9zoeACNBNf5F7L8ALYb1AaN73QAgbhT/NBelALrWRwDpsGAA8u82ATlZigBTAFT/iKBkAFyOeP5ofL4AtbE+//opVQCYgioBYPz2AJeXP/7vhT4AIDicAC2nvf+OhbMBg1bTALuzlv76qg7/0qNOACU0lwBjTRoA7pzV/9XA0QFJLlQAFEEpATbOTwDJg5L+qm8Y/7EhMv6rJsv/Tvd0ANHdmQCFgLIBOiwZAMknOwG9E/wAMeXSAXW7dQC1s7gBAHLbADBekwD1KTgAfQ3M/vStdwAs3SD+VOoUAPmgxgHsfur/L2Oo/qrimf9ms9gA4o16/3pCmf629YYA4+QZAdY56//YrTj/tefSAHeAnf+BX4j/bn4zAAKpt/8HgmL+RbBe/3QE4wHZ8pH/yq0fAWkBJ/8ur0UA5C86/9fgRf7POEX/EP6L/xfP1P/KFH7/X9Vg/wmwIQDIBc//8SqA/iMhwP/45cQBgRF4APtnl/8HNHD/jDhC/yji9f/ZRiX+rNYJ/0hDhgGSwNb/LCZwAES4S//OWvsAleuNALWqOgB09O8AXJ0CAGatYgDpiWABfzHLAAWblAAXlAn/03oMACKGGv/bzIgAhggp/+BTK/5VGfcAbX8A/qmIMADud9v/563VAM4S/v4Iugf/fgkHAW8qSABvNOz+YD+NAJO/f/7NTsD/DmrtAbvbTACv87v+aVmtAFUZWQGi85QAAnbR/iGeCQCLoy7/XUYoAGwqjv5v/I7/m9+QADPlp/9J/Jv/XnQM/5ig2v+c7iX/s+rP/8UAs/+apI0A4cRoAAojGf7R1PL/Yf3e/rhl5QDeEn8BpIiH/x7PjP6SYfMAgcAa/slUIf9vCk7/k1Gy/wQEGACh7tf/Bo0hADXXDv8ptdD/54udALPL3f//uXEAveKs/3FC1v/KPi3/ZkAI/06uEP6FdUT/"),C(I,2560,"AQ=="),C(I,2592,"JuiVj8KyJ7BFw/SJ8u+Y8NXfrAXTxjM5sTgCiG1T/AXHF2pwPU3YT7o8C3YNEGcPKiBT+iw5zMZOx/13kqwDeuz///////////////////////////////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////f+3T9VwaYxJY1pz3ot753hQ="),C(I,2783,"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"),C(I,33756,"AQ=="),C(I,33792,"AQ=="),C(I,33824,"4Ot6fDtBuK4WVuP68Z/EatoJjeucMrH9hmIFFl9JuABfnJW8o1CMJLHQsVWcg+9bBERcxFgcjobYIk7d0J8RV+z///////////////////////////////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////fwjJvPNn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMfeSF+ExnN4Fs="),C(I,34080,"CMm882fmCWo7p8qEha5nuyv4lP5y82488TYdXzr1T6XRguatf1IOUR9sPiuMaAWba71B+6vZgx95IX4TGc3gWyKuKNeYL4pCzWXvI5FEN3EvO03sz/vAtbzbiYGl27XpOLVI81vCVjkZ0AW28RHxWZtPGa+kgj+SGIFt2tVeHKtCAgOjmKoH2L5vcEUBW4MSjLLkTr6FMSTitP/Vw30MVW+Je/J0Xb5ysZYWO/6x3oA1Esclpwbcm5Qmac908ZvB0krxnsFpm+TjJU84hke+77XVjIvGncEPZZysd8yhDCR1AitZbyzpLYPkpm6qhHRK1PtBvdypsFy1UxGD2oj5dqvfZu5SUT6YEDK0LW3GMag/IfuYyCcDsOQO777Hf1m/wo+oPfML4MYlpwqTR5Gn1W+CA+BRY8oGcG4OCmcpKRT8L9JGhQq3JybJJlw4IRsu7SrEWvxtLE3fs5WdEw04U95jr4tUcwplqLJ3PLsKanbmru1HLsnCgTs1ghSFLHKSZAPxTKHov6IBMEK8S2YaqJGX+NBwi0vCML5UBqNRbMcYUu/WGeiS0RCpZVUkBpnWKiBxV4U1DvS40bsycKBqEMjQ0rgWwaQZU6tBUQhsNx6Z647fTHdIJ6hIm+G1vLA0Y1rJxbMMHDnLikHjSqrYTnPjY3dPypxbo7iy1vNvLmj8su9d7oKPdGAvF0NvY6V4cqvwoRR4yITsOWQaCALHjCgeYyP6/76Q6b2C3utsUKQVecay96P5vitTcuPyeHHGnGEm6s4+J8oHwsAhx7iG0R7r4M3WfdrqeNFu7n9PffW6bxdyqmfwBqaYyKLFfWMKrg35vgSYPxEbRxwTNQtxG4R9BCP1d9sokyTHQHuryjK8vskVCr6ePEwNEJzEZx1DtkI+y77UxUwqfmX8nCl/Wez61jqrb8tfF1hHSowZRGyA"),C(I,34912,"U2lnRWQyNTUxOSBubyBFZDI1NTE5IGNvbGxpc2lvbnMB"),C(I,34992,"MI5QAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0=");var mg,vg=(mg=[null,function(A,I,g,B,C){var Q;return A|=0,B|=0,s=Q=s+-64|0,(I|=0)|(g|=0)&&(QA(Q,C|=0),SA(Q,B,0),m(Q,A=wI(A,0,I),A,I,g),Dg(Q,64)),s=Q- -64|0,0},function(A,I,g,B,C){var Q;return A|=0,B|=0,s=Q=s+-64|0,(I|=0)|(g|=0)&&(QA(Q,C|=0),YA(Q,B,0),m(Q,A=wI(A,0,I),A,I,g),Dg(Q,64)),s=Q- -64|0,0},function(A,I,g,B,C,Q,E,i){A|=0,I|=0,C|=0,Q|=0,E|=0,i|=0;var n,a=0;return s=n=s-80|0,(g|=0)|(B|=0)&&(bI(a=n+8|0,Q),bI(n+12|0,E),QA(Q=n+16|0,i),SA(Q,C,a),m(Q,I,A,g,B),Dg(Q,64)),s=n+80|0,0},function(A,I,g,B,C,Q,E){A|=0,I|=0,C|=0,Q|=0,E|=0;var i,n=0;return s=i=s-80|0,(g|=0)|(B|=0)&&(bI(n=i+12|0,Q),QA(Q=i+16|0,E),YA(Q,C,n),m(Q,I,A,g,B),Dg(Q,64)),s=i+80|0,0},iI,function(A,I,g,B,C){var Q;return A|=0,s=Q=s-16|0,iI(Q,I|=0,g|=0,B|=0,C|=0),A=rg(A,Q),s=Q+16|0,0|A},function(A,I){return IA(A|=0,I|=0),0},function(A,I,g,B){return $(A|=0,I|=0,g|=0,B|=0),0},function(A,I){return W(A|=0,I|=0),0},function(A,I,g){A|=0,I|=0,g|=0;var B,C=0,E=0,a=0,r=0,o=0,t=0,e=0,f=0,c=0,y=0,w=0,D=0,p=0,u=0,F=0,l=0,_=0,k=0,G=0,S=0,b=0,m=0,v=0,M=0,P=0,Y=0,R=0,d=0,J=0;for(r=-1,Q[11+(E=(s=B=s-336|0)-16|0)|0]=0,Q[E+12|0]=0,Q[E+13|0]=0,Q[E+14|0]=0,i[E+8>>2]=0;;){for(e=n[g+a|0],C=0;Q[0|(o=(E+8|0)+C|0)]=n[0|o]|e^n[(33760+(C<<5)|0)+a|0],7!=(0|(C=C+1|0)););if(31==(0|(a=a+1|0)))break}for(e=127&n[g+31|0],a=0,C=0;Q[0|(o=(E+8|0)+C|0)]=n[0|o]|e^n[33791+(C<<5)|0],7!=(0|(C=C+1|0)););for(C=0;C=n[(E+8|0)+a|0]-1|C,7!=(0|(a=a+1|0)););if(!(C>>>8&1)){for(r=0;Q[A+r|0]=n[I+r|0],32!=(0|(r=r+1|0)););for(Q[0|A]=248&n[0|A],Q[A+31|0]=63&n[A+31|0]|64,N(I=B+288|0,g),ng(B+240|0),hg(B+192|0),UA(B+144|0,I),ng(B+96|0),g=254,I=0;C=I,AA(E=B+240|0,y=B+144|0,C^=I=n[(g>>>3|0)+A|0]>>>(7&g)&1),AA(t=B+192|0,r=B+96|0,C),m=g,g=g-1|0,cA(f=B+48|0,y,r),cA(B,E,t),yA(E,E,t),yA(t,y,r),H(r,f,E),H(t,t,B),U(f,B),U(B,E),yA(y,r,t),cA(t,r,t),H(E,B,f),cA(B,B,f),U(t,t),u=C=i[B+4>>2],F=C>>31,l=C=i[B+8>>2],v=C>>31,D=C=i[B+12>>2],p=C>>31,_=C=i[B+16>>2],M=C>>31,c=C=i[B+20>>2],w=C>>31,k=C=i[B+24>>2],P=C>>31,Y=C=i[B>>2],R=C>>31,E=qA(C=i[B+36>>2],C>>31,121666,0),C=h,d=a=E+16777216|0,e=C=a>>>0<16777216?C+1|0:C,G=E-(-33554432&a)|0,C=qA(C=i[B+32>>2],C>>31,121666,0),a=h,o=qA(E=i[B+28>>2],E>>31,121666,0),E=h,J=C,S=C=o+16777216|0,a=(C=(E=C>>>0<16777216?E+1|0:E)>>25)+a|0,C=a=(E=J+(b=(33554431&E)<<7|S>>>25)|0)>>>0<b>>>0?a+1|0:a,C=((67108863&(C=(a=E+33554432|0)>>>0<33554432?C+1|0:C))<<6|a>>>26)+G|0,i[r+36>>2]=C,C=-67108864&a,i[r+32>>2]=E-C,G=o-(-33554432&S)|0,E=qA(k,P,121666,0),k=h,a=qA(c,w,121666,0),C=h,o=E,c=E=a+16777216|0,w=(33554431&(C=E>>>0<16777216?C+1|0:C))<<7|E>>>25,C=(C>>25)+k|0,E=C=(o=o+w|0)>>>0<w>>>0?C+1|0:C,w=C=o+33554432|0,C=((67108863&(E=C>>>0<33554432?E+1|0:E))<<6|C>>>26)+G|0,i[r+28>>2]=C,C=-67108864&w,i[r+24>>2]=o-C,c=a-(-33554432&c)|0,C=qA(_,M,121666,0),_=h,o=qA(D,p,121666,0),E=h,a=C,D=C=o+16777216|0,p=(33554431&(E=C>>>0<16777216?E+1|0:E))<<7|C>>>25,E=(E>>25)+_|0,a=C=a+p|0,C=C>>>0<p>>>0?E+1|0:E,C=((67108863&(C=(E=a+33554432|0)>>>0<33554432?C+1|0:C))<<6|E>>>26)+c|0,i[r+20>>2]=C,C=-67108864&E,i[r+16>>2]=a-C,D=o-(-33554432&D)|0,C=qA(l,v,121666,0),l=h,o=qA(u,F,121666,0),a=h,c=C,u=C=o+16777216|0,E=C,C=(C=(a=C>>>0<16777216?a+1|0:a)>>25)+l|0,C=(E=c+(a=(33554431&a)<<7|E>>>25)|0)>>>0<a>>>0?C+1|0:C,a=E,E=C,F=C=a+33554432|0,C=((67108863&(E=C>>>0<33554432?E+1|0:E))<<6|C>>>26)+D|0,i[r+12>>2]=C,C=-67108864&F,i[r+8>>2]=a-C,C=qA((33554431&e)<<7|d>>>25,e>>25,19,0),a=h,E=(e=qA(Y,R,121666,0))+C|0,C=h+a|0,a=E,E=E>>>0<e>>>0?C+1|0:C,e=C=a+33554432|0,C=(o-(-33554432&u)|0)+((67108863&(E=C>>>0<33554432?E+1|0:E))<<6|C>>>26)|0,i[r+4>>2]=C,C=-67108864&e,i[r>>2]=a-C,U(y,y),yA(f,f,r),H(r,B+288|0,t),H(t,B,f),m;);AA(g=B+240|0,B+144|0,I),AA(C=B+192|0,B+96|0,I),O(C,C),H(g,g,C),T(A,g),r=0}return s=B+336|0,0|r},function(A,I){A|=0,I|=0;var g,B,C,E=0;for(s=g=s-208|0;Q[A+E|0]=n[I+E|0],32!=(0|(E=E+1|0)););return Q[0|A]=248&n[0|A],Q[A+31|0]=63&n[A+31|0]|64,BA(g+48|0,A),s=I=s-96|0,yA(E=I+48|0,B=g+128|0,C=g+88|0),cA(I,B,C),O(I,I),H(g,E,I),s=I+96|0,T(A,g),s=g+208|0,0},function(A,I,g,B,C){A|=0,B|=0,C|=0;var E,a=0;if(s=E=s-112|0,(I|=0)|(g|=0)){a=n[C+28|0]|n[C+29|0]<<8|n[C+30|0]<<16|n[C+31|0]<<24,i[E+24>>2]=n[C+24|0]|n[C+25|0]<<8|n[C+26|0]<<16|n[C+27|0]<<24,i[E+28>>2]=a,a=n[C+20|0]|n[C+21|0]<<8|n[C+22|0]<<16|n[C+23|0]<<24,i[E+16>>2]=n[C+16|0]|n[C+17|0]<<8|n[C+18|0]<<16|n[C+19|0]<<24,i[E+20>>2]=a,a=n[C+4|0]|n[C+5|0]<<8|n[C+6|0]<<16|n[C+7|0]<<24,i[E>>2]=n[0|C]|n[C+1|0]<<8|n[C+2|0]<<16|n[C+3|0]<<24,i[E+4>>2]=a,a=n[C+12|0]|n[C+13|0]<<8|n[C+14|0]<<16|n[C+15|0]<<24,i[E+8>>2]=n[C+8|0]|n[C+9|0]<<8|n[C+10|0]<<16|n[C+11|0]<<24,i[E+12>>2]=a,C=n[0|B]|n[B+1|0]<<8|n[B+2|0]<<16|n[B+3|0]<<24,B=n[B+4|0]|n[B+5|0]<<8|n[B+6|0]<<16|n[B+7|0]<<24,i[E+104>>2]=0,i[E+108>>2]=0,i[E+96>>2]=C,i[E+100>>2]=B;A:{if(!g&I>>>0>=64|g){for(;;){for(d(A,E+96|0,E),C=8,B=1;B=n[0|(a=(E+96|0)+C|0)]+B|0,Q[0|a]=B,B=B>>>8|0,16!=(0|(C=C+1|0)););if(A=A- -64|0,g=g-1|0,!(!(g=(I=I+-64|0)>>>0<4294967232?g+1|0:g)&I>>>0>63|g))break}if(!(I|g))break A}for(C=0,d(E+32|0,E+96|0,E);Q[A+C|0]=n[(E+32|0)+C|0],(0|I)!=(0|(C=C+1|0)););}Dg(E+32|0,64),Dg(E,32)}return s=E+112|0,0},function(A,I,g,B,C,E,a,r){A|=0,I|=0,C|=0,E|=0,a|=0,r|=0;var o,t=0,e=0;if(s=o=s-112|0,(g|=0)|(B|=0)){for(t=n[r+28|0]|n[r+29|0]<<8|n[r+30|0]<<16|n[r+31|0]<<24,i[o+24>>2]=n[r+24|0]|n[r+25|0]<<8|n[r+26|0]<<16|n[r+27|0]<<24,i[o+28>>2]=t,t=n[r+20|0]|n[r+21|0]<<8|n[r+22|0]<<16|n[r+23|0]<<24,i[o+16>>2]=n[r+16|0]|n[r+17|0]<<8|n[r+18|0]<<16|n[r+19|0]<<24,i[o+20>>2]=t,t=n[r+4|0]|n[r+5|0]<<8|n[r+6|0]<<16|n[r+7|0]<<24,i[o>>2]=n[0|r]|n[r+1|0]<<8|n[r+2|0]<<16|n[r+3|0]<<24,i[o+4>>2]=t,t=8,e=n[r+12|0]|n[r+13|0]<<8|n[r+14|0]<<16|n[r+15|0]<<24,i[o+8>>2]=n[r+8|0]|n[r+9|0]<<8|n[r+10|0]<<16|n[r+11|0]<<24,i[o+12>>2]=e,r=n[C+4|0]|n[C+5|0]<<8|n[C+6|0]<<16|n[C+7|0]<<24,i[o+96>>2]=n[0|C]|n[C+1|0]<<8|n[C+2|0]<<16|n[C+3|0]<<24,i[o+100>>2]=r;Q[(o+96|0)+t|0]=E,E=(255&a)<<24|E>>>8,a=a>>>8|0,16!=(0|(t=t+1|0)););if(!B&g>>>0>63|B)for(;;){for(t=0,d(o+32|0,o+96|0,o);Q[A+t|0]=n[(o+32|0)+t|0]^n[I+t|0],r=1,64!=(0|(t=t+1|0)););for(t=8;C=n[0|(E=(o+96|0)+t|0)]+r|0,Q[0|E]=C,r=C>>>8|0,16!=(0|(t=t+1|0)););if(I=I- -64|0,A=A- -64|0,B=B-1|0,!(!(B=(g=g+-64|0)>>>0<4294967232?B+1|0:B)&g>>>0>63|B))break}if(g|B)for(t=0,d(o+32|0,o+96|0,o);Q[A+t|0]=n[(o+32|0)+t|0]^n[I+t|0],(0|g)!=(0|(t=t+1|0)););Dg(o+32|0,64),Dg(o,32)}return s=o+112|0,0}],mg.grow=function(A){var I=this.length;return this.length=this.length+A,I},mg.set=function(A,I){this[A]=I},mg.get=function(A){return this[A]},mg);function Mg(){return B.byteLength/65536|0}return{f:function(){},g:function(A,I,g,B,C,Q,E,i,n,a,r,o){return 0|PA(A|=0,I|=0,g|=0,B|=0,(A=0)|(C|=0),Q|=0,E|=0,A|(i|=0),n|=0,r|=0,o|=0)},h:function(A,I,g,B,C,Q,E,n,a,r,o){return A|=0,I|=0,a|=0,a=B|=0,!(B=C|=0)&(C=0|a)>>>0<4294967280?(PA(A,A+C|0,0,g|=0,C,B,Q|=0,E|=0,n|=0,r|=0,o|=0),I&&(B=(A=C+16|0)>>>0<16?B+1|0:B,i[I>>2]=A,i[I+4>>2]=B)):(xI(),t()),0},i:function(A,I,g,B,C,Q,E,i,n,a,r,o){return 0|HA(A|=0,I|=0,g|=0,B|=0,(A=0)|(C|=0),Q|=0,E|=0,A|(i|=0),n|=0,r|=0,o|=0)},j:function(A,I,g,B,C,Q,E,n,a,r,o){return A|=0,I|=0,a|=0,a=B|=0,!(B=C|=0)&(C=0|a)>>>0<4294967280?(HA(A,A+C|0,0,g|=0,C,B,Q|=0,E|=0,n|=0,r|=0,o|=0),I&&(B=(A=C+16|0)>>>0<16?B+1|0:B,i[I>>2]=A,i[I+4>>2]=B)):(xI(),t()),0},k:function(A,I,g,B,C,Q,E,i,n,a,r){return 0|GA(A|=0,g|=0,(A=0)|(B|=0),C|=0,Q|=0,E|=0,A|(i|=0),n|=0,a|=0,r|=0)},l:function(A,I,g,B,C,Q,E,n,a,r,o){return I|=0,g|=0,B|=0,C|=0,n|=0,n|=0,g=-1,!(Q|=0)&(C|=0)>>>0>=16|Q&&(g=GA(A|=0,B,C-16|0,Q-(C>>>0<16)|0,(B+C|0)-16|0,E|=0,n,a|=0,r|=0,o|=0)),I&&(i[I>>2]=g?0:C-16|0,i[I+4>>2]=g?0:Q-(C>>>0<16)|0),0|g},m:function(A,I,g,B,C,Q,E,i,n,a,r){return 0|lA(A|=0,g|=0,(A=0)|(B|=0),C|=0,Q|=0,E|=0,A|(i|=0),n|=0,a|=0,r|=0)},n:function(A,I,g,B,C,Q,E,n,a,r,o){return I|=0,g|=0,B|=0,C|=0,n|=0,n|=0,g=-1,!(Q|=0)&(C|=0)>>>0>=16|Q&&(g=lA(A|=0,B,C-16|0,Q-(C>>>0<16)|0,(B+C|0)-16|0,E|=0,n,a|=0,r|=0,o|=0)),I&&(i[I>>2]=g?0:C-16|0,i[I+4>>2]=g?0:Q-(C>>>0<16)|0),0|g},o:pg,p:function(){return 12},q:Sg,r:_g,s:Fg,t:sg,u:pg,v:Gg,w:Sg,x:_g,y:Fg,z:sg,A:function(A,I,g,B,C,Q,E,i,n,a,r,o){return 0|fA(A|=0,I|=0,g|=0,B|=0,(A=0)|(C|=0),Q|=0,E|=0,A|(i|=0),n|=0,r|=0,o|=0)},B:function(A,I,g,B,C,Q,E,n,a,r,o){return A|=0,I|=0,a|=0,a=B|=0,!(B=C|=0)&(C=0|a)>>>0<4294967280?(fA(A,A+C|0,0,g|=0,C,B,Q|=0,E|=0,n|=0,r|=0,o|=0),I&&(B=(A=C+16|0)>>>0<16?B+1|0:B,i[I>>2]=A,i[I+4>>2]=B)):(xI(),t()),0},C:function(A,I,g,B,C,Q,E,i,n,a,r){return 0|rA(A|=0,g|=0,(A=0)|(B|=0),C|=0,Q|=0,E|=0,A|(i|=0),n|=0,a|=0,r|=0)},D:function(A,I,g,B,C,Q,E,n,a,r,o){return I|=0,g|=0,B|=0,C|=0,n|=0,n|=0,g=-1,!(Q|=0)&(C|=0)>>>0>=16|Q&&(g=rA(A|=0,B,C-16|0,Q-(C>>>0<16)|0,(B+C|0)-16|0,E|=0,n,a|=0,r|=0,o|=0)),I&&(i[I>>2]=g?0:C-16|0,i[I+4>>2]=g?0:Q-(C>>>0<16)|0),0|g},E:pg,F:ug,G:Sg,H:_g,I:Fg,J:sg,K:pg,L:pg,M:function(A,I,g,B,C){return 0|q(A|=0,I|=0,g|=0,B|=0,C|=0)},N:function(A,I,g,B,C){var Q;return A|=0,s=Q=s-32|0,q(Q,I|=0,g|=0,B|=0,C|=0),I=eg(A,Q),g=zA(Q,A,32),s=Q+32|0,g|((0|A)==(0|Q)?-1:I)},O:sg,P:pg,Q:pg,R:pg,S:pg,T:ug,U:_g,V:Fg,W:function(A,I,g){A|=0,I|=0;var B,C=0;return s=B=s+-64|0,_I(B,g|=0,32,0),g=i[B+28>>2],C=i[B+24>>2],Q[I+24|0]=C,Q[I+25|0]=C>>>8,Q[I+26|0]=C>>>16,Q[I+27|0]=C>>>24,Q[I+28|0]=g,Q[I+29|0]=g>>>8,Q[I+30|0]=g>>>16,Q[I+31|0]=g>>>24,g=i[B+20>>2],C=i[B+16>>2],Q[I+16|0]=C,Q[I+17|0]=C>>>8,Q[I+18|0]=C>>>16,Q[I+19|0]=C>>>24,Q[I+20|0]=g,Q[I+21|0]=g>>>8,Q[I+22|0]=g>>>16,Q[I+23|0]=g>>>24,g=i[B+12>>2],C=i[B+8>>2],Q[I+8|0]=C,Q[I+9|0]=C>>>8,Q[I+10|0]=C>>>16,Q[I+11|0]=C>>>24,Q[I+12|0]=g,Q[I+13|0]=g>>>8,Q[I+14|0]=g>>>16,Q[I+15|0]=g>>>24,g=i[B+4>>2],C=i[B>>2],Q[0|I]=C,Q[I+1|0]=C>>>8,Q[I+2|0]=C>>>16,Q[I+3|0]=C>>>24,Q[I+4|0]=g,Q[I+5|0]=g>>>8,Q[I+6|0]=g>>>16,Q[I+7|0]=g>>>24,Dg(B,64),A=Bg(A,I),s=B- -64|0,0|A},X:TI,Y:oI,Z:function(A,I,g,B,C,Q,E){return 0|zI(A|=0,I|=0,g|=0,B|=0,C|=0,Q|=0,E|=0)},_:function(A,I,g,B,C,Q,E,i){return 0|aI(A|=0,I|=0,g|=0,B|=0,C|=0,Q|=0,E|=0,i|=0)},$:function(A,I,g,B,C,Q){return A|=0,I|=0,C|=0,Q|=0,!(B|=0)&(g|=0)>>>0>=4294967280|B&&(xI(),t()),0|zI(A+16|0,A,I,g,B,C,Q)},aa:function(A,I,g,B,C,Q,E){return 0|pI(A|=0,I|=0,g|=0,B|=0,C|=0,Q|=0,E|=0)},ba:function(A,I,g,B,C,Q,E){return 0|jI(A|=0,I|=0,g|=0,B|=0,C|=0,Q|=0,E|=0)},ca:function(A,I,g,B,C,Q,E,i){return 0|rI(A|=0,I|=0,g|=0,B|=0,C|=0,Q|=0,E|=0,i|=0)},da:function(A,I,g,B,C,Q){return I|=0,0|(!(B|=0)&(g|=0)>>>0>=16|B?jI(A|=0,I+16|0,I,g-16|0,B-(g>>>0<16)|0,C|=0,Q|=0):-1)},ea:function(A,I,g,B,C,Q,E){return 0|cI(A|=0,I|=0,g|=0,B|=0,C|=0,Q|=0,E|=0)},fa:function(A,I,g,B,C){A|=0,I|=0,C|=0;var E,n,a=0,r=0;return n=g|=0,g=B|=0,s=E=s-96|0,B=-1,TI(E+32|0,E)||(sI(a=E- -64|0,r=E+32|0,C),B=pI(A+32|0,I,n,g,a,C,E),I=i[E+60>>2],g=i[E+56>>2],Q[A+24|0]=g,Q[A+25|0]=g>>>8,Q[A+26|0]=g>>>16,Q[A+27|0]=g>>>24,Q[A+28|0]=I,Q[A+29|0]=I>>>8,Q[A+30|0]=I>>>16,Q[A+31|0]=I>>>24,I=i[E+52>>2],g=i[E+48>>2],Q[A+16|0]=g,Q[A+17|0]=g>>>8,Q[A+18|0]=g>>>16,Q[A+19|0]=g>>>24,Q[A+20|0]=I,Q[A+21|0]=I>>>8,Q[A+22|0]=I>>>16,Q[A+23|0]=I>>>24,I=i[E+44>>2],g=i[E+40>>2],Q[A+8|0]=g,Q[A+9|0]=g>>>8,Q[A+10|0]=g>>>16,Q[A+11|0]=g>>>24,Q[A+12|0]=I,Q[A+13|0]=I>>>8,Q[A+14|0]=I>>>16,Q[A+15|0]=I>>>24,I=i[E+36>>2],g=i[E+32>>2],Q[0|A]=g,Q[A+1|0]=g>>>8,Q[A+2|0]=g>>>16,Q[A+3|0]=g>>>24,Q[A+4|0]=I,Q[A+5|0]=I>>>8,Q[A+6|0]=I>>>16,Q[A+7|0]=I>>>24,Dg(E,32),Dg(r,32),Dg(a,24)),s=E+96|0,0|B},ga:function(A,I,g,B,C,Q){A|=0,I|=0,Q|=0;var E,i=0;return s=E=s-32|0,i=-1,!(B|=0)&(g|=0)>>>0>=48|B&&(sI(E,I,C|=0),i=cI(A,I+32|0,g-32|0,B-(g>>>0<32)|0,E,I,Q)),s=E+32|0,0|i},ha:function(){return 48},ia:_g,ja:lg,ka:pg,la:_g,ma:lg,na:pg,oa:function(){return 384},pa:function(A,I,g,B,C,Q,E){return 0|qI(A|=0,I|=0,g|=0,B|=0,C|=0,Q|=0,E|=0)},qa:PI,ra:function(A,I,g,B){return 0|ig(A|=0,I|=0,g|=0,B|=0)},sa:dI,ta:sg,ua:lg,va:function(A,I,g,B){return 0|_I(A|=0,I|=0,g|=0,B|=0)},wa:_g,xa:lg,ya:Gg,za:pg,Aa:function(A,I,g,B,C,a){A|=0,I|=0,g|=0,B|=0,a|=0;var r,o=0,e=0,f=0,c=0;return s=r=s-32|0,f=n[0|(C|=0)]|n[C+1|0]<<8|n[C+2|0]<<16|n[C+3|0]<<24,C=n[C+4|0]|n[C+5|0]<<8|n[C+6|0]<<16|n[C+7|0]<<24,i[r+24>>2]=0,i[r+28>>2]=0,i[r+16>>2]=f,i[r+20>>2]=C,QI(r,g,B),i[r+8>>2]=0,i[r+12>>2]=0,I-65>>>0<=4294967246?(i[8952]=28,A=-1):(g=r+16|0,I-65>>>0<4294967232?A=-1:(s=c=(B=s)-384&-64,!a|!A|((C=255&I)-65&255)>>>0<=191?(xI(),t()):(s=e=s-192|0,!a|(C-65&255)>>>0<=191?(xI(),t()):(E[e+130>>1]=257,Q[e+129|0]=32,Q[e+128|0]=C,RI(4|(I=e+128|0)),QI(8|I,0,0),i[e+152>>2]=0,i[e+156>>2]=0,i[e+144>>2]=0,i[e+148>>2]=0,r?(f=n[r+4|0]|n[r+5|0]<<8|n[r+6|0]<<16|n[r+7|0]<<24,o=e+128|0,I=n[0|r]|n[r+1|0]<<8|n[r+2|0]<<16|n[r+3|0]<<24,Q[o+32|0]=I,Q[o+33|0]=I>>>8,Q[o+34|0]=I>>>16,Q[o+35|0]=I>>>24,Q[o+36|0]=f,Q[o+37|0]=f>>>8,Q[o+38|0]=f>>>16,Q[o+39|0]=f>>>24,f=n[r+12|0]|n[r+13|0]<<8|n[r+14|0]<<16|n[r+15|0]<<24,I=n[r+8|0]|n[r+9|0]<<8|n[r+10|0]<<16|n[r+11|0]<<24,Q[o+40|0]=I,Q[o+41|0]=I>>>8,Q[o+42|0]=I>>>16,Q[o+43|0]=I>>>24,Q[o+44|0]=f,Q[o+45|0]=f>>>8,Q[o+46|0]=f>>>16,Q[o+47|0]=f>>>24):(i[e+168>>2]=0,i[e+172>>2]=0,i[e+160>>2]=0,i[e+164>>2]=0),g?(f=n[g+4|0]|n[g+5|0]<<8|n[g+6|0]<<16|n[g+7|0]<<24,o=e+128|0,I=n[0|g]|n[g+1|0]<<8|n[g+2|0]<<16|n[g+3|0]<<24,Q[o+48|0]=I,Q[o+49|0]=I>>>8,Q[o+50|0]=I>>>16,Q[o+51|0]=I>>>24,Q[o+52|0]=f,Q[o+53|0]=f>>>8,Q[o+54|0]=f>>>16,Q[o+55|0]=f>>>24,f=n[g+12|0]|n[g+13|0]<<8|n[g+14|0]<<16|n[g+15|0]<<24,I=n[g+8|0]|n[g+9|0]<<8|n[g+10|0]<<16|n[g+11|0]<<24,Q[o+56|0]=I,Q[o+57|0]=I>>>8,Q[o+58|0]=I>>>16,Q[o+59|0]=I>>>24,Q[o+60|0]=f,Q[o+61|0]=f>>>8,Q[o+62|0]=f>>>16,Q[o+63|0]=f>>>24):(i[e+184>>2]=0,i[e+188>>2]=0,i[e+176>>2]=0,i[e+180>>2]=0),wA(c,e+128|0),wI(e+32|0,0,96),gA(c,I=eI(e,a,32),128,0),Dg(I,128),s=I+192|0),gA(c,0,0,0),Y(c,A,C),s=B),A=0)),s=r+32|0,0|A},Ba:sg,Ca:function(A,I,g){return A|=0,qI(I|=0,32,g|=0,32,0,0,0),0|ZI(A,I)},Da:function(A,I){return A|=0,EI(I|=0,32),0|ZI(A,I)},Ea:function(A,I,g,B,C){I|=0,g|=0,B|=0,C|=0;var E,i,a=0,r=0;if(i=a=s,s=a=a-512&-64,E=(A|=0)||I){if(r=-1,!JI(a+96|0,B,C)){for(B=I||A,A=0,PI(I=a+128|0,0,0,64),ig(I,r=a+96|0,32,0),Dg(r,32),ig(I,g,32,0),ig(I,C,32,0),dI(I,a+32|0,64),Dg(I,384);I=(a+32|0)+A|0,Q[A+E|0]=n[0|I],Q[A+B|0]=n[I+32|0],32!=(0|(A=A+1|0)););Dg(a+32|0,64),r=0}return s=i,0|r}xI(),t()},Fa:function(A,I,g,B,C){I|=0,g|=0,B|=0,C|=0;var E,i,a=0,r=0;if(i=a=s,s=a=a-512&-64,E=(A|=0)||I){if(r=-1,!JI(a+96|0,B,C)){for(B=I||A,A=0,PI(I=a+128|0,0,0,64),ig(I,r=a+96|0,32,0),Dg(r,32),ig(I,C,32,0),ig(I,g,32,0),dI(I,a+32|0,64),Dg(I,384);I=(a+32|0)+A|0,Q[A+B|0]=n[0|I],Q[A+E|0]=n[I+32|0],32!=(0|(A=A+1|0)););Dg(a+32|0,64),r=0}return s=i,0|r}xI(),t()},Ga:pg,Ha:pg,Ia:pg,Ja:pg,Ka:kg,La:Hg,Ma:Hg,Na:_g,Oa:bg,Pa:Sg,Qa:bg,Ra:_g,Sa:function(){return 128},Ta:function(){return 1403},Ua:kg,Va:bg,Wa:function(){return 8192},Xa:function(){return-2147483648},Ya:Hg,Za:function(){return 67108864},_a:Ug,$a:function(){return 268435456},ab:function(){return 4},bb:function(){return 1073741824},cb:function(A,I,g,B,C,Q,E,n,a,r,o){var t;A|=0,I|=0,g|=0,B|=0,Q|=0,E|=0,a|=0,r|=0,I|=0,t=0|(C|=0),C=0|(n|=0);A:{switch((o|=0)-1|0){case 0:A=wI(A,0,I);I:{if(1==(0|g)|g>>>0>1)i[8952]=22;else if(!g&I>>>0<=15)i[8952]=28;else if(!(Q|a)&r>>>0<2147483649)if((!a&C>>>0>=3|0!=(0|a))&r>>>0>8191){if((0|A)!=(0|B)){A=_(C,r>>>10|0,1,B,t,E,16,A,I,0,0,1)?-1:0;break I}i[8952]=28}else i[8952]=28;else i[8952]=22;A=-1}break A;case 1:A=wI(A,0,I);I:{if(1==(0|g)|g>>>0>1)i[8952]=22;else if(!g&I>>>0<=15)i[8952]=28;else if(!(Q|a)&r>>>0<2147483649)if(!!(C|a)&r>>>0>8191){if((0|A)!=(0|B)){A=_(C,r>>>10|0,1,B,t,E,16,A,I,0,0,2)?-1:0;break I}i[8952]=28}else i[8952]=28;else i[8952]=22;A=-1}break A}i[8952]=28,A=-1}return 0|A},db:function(A,I,g,B,C,Q,E){return 0|NA(A|=0,I|=0,(A=0)|(g|=0),B|=0,A|(C|=0),Q|=0,E|=0)},eb:function(A,I,g,B,C,Q,E,n){A|=0,I|=0,B|=0,Q|=0,E|=0;var a=0;a=g|=0,a|=g=0,g|=C|=0;A:{switch((n|=0)-1|0){case 1:A=NA(A,I,a,B,g,Q,E);break A;default:xI(),t();case 0:}s=C=s-16|0,A=wI(A,0,128),!(B|Q)&E>>>0<2147483649?(!Q&g>>>0>=3|0!=(0|Q))&E>>>0>8191?(EI(C,16),A=_(g,E>>>10|0,1,I,a,C,16,0,32,A,128,1)?-1:0):(i[8952]=28,A=-1):(i[8952]=22,A=-1),s=C+16|0}return 0|A},fb:function(A,I,g,B){I|=0,g|=0,B|=0;A:if(LA(A|=0,1403,10))if(LA(A,1393,9))i[8952]=28,A=-1;else{if(1==(0|B)|B>>>0>1)i[8952]=22;else{if(!(A=tA(A,I,g,1)))break A;-35==(0|A)&&(i[8952]=28)}A=-1}else{if(1==(0|B)|B>>>0>1)i[8952]=22;else{if(!(A=tA(A,I,g,2)))break A;-35==(0|A)&&(i[8952]=28)}A=-1}return 0|A},gb:function(A,I,g,B){return I|=0,g|=0,B|=0,LA(A|=0,1403,10)?LA(A,1393,9)?(i[8952]=28,A=-1):A=eA(A,I,g,B,1):A=eA(A,I,g,B,2),0|A},hb:ZI,ib:JI,jb:pg,kb:pg,lb:pg,mb:ug,nb:_g,ob:Fg,pb:sg,qb:zI,rb:function(A,I,g,B,C,Q){return A|=0,I|=0,C|=0,Q|=0,!(B|=0)&(g|=0)>>>0>=4294967280|B&&(xI(),t()),EA(A+16|0,A,I,g,B,C,Q),0},sb:jI,tb:function(A,I,g,B,C,Q){return I|=0,0|(!(B|=0)&(g|=0)>>>0>=16|B?iA(A|=0,I+16|0,I,g-16|0,B-(g>>>0<16)|0,C|=0,Q|=0):-1)},ub:sg,vb:function(A,I,g){return A|=0,g|=0,EI(I|=0,24),x(A,I,g),YI(A),g=n[I+16|0]|n[I+17|0]<<8|n[I+18|0]<<16|n[I+19|0]<<24,I=n[I+20|0]|n[I+21|0]<<8|n[I+22|0]<<16|n[I+23|0]<<24,Q[A+44|0]=0,Q[A+45|0]=0,Q[A+46|0]=0,Q[A+47|0]=0,Q[A+48|0]=0,Q[A+49|0]=0,Q[A+50|0]=0,Q[A+51|0]=0,Q[A+36|0]=g,Q[A+37|0]=g>>>8,Q[A+38|0]=g>>>16,Q[A+39|0]=g>>>24,Q[A+40|0]=I,Q[A+41|0]=I>>>8,Q[A+42|0]=I>>>16,Q[A+43|0]=I>>>24,0},wb:function(A,I,g){return x(A|=0,I|=0,g|=0),YI(A),g=n[I+16|0]|n[I+17|0]<<8|n[I+18|0]<<16|n[I+19|0]<<24,I=n[I+20|0]|n[I+21|0]<<8|n[I+22|0]<<16|n[I+23|0]<<24,Q[A+44|0]=0,Q[A+45|0]=0,Q[A+46|0]=0,Q[A+47|0]=0,Q[A+48|0]=0,Q[A+49|0]=0,Q[A+50|0]=0,Q[A+51|0]=0,Q[A+36|0]=g,Q[A+37|0]=g>>>8,Q[A+38|0]=g>>>16,Q[A+39|0]=g>>>24,Q[A+40|0]=I,Q[A+41|0]=I>>>8,Q[A+42|0]=I>>>16,Q[A+43|0]=I>>>24,0},xb:X,yb:function(A,I,g,B,C,E,a,r,o,e){A|=0,I|=0,B|=0,a|=0,r|=0,o|=0,e|=0;var f=0,c=0,y=0,w=0;return c=C|=0,C=E|=0,E=0|c,r|=f,s=c=s-336|0,(g|=0)&&(i[g>>2]=0,i[g+4>>2]=0),!C&E>>>0<4294967279?(fg(y=c+16|0,64,w=A+32|0,A),og(f=c+80|0,y),Dg(y,64),gg(f,a,r,o),gg(f,34048,0-r&15,0),wI(y,0,64),Q[c+16|0]=e,WA(y,y,64,0,w,1,A),gg(f,y,64,0),Q[0|I]=n[c+16|0],WA(a=I+1|0,B,E,C,w,2,A),gg(f,a,E,C),gg(f,34048,15&E,0),QI(I=c+8|0,r,o),gg(f,I,8,0),QI(I,E- -64|0,C-((E>>>0<4294967232)-1|0)|0),gg(f,I,8,0),tg(f,I=E+a|0),Dg(f,256),yI(A+36|0,I),nI(w),(2&e||BI(w,4))&&X(A),g&&(C=(A=E+17|0)>>>0<17?C+1|0:C,i[g>>2]=A,i[g+4>>2]=C),s=c+336|0):(xI(),t()),0},zb:function(A,I,g,B,C,E,a,r,o,e){A|=0,I|=0,B|=0,C|=0,E|=0,a|=0,r|=0,e|=0;var f,c=0,y=0,w=0,D=0,h=0,p=0;E|=0,f=(o|=0)|c,s=c=s-352|0,(g|=0)&&(i[g>>2]=0,i[g+4>>2]=0),B&&(Q[0|B]=255),p=-1;A:{I:{if(!(!a&E>>>0<17)){if(!(o=a-(E>>>0<17)|0)&(D=E-17|0)>>>0>=4294967279|o)break I;fg(y=c+32|0,64,h=A+32|0,A),og(w=c+96|0,y),Dg(y,64),gg(w,r,f,e),gg(w,34048,0-f&15,0),wI(y,0,64),Q[c+32|0]=n[0|C],WA(y,y,64,0,h,1,A),r=n[c+32|0],Q[c+32|0]=n[0|C],gg(w,y,64,0),gg(w,y=C+1|0,D,o),gg(w,34048,E-1&15,0),QI(C=c+24|0,f,e),gg(w,C,8,0),QI(C,E=E+47|0,a=E>>>0<47?a+1|0:a),gg(w,C,8,0),tg(w,c),Dg(w,256),zA(c,y+D|0,16)?Dg(c,16):(WA(I,y,D,o,h,2,A),yI(A+36|0,c),nI(h),(2&r||BI(h,4))&&X(A),g&&(i[g>>2]=D,i[g+4>>2]=o),p=0,B&&(Q[0|B]=r))}s=c+352|0;break A}xI(),t()}return 0|p},Ab:function(){return 52},Bb:function(){return 17},Cb:ug,Db:pg,Eb:function(){return-18},Fb:Sg,Gb:kg,Hb:Hg,Ib:Ug,Jb:Gg,Kb:_g,Lb:function(A,I,g,B,C){A|=0,I|=0,g|=0,B|=0;var Q=0,E=0,i=0,a=0,r=0,o=0,t=0,e=0,f=0,c=0,y=0,s=0,w=0,D=0,p=0,u=0;if(E=C|=0,C=n[C+4|0]|n[C+5|0]<<8|n[C+6|0]<<16|n[C+7|0]<<24,o=1886610805^(Q=n[0|E]|n[E+1|0]<<8|n[E+2|0]<<16|n[E+3|0]<<24),r=1936682341^C,Q^=1852142177,t=1819895653^C,C=1852075885^(i=n[E+8|0]|n[E+9|0]<<8|n[E+10|0]<<16|n[E+11|0]<<24),a=1685025377^(E=n[E+12|0]|n[E+13|0]<<8|n[E+14|0]<<16|n[E+15|0]<<24),e=2037671283^i,f=1952801890^E,E=g,(0|(i=(I+g|0)-(c=7&g)|0))!=(0|I)){for(;y=n[0|I]|n[I+1|0]<<8|n[I+2|0]<<16|n[I+3|0]<<24,u=n[I+4|0]|n[I+5|0]<<8|n[I+6|0]<<16|n[I+7|0]<<24,w=uA(C,a,13),B=h,g=a+r|0,a=g=(o=C+o|0)>>>0<C>>>0?g+1|0:g,o=uA(r=o,g,32),D=h,e=uA(C=e^y,g=f^u,16),g=g+t|0,g=(C=C+Q|0)>>>0<Q>>>0?g+1|0:g,Q=C,e=uA(C^=e,t=g^(f=h),21),f=h,w=uA(r^=w,B=a^=B,17),p=h,g=g+B|0,Q=uA(a=Q+r|0,g=a>>>0<Q>>>0?g+1|0:g,32),B=h,w=uA(r=a^w,g^=p,13),p=h,a=g,s=r,g=t+D|0,t=r=C+o|0,C=g=r>>>0<C>>>0?g+1|0:g,g=g+a|0,o=r=s+r|0,a=g=r>>>0<t>>>0?g+1|0:g,g=uA(r,g,32),D=h,r=C^=f,C=uA(t^=e,C,16),e=h,f=g,s=C,g=B+r|0,Q=g=(C=Q+t|0)>>>0<Q>>>0?g+1|0:g,g=(e^=g)+D|0,B=r=f+(t=s^C)|0,e=uA(t,e,21)^B,f=(r=B>>>0<t>>>0?g+1|0:g)^h,g=a^p,o=uA(a=o^w,g,17),g=g+Q|0,g=(a=C+a|0)>>>0<C>>>0?g+1|0:g,C=(Q=a)^o,a=g^(t=h),o=B^y,r^=u,Q=uA(Q,g,32),t=h,(0|i)!=(0|(I=I+8|0)););I=i}switch(g=E<<24,E=0,B=g,c-1|0){case 6:B|=n[I+6|0]<<16;case 5:B|=n[I+5|0]<<8;case 4:B|=n[I+4|0];case 3:E|=(i=n[I+3|0])<<24,B|=g=i>>>8|0;case 2:E|=(i=n[I+2|0])<<16,B|=g=i>>>16|0;case 1:E|=(i=n[I+1|0])<<8,B|=g=i>>>24|0;case 0:E=n[0|I]|E}return c=uA(C,a,13),y=h,g=a+r|0,i=I=C+o|0,C=g=I>>>0<C>>>0?g+1|0:g,a=uA(I,g,32),r=h,f=I=uA(o=E^e,g=I=B^f,16),g=g+t|0,g=(I=Q+o|0)>>>0<Q>>>0?g+1|0:g,Q=I,t=uA(I^=f,o=g^(e=h),21),e=h,c=uA(i^=c,C^=y,17),y=h,g=g+C|0,g=(C=Q+i|0)>>>0<Q>>>0?g+1|0:g,Q=C,C=uA(C,g,32),f=h,c=uA(i=Q^c,g^=y,13),y=h,Q=g,s=i,g=r+o|0,a=i=I+a|0,I=g=i>>>0<I>>>0?g+1|0:g,g=g+Q|0,Q=g=(i=s+i|0)>>>0<a>>>0?g+1|0:g,r=uA(i,g,32),o=h,e=I=uA(a^=t,g=I^=e,16),g=g+f|0,g=(I=C+a|0)>>>0<C>>>0?g+1|0:g,C=I,t=uA(I^=e,a=g^(t=h),21),e=h,c=uA(i^=c,Q^=y,17),y=h,g=g+Q|0,g=(Q=C+i|0)>>>0<C>>>0?g+1|0:g,i=uA(C=Q,g,32),f=h,c=uA(Q=C^c,g^=y,13),y=h,C=g,s=Q,g=a+o|0,g=(Q=I+r|0)>>>0<I>>>0?g+1|0:g,I=E,E=Q,a=I^Q,I=g,g=(g^B)+C|0,B=g=(Q=s+a|0)>>>0<a>>>0?g+1|0:g,a=uA(Q,g,32),r=h,g=I^e,C=uA(I=E^t,g,16),E=h,o=C,g=g+f|0,g=(C=I+(255^i)|0)>>>0<I>>>0?g+1|0:g,i=uA(I=o^C,E^=g,21),o=h,e=uA(Q^=c,B^=y,17),f=h,g=g+B|0,g=(B=C+Q|0)>>>0<C>>>0?g+1|0:g,B=uA(C=B,g,32),t=h,e=uA(Q=C^e,g^=f,13),f=h,C=g,s=Q,g=E+r|0,E=Q=I+a|0,I=g=Q>>>0<I>>>0?g+1|0:g,g=g+C|0,C=g=(Q=s+Q|0)>>>0<E>>>0?g+1|0:g,a=uA(Q,g,32),r=h,o=I=uA(E^=i,g=I^=o,16),g=g+t|0,g=(I=B+E|0)>>>0<B>>>0?g+1|0:g,B=I,i=uA(I^=o,E=g^(i=h),21),o=h,e=uA(Q^=e,C^=f,17),f=h,g=g+C|0,B=uA(C=B+Q|0,g=C>>>0<B>>>0?g+1|0:g,32),t=h,e=uA(Q=C^e,g^=f,13),f=h,C=g,s=Q,g=E+r|0,a=Q=I+a|0,E=Q,I=g=Q>>>0<I>>>0?g+1|0:g,g=g+C|0,g=(Q=s+Q|0)>>>0<E>>>0?g+1|0:g,E=Q,C=g,r=uA(Q,g,32),c=h,a=I=uA(Q=i^a,g=I^=o,16),g=g+t|0,g=(I=B+Q|0)>>>0<B>>>0?g+1|0:g,B=I,I^=a,a=Q=g^(i=h),i=uA(I,Q,21),Q=h,t=uA(E^=e,C^=f,17),e=h,g=g+C|0,B=uA(C=B+E|0,g=C>>>0<B>>>0?g+1|0:g,32),o=h,e=g^=e,t=uA(C^=t,g,13),E=h,f=i,g=a+c|0,a=i=I+r|0,I=g=i>>>0<I>>>0?g+1|0:g,f=Q=uA(i^=f,g^=Q,16),g=g+o|0,g=(Q=B+i|0)>>>0<B>>>0?g+1|0:g,B=Q,Q=g,g=uA(f^B,g^(r=h),21),r=h,o=g,g=I+e|0,g=Q+(E^=g=(i=C+a|0)>>>0<C>>>0?g+1|0:g)|0,g=(I=B+(C=i^t)|0)>>>0<B>>>0?g+1|0:g,B=o^I^uA(C,E,17),C=h^g^r,QI(A,uA(I,g,32)^B,h^C),0},Mb:function(A){EI(A|=0,16)},Nb:function(){return 208},Ob:lg,Pb:pg,Qb:pg,Rb:lg,Sb:function(){return-65},Tb:function(A,I,g){return 0|P(A|=0,I|=0,g|=0)},Ub:function(A,I){var g;return A|=0,I|=0,s=g=s-32|0,EI(g,32),P(A,I,g),Dg(g,32),s=g+32|0,0},Vb:function(A,I,g,B,C,Q){var E;return I|=0,C|=0,Q|=0,s=E=s-16|0,VI(A|=0,E+8|0,gI(A- -64|0,g|=0,g=B|=0),g,C,Q),64!=i[E+8>>2]|i[E+12>>2]?(I&&(i[I>>2]=0,i[I+4>>2]=0),wI(A,0,g- -64|0),A=-1):(A=0,I&&(i[I>>2]=g- -64,i[I+4>>2]=C-((g>>>0<4294967232)-1|0))),s=E+16|0,0|A},Wb:function(A,I,g,B,C,Q){A|=0,I|=0,g|=0;var E=0;A:{I:{if(E=B|=0,!(!(C|=0)&B>>>0<64||(B=C-1|0,E=C=E+-64|0,!(B=C>>>0<4294967232?B+1|0:B)&C>>>0>4294967231|B))){if(!OI(g,C=g- -64|0,E,B,Q|=0))break I;A&&wI(A,0,E)}if(g=-1,!I)break A;i[I>>2]=0,i[I+4>>2]=0;break A}I&&(i[I>>2]=E,i[I+4>>2]=B),g=0,A&&gI(A,C,E)}return 0|g},Xb:function(A,I,g,B,C,Q){return 0|VI(A|=0,I|=0,g|=0,B|=0,C|=0,Q|=0)},Yb:function(A,I,g,B,C){return 0|OI(A|=0,I|=0,g|=0,B|=0,C|=0)},Zb:function(A){return GI(A|=0),0},_b:function(A,I,g,B){return 0|z(A|=0,I|=0,g|=0,B|=0)},$b:function(A,I,g,B){var C;return I|=0,g|=0,B|=0,s=C=s+-64|0,MA(A|=0,C),A=u(I,g,C,64,0,B,1),s=C- -64|0,0|A},ac:function(A,I,g){var B;return I|=0,g|=0,s=B=s+-64|0,MA(A|=0,B),A=J(I,B,64,0,g,1),s=B- -64|0,0|A},bc:function(A,I){A|=0;var g,B=0,C=0,E=0,i=0,n=0,a=0;if(s=g=s-256|0,a=-1,!sA(I|=0)&&!V(g+96|0,I)){for(s=B=(s=i=s-160|0)-1760|0,DI(E=B+480|0,C=g+96|0),fI(I=B+320|0,C),tI(B,I),xA(I,B,E),tI(E=B+160|0,I),DI(C=B+640|0,E),xA(I,B,C),tI(E,I),DI(C=B+800|0,E),xA(I,B,C),tI(E,I),DI(C=B+960|0,E),xA(I,B,C),tI(E,I),DI(C=B+1120|0,E),xA(I,B,C),tI(E,I),DI(C=B+1280|0,E),xA(I,B,C),tI(E,I),DI(C=B+1440|0,E),xA(I,B,C),tI(E,I),DI(B+1600|0,E),LI(i),I=252;fI(B+320|0,i),E=I,(0|(I=Q[I+33504|0]))>0?(tI(C=B+160|0,n=B+320|0),xA(n,C,(B+480|0)+r((254&I)>>>1|0,160)|0)):(0|I)>=0||(tI(C=B+160|0,n=B+320|0),JA(n,C,(B+480|0)+r((0-I&254)>>>1|0,160)|0)),tI(i,B+320|0),I=E-1|0,E;);s=B+1760|0,I=mI(i),s=i+160|0,I&&(ng(g),cA(g,g,E=g+136|0),ng(I=g+48|0),yA(I,I,E),O(g,g),H(I,I,g),T(A,I),a=0)}return s=g+256|0,0|a},cc:function(A,I){A|=0;var g,B=0;return s=g=s+-64|0,_I(g,I|=0,32,0),Q[0|g]=248&n[0|g],Q[g+31|0]=63&n[g+31|0]|64,I=i[g+20>>2],B=i[g+16>>2],Q[A+16|0]=B,Q[A+17|0]=B>>>8,Q[A+18|0]=B>>>16,Q[A+19|0]=B>>>24,Q[A+20|0]=I,Q[A+21|0]=I>>>8,Q[A+22|0]=I>>>16,Q[A+23|0]=I>>>24,I=i[g+12>>2],B=i[g+8>>2],Q[A+8|0]=B,Q[A+9|0]=B>>>8,Q[A+10|0]=B>>>16,Q[A+11|0]=B>>>24,Q[A+12|0]=I,Q[A+13|0]=I>>>8,Q[A+14|0]=I>>>16,Q[A+15|0]=I>>>24,I=i[g+4>>2],B=i[g>>2],Q[0|A]=B,Q[A+1|0]=B>>>8,Q[A+2|0]=B>>>16,Q[A+3|0]=B>>>24,Q[A+4|0]=I,Q[A+5|0]=I>>>8,Q[A+6|0]=I>>>16,Q[A+7|0]=I>>>24,I=i[g+28>>2],B=i[g+24>>2],Q[A+24|0]=B,Q[A+25|0]=B>>>8,Q[A+26|0]=B>>>16,Q[A+27|0]=B>>>24,Q[A+28|0]=I,Q[A+29|0]=I>>>8,Q[A+30|0]=I>>>16,Q[A+31|0]=I>>>24,Dg(g,64),s=g- -64|0,0},dc:FI,ec:SI,fc:function(A){var I=0,g=0;if((A|=0)>>>0>=2){for(g=(0-A>>>0)%(A>>>0)|0;(I=FI())>>>0<g>>>0;);A=(I>>>0)%(A>>>0)|0}else A=0;return 0|A},gc:EI,hc:function(A,I,g){fg(A|=0,I|=0,1024,g|=0)},ic:pg,jc:function(){var A=0,I=0;return(A=i[9096])&&(A=i[A+20>>2])&&(I=0|vg[0|A]()),0|I},kc:function(A,I,g){A|=0,I|=0,1==(0|(g|=0))|g>>>0>1&&(e(1259,1119,197,1036),t()),EI(A,I)},lc:function(A,I,g,B){A|=0,g|=0;var C=0,E=0,i=0;if(!((B|=0)>>>0>2147483646|B<<1>>>0>=(I|=0)>>>0)){if(I=0,B){for(;C=(I<<1)+A|0,E=15&(i=n[I+g|0]),Q[C+1|0]=22272+((E<<8)+(E+65526&55552)|0)>>>8,E=C,C=i>>>4|0,Q[0|E]=87+((C+65526>>>8&217)+C|0),(0|B)!=(0|(I=I+1|0)););I=B<<1}else I=0;return Q[I+A|0]=0,0|A}xI(),t()},mc:function(A,I,g,B,C,E,a){A|=0,I|=0,g|=0,C|=0,E|=0,a|=0;var r=0,o=0,t=0,e=0,f=0,c=0,y=0,s=0,w=0,D=0,h=0;A:if(B|=0){I:{g:{B:for(;;){for(o=r;;){C:{if(!(255&((w=(65526+(y=(223&(c=n[g+o|0]))-55&255)^y+65520)>>>8|0)|(t=65526+(D=48^c)>>>8|0)))){if(t=1,!C|255&f)break g;if(DA(C,c))break C;r=o;break A}if(I>>>0<=e>>>0){i[8952]=68,t=0;break g}if(r=y&w|t&D,255&f?(Q[A+e|0]=r|h,e=e+1|0):h=r<<4,f^=-1,t=1,(r=o+1|0)>>>0<B>>>0)continue B;break I}if(f=0,!((o=o+1|0)>>>0<B>>>0))break}break}r=(A=r+1|0)>>>0<B>>>0?B:A;break A}r=o}255&f?(i[8952]=28,s=-1,r=r-1|0,e=0):t||(e=0,s=-1)}return a?i[a>>2]=g+r:(0|B)!=(0|r)&&(i[8952]=28,s=-1),E&&(i[E>>2]=e),0|s},nc:function(A,I){var g;return A|=0,ag(I|=0),A=r(g=(A>>>0)/3|0,-3)+A|0,1+(r(1&(A>>>1|A),2&I?A+1|0:4)+(g<<2)|0)|0},oc:Z,pc:L,qc:function(){var A=0;return i[9097]?A=1:(i[8954]=0,s=A=s-16|0,NI(A),i[A>>2]&&(NI(A),wI(35820,0,40)),s=A+16|0,i[8953]=1,SI(),EI(36368,16),i[9097]=1,A=0),0|A},rc:function(A,I,g,B,C){A|=0,I|=0,g|=0,C|=0;var E,a=0,r=0,o=0;s=E=s-16|0;A:{if(B|=0){if(o=-1,(a=(a=B-1|0)-(r=a&B?(g>>>0)%(B>>>0)|0:g&a)|0)>>>0>=(-1^g)>>>0)break A;if(!((g=g+a|0)>>>0>=C>>>0))for(A&&(i[A>>2]=g+1),A=I+g|0,o=0,Q[E+15|0]=0,g=0;C=I=A-g|0,r=n[0|I]&n[E+15|0],I=(g^a)-1>>>24|0,Q[0|C]=r|128&I,Q[E+15|0]=I|n[E+15|0],(0|B)!=(0|(g=g+1|0)););}else o=-1;return s=E+16|0,0|o}xI(),t()},sc:function(A,I,g,B){A|=0,I|=0,g|=0,B|=0;var C,Q=0,E=0,a=0,r=0,o=0;if(i[12+(C=s-16|0)>>2]=0,B-1>>>0<g>>>0){for(o=(Q=g-1|0)+I|0,g=0,I=0;r=((128^(E=n[o-g|0]))-1&i[C+12>>2]-1&a-1)>>>8&1,i[C+12>>2]=i[C+12>>2]|0-r&g,I|=r,a|=E,(0|B)!=(0|(g=g+1|0)););i[A>>2]=Q-i[C+12>>2],A=I-1|0}else A=-1;return 0|A},tc:function(){return 1368},uc:function(){return 10},vc:Ug,wc:kg,xc:k,yc:b,zc:vg}}(A)}(gA)},instantiate:function(A,I){return{then:function(I){var g=new D.Module(A);I({instance:new D.Instance(g)})}}},RuntimeError:Error};y=[],"object"!=typeof D&&d("no native wasm support detected");var h,p,u,F,l,_,k,H=!1,G="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function U(A,I){return A?function(A,I,g){for(var B=I+g,C=I;A[C]&&!(C>=B);)++C;if(C-I>16&&A.subarray&&G)return G.decode(A.subarray(I,C));for(var Q="";I<C;){var E=A[I++];if(128&E){var i=63&A[I++];if(192!=(224&E)){var n=63&A[I++];if((E=224==(240&E)?(15&E)<<12|i<<6|n:(7&E)<<18|i<<12|n<<6|63&A[I++])<65536)Q+=String.fromCharCode(E);else{var a=E-65536;Q+=String.fromCharCode(55296|a>>10,56320|1023&a)}}else Q+=String.fromCharCode((31&E)<<6|i)}else Q+=String.fromCharCode(E)}return Q}(u,A,I):""}function S(A){h=A,a.HEAP8=p=new Int8Array(A),a.HEAP16=F=new Int16Array(A),a.HEAP32=l=new Int32Array(A),a.HEAPU8=u=new Uint8Array(A),a.HEAPU16=new Uint16Array(A),a.HEAPU32=new Uint32Array(A),a.HEAPF32=_=new Float32Array(A),a.HEAPF64=k=new Float64Array(A)}var b,m=a.INITIAL_MEMORY||16777216;(w=a.wasmMemory?a.wasmMemory:new D.Memory({initial:m/65536,maximum:32768}))&&(h=w.buffer),m=h.byteLength,S(h);var v=[],M=[],P=[],Y=0,N=null,R=null;function d(A){throw a.onAbort&&a.onAbort(A),s(A="Aborted("+A+")"),H=!0,A+=". Build with -s ASSERTIONS=1 for more info.",new D.RuntimeError(A)}a.preloadedImages={},a.preloadedAudios={};var J,x,L,K,X="data:application/octet-stream;base64,";function T(A){return A.startsWith(X)}function V(A){return A.startsWith("file://")}function q(A){try{if(A==J&&y)return new Uint8Array(y);var I=AA(A);if(I)return I;if(Q)return Q(A);throw"both async and sync fetching of the wasm failed"}catch(A){d(A)}}T(J="<<< WASM_BINARY_FILE >>>")||(x=J,J=a.locateFile?a.locateFile(x,c):c+x);var z={35048:function(){return a.getRandomValue()},35084:function(){if(void 0===a.getRandomValue)try{var A="object"==typeof window?window:self,I=void 0!==A.crypto?A.crypto:A.msCrypto,g=function(){var A=new Uint32Array(1);return I.getRandomValues(A),A[0]>>>0};g(),a.getRandomValue=g}catch(A){try{var B=__webpack_require__(/*! crypto */ "crypto"),C=function(){var A=B.randomBytes(4);return(A[0]<<24|A[1]<<16|A[2]<<8|A[3])>>>0};C(),a.getRandomValue=C}catch(A){throw"No secure random number generator found"}}}};function j(A){for(;A.length>0;){var I=A.shift();if("function"!=typeof I){var g=I.func;"number"==typeof g?void 0===I.arg?W(g)():W(g)(I.arg):g(void 0===I.arg?null:I.arg)}else I(a)}}function W(A){return b.get(A)}var O=[];function Z(A){try{return w.grow(A-h.byteLength+65535>>>16),S(w.buffer),1}catch(A){}}var $="function"==typeof atob?atob:function(A){var I,g,B,C,Q,E,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",n="",a=0;A=A.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{I=i.indexOf(A.charAt(a++))<<2|(C=i.indexOf(A.charAt(a++)))>>4,g=(15&C)<<4|(Q=i.indexOf(A.charAt(a++)))>>2,B=(3&Q)<<6|(E=i.indexOf(A.charAt(a++))),n+=String.fromCharCode(I),64!==Q&&(n+=String.fromCharCode(g)),64!==E&&(n+=String.fromCharCode(B))}while(a<A.length);return n};function AA(A){if(T(A))return function(A){if("boolean"==typeof f&&f){var I=Buffer.from(A,"base64");return new Uint8Array(I.buffer,I.byteOffset,I.byteLength)}try{for(var g=$(A),B=new Uint8Array(g.length),C=0;C<g.length;++C)B[C]=g.charCodeAt(C);return B}catch(A){throw new Error("Converting base64 string to bytes failed.")}}(A.slice(X.length))}var IA,gA={b:function(A,I,g,B){d("Assertion failed: "+U(A)+", at: "+[I?U(I):"unknown filename",g,B?U(B):"unknown function"])},e:function(){d("")},c:function(A,I,g){var B=function(A,I){var g;for(O.length=0,I>>=2;g=u[A++];){var B=g<105;B&&1&I&&I++,O.push(B?k[I++>>1]:l[I]),++I}return O}(I,g);return z[A].apply(null,B)},d:function(A){var I,g=u.length,B=2147483648;if((A>>>=0)>B)return!1;for(var C=1;C<=4;C*=2){var Q=g*(1+.2/C);if(Q=Math.min(Q,A+100663296),Z(Math.min(B,(I=Math.max(A,Q))+(65536-I%65536)%65536)))return!0}return!1},a:w};function BA(A){function I(){IA||(IA=!0,a.calledRun=!0,H||(j(M),a.onRuntimeInitialized&&a.onRuntimeInitialized(),function(){if(a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;)A=a.postRun.shift(),P.unshift(A);var A;j(P)}()))}A=A||o,Y>0||(function(){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)A=a.preRun.shift(),v.unshift(A);var A;j(v)}(),Y>0||(a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1),I()}),1)):I()))}if(function(){var A={a:gA};function I(A,I){var g,B=A.exports;a.asm=B,b=a.asm.zc,g=a.asm.f,M.unshift(g),function(A){if(Y--,a.monitorRunDependencies&&a.monitorRunDependencies(Y),0==Y&&(null!==N&&(clearInterval(N),N=null),R)){var I=R;R=null,I()}}()}function g(A){I(A.instance)}function B(I){return function(){if(!y&&(t||e)){if("function"==typeof fetch&&!V(J))return fetch(J,{credentials:"same-origin"}).then((function(A){if(!A.ok)throw"failed to load wasm binary file at '"+J+"'";return A.arrayBuffer()})).catch((function(){return q(J)}));if(C)return new Promise((function(A,I){C(J,(function(I){A(new Uint8Array(I))}),I)}))}return Promise.resolve().then((function(){return q(J)}))}().then((function(I){return D.instantiate(I,A)})).then((function(A){return A})).then(I,(function(A){s("failed to asynchronously prepare wasm: "+A),d(A)}))}if(Y++,a.monitorRunDependencies&&a.monitorRunDependencies(Y),a.instantiateWasm)try{return a.instantiateWasm(A,I)}catch(A){return s("Module.instantiateWasm callback failed with error: "+A),!1}y||"function"!=typeof D.instantiateStreaming||T(J)||V(J)||"function"!=typeof fetch?B(g):fetch(J,{credentials:"same-origin"}).then((function(I){return D.instantiateStreaming(I,A).then(g,(function(A){return s("wasm streaming compile failed: "+A),s("falling back to ArrayBuffer instantiation"),B(g)}))}))}(),a.___wasm_call_ctors=function(){return(a.___wasm_call_ctors=a.asm.f).apply(null,arguments)},a._crypto_aead_chacha20poly1305_encrypt_detached=function(){return(a._crypto_aead_chacha20poly1305_encrypt_detached=a.asm.g).apply(null,arguments)},a._crypto_aead_chacha20poly1305_encrypt=function(){return(a._crypto_aead_chacha20poly1305_encrypt=a.asm.h).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_encrypt_detached=function(){return(a._crypto_aead_chacha20poly1305_ietf_encrypt_detached=a.asm.i).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_encrypt=function(){return(a._crypto_aead_chacha20poly1305_ietf_encrypt=a.asm.j).apply(null,arguments)},a._crypto_aead_chacha20poly1305_decrypt_detached=function(){return(a._crypto_aead_chacha20poly1305_decrypt_detached=a.asm.k).apply(null,arguments)},a._crypto_aead_chacha20poly1305_decrypt=function(){return(a._crypto_aead_chacha20poly1305_decrypt=a.asm.l).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_decrypt_detached=function(){return(a._crypto_aead_chacha20poly1305_ietf_decrypt_detached=a.asm.m).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_decrypt=function(){return(a._crypto_aead_chacha20poly1305_ietf_decrypt=a.asm.n).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_keybytes=function(){return(a._crypto_aead_chacha20poly1305_ietf_keybytes=a.asm.o).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_npubbytes=function(){return(a._crypto_aead_chacha20poly1305_ietf_npubbytes=a.asm.p).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_nsecbytes=function(){return(a._crypto_aead_chacha20poly1305_ietf_nsecbytes=a.asm.q).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_abytes=function(){return(a._crypto_aead_chacha20poly1305_ietf_abytes=a.asm.r).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_messagebytes_max=function(){return(a._crypto_aead_chacha20poly1305_ietf_messagebytes_max=a.asm.s).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_keygen=function(){return(a._crypto_aead_chacha20poly1305_ietf_keygen=a.asm.t).apply(null,arguments)},a._crypto_aead_chacha20poly1305_keybytes=function(){return(a._crypto_aead_chacha20poly1305_keybytes=a.asm.u).apply(null,arguments)},a._crypto_aead_chacha20poly1305_npubbytes=function(){return(a._crypto_aead_chacha20poly1305_npubbytes=a.asm.v).apply(null,arguments)},a._crypto_aead_chacha20poly1305_nsecbytes=function(){return(a._crypto_aead_chacha20poly1305_nsecbytes=a.asm.w).apply(null,arguments)},a._crypto_aead_chacha20poly1305_abytes=function(){return(a._crypto_aead_chacha20poly1305_abytes=a.asm.x).apply(null,arguments)},a._crypto_aead_chacha20poly1305_messagebytes_max=function(){return(a._crypto_aead_chacha20poly1305_messagebytes_max=a.asm.y).apply(null,arguments)},a._crypto_aead_chacha20poly1305_keygen=function(){return(a._crypto_aead_chacha20poly1305_keygen=a.asm.z).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=function(){return(a._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=a.asm.A).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_encrypt=function(){return(a._crypto_aead_xchacha20poly1305_ietf_encrypt=a.asm.B).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=function(){return(a._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=a.asm.C).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_decrypt=function(){return(a._crypto_aead_xchacha20poly1305_ietf_decrypt=a.asm.D).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_keybytes=function(){return(a._crypto_aead_xchacha20poly1305_ietf_keybytes=a.asm.E).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_npubbytes=function(){return(a._crypto_aead_xchacha20poly1305_ietf_npubbytes=a.asm.F).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_nsecbytes=function(){return(a._crypto_aead_xchacha20poly1305_ietf_nsecbytes=a.asm.G).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_abytes=function(){return(a._crypto_aead_xchacha20poly1305_ietf_abytes=a.asm.H).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_messagebytes_max=function(){return(a._crypto_aead_xchacha20poly1305_ietf_messagebytes_max=a.asm.I).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_keygen=function(){return(a._crypto_aead_xchacha20poly1305_ietf_keygen=a.asm.J).apply(null,arguments)},a._crypto_auth_bytes=function(){return(a._crypto_auth_bytes=a.asm.K).apply(null,arguments)},a._crypto_auth_keybytes=function(){return(a._crypto_auth_keybytes=a.asm.L).apply(null,arguments)},a._crypto_auth=function(){return(a._crypto_auth=a.asm.M).apply(null,arguments)},a._crypto_auth_verify=function(){return(a._crypto_auth_verify=a.asm.N).apply(null,arguments)},a._crypto_auth_keygen=function(){return(a._crypto_auth_keygen=a.asm.O).apply(null,arguments)},a._crypto_box_seedbytes=function(){return(a._crypto_box_seedbytes=a.asm.P).apply(null,arguments)},a._crypto_box_publickeybytes=function(){return(a._crypto_box_publickeybytes=a.asm.Q).apply(null,arguments)},a._crypto_box_secretkeybytes=function(){return(a._crypto_box_secretkeybytes=a.asm.R).apply(null,arguments)},a._crypto_box_beforenmbytes=function(){return(a._crypto_box_beforenmbytes=a.asm.S).apply(null,arguments)},a._crypto_box_noncebytes=function(){return(a._crypto_box_noncebytes=a.asm.T).apply(null,arguments)},a._crypto_box_macbytes=function(){return(a._crypto_box_macbytes=a.asm.U).apply(null,arguments)},a._crypto_box_messagebytes_max=function(){return(a._crypto_box_messagebytes_max=a.asm.V).apply(null,arguments)},a._crypto_box_seed_keypair=function(){return(a._crypto_box_seed_keypair=a.asm.W).apply(null,arguments)},a._crypto_box_keypair=function(){return(a._crypto_box_keypair=a.asm.X).apply(null,arguments)},a._crypto_box_beforenm=function(){return(a._crypto_box_beforenm=a.asm.Y).apply(null,arguments)},a._crypto_box_detached_afternm=function(){return(a._crypto_box_detached_afternm=a.asm.Z).apply(null,arguments)},a._crypto_box_detached=function(){return(a._crypto_box_detached=a.asm._).apply(null,arguments)},a._crypto_box_easy_afternm=function(){return(a._crypto_box_easy_afternm=a.asm.$).apply(null,arguments)},a._crypto_box_easy=function(){return(a._crypto_box_easy=a.asm.aa).apply(null,arguments)},a._crypto_box_open_detached_afternm=function(){return(a._crypto_box_open_detached_afternm=a.asm.ba).apply(null,arguments)},a._crypto_box_open_detached=function(){return(a._crypto_box_open_detached=a.asm.ca).apply(null,arguments)},a._crypto_box_open_easy_afternm=function(){return(a._crypto_box_open_easy_afternm=a.asm.da).apply(null,arguments)},a._crypto_box_open_easy=function(){return(a._crypto_box_open_easy=a.asm.ea).apply(null,arguments)},a._crypto_box_seal=function(){return(a._crypto_box_seal=a.asm.fa).apply(null,arguments)},a._crypto_box_seal_open=function(){return(a._crypto_box_seal_open=a.asm.ga).apply(null,arguments)},a._crypto_box_sealbytes=function(){return(a._crypto_box_sealbytes=a.asm.ha).apply(null,arguments)},a._crypto_generichash_bytes_min=function(){return(a._crypto_generichash_bytes_min=a.asm.ia).apply(null,arguments)},a._crypto_generichash_bytes_max=function(){return(a._crypto_generichash_bytes_max=a.asm.ja).apply(null,arguments)},a._crypto_generichash_bytes=function(){return(a._crypto_generichash_bytes=a.asm.ka).apply(null,arguments)},a._crypto_generichash_keybytes_min=function(){return(a._crypto_generichash_keybytes_min=a.asm.la).apply(null,arguments)},a._crypto_generichash_keybytes_max=function(){return(a._crypto_generichash_keybytes_max=a.asm.ma).apply(null,arguments)},a._crypto_generichash_keybytes=function(){return(a._crypto_generichash_keybytes=a.asm.na).apply(null,arguments)},a._crypto_generichash_statebytes=function(){return(a._crypto_generichash_statebytes=a.asm.oa).apply(null,arguments)},a._crypto_generichash=function(){return(a._crypto_generichash=a.asm.pa).apply(null,arguments)},a._crypto_generichash_init=function(){return(a._crypto_generichash_init=a.asm.qa).apply(null,arguments)},a._crypto_generichash_update=function(){return(a._crypto_generichash_update=a.asm.ra).apply(null,arguments)},a._crypto_generichash_final=function(){return(a._crypto_generichash_final=a.asm.sa).apply(null,arguments)},a._crypto_generichash_keygen=function(){return(a._crypto_generichash_keygen=a.asm.ta).apply(null,arguments)},a._crypto_hash_bytes=function(){return(a._crypto_hash_bytes=a.asm.ua).apply(null,arguments)},a._crypto_hash=function(){return(a._crypto_hash=a.asm.va).apply(null,arguments)},a._crypto_kdf_bytes_min=function(){return(a._crypto_kdf_bytes_min=a.asm.wa).apply(null,arguments)},a._crypto_kdf_bytes_max=function(){return(a._crypto_kdf_bytes_max=a.asm.xa).apply(null,arguments)},a._crypto_kdf_contextbytes=function(){return(a._crypto_kdf_contextbytes=a.asm.ya).apply(null,arguments)},a._crypto_kdf_keybytes=function(){return(a._crypto_kdf_keybytes=a.asm.za).apply(null,arguments)},a._crypto_kdf_derive_from_key=function(){return(a._crypto_kdf_derive_from_key=a.asm.Aa).apply(null,arguments)},a._crypto_kdf_keygen=function(){return(a._crypto_kdf_keygen=a.asm.Ba).apply(null,arguments)},a._crypto_kx_seed_keypair=function(){return(a._crypto_kx_seed_keypair=a.asm.Ca).apply(null,arguments)},a._crypto_kx_keypair=function(){return(a._crypto_kx_keypair=a.asm.Da).apply(null,arguments)},a._crypto_kx_client_session_keys=function(){return(a._crypto_kx_client_session_keys=a.asm.Ea).apply(null,arguments)},a._crypto_kx_server_session_keys=function(){return(a._crypto_kx_server_session_keys=a.asm.Fa).apply(null,arguments)},a._crypto_kx_publickeybytes=function(){return(a._crypto_kx_publickeybytes=a.asm.Ga).apply(null,arguments)},a._crypto_kx_secretkeybytes=function(){return(a._crypto_kx_secretkeybytes=a.asm.Ha).apply(null,arguments)},a._crypto_kx_seedbytes=function(){return(a._crypto_kx_seedbytes=a.asm.Ia).apply(null,arguments)},a._crypto_kx_sessionkeybytes=function(){return(a._crypto_kx_sessionkeybytes=a.asm.Ja).apply(null,arguments)},a._crypto_pwhash_alg_argon2i13=function(){return(a._crypto_pwhash_alg_argon2i13=a.asm.Ka).apply(null,arguments)},a._crypto_pwhash_alg_argon2id13=function(){return(a._crypto_pwhash_alg_argon2id13=a.asm.La).apply(null,arguments)},a._crypto_pwhash_alg_default=function(){return(a._crypto_pwhash_alg_default=a.asm.Ma).apply(null,arguments)},a._crypto_pwhash_bytes_min=function(){return(a._crypto_pwhash_bytes_min=a.asm.Na).apply(null,arguments)},a._crypto_pwhash_bytes_max=function(){return(a._crypto_pwhash_bytes_max=a.asm.Oa).apply(null,arguments)},a._crypto_pwhash_passwd_min=function(){return(a._crypto_pwhash_passwd_min=a.asm.Pa).apply(null,arguments)},a._crypto_pwhash_passwd_max=function(){return(a._crypto_pwhash_passwd_max=a.asm.Qa).apply(null,arguments)},a._crypto_pwhash_saltbytes=function(){return(a._crypto_pwhash_saltbytes=a.asm.Ra).apply(null,arguments)},a._crypto_pwhash_strbytes=function(){return(a._crypto_pwhash_strbytes=a.asm.Sa).apply(null,arguments)},a._crypto_pwhash_strprefix=function(){return(a._crypto_pwhash_strprefix=a.asm.Ta).apply(null,arguments)},a._crypto_pwhash_opslimit_min=function(){return(a._crypto_pwhash_opslimit_min=a.asm.Ua).apply(null,arguments)},a._crypto_pwhash_opslimit_max=function(){return(a._crypto_pwhash_opslimit_max=a.asm.Va).apply(null,arguments)},a._crypto_pwhash_memlimit_min=function(){return(a._crypto_pwhash_memlimit_min=a.asm.Wa).apply(null,arguments)},a._crypto_pwhash_memlimit_max=function(){return(a._crypto_pwhash_memlimit_max=a.asm.Xa).apply(null,arguments)},a._crypto_pwhash_opslimit_interactive=function(){return(a._crypto_pwhash_opslimit_interactive=a.asm.Ya).apply(null,arguments)},a._crypto_pwhash_memlimit_interactive=function(){return(a._crypto_pwhash_memlimit_interactive=a.asm.Za).apply(null,arguments)},a._crypto_pwhash_opslimit_moderate=function(){return(a._crypto_pwhash_opslimit_moderate=a.asm._a).apply(null,arguments)},a._crypto_pwhash_memlimit_moderate=function(){return(a._crypto_pwhash_memlimit_moderate=a.asm.$a).apply(null,arguments)},a._crypto_pwhash_opslimit_sensitive=function(){return(a._crypto_pwhash_opslimit_sensitive=a.asm.ab).apply(null,arguments)},a._crypto_pwhash_memlimit_sensitive=function(){return(a._crypto_pwhash_memlimit_sensitive=a.asm.bb).apply(null,arguments)},a._crypto_pwhash=function(){return(a._crypto_pwhash=a.asm.cb).apply(null,arguments)},a._crypto_pwhash_str=function(){return(a._crypto_pwhash_str=a.asm.db).apply(null,arguments)},a._crypto_pwhash_str_alg=function(){return(a._crypto_pwhash_str_alg=a.asm.eb).apply(null,arguments)},a._crypto_pwhash_str_verify=function(){return(a._crypto_pwhash_str_verify=a.asm.fb).apply(null,arguments)},a._crypto_pwhash_str_needs_rehash=function(){return(a._crypto_pwhash_str_needs_rehash=a.asm.gb).apply(null,arguments)},a._crypto_scalarmult_base=function(){return(a._crypto_scalarmult_base=a.asm.hb).apply(null,arguments)},a._crypto_scalarmult=function(){return(a._crypto_scalarmult=a.asm.ib).apply(null,arguments)},a._crypto_scalarmult_bytes=function(){return(a._crypto_scalarmult_bytes=a.asm.jb).apply(null,arguments)},a._crypto_scalarmult_scalarbytes=function(){return(a._crypto_scalarmult_scalarbytes=a.asm.kb).apply(null,arguments)},a._crypto_secretbox_keybytes=function(){return(a._crypto_secretbox_keybytes=a.asm.lb).apply(null,arguments)},a._crypto_secretbox_noncebytes=function(){return(a._crypto_secretbox_noncebytes=a.asm.mb).apply(null,arguments)},a._crypto_secretbox_macbytes=function(){return(a._crypto_secretbox_macbytes=a.asm.nb).apply(null,arguments)},a._crypto_secretbox_messagebytes_max=function(){return(a._crypto_secretbox_messagebytes_max=a.asm.ob).apply(null,arguments)},a._crypto_secretbox_keygen=function(){return(a._crypto_secretbox_keygen=a.asm.pb).apply(null,arguments)},a._crypto_secretbox_detached=function(){return(a._crypto_secretbox_detached=a.asm.qb).apply(null,arguments)},a._crypto_secretbox_easy=function(){return(a._crypto_secretbox_easy=a.asm.rb).apply(null,arguments)},a._crypto_secretbox_open_detached=function(){return(a._crypto_secretbox_open_detached=a.asm.sb).apply(null,arguments)},a._crypto_secretbox_open_easy=function(){return(a._crypto_secretbox_open_easy=a.asm.tb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_keygen=function(){return(a._crypto_secretstream_xchacha20poly1305_keygen=a.asm.ub).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_init_push=function(){return(a._crypto_secretstream_xchacha20poly1305_init_push=a.asm.vb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_init_pull=function(){return(a._crypto_secretstream_xchacha20poly1305_init_pull=a.asm.wb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_rekey=function(){return(a._crypto_secretstream_xchacha20poly1305_rekey=a.asm.xb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_push=function(){return(a._crypto_secretstream_xchacha20poly1305_push=a.asm.yb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_pull=function(){return(a._crypto_secretstream_xchacha20poly1305_pull=a.asm.zb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_statebytes=function(){return(a._crypto_secretstream_xchacha20poly1305_statebytes=a.asm.Ab).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_abytes=function(){return(a._crypto_secretstream_xchacha20poly1305_abytes=a.asm.Bb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_headerbytes=function(){return(a._crypto_secretstream_xchacha20poly1305_headerbytes=a.asm.Cb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_keybytes=function(){return(a._crypto_secretstream_xchacha20poly1305_keybytes=a.asm.Db).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_messagebytes_max=function(){return(a._crypto_secretstream_xchacha20poly1305_messagebytes_max=a.asm.Eb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_tag_message=function(){return(a._crypto_secretstream_xchacha20poly1305_tag_message=a.asm.Fb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_tag_push=function(){return(a._crypto_secretstream_xchacha20poly1305_tag_push=a.asm.Gb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_tag_rekey=function(){return(a._crypto_secretstream_xchacha20poly1305_tag_rekey=a.asm.Hb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_tag_final=function(){return(a._crypto_secretstream_xchacha20poly1305_tag_final=a.asm.Ib).apply(null,arguments)},a._crypto_shorthash_bytes=function(){return(a._crypto_shorthash_bytes=a.asm.Jb).apply(null,arguments)},a._crypto_shorthash_keybytes=function(){return(a._crypto_shorthash_keybytes=a.asm.Kb).apply(null,arguments)},a._crypto_shorthash=function(){return(a._crypto_shorthash=a.asm.Lb).apply(null,arguments)},a._crypto_shorthash_keygen=function(){return(a._crypto_shorthash_keygen=a.asm.Mb).apply(null,arguments)},a._crypto_sign_statebytes=function(){return(a._crypto_sign_statebytes=a.asm.Nb).apply(null,arguments)},a._crypto_sign_bytes=function(){return(a._crypto_sign_bytes=a.asm.Ob).apply(null,arguments)},a._crypto_sign_seedbytes=function(){return(a._crypto_sign_seedbytes=a.asm.Pb).apply(null,arguments)},a._crypto_sign_publickeybytes=function(){return(a._crypto_sign_publickeybytes=a.asm.Qb).apply(null,arguments)},a._crypto_sign_secretkeybytes=function(){return(a._crypto_sign_secretkeybytes=a.asm.Rb).apply(null,arguments)},a._crypto_sign_messagebytes_max=function(){return(a._crypto_sign_messagebytes_max=a.asm.Sb).apply(null,arguments)},a._crypto_sign_seed_keypair=function(){return(a._crypto_sign_seed_keypair=a.asm.Tb).apply(null,arguments)},a._crypto_sign_keypair=function(){return(a._crypto_sign_keypair=a.asm.Ub).apply(null,arguments)},a._crypto_sign=function(){return(a._crypto_sign=a.asm.Vb).apply(null,arguments)},a._crypto_sign_open=function(){return(a._crypto_sign_open=a.asm.Wb).apply(null,arguments)},a._crypto_sign_detached=function(){return(a._crypto_sign_detached=a.asm.Xb).apply(null,arguments)},a._crypto_sign_verify_detached=function(){return(a._crypto_sign_verify_detached=a.asm.Yb).apply(null,arguments)},a._crypto_sign_init=function(){return(a._crypto_sign_init=a.asm.Zb).apply(null,arguments)},a._crypto_sign_update=function(){return(a._crypto_sign_update=a.asm._b).apply(null,arguments)},a._crypto_sign_final_create=function(){return(a._crypto_sign_final_create=a.asm.$b).apply(null,arguments)},a._crypto_sign_final_verify=function(){return(a._crypto_sign_final_verify=a.asm.ac).apply(null,arguments)},a._crypto_sign_ed25519_pk_to_curve25519=function(){return(a._crypto_sign_ed25519_pk_to_curve25519=a.asm.bc).apply(null,arguments)},a._crypto_sign_ed25519_sk_to_curve25519=function(){return(a._crypto_sign_ed25519_sk_to_curve25519=a.asm.cc).apply(null,arguments)},a._randombytes_random=function(){return(a._randombytes_random=a.asm.dc).apply(null,arguments)},a._randombytes_stir=function(){return(a._randombytes_stir=a.asm.ec).apply(null,arguments)},a._randombytes_uniform=function(){return(a._randombytes_uniform=a.asm.fc).apply(null,arguments)},a._randombytes_buf=function(){return(a._randombytes_buf=a.asm.gc).apply(null,arguments)},a._randombytes_buf_deterministic=function(){return(a._randombytes_buf_deterministic=a.asm.hc).apply(null,arguments)},a._randombytes_seedbytes=function(){return(a._randombytes_seedbytes=a.asm.ic).apply(null,arguments)},a._randombytes_close=function(){return(a._randombytes_close=a.asm.jc).apply(null,arguments)},a._randombytes=function(){return(a._randombytes=a.asm.kc).apply(null,arguments)},a._sodium_bin2hex=function(){return(a._sodium_bin2hex=a.asm.lc).apply(null,arguments)},a._sodium_hex2bin=function(){return(a._sodium_hex2bin=a.asm.mc).apply(null,arguments)},a._sodium_base64_encoded_len=function(){return(a._sodium_base64_encoded_len=a.asm.nc).apply(null,arguments)},a._sodium_bin2base64=function(){return(a._sodium_bin2base64=a.asm.oc).apply(null,arguments)},a._sodium_base642bin=function(){return(a._sodium_base642bin=a.asm.pc).apply(null,arguments)},a._sodium_init=function(){return(a._sodium_init=a.asm.qc).apply(null,arguments)},a._sodium_pad=function(){return(a._sodium_pad=a.asm.rc).apply(null,arguments)},a._sodium_unpad=function(){return(a._sodium_unpad=a.asm.sc).apply(null,arguments)},a._sodium_version_string=function(){return(a._sodium_version_string=a.asm.tc).apply(null,arguments)},a._sodium_library_version_major=function(){return(a._sodium_library_version_major=a.asm.uc).apply(null,arguments)},a._sodium_library_version_minor=function(){return(a._sodium_library_version_minor=a.asm.vc).apply(null,arguments)},a._sodium_library_minimal=function(){return(a._sodium_library_minimal=a.asm.wc).apply(null,arguments)},a._malloc=function(){return(a._malloc=a.asm.xc).apply(null,arguments)},a._free=function(){return(a._free=a.asm.yc).apply(null,arguments)},a.setValue=function(A,I,g="i8",B){switch("*"===g.charAt(g.length-1)&&(g="i32"),g){case"i1":case"i8":p[A>>0]=I;break;case"i16":F[A>>1]=I;break;case"i32":l[A>>2]=I;break;case"i64":K=[I>>>0,(L=I,+Math.abs(L)>=1?L>0?(0|Math.min(+Math.floor(L/4294967296),4294967295))>>>0:~~+Math.ceil((L-+(~~L>>>0))/4294967296)>>>0:0)],l[A>>2]=K[0],l[A+4>>2]=K[1];break;case"float":_[A>>2]=I;break;case"double":k[A>>3]=I;break;default:d("invalid type for setValue: "+g)}},a.getValue=function(A,I="i8",g){switch("*"===I.charAt(I.length-1)&&(I="i32"),I){case"i1":case"i8":return p[A>>0];case"i16":return F[A>>1];case"i32":case"i64":return l[A>>2];case"float":return _[A>>2];case"double":return Number(k[A>>3]);default:d("invalid type for getValue: "+I)}return null},a.UTF8ToString=U,R=function A(){IA||BA(),IA||(R=A)},a.run=BA,a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();BA()}))};var g,C,Q,E,i,n,a=void 0!==a?a:{},r=Object.assign({},a),o=[],t="object"==typeof window,e="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,c="";f?(c=e?(__webpack_require__(/*! path */ "path").dirname)(c)+"/":__dirname+"/",n=()=>{i||(E=__webpack_require__(/*! fs */ "fs"),i=__webpack_require__(/*! path */ "path"))},g=function(A,I){var g=Z(A);return g?I?g:g.toString():(n(),A=i.normalize(A),E.readFileSync(A,I?void 0:"utf8"))},Q=A=>{var I=g(A,!0);return I.buffer||(I=new Uint8Array(I)),I},C=(A,I,g)=>{var B=Z(A);B&&I(B),n(),A=i.normalize(A),E.readFile(A,(function(A,B){A?g(A):I(B.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),o=process.argv.slice(2), true&&(module.exports=a),a.inspect=function(){return"[Emscripten Module object]"}):(t||e)&&(e?c=self.location.href:"undefined"!=typeof document&&document.currentScript&&(c=document.currentScript.src),c=0!==c.indexOf("blob:")?c.substr(0,c.replace(/[?#].*/,"").lastIndexOf("/")+1):"",g=A=>{try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.send(null),I.responseText}catch(I){var g=Z(A);if(g)return function(A){for(var I=[],g=0;g<A.length;g++){var B=A[g];B>255&&(B&=255),I.push(String.fromCharCode(B))}return I.join("")}(g);throw I}},e&&(Q=A=>{try{var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)}catch(I){var g=Z(A);if(g)return g;throw I}}),C=(A,I,g)=>{var B=new XMLHttpRequest;B.open("GET",A,!0),B.responseType="arraybuffer",B.onload=()=>{if(200==B.status||0==B.status&&B.response)I(B.response);else{var C=Z(A);C?I(C.buffer):g()}},B.onerror=g,B.send(null)}),a.print;var y,s,w=a.printErr||void 0;Object.assign(a,r),r=null,a.arguments&&(o=a.arguments),a.thisProgram&&a.thisProgram,a.quit&&a.quit,a.wasmBinary&&(y=a.wasmBinary),a.noExitRuntime,"object"!=typeof WebAssembly&&N("no native wasm support detected");var D,h,p,u,F,l,_,k=!1,H="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function G(A,I){return A?function(A,I,g){for(var B=I+g,C=I;A[C]&&!(C>=B);)++C;if(C-I>16&&A.subarray&&H)return H.decode(A.subarray(I,C));for(var Q="";I<C;){var E=A[I++];if(128&E){var i=63&A[I++];if(192!=(224&E)){var n=63&A[I++];if((E=224==(240&E)?(15&E)<<12|i<<6|n:(7&E)<<18|i<<12|n<<6|63&A[I++])<65536)Q+=String.fromCharCode(E);else{var a=E-65536;Q+=String.fromCharCode(55296|a>>10,56320|1023&a)}}else Q+=String.fromCharCode((31&E)<<6|i)}else Q+=String.fromCharCode(E)}return Q}(p,A,I):""}function U(A){D=A,a.HEAP8=h=new Int8Array(A),a.HEAP16=u=new Int16Array(A),a.HEAP32=F=new Int32Array(A),a.HEAPU8=p=new Uint8Array(A),a.HEAPU16=new Uint16Array(A),a.HEAPU32=new Uint32Array(A),a.HEAPF32=l=new Float32Array(A),a.HEAPF64=_=new Float64Array(A)}a.INITIAL_MEMORY;var S,b=[],m=[],v=[],M=0,P=null,Y=null;function N(A){throw a.onAbort&&a.onAbort(A),w(A="Aborted("+A+")"),k=!0,A+=". Build with -s ASSERTIONS=1 for more info.",new WebAssembly.RuntimeError(A)}a.preloadedImages={},a.preloadedAudios={};var R,d,J,x,L="data:application/octet-stream;base64,";function K(A){return A.startsWith(L)}function X(A){return A.startsWith("file://")}function T(A){try{if(A==R&&y)return new Uint8Array(y);var I=Z(A);if(I)return I;if(Q)return Q(A);throw"both async and sync fetching of the wasm failed"}catch(A){N(A)}}K(R="data:application/octet-stream;base64,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ASgCPDYCPCABQUBrIQEgAkFAayICIAVNDQALCyACIARPDQEDQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAESQ0ACwwBCyADQQRJBEAgACECDAELIAAgA0EEayIESwRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIgAS0AAjoAAiACIAEtAAM6AAMgAUEEaiEBIAJBBGoiAiAETQ0ACwsgAiADSQRAA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0cNAAsLIAAL7AEBEn8gAigCBCEDIAEoAgQhBCACKAIIIQUgASgCCCEGIAIoAgwhByABKAIMIQggAigCECEJIAEoAhAhCiACKAIUIQsgASgCFCEMIAIoAhghDSABKAIYIQ4gAigCHCEPIAEoAhwhECACKAIgIREgASgCICESIAIoAiQhEyABKAIkIRQgACACKAIAIAEoAgBqNgIAIAAgEyAUajYCJCAAIBEgEmo2AiAgACAPIBBqNgIcIAAgDSAOajYCGCAAIAsgDGo2AhQgACAJIApqNgIQIAAgByAIajYCDCAAIAUgBmo2AgggACADIARqNgIEC0ABA38gACABIAFB+ABqIgIQCiAAQShqIAFBKGoiAyABQdAAaiIEEAogAEHQAGogBCACEAogAEH4AGogASADEAoLGAEBf0GonAIoAgAiAARAIAARDwALEAMAC+wBARJ/IAIoAgQhAyABKAIEIQQgAigCCCEFIAEoAgghBiACKAIMIQcgASgCDCEIIAIoAhAhCSABKAIQIQogAigCFCELIAEoAhQhDCACKAIYIQ0gASgCGCEOIAIoAhwhDyABKAIcIRAgAigCICERIAEoAiAhEiACKAIkIRMgASgCJCEUIAAgASgCACACKAIAazYCACAAIBQgE2s2AiQgACASIBFrNgIgIAAgECAPazYCHCAAIA4gDWs2AhggACAMIAtrNgIUIAAgCiAJazYCECAAIAggB2s2AgwgACAGIAVrNgIIIAAgBCADazYCBAsEAEEgCwoAIAAgASACEDgLzAwBB38CQCAARQ0AIABBCGsiAyAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAMgAygCACIBayIDQaSYAigCAEkNASAAIAFqIQAgA0GomAIoAgBHBEAgAUH/AU0EQCADKAIIIgIgAUEDdiIEQQN0QbyYAmpGGiACIAMoAgwiAUYEQEGUmAJBlJgCKAIAQX4gBHdxNgIADAMLIAIgATYCDCABIAI2AggMAgsgAygCGCEGAkAgAyADKAIMIgFHBEAgAygCCCICIAE2AgwgASACNgIIDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQECQCADIAMoAhwiAkECdEHEmgJqIgQoAgBGBEAgBCABNgIAIAENAUGYmAJBmJgCKAIAQX4gAndxNgIADAMLIAZBEEEUIAYoAhAgA0YbaiABNgIAIAFFDQILIAEgBjYCGCADKAIQIgIEQCABIAI2AhAgAiABNgIYCyADKAIUIgJFDQEgASACNgIUIAIgATYCGAwBCyAFKAIEIgFBA3FBA0cNAEGcmAIgADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAMgBU8NACAFKAIEIgFBAXFFDQACQCABQQJxRQRAIAVBrJgCKAIARgRAQayYAiADNgIAQaCYAkGgmAIoAgAgAGoiADYCACADIABBAXI2AgQgA0GomAIoAgBHDQNBnJgCQQA2AgBBqJgCQQA2AgAPCyAFQaiYAigCAEYEQEGomAIgAzYCAEGcmAJBnJgCKAIAIABqIgA2AgAgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAFBeHEgAGohAAJAIAFB/wFNBEAgBSgCCCICIAFBA3YiBEEDdEG8mAJqRhogAiAFKAIMIgFGBEBBlJgCQZSYAigCAEF+IAR3cTYCAAwCCyACIAE2AgwgASACNgIIDAELIAUoAhghBgJAIAUgBSgCDCIBRwRAIAUoAggiAkGkmAIoAgBJGiACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEHEmgJqIgQoAgBGBEAgBCABNgIAIAENAUGYmAJBmJgCKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQaiYAigCAEcNAUGcmAIgADYCAA8LIAUgAUF+cTYCBCADIABBAXI2AgQgACADaiAANgIACyAAQf8BTQRAIABBA3YiAUEDdEG8mAJqIQACf0GUmAIoAgAiAkEBIAF0IgFxRQRAQZSYAiABIAJyNgIAIAAMAQsgACgCCAshAiAAIAM2AgggAiADNgIMIAMgADYCDCADIAI2AggPC0EfIQIgA0IANwIQIABB////B00EQCAAQQh2IgEgAUGA/j9qQRB2QQhxIgF0IgIgAkGA4B9qQRB2QQRxIgJ0IgQgBEGAgA9qQRB2QQJxIgR0QQ92IAEgAnIgBHJrIgFBAXQgACABQRVqdkEBcXJBHGohAgsgAyACNgIcIAJBAnRBxJoCaiEBAkACQAJAQZiYAigCACIEQQEgAnQiB3FFBEBBmJgCIAQgB3I2AgAgASADNgIAIAMgATYCGAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiABKAIAIQEDQCABIgQoAgRBeHEgAEYNAiACQR12IQEgAkEBdCECIAQgAUEEcWoiB0EQaigCACIBDQALIAcgAzYCECADIAQ2AhgLIAMgAzYCDCADIAM2AggMAQsgBCgCCCIAIAM2AgwgBCADNgIIIANBADYCGCADIAQ2AgwgAyAANgIIC0G0mAJBtJgCKAIAQQFrIgBBfyAAGzYCAAsLOwEBfyAAIAFBKGoiAiABEBIgAEEoaiACIAEQFSAAQdAAaiABQdAAahApIABB+ABqIAFB+ABqQfALEAoLlQEBBH8jAEEwayIFJAAgACABQShqIgMgARASIABBKGoiBCADIAEQFSAAQdAAaiIDIAAgAhAKIAQgBCACQShqEAogAEH4AGoiBiACQfgAaiABQfgAahAKIAAgAUHQAGogAkHQAGoQCiAFIAAgABASIAAgAyAEEBUgBCADIAQQEiADIAUgBhASIAYgBSAGEBUgBUEwaiQAC7kCAgN+An8jAEHABWsiBiQAAkAgAlANACAAIAApA0giBCACQgOGfCIDNwNIIABBQGsiByAHKQMAIAMgBFStfCACQj2IfDcDAEIAIQMgAkKAASAEQgOIQv8AgyIFfSIEVARAA0AgACADIAV8p2ogASADp2otAAA6AFAgA0IBfCIDIAJSDQAMAgsACwNAIAAgAyAFfKdqIAEgA6dqLQAAOgBQIANCAXwiAyAEUg0ACyAAIABB0ABqIAYgBkGABWoiBxBHIAEgBKdqIQEgAiAEfSICQv8AVgRAA0AgACABIAYgBxBHIAFBgAFqIQEgAkKAAX0iAkL/AFYNAAsLIAJQRQRAQgAhAwNAIAAgA6ciB2ogASAHai0AADoAUCADQgF8IgMgAlINAAsLIAZBwAUQCAsgBkHABWokAEEACxUAIABBATYCACAAQQRqQQBBJBAPGgsiAQF/IAEEQANAIAAgAmoQWzoAACACQQFqIgIgAUcNAAsLCwQAQRALhy4BC38jAEEQayILJAACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBBlJgCKAIAIgRBECAAQQtqQXhxIABBC0kbIgZBA3YiAHYiAUEDcQRAIAFBf3NBAXEgAGoiAkEDdCIFQcSYAmooAgAiAUEIaiEAAkAgASgCCCIDIAVBvJgCaiIFRgRAQZSYAiAEQX4gAndxNgIADAELIAMgBTYCDCAFIAM2AggLIAEgAkEDdCICQQNyNgIEIAEgAmoiASABKAIEQQFyNgIEDAwLIAZBnJgCKAIAIghNDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxIgBBACAAa3FBAWsiACAAQQx2QRBxIgB2IgFBBXZBCHEiAiAAciABIAJ2IgBBAnZBBHEiAXIgACABdiIAQQF2QQJxIgFyIAAgAXYiAEEBdkEBcSIBciAAIAF2aiICQQN0IgNBxJgCaigCACIBKAIIIgAgA0G8mAJqIgNGBEBBlJgCIARBfiACd3EiBDYCAAwBCyAAIAM2AgwgAyAANgIICyABQQhqIQAgASAGQQNyNgIEIAEgBmoiByACQQN0IgIgBmsiA0EBcjYCBCABIAJqIAM2AgAgCARAIAhBA3YiBUEDdEG8mAJqIQFBqJgCKAIAIQICfyAEQQEgBXQiBXFFBEBBlJgCIAQgBXI2AgAgAQwBCyABKAIICyEFIAEgAjYCCCAFIAI2AgwgAiABNgIMIAIgBTYCCAtBqJgCIAc2AgBBnJgCIAM2AgAMDAtBmJgCKAIAIgpFDQEgCkEAIAprcUEBayIAIABBDHZBEHEiAHYiAUEFdkEIcSICIAByIAEgAnYiAEECdkEEcSIBciAAIAF2IgBBAXZBAnEiAXIgACABdiIAQQF2QQFxIgFyIAAgAXZqQQJ0QcSaAmooAgAiASgCBEF4cSAGayEFIAEhAgNAAkAgAigCECIARQRAIAIoAhQiAEUNAQsgACgCBEF4cSAGayICIAUgAiAFSSICGyEFIAAgASACGyEBIAAhAgwBCwsgASgCGCEJIAEgASgCDCIDRwRAIAEoAggiAEGkmAIoAgBJGiAAIAM2AgwgAyAANgIIDAsLIAFBFGoiAigCACIARQRAIAEoAhAiAEUNAyABQRBqIQILA0AgAiEHIAAiA0EUaiICKAIAIgANACADQRBqIQIgAygCECIADQALIAdBADYCAAwKC0F/IQYgAEG/f0sNACAAQQtqIgBBeHEhBkGYmAIoAgAiB0UNAEEAIAZrIQUCQAJAAkACf0EAIAZBgAJJDQAaQR8gBkH///8HSw0AGiAAQQh2IgAgAEGA/j9qQRB2QQhxIgB0IgEgAUGA4B9qQRB2QQRxIgF0IgIgAkGAgA9qQRB2QQJxIgJ0QQ92IAAgAXIgAnJrIgBBAXQgBiAAQRVqdkEBcXJBHGoLIghBAnRBxJoCaigCACICRQRAQQAhAAwBC0EAIQAgBkEAQRkgCEEBdmsgCEEfRht0IQEDQAJAIAIoAgRBeHEiCSAGayIEIAVPDQAgBCEFIAIhAyAGIAlHDQBBACEFIAIhAAwDCyAAIAIoAhQiBCAEIAIgAUEddkEEcWooAhAiAkYbIAAgBBshACABQQF0IQEgAg0ACwsgACADckUEQEEAIQNBAiAIdCIAQQAgAGtyIAdxIgBFDQMgAEEAIABrcUEBayIAIABBDHZBEHEiAHYiAUEFdkEIcSICIAByIAEgAnYiAEECdkEEcSIBciAAIAF2IgBBAXZBAnEiAXIgACABdiIAQQF2QQFxIgFyIAAgAXZqQQJ0QcSaAmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAZrIgIgBUkhASACIAUgARshBSAAIAMgARshAyAAKAIQIgEEfyABBSAAKAIUCyIADQALCyADRQ0AIAVBnJgCKAIAIAZrTw0AIAMoAhghCCADIAMoAgwiAUcEQCADKAIIIgBBpJgCKAIASRogACABNgIMIAEgADYCCAwJCyADQRRqIgIoAgAiAEUEQCADKAIQIgBFDQMgA0EQaiECCwNAIAIhBCAAIgFBFGoiAigCACIADQAgAUEQaiECIAEoAhAiAA0ACyAEQQA2AgAMCAsgBkGcmAIoAgAiAU0EQEGomAIoAgAhAAJAIAEgBmsiAkEQTwRAQZyYAiACNgIAQaiYAiAAIAZqIgM2AgAgAyACQQFyNgIEIAAgAWogAjYCACAAIAZBA3I2AgQMAQtBqJgCQQA2AgBBnJgCQQA2AgAgACABQQNyNgIEIAAgAWoiASABKAIEQQFyNgIECyAAQQhqIQAMCgsgBkGgmAIoAgAiAUkEQEGgmAIgASAGayIBNgIAQayYAkGsmAIoAgAiACAGaiICNgIAIAIgAUEBcjYCBCAAIAZBA3I2AgQgAEEIaiEADAoLQQAhACAGQS9qIgUCf0HsmwIoAgAEQEH0mwIoAgAMAQtB+JsCQn83AgBB8JsCQoCggICAgAQ3AgBB7JsCIAtBDGpBcHFB2KrVqgVzNgIAQYCcAkEANgIAQdCbAkEANgIAQYAgCyICaiIEQQAgAmsiB3EiAiAGTQ0JQcybAigCACIDBEBBxJsCKAIAIgggAmoiCSAITSADIAlJcg0KC0HQmwItAABBBHENBAJAAkBBrJgCKAIAIgMEQEHUmwIhAANAIAMgACgCACIITwRAIAggACgCBGogA0sNAwsgACgCCCIADQALC0EAECoiAUF/Rg0FIAIhBEHwmwIoAgAiAEEBayIDIAFxBEAgAiABayABIANqQQAgAGtxaiEECyAEIAZNIARB/v///wdLcg0FQcybAigCACIABEBBxJsCKAIAIgMgBGoiByADTSAAIAdJcg0GCyAEECoiACABRw0BDAcLIAQgAWsgB3EiBEH+////B0sNBCAEECoiASAAKAIAIAAoAgRqRg0DIAEhAAsgAEF/RiAGQTBqIARNckUEQEH0mwIoAgAiASAFIARrakEAIAFrcSIBQf7///8HSwRAIAAhAQwHCyABECpBf0cEQCABIARqIQQgACEBDAcLQQAgBGsQKhoMBAsgACIBQX9HDQUMAwtBACEDDAcLQQAhAQwFCyABQX9HDQILQdCbAkHQmwIoAgBBBHI2AgALIAJB/v///wdLDQEgAhAqIgFBf0ZBABAqIgBBf0ZyIAAgAU1yDQEgACABayIEIAZBKGpNDQELQcSbAkHEmwIoAgAgBGoiADYCAEHImwIoAgAgAEkEQEHImwIgADYCAAsCQAJAAkBBrJgCKAIAIgMEQEHUmwIhAANAIAEgACgCACICIAAoAgQiBWpGDQIgACgCCCIADQALDAILQaSYAigCACIAQQAgACABTRtFBEBBpJgCIAE2AgALQQAhAEHYmwIgBDYCAEHUmwIgATYCAEG0mAJBfzYCAEG4mAJB7JsCKAIANgIAQeCbAkEANgIAA0AgAEEDdCICQcSYAmogAkG8mAJqIgM2AgAgAkHImAJqIAM2AgAgAEEBaiIAQSBHDQALQaCYAiAEQShrIgBBeCABa0EHcUEAIAFBCGpBB3EbIgJrIgM2AgBBrJgCIAEgAmoiAjYCACACIANBAXI2AgQgACABakEoNgIEQbCYAkH8mwIoAgA2AgAMAgsgAC0ADEEIcSACIANLciABIANNcg0AIAAgBCAFajYCBEGsmAIgA0F4IANrQQdxQQAgA0EIakEHcRsiAGoiATYCAEGgmAJBoJgCKAIAIARqIgIgAGsiADYCACABIABBAXI2AgQgAiADakEoNgIEQbCYAkH8mwIoAgA2AgAMAQtBpJgCKAIAIAFLBEBBpJgCIAE2AgALIAEgBGohAkHUmwIhAAJAAkACQAJAAkACQANAIAIgACgCAEcEQCAAKAIIIgANAQwCCwsgAC0ADEEIcUUNAQtB1JsCIQADQCADIAAoAgAiAk8EQCACIAAoAgRqIgUgA0sNAwsgACgCCCEADAALAAsgACABNgIAIAAgACgCBCAEajYCBCABQXggAWtBB3FBACABQQhqQQdxG2oiCCAGQQNyNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIEIAYgCGoiB2shBiADIARGBEBBrJgCIAc2AgBBoJgCQaCYAigCACAGaiIANgIAIAcgAEEBcjYCBAwDCyAEQaiYAigCAEYEQEGomAIgBzYCAEGcmAJBnJgCKAIAIAZqIgA2AgAgByAAQQFyNgIEIAAgB2ogADYCAAwDCyAEKAIEIgBBA3FBAUYEQCAAQXhxIQkCQCAAQf8BTQRAIAQoAggiASAAQQN2IgJBA3RBvJgCakYaIAEgBCgCDCIARgRAQZSYAkGUmAIoAgBBfiACd3E2AgAMAgsgASAANgIMIAAgATYCCAwBCyAEKAIYIQMCQCAEIAQoAgwiAUcEQCAEKAIIIgAgATYCDCABIAA2AggMAQsCQCAEQRRqIgAoAgAiBQ0AIARBEGoiACgCACIFDQBBACEBDAELA0AgACECIAUiAUEUaiIAKAIAIgUNACABQRBqIQAgASgCECIFDQALIAJBADYCAAsgA0UNAAJAIAQgBCgCHCIAQQJ0QcSaAmoiAigCAEYEQCACIAE2AgAgAQ0BQZiYAkGYmAIoAgBBfiAAd3E2AgAMAgsgA0EQQRQgAygCECAERhtqIAE2AgAgAUUNAQsgASADNgIYIAQoAhAiAARAIAEgADYCECAAIAE2AhgLIAQoAhQiAEUNACABIAA2AhQgACABNgIYCyAGIAlqIQYgBCAJaiEECyAEIAQoAgRBfnE2AgQgByAGQQFyNgIEIAYgB2ogBjYCACAGQf8BTQRAIAZBA3YiAUEDdEG8mAJqIQACf0GUmAIoAgAiAkEBIAF0IgFxRQRAQZSYAiABIAJyNgIAIAAMAQsgACgCCAshASAAIAc2AgggASAHNgIMIAcgADYCDCAHIAE2AggMAwtBHyEAIAZB////B00EQCAGQQh2IgAgAEGA/j9qQRB2QQhxIgB0IgEgAUGA4B9qQRB2QQRxIgF0IgIgAkGAgA9qQRB2QQJxIgJ0QQ92IAAgAXIgAnJrIgBBAXQgBiAAQRVqdkEBcXJBHGohAAsgByAANgIcIAdCADcCECAAQQJ0QcSaAmohAQJAQZiYAigCACICQQEgAHQiA3FFBEBBmJgCIAIgA3I2AgAgASAHNgIAIAcgATYCGAwBCyAGQQBBGSAAQQF2ayAAQR9GG3QhACABKAIAIQEDQCABIgIoAgRBeHEgBkYNAyAAQR12IQEgAEEBdCEAIAIgAUEEcWoiAygCECIBDQALIAMgBzYCECAHIAI2AhgLIAcgBzYCDCAHIAc2AggMAgtBoJgCIARBKGsiAEF4IAFrQQdxQQAgAUEIakEHcRsiAmsiBzYCAEGsmAIgASACaiICNgIAIAIgB0EBcjYCBCAAIAFqQSg2AgRBsJgCQfybAigCADYCACADIAVBJyAFa0EHcUEAIAVBJ2tBB3EbakEvayIAIAAgA0EQakkbIgJBGzYCBCACQdybAikCADcCECACQdSbAikCADcCCEHcmwIgAkEIajYCAEHYmwIgBDYCAEHUmwIgATYCAEHgmwJBADYCACACQRhqIQADQCAAQQc2AgQgAEEIaiEBIABBBGohACABIAVJDQALIAIgA0YNAyACIAIoAgRBfnE2AgQgAyACIANrIgVBAXI2AgQgAiAFNgIAIAVB/wFNBEAgBUEDdiIBQQN0QbyYAmohAAJ/QZSYAigCACICQQEgAXQiAXFFBEBBlJgCIAEgAnI2AgAgAAwBCyAAKAIICyEBIAAgAzYCCCABIAM2AgwgAyAANgIMIAMgATYCCAwEC0EfIQAgA0IANwIQIAVB////B00EQCAFQQh2IgAgAEGA/j9qQRB2QQhxIgB0IgEgAUGA4B9qQRB2QQRxIgF0IgIgAkGAgA9qQRB2QQJxIgJ0QQ92IAAgAXIgAnJrIgBBAXQgBSAAQRVqdkEBcXJBHGohAAsgAyAANgIcIABBAnRBxJoCaiEBAkBBmJgCKAIAIgJBASAAdCIEcUUEQEGYmAIgAiAEcjYCACABIAM2AgAgAyABNgIYDAELIAVBAEEZIABBAXZrIABBH0YbdCEAIAEoAgAhAQNAIAEiAigCBEF4cSAFRg0EIABBHXYhASAAQQF0IQAgAiABQQRxaiIEKAIQIgENAAsgBCADNgIQIAMgAjYCGAsgAyADNgIMIAMgAzYCCAwDCyACKAIIIgAgBzYCDCACIAc2AgggB0EANgIYIAcgAjYCDCAHIAA2AggLIAhBCGohAAwFCyACKAIIIgAgAzYCDCACIAM2AgggA0EANgIYIAMgAjYCDCADIAA2AggLQaCYAigCACIAIAZNDQBBoJgCIAAgBmsiATYCAEGsmAJBrJgCKAIAIgAgBmoiAjYCACACIAFBAXI2AgQgACAGQQNyNgIEIABBCGohAAwDC0HglwJBMDYCAEEAIQAMAgsCQCAIRQ0AAkAgAygCHCIAQQJ0QcSaAmoiAigCACADRgRAIAIgATYCACABDQFBmJgCIAdBfiAAd3EiBzYCAAwCCyAIQRBBFCAIKAIQIANGG2ogATYCACABRQ0BCyABIAg2AhggAygCECIABEAgASAANgIQIAAgATYCGAsgAygCFCIARQ0AIAEgADYCFCAAIAE2AhgLAkAgBUEPTQRAIAMgBSAGaiIAQQNyNgIEIAAgA2oiACAAKAIEQQFyNgIEDAELIAMgBkEDcjYCBCADIAZqIgQgBUEBcjYCBCAEIAVqIAU2AgAgBUH/AU0EQCAFQQN2IgFBA3RBvJgCaiEAAn9BlJgCKAIAIgJBASABdCIBcUUEQEGUmAIgASACcjYCACAADAELIAAoAggLIQEgACAENgIIIAEgBDYCDCAEIAA2AgwgBCABNgIIDAELQR8hACAFQf///wdNBEAgBUEIdiIAIABBgP4/akEQdkEIcSIAdCIBIAFBgOAfakEQdkEEcSIBdCICIAJBgIAPakEQdkECcSICdEEPdiAAIAFyIAJyayIAQQF0IAUgAEEVanZBAXFyQRxqIQALIAQgADYCHCAEQgA3AhAgAEECdEHEmgJqIQECQAJAIAdBASAAdCICcUUEQEGYmAIgAiAHcjYCACABIAQ2AgAMAQsgBUEAQRkgAEEBdmsgAEEfRht0IQAgASgCACECA0AgAiIBKAIEQXhxIAVGDQIgAEEddiECIABBAXQhACABIAJBBHFqIgcoAhAiAg0ACyAHIAQ2AhALIAQgATYCGCAEIAQ2AgwgBCAENgIIDAELIAEoAggiACAENgIMIAEgBDYCCCAEQQA2AhggBCABNgIMIAQgADYCCAsgA0EIaiEADAELAkAgCUUNAAJAIAEoAhwiAEECdEHEmgJqIgIoAgAgAUYEQCACIAM2AgAgAw0BQZiYAiAKQX4gAHdxNgIADAILIAlBEEEUIAkoAhAgAUYbaiADNgIAIANFDQELIAMgCTYCGCABKAIQIgAEQCADIAA2AhAgACADNgIYCyABKAIUIgBFDQAgAyAANgIUIAAgAzYCGAsCQCAFQQ9NBEAgASAFIAZqIgBBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQMAQsgASAGQQNyNgIEIAEgBmoiAyAFQQFyNgIEIAMgBWogBTYCACAIBEAgCEEDdiIHQQN0QbyYAmohAEGomAIoAgAhAgJ/QQEgB3QiByAEcUUEQEGUmAIgBCAHcjYCACAADAELIAAoAggLIQQgACACNgIIIAQgAjYCDCACIAA2AgwgAiAENgIIC0GomAIgAzYCAEGcmAIgBTYCAAsgAUEIaiEACyALQRBqJAAgAAtlAQN/IAJFBEBBAA8LAkAgAC0AACIDRQ0AA0ACQCABLQAAIgVFDQAgAkEBayICRSADIAVHcg0AIAFBAWohASAALQABIQMgAEEBaiEAIAMNAQwCCwsgAyEECyAEQf8BcSABLQAAawt/AQN/IAAhAQJAIABBA3EEQANAIAEtAABFDQIgAUEBaiIBQQNxDQALCwNAIAEiAkEEaiEBIAIoAgAiA0F/cyADQYGChAhrcUGAgYKEeHFFDQALIANB/wFxRQRAIAIgAGsPCwNAIAItAAEhAyACQQFqIgEhAiADDQALCyABIABrCygAIAAgASACEFUgAEEoaiABQShqIAIQVSAAQdAAaiABQdAAaiACEFULEQAgACABQdSRAigCABEDABoLEQAgACABQcyRAigCABEDABoLCgAgACABIAIQFwsRACAAIAFzQf8BcUEBa0EfdguwAQEDfyMAQcAFayICJAACQCAAKAJIQQN2Qf8AcSIDQe8ATQRAIAAgA2pB0ABqQeCPAkHwACADaxARGgwBCyAAQdAAaiIEIANqQeCPAkGAASADaxARGiAAIAQgAiACQYAFahBHIARBAEHwABAPGgsgAEHAAWogAEFAa0EQEKUBIAAgAEHQAGogAiACQYAFahBHIAEgAEHAABClASACQcAFEAggAEHQARAIIAJBwAVqJAALCAAgAEEgEB0LRgEEfiABKQIIIQIgASkCECEDIAEpAhghBCABKQIAIQUgACABKQIgNwIgIAAgBDcCGCAAIAM3AhAgACACNwIIIAAgBTcCAAtSAQJ/QbCRAigCACIBIABBA2pBfHEiAmohAAJAIAJBACAAIAFNGw0AIAA/AEEQdEsEQCAAEAJFDQELQbCRAiAANgIAIAEPC0HglwJBMDYCAEF/CwwAIAAgAUGACBARGgv6BQEKfyMAQTBrIgIkACACIAEoAiAiAyABKAIcIgQgASgCGCIFIAEoAhQiBiABKAIQIgcgASgCDCIIIAEoAggiCSABKAIEIgogASgCACILIAEoAiQiAUETbEGAgIAIakEZdmpBGnVqQRl1akEadWpBGXVqQRp1akEZdWpBGnVqQRl1akEadSABakEZdUETbCALaiILQf///x9xNgIAIAIgCiALQRp1aiIKQf///w9xNgIEIAIgCSAKQRl1aiIJQf///x9xNgIIIAIgCCAJQRp1aiIIQf///w9xNgIMIAIgByAIQRl1aiIHQf///x9xNgIQIAIgBiAHQRp1aiIGQf///w9xNgIUIAIgBSAGQRl1aiIFQf///x9xNgIYIAIgBCAFQRp1aiIEQf///w9xNgIcIAIgAyAEQRl1aiID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IABBPGoiASAcKAIUEAkgAEFAayABQgQQFxogHCgCECIBBEAgAEFAayABIBw1AhQQFxoLIABBPGoiASAcKAIcEAkgAEFAayABQgQQFxoCQCAcKAIYIgFFDQAgAEFAayABIBw1AhwQFxogHC0AOEECcUUNACAcKAIYIBwoAhwQCCAcQQA2AhwLIABBPGoiASAcKAIkEAkgAEFAayABQgQQFxogHCgCICIBBEAgAEFAayABIBw1AiQQFxoLIABBQGsgBEHAABBMGgsgBiQAIARBQGtBCBAIQQAhAyMAQYAIayIAJAAgAigCHARAIARBxABqIQUgBEFAayEBA0AgAUEAEAkgBSADEAkgAEGACCAEQcgAEFogAigCACgCBCACKAIYIANsQQp0aiAAEIgBIAFBARAJIABBgAggBEHIABBaIAIoAgAoAgQgAigCGCADbEEKdGpBgAhqIAAQiAEgA0EBaiIDIAIoAhxJDQALCyAAQYAIEAggAEGACGokACAEQcgAEAhBACEDCyAEQdAAaiQAIAMiAA0AIAIoAggEQANAQQAhICMAQSBrIgMkAAJAIAJFDQAgAigCHEUNACADICU2AhBBASEBA0AgAyAgOgAYQQAhHkEAIQAgAQRAA0AgA0EANgIcIAMgAykDGDcDCCADIB42AhQgAyADKQMQNwMAQQAhAQJAIAJFDQACfwJAIAIoAiRBAkcEQCACKAIEIR8MAQsgAigCBCEfQQEgAygCACIFIAMtAAgiBEEBS3INARoLIwBBgCBrIgAkACAAQYAYahA+IABBgBBqED4CQCACRSADRXINACAAIAM1AgA3A4AQIAAgAzUCBDcDiBAgACADMQAINwOQECAAIAI1AhA3A5gQIAAgAjUCCDcDoBAgACACNQIkNwOoECACKAIURQ0AA0AgAUH/AHEiBEUEQCAAIAApA7AQQgF8NwOwECAAED4gAEGACGoiBRA+IABBgBhqIgYgAEGAEGogABBZIAYgACAFEFkLIB8gAUEDdGogAEGACGogBEEDdGopAwA3AwAgAUEBaiIBIAIoAhRJDQALCyAAQYAgaiQAIAMtAAghBCADKAIAIQVBAAshJkEAIARB/wFxIgFFQQF0IAUbIgUgAigCFCIETw0AQX8gAigCGCIAQQFrIAUgACADKAIEbGogASAEbGoiBCAAcBsgBGohAQNAIARB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AWsgHCgCACAcKAIEQQMQaBshAQwBC0FhIQELIABBEGokACABRQ0AICIgCBAIIAkgChAIQWEhAgwBCyAHBEAgByAiIAgQERoLICIgCBAIQQAhAgsgIhAYCyAcQUBrJAAgAgsrAQF/IwBB0AFrIgMkACADEDYgAyABIAIQGxogAyAAECcgA0HQAWokAEEACxwAIABCADcDQCAAQgA3A0ggAEGgigJBwAAQERoLBABBbwvBAQIFfwF+IAJQRQRAIAJBgAIgACgA4AIiBGsiA60iCFYEQCAAQeABaiEGIABB4ABqIQUDQCAAIARqQeAAaiABIAMQERogACAAKADgAiADajYA4AIgAEKAARBxIAAgBRB0IAUgBkGAARARGiAAIAAoAOACIgdBgAFrIgQ2AOACIAEgA2ohASACIAh9IgJBgAMgB2siA60iCFYNAAsLIAAgBGpB4ABqIAEgAqciARARGiAAIAAoAOACIAFqNgDgAgtBAAupAwEVfyABKAIEIQsgACgCBCEMIAEoAgghDSAAKAIIIQ4gASgCDCEPIAAoAgwhAyABKAIQIRAgACgCECEEIAEoAhQhESAAKAIUIQUgASgCGCESIAAoAhghBiABKAIcIRMgACgCHCEHIAEoAiAhFCAAKAIgIQggASgCJCEVIAAoAiQhCSAAQQAgAmsiAiABKAIAIhYgACgCACIKc3EiFyAKczYCACAAIAkgCSAVcyACcSIKczYCJCAAIAggCCAUcyACcSIJczYCICAAIAcgByATcyACcSIIczYCHCAAIAYgBiAScyACcSIHczYCGCAAIAUgBSARcyACcSIGczYCFCAAIAQgBCAQcyACcSIFczYCECAAIAMgAyAPcyACcSIEczYCDCAAIA4gDSAOcyACcSIDczYCCCAAIAwgCyAMcyACcSIAczYCBCABIAogFXM2AiQgASAJIBRzNgIgIAEgCCATczYCHCABIAcgEnM2AhggASAGIBFzNgIUIAEgBSAQczYCECABIAQgD3M2AgwgASADIA1zNgIIIAEgACALczYCBCABIBYgF3M2AgALQQECfyMAQYABayIDJAAgA0EIaiICIAEQKSACQShqIAFBKGoQKSACQdAAaiABQdAAahApIAAgAhAxIANBgAFqJAALMgEBfyAAIAEgAUH4AGoiAhAKIABBKGogAUEoaiABQdAAaiIBEAogAEHQAGogASACEAoL4AMBA38jAEHAAWsiAiQAIAJBkAFqIgQgARANIAJB4ABqIgMgBBANIAMgAxANIAMgASADEAogBCAEIAMQCiACQTBqIgEgBBANIAMgAyABEAogASADEA1BASEBA0AgAkEwaiIDIAMQDSABQQFqIgFBBUcNAAsgAkHgAGoiASACQTBqIgMgARAKIAMgARANQQEhAQNAIAJBMGoiAyADEA0gAUEBaiIBQQpHDQALIAJBMGoiASABIAJB4ABqEAogAiABEA1BASEBA0AgAiACEA0gAUEBaiIBQRRHDQALIAJBMGoiASACIAEQCkEBIQEDQCACQTBqIgMgAxANIAFBAWoiAUELRw0ACyACQeAAaiIBIAJBMGoiAyABEAogAyABEA1BASEBA0AgAkEwaiIDIAMQDSABQQFqIgFBMkcNAAsgAkEwaiIBIAEgAkHgAGoQCiACIAEQDUEBIQEDQCACIAIQDSABQQFqIgFB5ABHDQALIAJBMGoiASACIAEQCkEBIQEDQCACQTBqIgMgAxANIAFBAWoiAUEzRw0ACyACQeAAaiIBIAJBMGogARAKQQEhAQNAIAJB4ABqIgMgAxANIAFBAWoiAUEGRw0ACyAAIAJB4ABqIAJBkAFqEAogAkHAAWokAAsLACAAIAFBEBCHAQsMACAAQQBBgAgQDxoLZgEFfyMAQRBrIgMkAEEKIQIDQAJAIAIiBEEBayICIANBBmpqIgUgASABQQpuIgZBCmxrQTByOgAAIAFBCkkNACAGIQEgAg0BCwsgACAFQQsgBGsiABARIABqQQA6AAAgA0EQaiQAC40BAQZ/AkAgAC0AACIGQTprQf8BcUH2AUkNACAGIQMgACECA0AgAiEHIARBmbPmzAFLDQEgA0H/AXFBMGsiAiAEQQpsIgNBf3NLDQEgAiADaiEEIAdBAWoiAi0AACIDQTprQf8BcUH1AUsNAAsgBkEwRiAAIAdHcSAAIAJGcg0AIAEgBDYCACACIQULIAULCgAgACABIAIQTAsMACAAIAEgAiADEE0L0gkBMX8jAEFAaiIcJAAgACgCPCEdIAAoAjghHiAAKAI0IRMgACgCMCEQIAAoAiwhHyAAKAIoISAgACgCJCEhIAAoAiAhIiAAKAIcISMgACgCGCEkIAAoAhQhJSAAKAIQISYgACgCDCEnIAAoAgghKCAAKAIEISkgACgCACEqA0ACQCADQj9WBEAgAiEEDAELQQAhBSAcQQBBwAAQDyEEIANQRQRAA0AgBCAFaiABIAVqLQAAOgAAIAMgBUEBaiIFrVYNAAsLIAQhASACISsLQRQhFSAqIQ0gKSEUICghESAnIQ4gJiEFICUhCSAkIQIgIyEPICIhCyAhIQogICEYIB0hEiAeIQcgEyEIIBAhBiAfIQwDQCAFIAsgBSANaiINIAZzQRAQByIFaiIGc0EMEAchCyALIAUgCyANaiINc0EIEAciGSAGaiIac0EHEAchFiAKIAkgFGoiCyAIc0EQEAciCGoiBiAJc0EMEAchCiAKIAggCiALaiIUc0EIEAciCyAGaiIbc0EHEAchCSACIAcgAiARaiIHc0EQEAciCCAYaiIGc0EMEAchAiACIAggAiAHaiIKc0EIEAciBSAGaiIHc0EHEAchFyAMIA4gD2oiBiASc0EQEAciAmoiDCAPc0EMEAchEiASIAwgAiAGIBJqIg5zQQgQByICaiIIc0EHEAchESAJIAIgCSANaiIGc0EQEAciDCAHaiICc0EMEAchByAHIAwgBiAHaiINc0EIEAciEiACaiIYc0EHEAchCSAXIBkgFCAXaiIGc0EQEAciDCAIaiICc0EMEAchCCAIIAwgBiAIaiIUc0EIEAciBiACaiIMc0EHEAchAiARIAsgCiARaiIKc0EQEAciCCAaaiIHc0EMEAchDyAPIAcgCCAKIA9qIhFzQQgQByIIaiILc0EHEAchDyAWIAUgDiAWaiIOc0EQEAciByAbaiIKc0EMEAchBSAFIAogByAFIA5qIg5zQQgQByIHaiIKc0EHEAchBSAVQQJrIhUNAAsgASgABCEsIAEoAAghLSABKAAMIS4gASgAECEvIAEoABQhMCABKAAYITEgASgAHCEyIAEoACAhMyABKAAkITQgASgAKCEVIAEoACwhFiABKAAwIRcgASgANCEZIAEoADghGiABKAA8IRsgBCABKAAAIA0gKmpzEAkgBEEEaiAsIBQgKWpzEAkgBEEIaiAtIBEgKGpzEAkgBEEMaiAuIA4gJ2pzEAkgBEEQaiAvIAUgJmpzEAkgBEEUaiAwIAkgJWpzEAkgBEEYaiAxIAIgJGpzEAkgBEEcaiAyIA8gI2pzEAkgBEEgaiAzIAsgImpzEAkgBEEkaiA0IAogIWpzEAkgBEEoaiAVIBggIGpzEAkgBEEsaiAWIAwgH2pzEAkgBEEwaiAXIAYgEGpzEAkgBEE0aiAZIAggE2pzEAkgBEE4aiAaIAcgHmpzEAkgBEE8aiAbIBIgHWpzEAkgEyAQIBBBAWoiEEtqIRMgA0LAAFgEQAJAIANCP1YNACADpyIBRQ0AQQAhCQNAIAkgK2ogBCAJai0AADoAACAJQQFqIgkgAUcNAAsLIAAgEzYCNCAAIBA2AjAgHEFAayQABSABQUBrIQEgBEFAayECIANCQHwhAwwBCwsL7wEBAn8CfwJAIAFB/wFxIgMEQCAAQQNxBEADQCAALQAAIgJFIAIgAUH/AXFGcg0DIABBAWoiAEEDcQ0ACwsCQCAAKAIAIgJBf3MgAkGBgoQIa3FBgIGChHhxDQAgA0GBgoQIbCEDA0AgAiADcyICQX9zIAJBgYKECGtxQYCBgoR4cQ0BIAAoAgQhAiAAQQRqIQAgAkGBgoQIayACQX9zcUGAgYKEeHFFDQALCwNAIAAiAi0AACIDBEAgAkEBaiEAIAMgAUH/AXFHDQELCyACDAILIAAQISAAagwBCyAACyIAQQAgAC0AACABQf8BcUYbC3EAIABC5fDBi+aNmZAzNwIAIABCstqIy8eumZDrADcCCCAAIAEoAAA2AhAgACABKAAENgIUIAAgASgACDYCGCAAIAEoAAw2AhwgACABKAAQNgIgIAAgASgAFDYCJCAAIAEoABg2AiggACABKAAcNgIsC+gCAQJ/AkAgACABRg0AIAEgACACaiIEa0EAIAJBAXRrTQRAIAAgASACEBEPCyAAIAFzQQNxIQMCQAJAIAAgAUkEQCADBEAgACEDDAMLIABBA3FFBEAgACEDDAILIAAhAwNAIAJFDQQgAyABLQAAOgAAIAFBAWohASACQQFrIQIgA0EBaiIDQQNxDQALDAELAkAgAw0AIARBA3EEQANAIAJFDQUgACACQQFrIgJqIgMgASACai0AADoAACADQQNxDQALCyACQQNNDQADQCAAIAJBBGsiAmogASACaigCADYCACACQQNLDQALCyACRQ0CA0AgACACQQFrIgJqIAEgAmotAAA6AAAgAg0ACwwCCyACQQNNDQADQCADIAEoAgA2AgAgAUEEaiEBIANBBGohAyACQQRrIgJBA0sNAAsLIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQQFrIgINAAsLIAALiRgCEH4SfwNAIAIgFUEDdCIUaiABIBRqKQAAIgRCOIYgBEIohkKAgICAgIDA/wCDhCAEQhiGQoCAgICA4D+DIARCCIZCgICAgPAfg4SEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISENwMAIBVBAWoiFUEQRw0ACyADIABBwAAQESEBA0AgASACIBZBA3QiA2oiFSkDACABKQMgIgpBDhAFIApBEhAFhSAKQSkQBYV8IANB4IoCaikDAHwgCiABKQMwIgcgASkDKCILhYMgB4V8IAEpAzh8IgQgASkDGHwiCDcDGCABIAEpAwAiBUEcEAUgBUEiEAWFIAVBJxAFhSAEfCABKQMQIgkgASkDCCIGhCAFgyAGIAmDhHwiBDcDOCABIAkgByALIAggCiALhYOFfCAIQQ4QBSAIQRIQBYUgCEEpEAWFfCACIANBCHIiFGoiGCkDAHwgFEHgigJqKQMAfCIHfCIJNwMQIAEgByAEIAUgBoSDIAUgBoOEfCAEQRwQBSAEQSIQBYUgBEEnEAWFfCIHNwMwIAEgBiALIAogCSAIIAqFg4V8IAlBDhAFIAlBEhAFhSAJQSkQBYV8IAIgA0EQciIUaiIZKQMAfCAUQeCKAmopAwB8Igx8Igs3AwggASAMIAcgBCAFhIMgBCAFg4R8IAdBHBAFIAdBIhAFhSAHQScQBYV8IgY3AyggASAFIAogCyAIIAmFgyAIhXwgC0EOEAUgC0ESEAWFIAtBKRAFhXwgAiADQRhyIhRqIhopAwB8IBRB4IoCaikDAHwiDHwiCjcDACABIAwgBiAEIAeEgyAEIAeDhHwgBkEcEAUgBkEiEAWFIAZBJxAFhXwiBTcDICABIAQgCiAJIAuFgyAJhSAIfCAKQQ4QBSAKQRIQBYUgCkEpEAWFfCACIANBIHIiFGoiGykDAHwgFEHgigJqKQMAfCIMfCIINwM4IAEgDCAFIAYgB4SDIAYgB4OEfCAFQRwQBSAFQSIQBYUgBUEnEAWFfCIENwMYIAEgByAIIAogC4WDIAuFIAl8IAhBDhAFIAhBEhAFhSAIQSkQBYV8IAIgA0EociIUaiIcKQMAfCAUQeCKAmopAwB8Igx8Igk3AzAgASAMIAQgBSAGhIMgBSAGg4R8IARBHBAFIARBIhAFhSAEQScQBYV8Igc3AxAgASAGIAkgCCAKhYMgCoUgC3wgCUEOEAUgCUESEAWFIAlBKRAFhXwgAiADQTByIhRqIh0pAwB8IBRB4IoCaikDAHwiDHwiCzcDKCABIAwgByAEIAWEgyAEIAWDhHwgB0EcEAUgB0EiEAWFIAdBJxAFhXwiBjcDCCABIAUgCyAIIAmFgyAIhSAKfCALQQ4QBSALQRIQBYUgC0EpEAWFfCACIANBOHIiFGoiHikDAHwgFEHgigJqKQMAfCIMfCIKNwMgIAEgDCAGIAQgB4SDIAQgB4OEfCAGQRwQBSAGQSIQBYUgBkEnEAWFfCIFNwMAIAEgBCAKIAkgC4WDIAmFIAh8IApBDhAFIApBEhAFhSAKQSkQBYV8IAIgA0HAAHIiFGoiHykDAHwgFEHgigJqKQMAfCIMfCIINwMYIAEgDCAFIAYgB4SDIAYgB4OEfCAFQRwQBSAFQSIQBYUgBUEnEAWFfCIENwM4IAEgByAIIAogC4WDIAuFIAl8IAhBDhAFIAhBEhAFhSAIQSkQBYV8IAIgA0HIAHIiFGoiICkDAHwgFEHgigJqKQMAfCIMfCIJNwMQIAEgDCAEIAUgBoSDIAUgBoOEfCAEQRwQBSAEQSIQBYUgBEEnEAWFfCIHNwMwIAEgBiAJIAggCoWDIAqFIAt8IAlBDhAFIAlBEhAFhSAJQSkQBYV8IAIgA0HQAHIiFGoiISkDAHwgFEHgigJqKQMAfCIMfCILNwMIIAEgDCAHIAQgBYSDIAQgBYOEfCAHQRwQBSAHQSIQBYUgB0EnEAWFfCIGNwMoIAEgBSALIAggCYWDIAiFIAp8IAtBDhAFIAtBEhAFhSALQSkQBYV8IAIgA0HYAHIiFGoiIikDAHwgFEHgigJqKQMAfCIMfCIKNwMAIAEgDCAGIAQgB4SDIAQgB4OEfCAGQRwQBSAGQSIQBYUgBkEnEAWFfCIFNwMgIAEgBCAKIAkgC4WDIAmFIAh8IApBDhAFIApBEhAFhSAKQSkQBYV8IAIgA0HgAHIiFGoiIykDAHwgFEHgigJqKQMAfCIMfCIINwM4IAEgDCAFIAYgB4SDIAYgB4OEfCAFQRwQBSAFQSIQBYUgBUEnEAWFfCIENwMYIAEgByAIIAogC4WDIAuFIAl8IAhBDhAFIAhBEhAFhSAIQSkQBYV8IAIgA0HoAHIiFGoiJCkDAHwgFEHgigJqKQMAfCIMfCIJNwMwIAEgDCAEIAUgBoSDIAUgBoOEfCAEQRwQBSAEQSIQBYUgBEEnEAWFfCIHNwMQIAEgCSAIIAqFgyAKhSALfCAJQQ4QBSAJQRIQBYUgCUEpEAWFfCACIANB8AByIhRqIiUpAwB8IBRB4IoCaikDAHwiCyAGfCIGNwMoIAEgCyAHIAQgBYSDIAQgBYOEfCAHQRwQBSAHQSIQBYUgB0EnEAWFfCILNwMIIAEgBiAIIAmFgyAIhSAKfCAGQQ4QBSAGQRIQBYUgBkEpEAWFfCACIANB+AByIgNqIhQpAwB8IANB4IoCaikDAHwiBiAFfDcDICABIAYgCyAEIAeEgyAEIAeDhHwgC0EcEAUgC0EiEAWFIAtBJxAFhXw3AwAgFkHAAEYEQANAIAAgF0EDdCICaiIDIAMpAwAgASACaikDAHw3AwAgF0EBaiIXQQhHDQALBSACIBZBEGoiFkEDdGogJSkDACIEQgaIIARBExAFhSAEQT0QBYUgICkDACIFfCAVKQMAfCAYKQMAIgZCB4ggBkEBEAWFIAZBCBAFhXwiBzcDACAVIAYgISkDACIIfCAUKQMAIgZCBoggBkETEAWFIAZBPRAFhXwgGSkDACIKQgeIIApBARAFhSAKQQgQBYV8Igk3A4gBIBUgCiAiKQMAIgt8IAdBExAFIAdCBoiFIAdBPRAFhXwgGikDACINQgeIIA1BARAFhSANQQgQBYV8Igo3A5ABIBUgDSAjKQMAIgx8IAlBExAFIAlCBoiFIAlBPRAFhXwgGykDACIOQgeIIA5BARAFhSAOQQgQBYV8Ig03A5gBIBUgDiAkKQMAIhJ8IApBExAFIApCBoiFIApBPRAFhXwgHCkDACIPQgeIIA9BARAFhSAPQQgQBYV8Ig43A6ABIBUgBCAPfCANQRMQBSANQgaIhSANQT0QBYV8IB0pAwAiEEIHiCAQQQEQBYUgEEEIEAWFfCIPNwOoASAVIAYgEHwgDkETEAUgDkIGiIUgDkE9EAWFfCAeKQMAIhFCB4ggEUEBEAWFIBFBCBAFhXwiEDcDsAEgFSAHIBF8IA9BExAFIA9CBoiFIA9BPRAFhXwgHykDACITQgeIIBNBARAFhSATQQgQBYV8IhE3A7gBIBUgCSATfCAQQRMQBSAQQgaIhSAQQT0QBYV8IAVBARAFIAVCB4iFIAVBCBAFhXwiCTcDwAEgFSAFIAp8IBFBExAFIBFCBoiFIBFBPRAFhXwgCEEBEAUgCEIHiIUgCEEIEAWFfCIFNwPIASAVIAggDXwgCUETEAUgCUIGiIUgCUE9EAWFfCALQQEQBSALQgeIhSALQQgQBYV8Igg3A9ABIBUgCyAOfCAFQRMQBSAFQgaIhSAFQT0QBYV8IAxBARAFIAxCB4iFIAxBCBAFhXwiBTcD2AEgFSAMIA98IAhBExAFIAhCBoiFIAhBPRAFhXwgEkEBEAUgEkIHiIUgEkEIEAWFfCIINwPgASAVIBAgEnwgBUETEAUgBUIGiIUgBUE9EAWFfCAEQQEQBSAEQgeIhSAEQQgQBYV8IgU3A+gBIBUgBCARfCAIQRMQBSAIQgaIhSAIQT0QBYV8IAZBARAFIAZCB4iFIAZBCBAFhXw3A/ABIBUgBiAJfCAFQRMQBSAFQgaIhSAFQT0QBYV8IAdBARAFIAdCB4iFIAdBCBAFhXw3A/gBDAELCwsEAEECCwQAQQELBABBGAusBQESf0Gy2ojLByEDQe7IgZkDIQxB5fDBiwYhDUH0yoHZBiEEIAIoAAAhBiACKAAEIQcgAigACCEFIAIoAAwhCCACKAAQIQogAigAFCELIAIoABghDyACKAAcIREgASgAACECIAEoAAQhDiABKAAIIQkgASgADCEBA0AgBiAKIAIgBiANaiINc0EQEAciEGoiCnNBDBAHIQIgAiAKIBAgAiANaiINc0EIEAciEGoiCnNBBxAHIQYgByAOIAcgDGoiDHNBEBAHIg4gC2oiC3NBDBAHIQIgAiAOIAIgDGoiDHNBCBAHIg4gC2oiC3NBBxAHIQIgBSAJIAMgBWoiB3NBEBAHIgkgD2oiD3NBDBAHIQMgAyAJIAMgB2oiEnNBCBAHIgkgD2oiB3NBBxAHIQMgCCABIAQgCGoiBHNBEBAHIgUgEWoiD3NBDBAHIQEgASAFIAEgBGoiE3NBCBAHIgUgD2oiCHNBBxAHIQQgAiAHIAUgAiANaiIBc0EQEAciBWoiB3NBDBAHIQIgAiAHIAUgASACaiINc0EIEAciAWoiD3NBBxAHIQcgAyAIIBAgAyAMaiICc0EQEAciBWoiCHNBDBAHIQMgAyAIIAUgAiADaiIMc0EIEAciAmoiEXNBBxAHIQUgBCAOIAQgEmoiA3NBEBAHIgggCmoiCnNBDBAHIQQgBCAKIAggAyAEaiIDc0EIEAciDmoiCnNBBxAHIQggBiAJIAYgE2oiBHNBEBAHIgkgC2oiC3NBDBAHIQYgBiAJIAQgBmoiBHNBCBAHIgkgC2oiC3NBBxAHIQYgFEEBaiIUQQpHDQALIAAgDRAJIABBBGogDBAJIABBCGogAxAJIABBDGogBBAJIABBEGogAhAJIABBFGogDhAJIABBGGogCRAJIABBHGogARAJCzEAIAJBgAJPBEBBACIAQf8JaiAAQbYJakHrACAAQasIahAAAAsgACABIAJB/wFxEHALVgEBf0F/IQQCQCADQcEAa0FASSACQcAAS3INAAJAIAFBACACG0UEQCAAIANB/wFxEK0BRQ0BDAILIAAgA0H/AXEgASACQf8BcRCsAQ0BC0EAIQQLIAQLmAYBIX8gAigABCESIAIoAAghEyACKAAMIRQgAigAECEVIAIoABQhFiACKAAYIRcgAigAHCEYQeXwwYsGIQwgAigAACIaIQIgEiEGIBMhESAUIQdB7siBmQMhDSABKAAAIhshCCABKAAEIhwhCSABKAAIIh0hCiABKAAMIh4hDkGy2ojLByEPIBUhAUH0yoHZBiEFIBghCyAXIQMgFiEEA0AgBCAMakEHEAcgB3MiByAMakEJEAcgCnMiCiAHakENEAcgBHMiHyAKakESEAchICACIA1qQQcQByAOcyIEIA1qQQkQByADcyIQIARqQQ0QByACcyICIBBqQRIQByEOIAggD2pBBxAHIAtzIgsgD2pBCRAHIAZzIgYgC2pBDRAHIAhzIgggBmpBEhAHISEgASAFakEHEAcgEXMiAyAFakEJEAcgCXMiCSADakENEAcgAXMiIiAJakESEAchIyADIAwgIHMiAWpBBxAHIAJzIgIgAWpBCRAHIAZzIgYgAmpBDRAHIANzIhEgBmpBEhAHIAFzIQwgDSAOcyIBIAdqQQcQByAIcyIIIAFqQQkQByAJcyIJIAhqQQ0QByAHcyIHIAlqQRIQByABcyENIA8gIXMiAyAEakEHEAcgInMiASADakEJEAcgCnMiCiABakENEAcgBHMiDiAKakESEAcgA3MhDyAFICNzIgUgC2pBBxAHIB9zIgQgBWpBCRAHIBBzIgMgBGpBDRAHIAtzIgsgA2pBEhAHIAVzIQUgGUESSSEQIBlBAmohGSAQDQALIAAgDEHl8MGLBmoQCSAAQQRqIAIgGmoQCSAAQQhqIAYgEmoQCSAAQQxqIBEgE2oQCSAAQRBqIAcgFGoQCSAAQRRqIA1B7siBmQNqEAkgAEEYaiAIIBtqEAkgAEEcaiAJIBxqEAkgAEEgaiAKIB1qEAkgAEEkaiAOIB5qEAkgAEEoaiAPQbLaiMsHahAJIABBLGogASAVahAJIABBMGogBCAWahAJIABBNGogAyAXahAJIABBOGogCyAYahAJIABBPGogBUH0yoHZBmoQCQtpAQF/IwBBEGsiAyAANgIMIAMgATYCCEEAIQEgA0EAOgAHIAIEQANAIAMgAy0AByADKAIIIAFqLQAAIAMoAgwgAWotAABzcjoAByABQQFqIgEgAkcNAAsLIAMtAAdBAWtBCHZBAXFBAWsLlRIBHn4gABAOIRAgADUAAiERIABBBWoQDiESIAA1AAchGSAANQAKIRogAEENahAOIRsgADUADyELIABBEmoQDiEKIABBFWoQDiEIIAA1ABchBSAAQRpqEA4hASAANQAcIRwgADUAHyETIABBImoQDiEUIAA1ACQhDCAAQSdqEA4hDyAAQSpqEA4hCSAANQAsIQYgACAAQS9qEA5CAohC////AIMiAkLRqwh+IAFCAohC////AIN8IAA1ADFCB4hC////AIMiAULTjEN+fCAANQA0QgSIQv///wCDIgNC5/YnfnwgAEE3ahAOQgGIQv///wCDIgRCmNocfnwgADUAOUIGiEL///8AgyIHQpPYKH58IhUgBkIFiEL///8AgyAANQA8QgOIIgZCg6FWfiAJQv///wCDfCINQoCAQH0iDkIVh3wiCUKDoVZ+fCACQtOMQ34gBUIFiEL///8Ag3wgAULn9id+fCADQpjaHH58IARCk9gofnwgAkLn9id+IAhC////AIN8IAFCmNocfnwgA0KT2Ch+fCIFQoCAQH0iFkIViHwiCEKAgEB9IhdCFYd8IBVCgIBAfSIVQoCAgH+DfSIYIBhCgIBAfSIYQoCAgH+DfSAJQtGrCH4gCHwgF0KAgIB/g30gDSAOQoCAgH+DfSAGQtGrCH4gD0IDiEL///8Ag3wgB0KDoVZ+fCAEQoOhVn4gDEIGiEL///8Ag3wgBkLTjEN+fCAHQtGrCH58IgxCgIBAfSIPQhWHfCINQoCAQH0iDkIVh3wiCEKDoVZ+fCAFIAJCmNocfiAKQgOIQv///wCDfCABQpPYKH58IAJCk9gofiALQgaIQv///wCDfCIXQoCAQH0iHUIViHwiCkKAgEB9Ih5CFYh8IBZCgICA////B4N9IAlC04xDfnwgCELRqwh+fCANIA5CgICAf4N9IgtCg6FWfnwiBUKAgEB9Ig1CFYd8Ig5CgIBAfSIWQhWHfCAOIBZCgICAf4N9IAUgDUKAgIB/g30gCiAeQoCAgP///weDfSAJQuf2J358IAhC04xDfnwgC0LRqwh+fCAMIA9CgICAf4N9IANCg6FWfiAUQgGIQv///wCDfCAEQtGrCH58IAZC5/YnfnwgB0LTjEN+fCABQoOhVn4gE0IEiEL///8Ag3wgA0LRqwh+fCAEQtOMQ358IAZCmNocfnwgB0Ln9id+fCITQoCAQH0iFEIVh3wiBUKAgEB9IgxCFYd8IgpCg6FWfnwgFyAdQoCAgP///wGDfSAJQpjaHH58IAhC5/YnfnwgC0LTjEN+fCAKQtGrCH58IAUgDEKAgIB/g30iBUKDoVZ+fCIMQoCAQH0iD0IVh3wiDUKAgEB9Ig5CFYd8IA0gDkKAgIB/g30gDCAPQoCAgH+DfSAJQpPYKH4gG0IBiEL///8Ag3wgCEKY2hx+fCALQuf2J358IApC04xDfnwgBULRqwh+fCATIBRCgICAf4N9IAJCg6FWfiAcQgeIQv///wCDfCABQtGrCH58IANC04xDfnwgBELn9id+fCAGQpPYKH58IAdCmNocfnwgFUIVh3wiAUKAgEB9IgNCFYd8IgJCg6FWfnwgCEKT2Ch+IBpCBIhC////AIN8IAtCmNocfnwgCkLn9id+fCAFQtOMQ358IAJC0asIfnwiBEKAgEB9IgdCFYd8IgZCgIBAfSIJQhWHfCAGIAEgA0KAgIB/g30gGEIVh3wiA0KAgEB9IghCFYciAUKDoVZ+fCAJQoCAgH+DfSABQtGrCH4gBHwgB0KAgIB/g30gC0KT2Ch+IBlCB4hC////AIN8IApCmNocfnwgBULn9id+fCACQtOMQ358IApCk9gofiASQgKIQv///wCDfCAFQpjaHH58IAJC5/YnfnwiBEKAgEB9IgdCFYd8IgZCgIBAfSIJQhWHfCAGIAFC04xDfnwgCUKAgIB/g30gAULn9id+IAR8IAdCgICAf4N9IAVCk9gofiARQgWIQv///wCDfCACQpjaHH58IAJCk9gofiAQQv///wCDfCICQoCAQH0iBEIVh3wiB0KAgEB9IgZCFYd8IAFCmNocfiAHfCAGQoCAgH+DfSACIARCgICAf4N9IAFCk9gofnwiAUIVh3wiBEIVh3wiB0IVh3wiBkIVh3wiCUIVh3wiC0IVh3wiCkIVh3wiBUIVh3wiEEIVh3wiEUIVh3wiEkIVhyADIAhCgICAf4N9fCIIQhWHIgJCk9gofiABQv///wCDfCIBPAAAIAAgAUIIiDwAASAAIAJCmNocfiAEQv///wCDfCABQhWHfCIDQguIPAAEIAAgA0IDiDwAAyAAIAJC5/YnfiAHQv///wCDfCADQhWHfCIEQgaIPAAGIAAgAUIQiEIfgyADQv///wCDIgNCBYaEPAACIAAgAkLTjEN+IAZC////AIN8IARCFYd8IgFCCYg8AAkgACABQgGIPAAIIAAgBEL///8AgyIEQgKGIANCE4iEPAAFIAAgAkLRqwh+IAlC////AIN8IAFCFYd8IgNCDIg8AAwgACADQgSIPAALIAAgAUL///8AgyIHQgeGIARCDoiEPAAHIAAgAkKDoVZ+IAtC////AIN8IANCFYd8IgFCB4g8AA4gACADQv///wCDIgNCBIYgB0IRiIQ8AAogACAKQv///wCDIAFCFYd8IgJCCog8ABEgACACQgKIPAAQIAAgAUL///8AgyIEQgGGIANCFIiEPAANIAAgBUL///8AgyACQhWHfCIBQg2IPAAUIAAgAUIFiDwAEyAAIAJC////AIMiA0IGhiAEQg+IhDwADyAAIBBC////AIMgAUIVh3wiAjwAFSAAIAFCA4YgA0ISiIQ8ABIgACACQgiIPAAWIAAgEUL///8AgyACQhWHfCIBQguIPAAZIAAgAUIDiDwAGCAAIBJC////AIMgAUIVh3wiA0IGiDwAGyAAIAJCEIhCH4MgAUL///8AgyIBQgWGhDwAFyAAIAhC////AIMgA0IVh3wiAkIRiDwAHyAAIAJCCYg8AB4gACACQgGIPAAdIAAgA0L///8AgyIDQgKGIAFCE4iEPAAaIAAgAkIHhiADQg6IhDwAHAvaAQEFfyMAQRBrIgNBADYACyADQQA2AggDQCAAIAJqLQAAIQRBACEBA0AgA0EIaiABaiIFIAUtAAAgAUEFdEHgE2ogAmotAAAgBHNyOgAAIAFBAWoiAUEHRw0ACyACQQFqIgJBH0cNAAsgAC0AH0H/AHEhAkEAIQBBACEBA0AgA0EIaiABaiIEIAQtAAAgAiABQQV0Qf8Tai0AAHNyOgAAIAFBAWoiAUEHRw0AC0EAIQEDQCADQQhqIABqLQAAQQFrIAFyIQEgAEEBaiIAQQdHDQALIAFBCHZBAXEL5wIBBX8jAEHQA2siAyQAA0AgA0GQA2ogAkEBdGoiBSABIAJqLQAAIgZBBHY6AAEgBSAGQQ9xOgAAIAJBAWoiAkEgRw0AC0EAIQIDQCADQZADaiAEaiIBIAEtAAAgAmoiASABQRh0QYCAgEBrIgFBGHVB8AFxazoAACABQRx1IQIgBEEBaiIEQT9HDQALIAMgAy0AzwMgAmo6AM8DIAAQekEBIQIDQCADIAJBAXYgA0GQA2ogAmosAAAQeSADQfABaiIBIAAgAxBTIAAgARATIAJBPkkhASACQQJqIQIgAQ0ACyADQfABaiIBIAAQOiADQfgAaiICIAEQOyABIAIQMSACIAEQOyABIAIQMSACIAEQOyABIAIQMSAAIAEQE0EAIQIDQCADIAJBAXYgA0GQA2ogAmosAAAQeSADQfABaiIBIAAgAxBTIAAgARATIAJBPkkhASACQQJqIQIgAQ0ACyADQdADaiQAC4sBAQR/IwBBMGsiBSQAIAAgAUEoaiIDIAEQEiAAQShqIgQgAyABEBUgAEHQAGoiAyAAIAIQCiAEIAQgAkEoahAKIABB+ABqIgYgAkHQAGogAUH4AGoQCiAFIAFB0ABqIgEgARASIAAgAyAEEBUgBCADIAQQEiADIAUgBhASIAYgBSAGEBUgBUEwaiQAC1YBA38jAEGQAWsiAiQAIAJB4ABqIgMgAUHQAGoQPCACQTBqIgQgASADEAogAiABQShqIAMQCiAAIAIQLCAAIAQQf0EHdCAALQAfczoAHyACQZABaiQAC68CARN/IAEoAgQhDCAAKAIEIQMgASgCCCENIAAoAgghBCABKAIMIQ4gACgCDCEFIAEoAhAhDyAAKAIQIQYgASgCFCEQIAAoAhQhByABKAIYIREgACgCGCEIIAEoAhwhEiAAKAIcIQkgASgCICETIAAoAiAhCiABKAIkIRQgACgCJCELIABBACACayICIAAoAgAiFSABKAIAc3EgFXM2AgAgACALIAsgFHMgAnFzNgIkIAAgCiAKIBNzIAJxczYCICAAIAkgCSAScyACcXM2AhwgACAIIAggEXMgAnFzNgIYIAAgByAHIBBzIAJxczYCFCAAIAYgBiAPcyACcXM2AhAgACAFIAUgDnMgAnFzNgIMIAAgBCAEIA1zIAJxczYCCCAAIAMgAyAMcyACcXM2AgQLJAEBfyMAQSBrIgEkACABIAAQLCABQSAQdSEAIAFBIGokACAAC6YEAg5+Cn8gACgCJCESIAAoAiAhEyAAKAIcIRQgACgCGCEVIAAoAhQhESACQhBaBEAgAC0AUEVBGHQhFiAAKAIEIhdBBWytIQ8gACgCCCIYQQVsrSENIAAoAgwiGUEFbK0hCyAAKAIQIhpBBWytIQkgGq0hECAZrSEOIBitIQwgF60hCiAANQIAIQgDQCABKAADQQJ2Qf///x9xIBVqrSIDIA5+IAEoAABB////H3EgEWqtIgQgEH58IAEoAAZBBHZB////H3EgFGqtIgUgDH58IAEoAAlBBnYgE2qtIgYgCn58IBIgFmogASgADEEIdmqtIgcgCH58IAMgDH4gBCAOfnwgBSAKfnwgBiAIfnwgByAJfnwgAyAKfiAEIAx+fCAFIAh+fCAGIAl+fCAHIAt+fCADIAh+IAQgCn58IAUgCX58IAYgC358IAcgDX58IAMgCX4gBCAIfnwgBSALfnwgBiANfnwgByAPfnwiA0IaiEL/////D4N8IgRCGohC/////w+DfCIFQhqIQv////8Pg3wiBkIaiEL/////D4N8IgdCGoinQQVsIAOnQf///x9xaiIRQRp2IASnQf///x9xaiEVIAWnQf///x9xIRQgBqdB////H3EhEyAHp0H///8fcSESIBFB////H3EhESABQRBqIQEgAkIQfSICQg9WDQALCyAAIBE2AhQgACASNgIkIAAgEzYCICAAIBQ2AhwgACAVNgIYC+8BAQJ/IABFBEBBZw8LIAAoAgBFBEBBfw8LAn9BfiAAKAIEQRBJDQAaIAAoAghFBEBBbiAAKAIMDQEaCyAAKAIUIQEgACgCEEUEQEFtQXogARsPC0F6IAFBCEkNABogACgCGEUEQEFs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IAEgFiAZhUEQEAUiFjcDcCABIBYgF3wiFjcDSCABIBMgFoVBPxAFNwMgIAAgASkDQCAeIAApAACFhTcAAEEBISEDQCAAICFBA3QiIGoiIiABICBqIiApAwAgIikAAIUgIEFAaykDAIU3AAAgIUEBaiIhQQhHDQALIAFBgAJqJAALRQECfyMAQRBrIgNBADoADyABBEADQCADIAAgAmotAAAgAy0AD3I6AA8gAkEBaiICIAFHDQALCyADLQAPQQFrQQh2QQFxCxkAIAAgASACIANCACAEQeSRAigCABESABoLEAAgACABQdyRAigCABEDAAsDAAEL9wEBBH8jAEGAAWsiAyQAIAAQHCAAQShqIgQQHCAAQdAAaiIFEDAgACABQcAHbEHgFWoiASACQQAgAkGAAXFBB3YiBmsgAnFBAXRrQRh0QRh1IgJBARAmECIgACABQfgAaiACQQIQJhAiIAAgAUHwAWogAkEDECYQIiAAIAFB6AJqIAJBBBAmECIgACABQeADaiACQQUQJhAiIAAgAUHYBGogAkEGECYQIiAAIAFB0AVqIAJBBxAmECIgACABQcgGaiACQQgQJhAiIANBCGoiASAEECkgA0EwaiAAECkgA0HYAGogBRCAASAAIAEgBhAiIANBgAFqJAALHQAgABAwIABBKGoQHCAAQdAAahAcIABB+ABqEDALgAIBCH8DQCAAIAJqIAEgAkEDdmotAAAgAkEHcXZBAXE6AAAgAkEBaiICQYACRw0ACwNAIAQiAUEBaiEEAkAgACABaiIGLQAARQ0AIAQhAkEBIQUgAUH+AUsNAANAAkAgACACaiIDLAAAIgdFDQAgByAFdCIHIAYsAAAiCGoiCUEPTARAIAYgCToAACADQQA6AAAMAQsgCCAHayIDQXFIDQIgBiADOgAAA0AgACACaiIDLQAARQRAIANBAToAAAwCCyADQQA6AAAgAkH/AUkhAyACQQFqIQIgAw0ACwsgBUEFSw0BIAVBAWoiBSABaiICQYACSQ0ACwsgBEGAAkcNAAsLlQEBBH8jAEEwayIFJAAgACABQShqIgMgARASIABBKGoiBCADIAEQFSAAQdAAaiIDIAAgAkEoahAKIAQgBCACEAogAEH4AGoiBiACQfgAaiABQfgAahAKIAAgAUHQAGogAkHQAGoQCiAFIAAgABASIAAgAyAE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AAAgA0IBfCIDIAJSDQALIAAgACkDOCACfDcDOAsLsgEBAX8gACABKAAAQf///x9xNgIAIAAgASgAA0ECdkGD/v8fcTYCBCAAIAEoAAZBBHZB/4H/H3E2AgggACABKAAJQQZ2Qf//wB9xNgIMIAEoAAwhAiAAQgA3AhQgAEIANwIcIABBADYCJCAAIAJBCHZB//8/cTYCECAAIAEoABA2AiggACABKAAUNgIsIAAgASgAGDYCMCABKAAcIQEgAEEAOgBQIABCADcDOCAAIAE2AjQLMAECfyMAIgVBgAFrQUBxIgQkACAEIAMQhAEgBCABIAIQgwEgBCAAEIIBIAUkAEEACwsAIAAgAUEgEIcBC2wBAX8jAEEQayIDIAA2AgwgAyABNgIIQQAhASADQQA2AgQgAkEASgRAA0AgAyADKAIEIAMoAgggAWotAAAgAygCDCABai0AAHNyNgIEIAFBAWoiASACRw0ACwsgAygCBEEBa0EIdkEBcUEBawspAQJ/A0AgACACQQN0IgNqIAEgA2opAAA3AwAgAkEBaiICQYABRw0ACwtyAQF/AkAgAUEEcUUNACAAKAIAIgEEQCABKAIEIAAoAhBBCnQQCAsgACgCBCIBRQ0AIAEgACgCFEEDdBAICyAAKAIEEBggAEEANgIEAkAgACgCACIBRQ0AIAEoAgAiAkUNACACEBgLIAEQGCAAQQA2AgALEAAgAEIANwIAIABCADcCCAspAQF/IwBBEGsiACQAIABBADoAD0GMkgIgAEEPakEAEAEaIABBEGokAAsoACACQoCAgIAQWgRAEBQACyAAIAEgAiADQgEgBEG8kQIoAgAREgAaCxYAIABCwAAgASACQbSRAigCABENABoLPQECfyMAIgRBgANrQUBxIgMkACADQQBBAEEYEEIaIAMgAUIgECUaIAMgAkIgECUaIAMgAEEYEEEaIAQkAAsqAQF/QX8hBiACQhBaBH8gACABQRBqIAEgAkIQfSADIAQgBRCQAQUgBgsLPAECfyMAQSBrIgckAEF/IQggByAFIAYQZEUEQCAAIAEgAiADIAQgBxBgIQggB0EgEAgLIAdBIGokACAICyUAIAJC8P///w9aBEAQFAALIABBEGogACABIAIgAyAEIAUQkgELPAECfyMAQSBrIgckAEF/IQggByAFIAYQZEUEQCAAIAEgAiAD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AUEgaiAIQiB9IAYgASAFEI8BIQcLIAZBIGokACAHC5kBAgJ/AX4gAq0gA61CIIaEIQcjAEHgAGsiAiQAQX8hAyACQSBqIAIQkwFFBEAgAkFAayIFIAJBIGoiBiAEEI4BIABBIGogASAHIAUgBCACEJEBIQMgACACKQM4NwAYIAAgAikDMDcAECAAIAIpAyg3AAggACACKQMgNwAAIAJBIBAIIAZBIBAIIAVBGBAICyACQeAAaiQAIAMLGQAgACABIAKtIAOtQiCGhCAEIAUgBhCPAQstAQF+IAKtIAOtQiCGhCIGQhBaBH8gACABQRBqIAEgBkIQfSAEIAUQYAVBfwsLGwAgACABIAIgA60gBK1CIIaEIAUgBiAHEJABCxgAIAAgASACIAOtIAStQiCGhCAFIAYQYAsZACAAIAEgAq0gA61CIIaEIAQgBSAGEJEBCy4BAX4gAq0gA61CIIaEIgZC8P///w9aBEAQFAALIABBEGogACABIAYgBCAFEGELGwAgACABIAIgA60gBK1CIIaEIAUgBiAHEJIBCxgAIAAgASACIAOtIAStQiCGhCAFIAYQYQtIAQF/IwBBIGsiBSQAIAUgASACrSADrUIghoQgBBCUARogACAFEIYBIQEgBSAAQSAQTyECIAVBIGokACACQX8gASAAIAVGG3ILFQAgACABIAKtIAOtQiCGhCAEEJQBC1sBAn4gB60gCK1CIIaEIQxBfyECIAStIAWtQiCGhCILQhBaBEAgACADIAtCEH0gAyALp2pBEGsgBiAMIAkgChCaASECCyABBEAgAUIAIAtCEH0gAhs3AwALIAILJQAgACACIAOtIAStQiCGhCAFIAYgB60gCK1CIIaEIAkgChCaAQtZAQJ+An8gBq0gB61CIIaEIQwgA60gBK1CIIaEIgtC8P///w9UBEAgACAAIAunakEAIAIgCyAFIAwgCSAKEJsBGiABBEAgASALQhB8NwMAC0EADAELEBQACwsnACAAIAEgAiADIAStIAWtQiCGhCAGIAetIAitQiCGhCAKIAsQmwELWwECfiAHrSAIrUIghoQhDEF/IQIgBK0gBa1CIIaEIgtCEFoEQCAAIAMgC0IQfSADIAunakEQayAGIAwgCSAKEKYBIQILIAEEQCABQgAgC0IQfSACGzcDAAsgAgslACAAIAIgA60gBK1CIIaE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QQ9xIgZBCHQgBkH2/wNqQYCyA3FqQYCuAWpBCHY6AAEgBCAFQQR2IgQgBEH2/wNqQQh2QdkBcWpB1wBqOgAAIAFBAWoiASADRw0ACyADQQF0BSABCyAAakEAOgAAIAAPCxAUAAssAQF/IwBBQGoiAyQAIAAgAxAnIAEgA0LAACACQQEQoQEhACADQUBrJAAgAAsuAQF/IwBBQGoiBCQAIAAgBBAnIAEgAiAEQsAAIANBARCjASEAIARBQGskACAACwgAIAAQNkEACywBAX8jAEEgayICJAAgAkEgEB0gACABIAIQpAEaIAJBIBAIIAJBIGokAEEACwsAIAAgASACEKQBCwUAQb9/CwUAQdABC20BAX8jAEFAaiICJAAgAiABQiAQNRogAiACLQAAQfgBcToAACACIAItAB9BP3FBwAByOgAfIAAgAikDEDcAECAAIAIpAwg3AAggACACKQMANwAAIAAgAikDGDcAGCACQcAAEAggAkFAayQAQQALnwQBB38jAEGAAmsiBSQAQX8hCAJAIAEQUQ0AIAVB4ABqIAEQfg0AIwBBoAFrIgYkACMAQeANayICJAAgAkHgA2oiAyAFQeAAaiIEEBkgAkHAAmoiASAEEDogAiABEBMgASACIAMQGiACQaABaiIDIAEQEyACQYAFaiIEIAMQGSABIAIgBBAaIAMgARATIAJBoAZqIgQgAxAZIAEgAiAEEBogAyABEBMgAkHAB2oiBCADEBkgASACIAQQGiADIAEQEyACQeAIaiIEIAMQGSABIAIgBBAaIAMgARATIAJBgApqIgQgAxAZIAEgAiAEEBogAyABEBMgAkGgC2oiBCADEBkgASACIAQQGiADIAEQEyACQcAMaiADEBkgBhB6QfwBIQEDQCACQcACaiAGEDoCQCABIgNB4IUCaiwAACIBQQBKBEAgAkGgAWoiBCACQcACaiIHEBMgByAEIAJB4ANqIAFB/gFxQQF2QaABbGoQGgwBCyABQQBODQAgAkGgAWoiBCACQcACaiIHEBMgByAEIAJB4ANqQQAgAWtB/gFxQQF2QaABbGoQfAsgBiACQcACahATIANBAWshASADDQALIAJB4A1qJAAgBhBWIQEgBkGgAWokACABRQ0AIAUQHCAFIAUgBUGIAWoiAxAVIAVBMGoiARAcIAEgASADEBIgBSAFEDwgASAB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xAGBEXgA+2eX/wc0cP+MOEL/KOL1/9lGJf6s1gn/SEOGAZLA1v8sJnAARLhL/85a+wCV640Atao6AHT07wBcnQIAZq1iAOmJYAF/McsABZuUABeUCf/TegwAIoYa/9vMiACGCCn/4FMr/lUZ9wBtfwD+qYgwAO532//nrdUAzhL+/gi6B/9+CQcBbypIAG807P5gP40Ak79//s1OwP8Oau0Bu9tMAK/zu/5pWa0AVRlZAaLzlAACdtH+IZ4JAIujLv9dRigAbCqO/m/8jv+b35AAM+Wn/0n8m/9edAz/mKDa/5zuJf+z6s//xQCz/5qkjQDhxGgACiMZ/tHU8v9h/d7+uGXlAN4SfwGkiIf/Hs+M/pJh8wCBwBr+yVQh/28KTv+TUbL/BAQYAKHu1/8GjSEANdcO/ym10P/ni50As8vd//+5cQC94qz/cULW/8o+Lf9mQAj/Tq4Q/oV1RP8AQYAUCwEBAEGgFAuwASbolY/CsiewRcP0ifLvmPDV36wF08YzObE4AohtU/wFxxdqcD1N2E+6PAt2DRBnDyogU/osOczGTsf9d5KsA3rs////////////////////////////////////////f+3///////////////////////////////////////9/7v///////////////////////////////////////3/t0/VcGmMSWNac96Le+d4UAEHfFQv88AEQhTuMAb3xJP/4JcMBYNw3ALdMPv/DQj0AMkykAeGkTP9MPaP/dT4fAFGRQP92QQ4AonPW/waKLgB85vT/CoqPADQawgC49EwAgY8pAb70E/97qnr/YoFEAHnVkwBWZR7/oWebAIxZQ//v5b4BQwu1AMbwif7uRbz/6nE8/yX/Of9Fsrb+gNCzAHYaff4DB9b/8TJN/1XLxf/Th/r/GTBk/7vVtP4RWGkAU9GeAQVzYgAErjz+qzdu/9m1Ef8UvKoAkpxm/lfWrv9yepsB6SyqAH8I7wHW7OoArwXbADFqPf8GQtD/Ampu/1HqE//Xa8D/Q5fuABMqbP/lVXEBMkSH/xFqCQAyZwH/UAGoASOYHv8QqLkBOFno/2XS/AAp+kcAzKpP/w4u7/9QTe8AvdZL/xGN+QAmUEz/vlV1AFbkqgCc2NABw8+k/5ZCTP+v4RD/jVBiAUzb8gDGonIALtqY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//////////////9/7f///////////////////////////////////////3/u////////////////////////////////////////fwjJvPNn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMfeSF+ExnN4FsAQaCKAgvBBQjJvPNn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMfeSF+ExnN4FsirijXmC+KQs1l7yORRDdxLztN7M/7wLW824mBpdu16Ti1SPNbwlY5GdAFtvER8VmbTxmvpII/khiBbdrVXhyrQgIDo5iqB9i+b3BFAVuDEoyy5E6+hTEk4rT/1cN9DFVviXvydF2+crGWFjv+sd6ANRLHJacG3JuUJmnPdPGbwdJK8Z7BaZvk4yVPOIZHvu+11YyLxp3BD2WcrHfMoQwkdQIrWW8s6S2D5KZuqoR0StT7Qb3cqbBctVMRg9qI+Xar32buUlE+mBAytC1txjGoPyH7mMgnA7DkDu++x39Zv8KPqD3zC+DGJacKk0eRp9VvggPgUWPKBnBuDgpnKSkU/C/SRoUKtycmySZcOCEbLu0qxFr8bSxN37OVnRMNOFPeY6+LVHMKZaiydzy7Cmp25q7tRy7JwoE7NYIUhSxykmQD8Uyh6L+iATBCvEtmGqiRl/jQcItLwjC+VAajUWzHGFLv1hnoktEQqWVVJAaZ1iogcVeFNQ70uNG7MnCgahDI0NK4FsGkGVOrQVEIbDcemeuO30x3SCeoSJvhtbywNGNaycWzDBw5y4pB40qq2E5z42N3T8qcW6O4stbzby5o/LLvXe6Cj3RgLxdDb2OleHKr8KEUeMiE7DlkGggCx4woHmMj+v++kOm9gt7rbFCkFXnGsvej+b4rU3Lj8nhxxpxhJurOPifKB8LAIce4htEe6+DN1n3a6njRbu5/T331um8Xcqpn8AammMiixX1jCq4N+b4EmD8RG0ccEzULcRuEfQQj9XfbKJMkx0B7q8oyvL7JFQq+njxMDRCcxGcdQ7ZCPsu+1MVMKn5l/Jwpf1ns+tY6q2/LXxdYR0qMGURsgABB4JACCyFTaWdFZDI1NTE5IG5vIEVkMjU1MTkgY29sbGlzaW9ucwEAQbCRAgs1MI5QAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0=")||(d=R,R=a.locateFile?a.locateFile(d,c):c+d);var V={35048:function(){return a.getRandomValue()},35084:function(){if(void 0===a.getRandomValue)try{var A="object"==typeof window?window:self,I=void 0!==A.crypto?A.crypto:A.msCrypto,g=function(){var A=new Uint32Array(1);return I.getRandomValues(A),A[0]>>>0};g(),a.getRandomValue=g}catch(A){try{var B=__webpack_require__(/*! crypto */ "crypto"),C=function(){var A=B.randomBytes(4);return(A[0]<<24|A[1]<<16|A[2]<<8|A[3])>>>0};C(),a.getRandomValue=C}catch(A){throw"No secure random number generator found"}}}};function q(A){for(;A.length>0;){var I=A.shift();if("function"!=typeof I){var g=I.func;"number"==typeof g?void 0===I.arg?z(g)():z(g)(I.arg):g(void 0===I.arg?null:I.arg)}else I(a)}}function z(A){return S.get(A)}var j=[];function W(A){try{return s.grow(A-D.byteLength+65535>>>16),U(s.buffer),1}catch(A){}}var O="function"==typeof atob?atob:function(A){var I,g,B,C,Q,E,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",n="",a=0;A=A.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{I=i.indexOf(A.charAt(a++))<<2|(C=i.indexOf(A.charAt(a++)))>>4,g=(15&C)<<4|(Q=i.indexOf(A.charAt(a++)))>>2,B=(3&Q)<<6|(E=i.indexOf(A.charAt(a++))),n+=String.fromCharCode(I),64!==Q&&(n+=String.fromCharCode(g)),64!==E&&(n+=String.fromCharCode(B))}while(a<A.length);return n};function Z(A){if(K(A))return function(A){if("boolean"==typeof f&&f){var I=Buffer.from(A,"base64");return new Uint8Array(I.buffer,I.byteOffset,I.byteLength)}try{for(var g=O(A),B=new Uint8Array(g.length),C=0;C<g.length;++C)B[C]=g.charCodeAt(C);return B}catch(A){throw new Error("Converting base64 string to bytes failed.")}}(A.slice(L.length))}var $,AA={a:function(A,I,g,B){N("Assertion failed: "+G(A)+", at: "+[I?G(I):"unknown filename",g,B?G(B):"unknown function"])},d:function(){N("")},b:function(A,I,g){var B=function(A,I){var g;for(j.length=0,I>>=2;g=p[A++];){var B=g<105;B&&1&I&&I++,j.push(B?_[I++>>1]:F[I]),++I}return j}(I,g);return V[A].apply(null,B)},e:function(A,I,g){p.copyWithin(A,I,I+g)},c:function(A){var I,g=p.length,B=2147483648;if((A>>>=0)>B)return!1;for(var C=1;C<=4;C*=2){var Q=g*(1+.2/C);if(Q=Math.min(Q,A+100663296),W(Math.min(B,(I=Math.max(A,Q))+(65536-I%65536)%65536)))return!0}return!1}};function IA(A){function I(){$||($=!0,a.calledRun=!0,k||(q(m),a.onRuntimeInitialized&&a.onRuntimeInitialized(),function(){if(a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;)A=a.postRun.shift(),v.unshift(A);var A;q(v)}()))}A=A||o,M>0||(function(){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)A=a.preRun.shift(),b.unshift(A);var A;q(b)}(),M>0||(a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1),I()}),1)):I()))}if(function(){var A={a:AA};function I(A,I){var g,B=A.exports;a.asm=B,U((s=a.asm.f).buffer),S=a.asm.Ac,g=a.asm.g,m.unshift(g),function(A){if(M--,a.monitorRunDependencies&&a.monitorRunDependencies(M),0==M&&(null!==P&&(clearInterval(P),P=null),Y)){var I=Y;Y=null,I()}}()}function g(A){I(A.instance)}function B(I){return function(){if(!y&&(t||e)){if("function"==typeof fetch&&!X(R))return fetch(R,{credentials:"same-origin"}).then((function(A){if(!A.ok)throw"failed to load wasm binary file at '"+R+"'";return A.arrayBuffer()})).catch((function(){return T(R)}));if(C)return new Promise((function(A,I){C(R,(function(I){A(new Uint8Array(I))}),I)}))}return Promise.resolve().then((function(){return T(R)}))}().then((function(I){return WebAssembly.instantiate(I,A)})).then((function(A){return A})).then(I,(function(A){w("failed to asynchronously prepare wasm: "+A),N(A)}))}if(M++,a.monitorRunDependencies&&a.monitorRunDependencies(M),a.instantiateWasm)try{return a.instantiateWasm(A,I)}catch(A){return w("Module.instantiateWasm callback failed with error: "+A),!1}y||"function"!=typeof WebAssembly.instantiateStreaming||K(R)||X(R)||"function"!=typeof fetch?B(g):fetch(R,{credentials:"same-origin"}).then((function(I){return WebAssembly.instantiateStreaming(I,A).then(g,(function(A){return w("wasm streaming compile failed: "+A),w("falling back to ArrayBuffer instantiation"),B(g)}))}))}(),a.___wasm_call_ctors=function(){return(a.___wasm_call_ctors=a.asm.g).apply(null,arguments)},a._crypto_aead_chacha20poly1305_encrypt_detached=function(){return(a._crypto_aead_chacha20poly1305_encrypt_detached=a.asm.h).apply(null,arguments)},a._crypto_aead_chacha20poly1305_encrypt=function(){return(a._crypto_aead_chacha20poly1305_encrypt=a.asm.i).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_encrypt_detached=function(){return(a._crypto_aead_chacha20poly1305_ietf_encrypt_detached=a.asm.j).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_encrypt=function(){return(a._crypto_aead_chacha20poly1305_ietf_encrypt=a.asm.k).apply(null,arguments)},a._crypto_aead_chacha20poly1305_decrypt_detached=function(){return(a._crypto_aead_chacha20poly1305_decrypt_detached=a.asm.l).apply(null,arguments)},a._crypto_aead_chacha20poly1305_decrypt=function(){return(a._crypto_aead_chacha20poly1305_decrypt=a.asm.m).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_decrypt_detached=function(){return(a._crypto_aead_chacha20poly1305_ietf_decrypt_detached=a.asm.n).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_decrypt=function(){return(a._crypto_aead_chacha20poly1305_ietf_decrypt=a.asm.o).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_keybytes=function(){return(a._crypto_aead_chacha20poly1305_ietf_keybytes=a.asm.p).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_npubbytes=function(){return(a._crypto_aead_chacha20poly1305_ietf_npubbytes=a.asm.q).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_nsecbytes=function(){return(a._crypto_aead_chacha20poly1305_ietf_nsecbytes=a.asm.r).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_abytes=function(){return(a._crypto_aead_chacha20poly1305_ietf_abytes=a.asm.s).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_messagebytes_max=function(){return(a._crypto_aead_chacha20poly1305_ietf_messagebytes_max=a.asm.t).apply(null,arguments)},a._crypto_aead_chacha20poly1305_ietf_keygen=function(){return(a._crypto_aead_chacha20poly1305_ietf_keygen=a.asm.u).apply(null,arguments)},a._crypto_aead_chacha20poly1305_keybytes=function(){return(a._crypto_aead_chacha20poly1305_keybytes=a.asm.v).apply(null,arguments)},a._crypto_aead_chacha20poly1305_npubbytes=function(){return(a._crypto_aead_chacha20poly1305_npubbytes=a.asm.w).apply(null,arguments)},a._crypto_aead_chacha20poly1305_nsecbytes=function(){return(a._crypto_aead_chacha20poly1305_nsecbytes=a.asm.x).apply(null,arguments)},a._crypto_aead_chacha20poly1305_abytes=function(){return(a._crypto_aead_chacha20poly1305_abytes=a.asm.y).apply(null,arguments)},a._crypto_aead_chacha20poly1305_messagebytes_max=function(){return(a._crypto_aead_chacha20poly1305_messagebytes_max=a.asm.z).apply(null,arguments)},a._crypto_aead_chacha20poly1305_keygen=function(){return(a._crypto_aead_chacha20poly1305_keygen=a.asm.A).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=function(){return(a._crypto_aead_xchacha20poly1305_ietf_encrypt_detached=a.asm.B).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_encrypt=function(){return(a._crypto_aead_xchacha20poly1305_ietf_encrypt=a.asm.C).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=function(){return(a._crypto_aead_xchacha20poly1305_ietf_decrypt_detached=a.asm.D).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_decrypt=function(){return(a._crypto_aead_xchacha20poly1305_ietf_decrypt=a.asm.E).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_keybytes=function(){return(a._crypto_aead_xchacha20poly1305_ietf_keybytes=a.asm.F).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_npubbytes=function(){return(a._crypto_aead_xchacha20poly1305_ietf_npubbytes=a.asm.G).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_nsecbytes=function(){return(a._crypto_aead_xchacha20poly1305_ietf_nsecbytes=a.asm.H).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_abytes=function(){return(a._crypto_aead_xchacha20poly1305_ietf_abytes=a.asm.I).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_messagebytes_max=function(){return(a._crypto_aead_xchacha20poly1305_ietf_messagebytes_max=a.asm.J).apply(null,arguments)},a._crypto_aead_xchacha20poly1305_ietf_keygen=function(){return(a._crypto_aead_xchacha20poly1305_ietf_keygen=a.asm.K).apply(null,arguments)},a._crypto_auth_bytes=function(){return(a._crypto_auth_bytes=a.asm.L).apply(null,arguments)},a._crypto_auth_keybytes=function(){return(a._crypto_auth_keybytes=a.asm.M).apply(null,arguments)},a._crypto_auth=function(){return(a._crypto_auth=a.asm.N).apply(null,arguments)},a._crypto_auth_verify=function(){return(a._crypto_auth_verify=a.asm.O).apply(null,arguments)},a._crypto_auth_keygen=function(){return(a._crypto_auth_keygen=a.asm.P).apply(null,arguments)},a._crypto_box_seedbytes=function(){return(a._crypto_box_seedbytes=a.asm.Q).apply(null,arguments)},a._crypto_box_publickeybytes=function(){return(a._crypto_box_publickeybytes=a.asm.R).apply(null,arguments)},a._crypto_box_secretkeybytes=function(){return(a._crypto_box_secretkeybytes=a.asm.S).apply(null,arguments)},a._crypto_box_beforenmbytes=function(){return(a._crypto_box_beforenmbytes=a.asm.T).apply(null,arguments)},a._crypto_box_noncebytes=function(){return(a._crypto_box_noncebytes=a.asm.U).apply(null,arguments)},a._crypto_box_macbytes=function(){return(a._crypto_box_macbytes=a.asm.V).apply(null,arguments)},a._crypto_box_messagebytes_max=function(){return(a._crypto_box_messagebytes_max=a.asm.W).apply(null,arguments)},a._crypto_box_seed_keypair=function(){return(a._crypto_box_seed_keypair=a.asm.X).apply(null,arguments)},a._crypto_box_keypair=function(){return(a._crypto_box_keypair=a.asm.Y).apply(null,arguments)},a._crypto_box_beforenm=function(){return(a._crypto_box_beforenm=a.asm.Z).apply(null,arguments)},a._crypto_box_detached_afternm=function(){return(a._crypto_box_detached_afternm=a.asm._).apply(null,arguments)},a._crypto_box_detached=function(){return(a._crypto_box_detached=a.asm.$).apply(null,arguments)},a._crypto_box_easy_afternm=function(){return(a._crypto_box_easy_afternm=a.asm.aa).apply(null,arguments)},a._crypto_box_easy=function(){return(a._crypto_box_easy=a.asm.ba).apply(null,arguments)},a._crypto_box_open_detached_afternm=function(){return(a._crypto_box_open_detached_afternm=a.asm.ca).apply(null,arguments)},a._crypto_box_open_detached=function(){return(a._crypto_box_open_detached=a.asm.da).apply(null,arguments)},a._crypto_box_open_easy_afternm=function(){return(a._crypto_box_open_easy_afternm=a.asm.ea).apply(null,arguments)},a._crypto_box_open_easy=function(){return(a._crypto_box_open_easy=a.asm.fa).apply(null,arguments)},a._crypto_box_seal=function(){return(a._crypto_box_seal=a.asm.ga).apply(null,arguments)},a._crypto_box_seal_open=function(){return(a._crypto_box_seal_open=a.asm.ha).apply(null,arguments)},a._crypto_box_sealbytes=function(){return(a._crypto_box_sealbytes=a.asm.ia).apply(null,arguments)},a._crypto_generichash_bytes_min=function(){return(a._crypto_generichash_bytes_min=a.asm.ja).apply(null,arguments)},a._crypto_generichash_bytes_max=function(){return(a._crypto_generichash_bytes_max=a.asm.ka).apply(null,arguments)},a._crypto_generichash_bytes=function(){return(a._crypto_generichash_bytes=a.asm.la).apply(null,arguments)},a._crypto_generichash_keybytes_min=function(){return(a._crypto_generichash_keybytes_min=a.asm.ma).apply(null,arguments)},a._crypto_generichash_keybytes_max=function(){return(a._crypto_generichash_keybytes_max=a.asm.na).apply(null,arguments)},a._crypto_generichash_keybytes=function(){return(a._crypto_generichash_keybytes=a.asm.oa).apply(null,arguments)},a._crypto_generichash_statebytes=function(){return(a._crypto_generichash_statebytes=a.asm.pa).apply(null,arguments)},a._crypto_generichash=function(){return(a._crypto_generichash=a.asm.qa).apply(null,arguments)},a._crypto_generichash_init=function(){return(a._crypto_generichash_init=a.asm.ra).apply(null,arguments)},a._crypto_generichash_update=function(){return(a._crypto_generichash_update=a.asm.sa).apply(null,arguments)},a._crypto_generichash_final=function(){return(a._crypto_generichash_final=a.asm.ta).apply(null,arguments)},a._crypto_generichash_keygen=function(){return(a._crypto_generichash_keygen=a.asm.ua).apply(null,arguments)},a._crypto_hash_bytes=function(){return(a._crypto_hash_bytes=a.asm.va).apply(null,arguments)},a._crypto_hash=function(){return(a._crypto_hash=a.asm.wa).apply(null,arguments)},a._crypto_kdf_bytes_min=function(){return(a._crypto_kdf_bytes_min=a.asm.xa).apply(null,arguments)},a._crypto_kdf_bytes_max=function(){return(a._crypto_kdf_bytes_max=a.asm.ya).apply(null,arguments)},a._crypto_kdf_contextbytes=function(){return(a._crypto_kdf_contextbytes=a.asm.za).apply(null,arguments)},a._crypto_kdf_keybytes=function(){return(a._crypto_kdf_keybytes=a.asm.Aa).apply(null,arguments)},a._crypto_kdf_derive_from_key=function(){return(a._crypto_kdf_derive_from_key=a.asm.Ba).apply(null,arguments)},a._crypto_kdf_keygen=function(){return(a._crypto_kdf_keygen=a.asm.Ca).apply(null,arguments)},a._crypto_kx_seed_keypair=function(){return(a._crypto_kx_seed_keypair=a.asm.Da).apply(null,arguments)},a._crypto_kx_keypair=function(){return(a._crypto_kx_keypair=a.asm.Ea).apply(null,arguments)},a._crypto_kx_client_session_keys=function(){return(a._crypto_kx_client_session_keys=a.asm.Fa).apply(null,arguments)},a._crypto_kx_server_session_keys=function(){return(a._crypto_kx_server_session_keys=a.asm.Ga).apply(null,arguments)},a._crypto_kx_publickeybytes=function(){return(a._crypto_kx_publickeybytes=a.asm.Ha).apply(null,arguments)},a._crypto_kx_secretkeybytes=function(){return(a._crypto_kx_secretkeybytes=a.asm.Ia).apply(null,arguments)},a._crypto_kx_seedbytes=function(){return(a._crypto_kx_seedbytes=a.asm.Ja).apply(null,arguments)},a._crypto_kx_sessionkeybytes=function(){return(a._crypto_kx_sessionkeybytes=a.asm.Ka).apply(null,arguments)},a._crypto_pwhash_alg_argon2i13=function(){return(a._crypto_pwhash_alg_argon2i13=a.asm.La).apply(null,arguments)},a._crypto_pwhash_alg_argon2id13=function(){return(a._crypto_pwhash_alg_argon2id13=a.asm.Ma).apply(null,arguments)},a._crypto_pwhash_alg_default=function(){return(a._crypto_pwhash_alg_default=a.asm.Na).apply(null,arguments)},a._crypto_pwhash_bytes_min=function(){return(a._crypto_pwhash_bytes_min=a.asm.Oa).apply(null,arguments)},a._crypto_pwhash_bytes_max=function(){return(a._crypto_pwhash_bytes_max=a.asm.Pa).apply(null,arguments)},a._crypto_pwhash_passwd_min=function(){return(a._crypto_pwhash_passwd_min=a.asm.Qa).apply(null,arguments)},a._crypto_pwhash_passwd_max=function(){return(a._crypto_pwhash_passwd_max=a.asm.Ra).apply(null,arguments)},a._crypto_pwhash_saltbytes=function(){return(a._crypto_pwhash_saltbytes=a.asm.Sa).apply(null,arguments)},a._crypto_pwhash_strbytes=function(){return(a._crypto_pwhash_strbytes=a.asm.Ta).apply(null,arguments)},a._crypto_pwhash_strprefix=function(){return(a._crypto_pwhash_strprefix=a.asm.Ua).apply(null,arguments)},a._crypto_pwhash_opslimit_min=function(){return(a._crypto_pwhash_opslimit_min=a.asm.Va).apply(null,arguments)},a._crypto_pwhash_opslimit_max=function(){return(a._crypto_pwhash_opslimit_max=a.asm.Wa).apply(null,arguments)},a._crypto_pwhash_memlimit_min=function(){return(a._crypto_pwhash_memlimit_min=a.asm.Xa).apply(null,arguments)},a._crypto_pwhash_memlimit_max=function(){return(a._crypto_pwhash_memlimit_max=a.asm.Ya).apply(null,arguments)},a._crypto_pwhash_opslimit_interactive=function(){return(a._crypto_pwhash_opslimit_interactive=a.asm.Za).apply(null,arguments)},a._crypto_pwhash_memlimit_interactive=function(){return(a._crypto_pwhash_memlimit_interactive=a.asm._a).apply(null,arguments)},a._crypto_pwhash_opslimit_moderate=function(){return(a._crypto_pwhash_opslimit_moderate=a.asm.$a).apply(null,arguments)},a._crypto_pwhash_memlimit_moderate=function(){return(a._crypto_pwhash_memlimit_moderate=a.asm.ab).apply(null,arguments)},a._crypto_pwhash_opslimit_sensitive=function(){return(a._crypto_pwhash_opslimit_sensitive=a.asm.bb).apply(null,arguments)},a._crypto_pwhash_memlimit_sensitive=function(){return(a._crypto_pwhash_memlimit_sensitive=a.asm.cb).apply(null,arguments)},a._crypto_pwhash=function(){return(a._crypto_pwhash=a.asm.db).apply(null,arguments)},a._crypto_pwhash_str=function(){return(a._crypto_pwhash_str=a.asm.eb).apply(null,arguments)},a._crypto_pwhash_str_alg=function(){return(a._crypto_pwhash_str_alg=a.asm.fb).apply(null,arguments)},a._crypto_pwhash_str_verify=function(){return(a._crypto_pwhash_str_verify=a.asm.gb).apply(null,arguments)},a._crypto_pwhash_str_needs_rehash=function(){return(a._crypto_pwhash_str_needs_rehash=a.asm.hb).apply(null,arguments)},a._crypto_scalarmult_base=function(){return(a._crypto_scalarmult_base=a.asm.ib).apply(null,arguments)},a._crypto_scalarmult=function(){return(a._crypto_scalarmult=a.asm.jb).apply(null,arguments)},a._crypto_scalarmult_bytes=function(){return(a._crypto_scalarmult_bytes=a.asm.kb).apply(null,arguments)},a._crypto_scalarmult_scalarbytes=function(){return(a._crypto_scalarmult_scalarbytes=a.asm.lb).apply(null,arguments)},a._crypto_secretbox_keybytes=function(){return(a._crypto_secretbox_keybytes=a.asm.mb).apply(null,arguments)},a._crypto_secretbox_noncebytes=function(){return(a._crypto_secretbox_noncebytes=a.asm.nb).apply(null,arguments)},a._crypto_secretbox_macbytes=function(){return(a._crypto_secretbox_macbytes=a.asm.ob).apply(null,arguments)},a._crypto_secretbox_messagebytes_max=function(){return(a._crypto_secretbox_messagebytes_max=a.asm.pb).apply(null,arguments)},a._crypto_secretbox_keygen=function(){return(a._crypto_secretbox_keygen=a.asm.qb).apply(null,arguments)},a._crypto_secretbox_detached=function(){return(a._crypto_secretbox_detached=a.asm.rb).apply(null,arguments)},a._crypto_secretbox_easy=function(){return(a._crypto_secretbox_easy=a.asm.sb).apply(null,arguments)},a._crypto_secretbox_open_detached=function(){return(a._crypto_secretbox_open_detached=a.asm.tb).apply(null,arguments)},a._crypto_secretbox_open_easy=function(){return(a._crypto_secretbox_open_easy=a.asm.ub).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_keygen=function(){return(a._crypto_secretstream_xchacha20poly1305_keygen=a.asm.vb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_init_push=function(){return(a._crypto_secretstream_xchacha20poly1305_init_push=a.asm.wb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_init_pull=function(){return(a._crypto_secretstream_xchacha20poly1305_init_pull=a.asm.xb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_rekey=function(){return(a._crypto_secretstream_xchacha20poly1305_rekey=a.asm.yb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_push=function(){return(a._crypto_secretstream_xchacha20poly1305_push=a.asm.zb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_pull=function(){return(a._crypto_secretstream_xchacha20poly1305_pull=a.asm.Ab).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_statebytes=function(){return(a._crypto_secretstream_xchacha20poly1305_statebytes=a.asm.Bb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_abytes=function(){return(a._crypto_secretstream_xchacha20poly1305_abytes=a.asm.Cb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_headerbytes=function(){return(a._crypto_secretstream_xchacha20poly1305_headerbytes=a.asm.Db).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_keybytes=function(){return(a._crypto_secretstream_xchacha20poly1305_keybytes=a.asm.Eb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_messagebytes_max=function(){return(a._crypto_secretstream_xchacha20poly1305_messagebytes_max=a.asm.Fb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_tag_message=function(){return(a._crypto_secretstream_xchacha20poly1305_tag_message=a.asm.Gb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_tag_push=function(){return(a._crypto_secretstream_xchacha20poly1305_tag_push=a.asm.Hb).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_tag_rekey=function(){return(a._crypto_secretstream_xchacha20poly1305_tag_rekey=a.asm.Ib).apply(null,arguments)},a._crypto_secretstream_xchacha20poly1305_tag_final=function(){return(a._crypto_secretstream_xchacha20poly1305_tag_final=a.asm.Jb).apply(null,arguments)},a._crypto_shorthash_bytes=function(){return(a._crypto_shorthash_bytes=a.asm.Kb).apply(null,arguments)},a._crypto_shorthash_keybytes=function(){return(a._crypto_shorthash_keybytes=a.asm.Lb).apply(null,arguments)},a._crypto_shorthash=function(){return(a._crypto_shorthash=a.asm.Mb).apply(null,arguments)},a._crypto_shorthash_keygen=function(){return(a._crypto_shorthash_keygen=a.asm.Nb).apply(null,arguments)},a._crypto_sign_statebytes=function(){return(a._crypto_sign_statebytes=a.asm.Ob).apply(null,arguments)},a._crypto_sign_bytes=function(){return(a._crypto_sign_bytes=a.asm.Pb).apply(null,arguments)},a._crypto_sign_seedbytes=function(){return(a._crypto_sign_seedbytes=a.asm.Qb).apply(null,arguments)},a._crypto_sign_publickeybytes=function(){return(a._crypto_sign_publickeybytes=a.asm.Rb).apply(null,arguments)},a._crypto_sign_secretkeybytes=function(){return(a._crypto_sign_secretkeybytes=a.asm.Sb).apply(null,arguments)},a._crypto_sign_messagebytes_max=function(){return(a._crypto_sign_messagebytes_max=a.asm.Tb).apply(null,arguments)},a._crypto_sign_seed_keypair=function(){return(a._crypto_sign_seed_keypair=a.asm.Ub).apply(null,arguments)},a._crypto_sign_keypair=function(){return(a._crypto_sign_keypair=a.asm.Vb).apply(null,arguments)},a._crypto_sign=function(){return(a._crypto_sign=a.asm.Wb).apply(null,arguments)},a._crypto_sign_open=function(){return(a._crypto_sign_open=a.asm.Xb).apply(null,arguments)},a._crypto_sign_detached=function(){return(a._crypto_sign_detached=a.asm.Yb).apply(null,arguments)},a._crypto_sign_verify_detached=function(){return(a._crypto_sign_verify_detached=a.asm.Zb).apply(null,arguments)},a._crypto_sign_init=function(){return(a._crypto_sign_init=a.asm._b).apply(null,arguments)},a._crypto_sign_update=function(){return(a._crypto_sign_update=a.asm.$b).apply(null,arguments)},a._crypto_sign_final_create=function(){return(a._crypto_sign_final_create=a.asm.ac).apply(null,arguments)},a._crypto_sign_final_verify=function(){return(a._crypto_sign_final_verify=a.asm.bc).apply(null,arguments)},a._crypto_sign_ed25519_pk_to_curve25519=function(){return(a._crypto_sign_ed25519_pk_to_curve25519=a.asm.cc).apply(null,arguments)},a._crypto_sign_ed25519_sk_to_curve25519=function(){return(a._crypto_sign_ed25519_sk_to_curve25519=a.asm.dc).apply(null,arguments)},a._randombytes_random=function(){return(a._randombytes_random=a.asm.ec).apply(null,arguments)},a._randombytes_stir=function(){return(a._randombytes_stir=a.asm.fc).apply(null,arguments)},a._randombytes_uniform=function(){return(a._randombytes_uniform=a.asm.gc).apply(null,arguments)},a._randombytes_buf=function(){return(a._randombytes_buf=a.asm.hc).apply(null,arguments)},a._randombytes_buf_deterministic=function(){return(a._randombytes_buf_deterministic=a.asm.ic).apply(null,arguments)},a._randombytes_seedbytes=function(){return(a._randombytes_seedbytes=a.asm.jc).apply(null,arguments)},a._randombytes_close=function(){return(a._randombytes_close=a.asm.kc).apply(null,arguments)},a._randombytes=function(){return(a._randombytes=a.asm.lc).apply(null,arguments)},a._sodium_bin2hex=function(){return(a._sodium_bin2hex=a.asm.mc).apply(null,arguments)},a._sodium_hex2bin=function(){return(a._sodium_hex2bin=a.asm.nc).apply(null,arguments)},a._sodium_base64_encoded_len=function(){return(a._sodium_base64_encoded_len=a.asm.oc).apply(null,arguments)},a._sodium_bin2base64=function(){return(a._sodium_bin2base64=a.asm.pc).apply(null,arguments)},a._sodium_base642bin=function(){return(a._sodium_base642bin=a.asm.qc).apply(null,arguments)},a._sodium_init=function(){return(a._sodium_init=a.asm.rc).apply(null,arguments)},a._sodium_pad=function(){return(a._sodium_pad=a.asm.sc).apply(null,arguments)},a._sodium_unpad=function(){return(a._sodium_unpad=a.asm.tc).apply(null,arguments)},a._sodium_version_string=function(){return(a._sodium_version_string=a.asm.uc).apply(null,arguments)},a._sodium_library_version_major=function(){return(a._sodium_library_version_major=a.asm.vc).apply(null,arguments)},a._sodium_library_version_minor=function(){return(a._sodium_library_version_minor=a.asm.wc).apply(null,arguments)},a._sodium_library_minimal=function(){return(a._sodium_library_minimal=a.asm.xc).apply(null,arguments)},a._malloc=function(){return(a._malloc=a.asm.yc).apply(null,arguments)},a._free=function(){return(a._free=a.asm.zc).apply(null,arguments)},a.setValue=function(A,I,g="i8",B){switch("*"===g.charAt(g.length-1)&&(g="i32"),g){case"i1":case"i8":h[A>>0]=I;break;case"i16":u[A>>1]=I;break;case"i32":F[A>>2]=I;break;case"i64":x=[I>>>0,(J=I,+Math.abs(J)>=1?J>0?(0|Math.min(+Math.floor(J/4294967296),4294967295))>>>0:~~+Math.ceil((J-+(~~J>>>0))/4294967296)>>>0:0)],F[A>>2]=x[0],F[A+4>>2]=x[1];break;case"float":l[A>>2]=I;break;case"double":_[A>>3]=I;break;default:N("invalid type for setValue: "+g)}},a.getValue=function(A,I="i8",g){switch("*"===I.charAt(I.length-1)&&(I="i32"),I){case"i1":case"i8":return h[A>>0];case"i16":return u[A>>1];case"i32":case"i64":return F[A>>2];case"float":return l[A>>2];case"double":return Number(_[A>>3]);default:N("invalid type for getValue: "+I)}return null},a.UTF8ToString=G,Y=function A(){$||IA(),$||(Y=A)},a.run=IA,a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();IA()})).catch((function(){return B.useBackupModule()})),I} true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (I),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0}(this);


/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(/*! yallist */ "./node_modules/yallist/yallist.js")

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache


/***/ }),

/***/ "./node_modules/minimatch/minimatch.js":
/*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return __webpack_require__(/*! path */ "path") } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(/*! brace-expansion */ "./node_modules/brace-expansion/index.js")

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ "./node_modules/once/once.js":
/*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(/*! wrappy */ "./node_modules/wrappy/wrappy.js")
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ "./node_modules/ssh-config/index.js":
/*!******************************************!*\
  !*** ./node_modules/ssh-config/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const glob = __webpack_require__(/*! ./src/glob */ "./node_modules/ssh-config/src/glob.js")

const RE_SPACE = /\s/
const RE_LINE_BREAK = /\r|\n/
const RE_SECTION_DIRECTIVE = /^(Host|Match)$/i

const DIRECTIVE = 1
const COMMENT = 2

function compare(line, opts) {
  return opts.hasOwnProperty(line.param) && opts[line.param] === line.value
}

class SSHConfig extends Array {
  /**
   * Query ssh config by host.
   *
   * @return {Object} The applied options of current Host
   */
  compute(host) {
    const obj = {}
    const setProperty = (name, value) => {
      if (name === 'IdentityFile') {
        const list = obj[name] || (obj[name] = [])
        list.push(value)
      }
      else if (obj[name] == null) {
        obj[name] = value
      }
    }

    for (const line of this) {
      if (line.type !== DIRECTIVE) continue
      if (line.param === 'Host') {
        if (glob(line.value, host)) {
          setProperty(line.param, line.value)

          line.config
            .filter(line => line.type === DIRECTIVE)
            .forEach(line => setProperty(line.param, line.value))
        }
      }
      else if (line.param === 'Match') {
        // TODO
      }
      else {
        setProperty(line.param, line.value)
      }
    }

    return obj
  }

  /**
   * find section by Host or Match
   */
  find(opts = {}) {
    if (typeof opts === 'function') return super.find(opts)

    if (!(opts && ('Host' in opts || 'Match' in opts))) {
      throw new Error('Can only find by Host or Match')
    }

    return super.find(line => compare(line, opts))
  }

  /**
   * Remove section
   */
  remove(opts = {}) {
    if (!(opts && ('Host' in opts || 'Match' in opts))) {
      throw new Error('Can only remove by Host or Match')
    }

    const index = typeof opts === 'function'
      ? super.findIndex(opts)
      : super.findIndex(line => compare(line, opts))

    if (index >= 0) return this.splice(index, 1)
  }

  /**
   * toString()
   */
  toString() {
    return this.constructor.stringify(this)
  }


  /**
   * Append new section to existing ssh config.
   */
  append(opts) {
    let indent = '  '

    outer:
    for (const line of this) {
      if (RE_SECTION_DIRECTIVE.test(line.param)) {
        for (const subline of line.config) {
          if (subline.before) {
            indent = subline.before
            break outer
          }
        }
      }
    }

    const lastEntry = this.length > 0 ? this[this.length - 1] : null
    let config = lastEntry && lastEntry.config || this
    let configWas = this

    let lastLine = config.length > 0 ? config[config.length - 1] : lastEntry
    if (lastLine && !lastLine.after) lastLine.after = '\n'

    for (const param in opts) {
      const line = {
        type: DIRECTIVE,
        param,
        separator: ' ',
        value: opts[param],
        before: '',
        after: '\n'
      }

      if (RE_SECTION_DIRECTIVE.test(param)) {
        config = configWas
        // separate sections with an extra newline
        // https://github.com/cyjake/ssh-config/issues/23#issuecomment-564768248
        if (lastLine && lastLine.after === '\n') lastLine.after += '\n'
        config.push(line)
        config = line.config = new SSHConfig()
      } else {
        line.before = config === configWas ? '' : indent
        config.push(line)
      }
      lastLine = line
    }

    return configWas
  }

  /**
   * Stringify structured object into ssh config text
   */
  static stringify(config) {
    let str = ''

    const formatValue = (value, quoted) => {
      if (Array.isArray(value)) {
        return value.map(chunk => formatValue(chunk, RE_SPACE.test(chunk))).join(' ')
      }

      return quoted ? `"${value}"` : value
    }

    const format = line => {
      str += line.before

      if (line.type === COMMENT) {
        str += line.content
      }
      else if (line.type === DIRECTIVE) {
        const quoted = line.quoted
          || (/IdentityFile/i.test(line.param) && RE_SPACE.test(line.value))
        const value = formatValue(line.value, quoted)
        str += `${line.param}${line.separator}${value}`
      }

      str += line.after

      if (line.config) {
        line.config.forEach(format)
      }
    }

    config.forEach(format)

    return str
  }

  static get DIRECTIVE() {
    return DIRECTIVE
  }

  static get COMMENT() {
    return COMMENT
  }

  /**
   * Parse ssh config text into structured object.
   */
  static parse(str) {
    let i = 0
    let chr = next()
    let config = new SSHConfig()
    let configWas = config

    function next() {
      return str[i++]
    }

    function space() {
      let spaces = ''

      while (RE_SPACE.test(chr)) {
        spaces += chr
        chr = next()
      }

      return spaces
    }

    function linebreak() {
      let breaks = ''

      while (RE_LINE_BREAK.test(chr)) {
        breaks += chr
        chr = next()
      }

      return breaks
    }

    function parameter() {
      let param = ''

      while (chr && /[^ \t=]/.test(chr)) {
        param += chr
        chr = next()
      }

      return param
    }

    function separator() {
      let sep = space()

      if (chr === '=') {
        sep += chr
        chr = next()
      }

      return sep + space()
    }

    function value() {
      let val = ''
      let quoted = false
      let escaped = false

      while (chr && !RE_LINE_BREAK.test(chr)) {
        // backslash escapes only double quotes
        if (escaped) {
          val += chr === '"' ? chr : `\\${chr}`
          escaped = false
        }
        // ProxyCommand ssh -W "%h:%p" firewall.example.org
        else if (chr === '"' && (!val || quoted)) {
          quoted = !quoted
        }
        else if (chr === '\\') {
          escaped = true
        }
        else {
          val += chr
        }
        chr = next()
      }

      if (quoted || escaped) {
        throw new Error(`Unexpected line break at ${val}`)
      }

      return val.trim()
    }

    function comment() {
      const type = COMMENT
      let content = ''

      while (chr && !RE_LINE_BREAK.test(chr)) {
        content += chr
        chr = next()
      }

      return { type, content }
    }

    // Host *.co.uk
    // Host * !local.dev
    // Host "foo bar"
    function patterns() {
      const results = []
      let val = ''
      let quoted = false
      let escaped = false

      while (chr && !RE_LINE_BREAK.test(chr)) {
        if (escaped) {
          val += chr === '"' ? chr : `\\${chr}`
          escaped = false
        }
        else if (chr === '"') {
          quoted = !quoted
        }
        else if (chr === '\\') {
          escaped = true
        }
        else if (quoted) {
          val += chr
        }
        else if (/[ \t]/.test(chr)) {
          if (val) {
            results.push(val)
            val = ''
          }
          // otherwise ignore the space
        }
        else {
          val += chr
        }

        chr = next()
      }

      if (quoted || escaped) {
        throw new Error(`Unexpected line break at ${results.concat(val).join(' ')}`)
      }
      results.push(val)
      return results.length > 1 ? results : results[0]
    }

    function directive() {
      const type = DIRECTIVE
      const param = parameter()
      // Host "foo bar" baz
      const multiple = param.toLowerCase() == 'host'
      const result = {
        type,
        param,
        separator: separator(),
        quoted: !multiple && chr === '"',
        value: multiple ? patterns() : value()
      }
      if (!result.quoted) delete result.quoted
      return result
    }

    function line() {
      const before = space()
      const node = chr === '#' ? comment() : directive()
      const after = linebreak()

      node.before = before
      node.after = after

      return node
    }


    while (chr) {
      let node = line()

      if (node.type === DIRECTIVE && RE_SECTION_DIRECTIVE.test(node.param)) {
        config = configWas
        config.push(node)
        config = node.config = new SSHConfig()
      }
      else {
        config.push(node)
      }
    }

    return configWas
  }
}

module.exports = SSHConfig


/***/ }),

/***/ "./node_modules/ssh-config/src/glob.js":
/*!*********************************************!*\
  !*** ./node_modules/ssh-config/src/glob.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


function match(pattern, str) {
  pattern = pattern
    .replace(/\./g, '\\.')
    .replace(/\+/g, '\\+')
    .replace(/\*/g, '.*')
    .replace(/\?/g, '.?')

  return new RegExp('^(?:' + pattern + ')$').test(str)
}

/**
 * A helper function to match input against [pattern-list](https://www.freebsd.org/cgi/man.cgi?query=ssh_config&sektion=5#PATTERNS).
 * According to `man ssh_config`, negated patterns shall be matched first.
 *
 * @param {string|string[]} patternList
 * @param {string} str
 */
function glob(patternList, str) {
  const patterns = Array.isArray(patternList) ? patternList : patternList.split(/,/)

  // > If a negated entry is matched, then the Host entry is ignored, regardless of whether any other patterns on the line match.
  let result = false
  for (const pattern of patterns) {
    const negate = pattern[0] == '!'

    if (negate && match(pattern.slice(1), str)) {
      return false
    } else if (match(pattern, str)) {
      // wait until all of the pattern match results because there might be a negated pattern
      result = true
    }
  }

  return result
}

module.exports = glob


/***/ }),

/***/ "./node_modules/tr46/index.js":
/*!************************************!*\
  !*** ./node_modules/tr46/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var punycode = __webpack_require__(/*! punycode */ "punycode");
var mappingTable = __webpack_require__(/*! ./lib/mappingTable.json */ "./node_modules/tr46/lib/mappingTable.json");

var PROCESSING_OPTIONS = {
  TRANSITIONAL: 0,
  NONTRANSITIONAL: 1
};

function normalize(str) { // fix bug in v8
  return str.split('\u0000').map(function (s) { return s.normalize('NFC'); }).join('\u0000');
}

function findStatus(val) {
  var start = 0;
  var end = mappingTable.length - 1;

  while (start <= end) {
    var mid = Math.floor((start + end) / 2);

    var target = mappingTable[mid];
    if (target[0][0] <= val && target[0][1] >= val) {
      return target;
    } else if (target[0][0] > val) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return null;
}

var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function countSymbols(string) {
  return string
    // replace every surrogate pair with a BMP symbol
    .replace(regexAstralSymbols, '_')
    // then get the length
    .length;
}

function mapChars(domain_name, useSTD3, processing_option) {
  var hasError = false;
  var processed = "";

  var len = countSymbols(domain_name);
  for (var i = 0; i < len; ++i) {
    var codePoint = domain_name.codePointAt(i);
    var status = findStatus(codePoint);

    switch (status[1]) {
      case "disallowed":
        hasError = true;
        processed += String.fromCodePoint(codePoint);
        break;
      case "ignored":
        break;
      case "mapped":
        processed += String.fromCodePoint.apply(String, status[2]);
        break;
      case "deviation":
        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
          processed += String.fromCodePoint.apply(String, status[2]);
        } else {
          processed += String.fromCodePoint(codePoint);
        }
        break;
      case "valid":
        processed += String.fromCodePoint(codePoint);
        break;
      case "disallowed_STD3_mapped":
        if (useSTD3) {
          hasError = true;
          processed += String.fromCodePoint(codePoint);
        } else {
          processed += String.fromCodePoint.apply(String, status[2]);
        }
        break;
      case "disallowed_STD3_valid":
        if (useSTD3) {
          hasError = true;
        }

        processed += String.fromCodePoint(codePoint);
        break;
    }
  }

  return {
    string: processed,
    error: hasError
  };
}

var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;

function validateLabel(label, processing_option) {
  if (label.substr(0, 4) === "xn--") {
    label = punycode.toUnicode(label);
    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
  }

  var error = false;

  if (normalize(label) !== label ||
      (label[3] === "-" && label[4] === "-") ||
      label[0] === "-" || label[label.length - 1] === "-" ||
      label.indexOf(".") !== -1 ||
      label.search(combiningMarksRegex) === 0) {
    error = true;
  }

  var len = countSymbols(label);
  for (var i = 0; i < len; ++i) {
    var status = findStatus(label.codePointAt(i));
    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid") ||
        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&
         status[1] !== "valid" && status[1] !== "deviation")) {
      error = true;
      break;
    }
  }

  return {
    label: label,
    error: error
  };
}

function processing(domain_name, useSTD3, processing_option) {
  var result = mapChars(domain_name, useSTD3, processing_option);
  result.string = normalize(result.string);

  var labels = result.string.split(".");
  for (var i = 0; i < labels.length; ++i) {
    try {
      var validation = validateLabel(labels[i]);
      labels[i] = validation.label;
      result.error = result.error || validation.error;
    } catch(e) {
      result.error = true;
    }
  }

  return {
    string: labels.join("."),
    error: result.error
  };
}

module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
  var result = processing(domain_name, useSTD3, processing_option);
  var labels = result.string.split(".");
  labels = labels.map(function(l) {
    try {
      return punycode.toASCII(l);
    } catch(e) {
      result.error = true;
      return l;
    }
  });

  if (verifyDnsLength) {
    var total = labels.slice(0, labels.length - 1).join(".").length;
    if (total.length > 253 || total.length === 0) {
      result.error = true;
    }

    for (var i=0; i < labels.length; ++i) {
      if (labels.length > 63 || labels.length === 0) {
        result.error = true;
        break;
      }
    }
  }

  if (result.error) return null;
  return labels.join(".");
};

module.exports.toUnicode = function(domain_name, useSTD3) {
  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);

  return {
    domain: result.string,
    error: result.error
  };
};

module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;


/***/ }),

/***/ "./node_modules/undici/index.js":
/*!**************************************!*\
  !*** ./node_modules/undici/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Client = __webpack_require__(/*! ./lib/dispatcher/client */ "./node_modules/undici/lib/dispatcher/client.js")
const Dispatcher = __webpack_require__(/*! ./lib/dispatcher/dispatcher */ "./node_modules/undici/lib/dispatcher/dispatcher.js")
const Pool = __webpack_require__(/*! ./lib/dispatcher/pool */ "./node_modules/undici/lib/dispatcher/pool.js")
const BalancedPool = __webpack_require__(/*! ./lib/dispatcher/balanced-pool */ "./node_modules/undici/lib/dispatcher/balanced-pool.js")
const Agent = __webpack_require__(/*! ./lib/dispatcher/agent */ "./node_modules/undici/lib/dispatcher/agent.js")
const ProxyAgent = __webpack_require__(/*! ./lib/dispatcher/proxy-agent */ "./node_modules/undici/lib/dispatcher/proxy-agent.js")
const RetryAgent = __webpack_require__(/*! ./lib/dispatcher/retry-agent */ "./node_modules/undici/lib/dispatcher/retry-agent.js")
const errors = __webpack_require__(/*! ./lib/core/errors */ "./node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ./lib/core/util */ "./node_modules/undici/lib/core/util.js")
const { InvalidArgumentError } = errors
const api = __webpack_require__(/*! ./lib/api */ "./node_modules/undici/lib/api/index.js")
const buildConnector = __webpack_require__(/*! ./lib/core/connect */ "./node_modules/undici/lib/core/connect.js")
const MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ "./node_modules/undici/lib/mock/mock-client.js")
const MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ "./node_modules/undici/lib/mock/mock-agent.js")
const MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ "./node_modules/undici/lib/mock/mock-pool.js")
const mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ "./node_modules/undici/lib/mock/mock-errors.js")
const RetryHandler = __webpack_require__(/*! ./lib/handler/retry-handler */ "./node_modules/undici/lib/handler/retry-handler.js")
const { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ "./node_modules/undici/lib/global.js")
const DecoratorHandler = __webpack_require__(/*! ./lib/handler/decorator-handler */ "./node_modules/undici/lib/handler/decorator-handler.js")
const RedirectHandler = __webpack_require__(/*! ./lib/handler/redirect-handler */ "./node_modules/undici/lib/handler/redirect-handler.js")
const createRedirectInterceptor = __webpack_require__(/*! ./lib/interceptor/redirect-interceptor */ "./node_modules/undici/lib/interceptor/redirect-interceptor.js")

Object.assign(Dispatcher.prototype, api)

module.exports.Dispatcher = Dispatcher
module.exports.Client = Client
module.exports.Pool = Pool
module.exports.BalancedPool = BalancedPool
module.exports.Agent = Agent
module.exports.ProxyAgent = ProxyAgent
module.exports.RetryAgent = RetryAgent
module.exports.RetryHandler = RetryHandler

module.exports.DecoratorHandler = DecoratorHandler
module.exports.RedirectHandler = RedirectHandler
module.exports.createRedirectInterceptor = createRedirectInterceptor

module.exports.buildConnector = buildConnector
module.exports.errors = errors
module.exports.util = {
  parseHeaders: util.parseHeaders,
  headerNameToString: util.headerNameToString
}

function makeDispatcher (fn) {
  return (url, opts, handler) => {
    if (typeof opts === 'function') {
      handler = opts
      opts = null
    }

    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {
      throw new InvalidArgumentError('invalid url')
    }

    if (opts != null && typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    if (opts && opts.path != null) {
      if (typeof opts.path !== 'string') {
        throw new InvalidArgumentError('invalid opts.path')
      }

      let path = opts.path
      if (!opts.path.startsWith('/')) {
        path = `/${path}`
      }

      url = new URL(util.parseOrigin(url).origin + path)
    } else {
      if (!opts) {
        opts = typeof url === 'object' ? url : {}
      }

      url = util.parseURL(url)
    }

    const { agent, dispatcher = getGlobalDispatcher() } = opts

    if (agent) {
      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')
    }

    return fn.call(dispatcher, {
      ...opts,
      origin: url.origin,
      path: url.search ? `${url.pathname}${url.search}` : url.pathname,
      method: opts.method || (opts.body ? 'PUT' : 'GET')
    }, handler)
  }
}

module.exports.setGlobalDispatcher = setGlobalDispatcher
module.exports.getGlobalDispatcher = getGlobalDispatcher

const fetchImpl = (__webpack_require__(/*! ./lib/web/fetch */ "./node_modules/undici/lib/web/fetch/index.js").fetch)
module.exports.fetch = async function fetch (init, options = undefined) {
  try {
    return await fetchImpl(init, options)
  } catch (err) {
    if (err && typeof err === 'object') {
      Error.captureStackTrace(err, this)
    }

    throw err
  }
}
module.exports.Headers = __webpack_require__(/*! ./lib/web/fetch/headers */ "./node_modules/undici/lib/web/fetch/headers.js").Headers
module.exports.Response = __webpack_require__(/*! ./lib/web/fetch/response */ "./node_modules/undici/lib/web/fetch/response.js").Response
module.exports.Request = __webpack_require__(/*! ./lib/web/fetch/request */ "./node_modules/undici/lib/web/fetch/request.js").Request
module.exports.FormData = __webpack_require__(/*! ./lib/web/fetch/formdata */ "./node_modules/undici/lib/web/fetch/formdata.js").FormData
module.exports.File = __webpack_require__(/*! ./lib/web/fetch/file */ "./node_modules/undici/lib/web/fetch/file.js").File
module.exports.FileReader = __webpack_require__(/*! ./lib/web/fileapi/filereader */ "./node_modules/undici/lib/web/fileapi/filereader.js").FileReader

const { setGlobalOrigin, getGlobalOrigin } = __webpack_require__(/*! ./lib/web/fetch/global */ "./node_modules/undici/lib/web/fetch/global.js")

module.exports.setGlobalOrigin = setGlobalOrigin
module.exports.getGlobalOrigin = getGlobalOrigin

const { CacheStorage } = __webpack_require__(/*! ./lib/web/cache/cachestorage */ "./node_modules/undici/lib/web/cache/cachestorage.js")
const { kConstruct } = __webpack_require__(/*! ./lib/web/cache/symbols */ "./node_modules/undici/lib/web/cache/symbols.js")

// Cache & CacheStorage are tightly coupled with fetch. Even if it may run
// in an older version of Node, it doesn't have any use without fetch.
module.exports.caches = new CacheStorage(kConstruct)

const { deleteCookie, getCookies, getSetCookies, setCookie } = __webpack_require__(/*! ./lib/web/cookies */ "./node_modules/undici/lib/web/cookies/index.js")

module.exports.deleteCookie = deleteCookie
module.exports.getCookies = getCookies
module.exports.getSetCookies = getSetCookies
module.exports.setCookie = setCookie

const { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./lib/web/fetch/data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")

module.exports.parseMIMEType = parseMIMEType
module.exports.serializeAMimeType = serializeAMimeType

const { CloseEvent, ErrorEvent, MessageEvent } = __webpack_require__(/*! ./lib/web/websocket/events */ "./node_modules/undici/lib/web/websocket/events.js")
module.exports.WebSocket = __webpack_require__(/*! ./lib/web/websocket/websocket */ "./node_modules/undici/lib/web/websocket/websocket.js").WebSocket
module.exports.CloseEvent = CloseEvent
module.exports.ErrorEvent = ErrorEvent
module.exports.MessageEvent = MessageEvent

module.exports.request = makeDispatcher(api.request)
module.exports.stream = makeDispatcher(api.stream)
module.exports.pipeline = makeDispatcher(api.pipeline)
module.exports.connect = makeDispatcher(api.connect)
module.exports.upgrade = makeDispatcher(api.upgrade)

module.exports.MockClient = MockClient
module.exports.MockPool = MockPool
module.exports.MockAgent = MockAgent
module.exports.mockErrors = mockErrors

const { EventSource } = __webpack_require__(/*! ./lib/web/eventsource/eventsource */ "./node_modules/undici/lib/web/eventsource/eventsource.js")

module.exports.EventSource = EventSource


/***/ }),

/***/ "./node_modules/undici/lib/api/abort-signal.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/abort-signal.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { addAbortListener } = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")

const kListener = Symbol('kListener')
const kSignal = Symbol('kSignal')

function abort (self) {
  if (self.abort) {
    self.abort(self[kSignal]?.reason)
  } else {
    self.onError(self[kSignal]?.reason ?? new RequestAbortedError())
  }
}

function addSignal (self, signal) {
  self[kSignal] = null
  self[kListener] = null

  if (!signal) {
    return
  }

  if (signal.aborted) {
    abort(self)
    return
  }

  self[kSignal] = signal
  self[kListener] = () => {
    abort(self)
  }

  addAbortListener(self[kSignal], self[kListener])
}

function removeSignal (self) {
  if (!self[kSignal]) {
    return
  }

  if ('removeEventListener' in self[kSignal]) {
    self[kSignal].removeEventListener('abort', self[kListener])
  } else {
    self[kSignal].removeListener('abort', self[kListener])
  }

  self[kSignal] = null
  self[kListener] = null
}

module.exports = {
  addSignal,
  removeSignal
}


/***/ }),

/***/ "./node_modules/undici/lib/api/api-connect.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-connect.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { AsyncResource } = __webpack_require__(/*! node:async_hooks */ "node:async_hooks")
const { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ "./node_modules/undici/lib/api/abort-signal.js")

class ConnectHandler extends AsyncResource {
  constructor (opts, callback) {
    if (!opts || typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    if (typeof callback !== 'function') {
      throw new InvalidArgumentError('invalid callback')
    }

    const { signal, opaque, responseHeaders } = opts

    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
    }

    super('UNDICI_CONNECT')

    this.opaque = opaque || null
    this.responseHeaders = responseHeaders || null
    this.callback = callback
    this.abort = null

    addSignal(this, signal)
  }

  onConnect (abort, context) {
    if (!this.callback) {
      throw new RequestAbortedError()
    }

    this.abort = abort
    this.context = context
  }

  onHeaders () {
    throw new SocketError('bad connect', null)
  }

  onUpgrade (statusCode, rawHeaders, socket) {
    const { callback, opaque, context } = this

    removeSignal(this)

    this.callback = null

    let headers = rawHeaders
    // Indicates is an HTTP2Session
    if (headers != null) {
      headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)
    }

    this.runInAsyncScope(callback, null, null, {
      statusCode,
      headers,
      socket,
      opaque,
      context
    })
  }

  onError (err) {
    const { callback, opaque } = this

    removeSignal(this)

    if (callback) {
      this.callback = null
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque })
      })
    }
  }
}

function connect (opts, callback) {
  if (callback === undefined) {
    return new Promise((resolve, reject) => {
      connect.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve(data)
      })
    })
  }

  try {
    const connectHandler = new ConnectHandler(opts, callback)
    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler)
  } catch (err) {
    if (typeof callback !== 'function') {
      throw err
    }
    const opaque = opts?.opaque
    queueMicrotask(() => callback(err, { opaque }))
  }
}

module.exports = connect


/***/ }),

/***/ "./node_modules/undici/lib/api/api-pipeline.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-pipeline.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Readable,
  Duplex,
  PassThrough
} = __webpack_require__(/*! node:stream */ "node:stream")
const {
  InvalidArgumentError,
  InvalidReturnValueError,
  RequestAbortedError
} = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const { AsyncResource } = __webpack_require__(/*! node:async_hooks */ "node:async_hooks")
const { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ "./node_modules/undici/lib/api/abort-signal.js")
const assert = __webpack_require__(/*! node:assert */ "node:assert")

const kResume = Symbol('resume')

class PipelineRequest extends Readable {
  constructor () {
    super({ autoDestroy: true })

    this[kResume] = null
  }

  _read () {
    const { [kResume]: resume } = this

    if (resume) {
      this[kResume] = null
      resume()
    }
  }

  _destroy (err, callback) {
    this._read()

    callback(err)
  }
}

class PipelineResponse extends Readable {
  constructor (resume) {
    super({ autoDestroy: true })
    this[kResume] = resume
  }

  _read () {
    this[kResume]()
  }

  _destroy (err, callback) {
    if (!err && !this._readableState.endEmitted) {
      err = new RequestAbortedError()
    }

    callback(err)
  }
}

class PipelineHandler extends AsyncResource {
  constructor (opts, handler) {
    if (!opts || typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    if (typeof handler !== 'function') {
      throw new InvalidArgumentError('invalid handler')
    }

    const { signal, method, opaque, onInfo, responseHeaders } = opts

    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
    }

    if (method === 'CONNECT') {
      throw new InvalidArgumentError('invalid method')
    }

    if (onInfo && typeof onInfo !== 'function') {
      throw new InvalidArgumentError('invalid onInfo callback')
    }

    super('UNDICI_PIPELINE')

    this.opaque = opaque || null
    this.responseHeaders = responseHeaders || null
    this.handler = handler
    this.abort = null
    this.context = null
    this.onInfo = onInfo || null

    this.req = new PipelineRequest().on('error', util.nop)

    this.ret = new Duplex({
      readableObjectMode: opts.objectMode,
      autoDestroy: true,
      read: () => {
        const { body } = this

        if (body?.resume) {
          body.resume()
        }
      },
      write: (chunk, encoding, callback) => {
        const { req } = this

        if (req.push(chunk, encoding) || req._readableState.destroyed) {
          callback()
        } else {
          req[kResume] = callback
        }
      },
      destroy: (err, callback) => {
        const { body, req, res, ret, abort } = this

        if (!err && !ret._readableState.endEmitted) {
          err = new RequestAbortedError()
        }

        if (abort && err) {
          abort()
        }

        util.destroy(body, err)
        util.destroy(req, err)
        util.destroy(res, err)

        removeSignal(this)

        callback(err)
      }
    }).on('prefinish', () => {
      const { req } = this

      // Node < 15 does not call _final in same tick.
      req.push(null)
    })

    this.res = null

    addSignal(this, signal)
  }

  onConnect (abort, context) {
    const { ret, res } = this

    assert(!res, 'pipeline cannot be retried')

    if (ret.destroyed) {
      throw new RequestAbortedError()
    }

    this.abort = abort
    this.context = context
  }

  onHeaders (statusCode, rawHeaders, resume) {
    const { opaque, handler, context } = this

    if (statusCode < 200) {
      if (this.onInfo) {
        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)
        this.onInfo({ statusCode, headers })
      }
      return
    }

    this.res = new PipelineResponse(resume)

    let body
    try {
      this.handler = null
      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)
      body = this.runInAsyncScope(handler, null, {
        statusCode,
        headers,
        opaque,
        body: this.res,
        context
      })
    } catch (err) {
      this.res.on('error', util.nop)
      throw err
    }

    if (!body || typeof body.on !== 'function') {
      throw new InvalidReturnValueError('expected Readable')
    }

    body
      .on('data', (chunk) => {
        const { ret, body } = this

        if (!ret.push(chunk) && body.pause) {
          body.pause()
        }
      })
      .on('error', (err) => {
        const { ret } = this

        util.destroy(ret, err)
      })
      .on('end', () => {
        const { ret } = this

        ret.push(null)
      })
      .on('close', () => {
        const { ret } = this

        if (!ret._readableState.ended) {
          util.destroy(ret, new RequestAbortedError())
        }
      })

    this.body = body
  }

  onData (chunk) {
    const { res } = this
    return res.push(chunk)
  }

  onComplete (trailers) {
    const { res } = this
    res.push(null)
  }

  onError (err) {
    const { ret } = this
    this.handler = null
    util.destroy(ret, err)
  }
}

function pipeline (opts, handler) {
  try {
    const pipelineHandler = new PipelineHandler(opts, handler)
    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)
    return pipelineHandler.ret
  } catch (err) {
    return new PassThrough().destroy(err)
  }
}

module.exports = pipeline


/***/ }),

/***/ "./node_modules/undici/lib/api/api-request.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-request.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Readable = __webpack_require__(/*! ./readable */ "./node_modules/undici/lib/api/readable.js")
const {
  InvalidArgumentError,
  RequestAbortedError
} = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/api/util.js")
const { AsyncResource } = __webpack_require__(/*! node:async_hooks */ "node:async_hooks")
const { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ "./node_modules/undici/lib/api/abort-signal.js")

class RequestHandler extends AsyncResource {
  constructor (opts, callback) {
    if (!opts || typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts

    try {
      if (typeof callback !== 'function') {
        throw new InvalidArgumentError('invalid callback')
      }

      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {
        throw new InvalidArgumentError('invalid highWaterMark')
      }

      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
      }

      if (method === 'CONNECT') {
        throw new InvalidArgumentError('invalid method')
      }

      if (onInfo && typeof onInfo !== 'function') {
        throw new InvalidArgumentError('invalid onInfo callback')
      }

      super('UNDICI_REQUEST')
    } catch (err) {
      if (util.isStream(body)) {
        util.destroy(body.on('error', util.nop), err)
      }
      throw err
    }

    this.responseHeaders = responseHeaders || null
    this.opaque = opaque || null
    this.callback = callback
    this.res = null
    this.abort = null
    this.body = body
    this.trailers = {}
    this.context = null
    this.onInfo = onInfo || null
    this.throwOnError = throwOnError
    this.highWaterMark = highWaterMark

    if (util.isStream(body)) {
      body.on('error', (err) => {
        this.onError(err)
      })
    }

    addSignal(this, signal)
  }

  onConnect (abort, context) {
    if (!this.callback) {
      throw new RequestAbortedError()
    }

    this.abort = abort
    this.context = context
  }

  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this

    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)

    if (statusCode < 200) {
      if (this.onInfo) {
        this.onInfo({ statusCode, headers })
      }
      return
    }

    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers
    const contentType = parsedHeaders['content-type']
    const body = new Readable({ resume, abort, contentType, highWaterMark })

    this.callback = null
    this.res = body
    if (callback !== null) {
      if (this.throwOnError && statusCode >= 400) {
        this.runInAsyncScope(getResolveErrorBodyCallback, null,
          { callback, body, contentType, statusCode, statusMessage, headers }
        )
      } else {
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          trailers: this.trailers,
          opaque,
          body,
          context
        })
      }
    }
  }

  onData (chunk) {
    const { res } = this
    return res.push(chunk)
  }

  onComplete (trailers) {
    const { res } = this

    removeSignal(this)

    util.parseHeaders(trailers, this.trailers)

    res.push(null)
  }

  onError (err) {
    const { res, callback, body, opaque } = this

    removeSignal(this)

    if (callback) {
      // TODO: Does this need queueMicrotask?
      this.callback = null
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque })
      })
    }

    if (res) {
      this.res = null
      // Ensure all queued handlers are invoked before destroying res.
      queueMicrotask(() => {
        util.destroy(res, err)
      })
    }

    if (body) {
      this.body = null
      util.destroy(body, err)
    }
  }
}

function request (opts, callback) {
  if (callback === undefined) {
    return new Promise((resolve, reject) => {
      request.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve(data)
      })
    })
  }

  try {
    this.dispatch(opts, new RequestHandler(opts, callback))
  } catch (err) {
    if (typeof callback !== 'function') {
      throw err
    }
    const opaque = opts?.opaque
    queueMicrotask(() => callback(err, { opaque }))
  }
}

module.exports = request
module.exports.RequestHandler = RequestHandler


/***/ }),

/***/ "./node_modules/undici/lib/api/api-stream.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/api/api-stream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { finished, PassThrough } = __webpack_require__(/*! node:stream */ "node:stream")
const {
  InvalidArgumentError,
  InvalidReturnValueError,
  RequestAbortedError
} = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/api/util.js")
const { AsyncResource } = __webpack_require__(/*! node:async_hooks */ "node:async_hooks")
const { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ "./node_modules/undici/lib/api/abort-signal.js")

class StreamHandler extends AsyncResource {
  constructor (opts, factory, callback) {
    if (!opts || typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts

    try {
      if (typeof callback !== 'function') {
        throw new InvalidArgumentError('invalid callback')
      }

      if (typeof factory !== 'function') {
        throw new InvalidArgumentError('invalid factory')
      }

      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
      }

      if (method === 'CONNECT') {
        throw new InvalidArgumentError('invalid method')
      }

      if (onInfo && typeof onInfo !== 'function') {
        throw new InvalidArgumentError('invalid onInfo callback')
      }

      super('UNDICI_STREAM')
    } catch (err) {
      if (util.isStream(body)) {
        util.destroy(body.on('error', util.nop), err)
      }
      throw err
    }

    this.responseHeaders = responseHeaders || null
    this.opaque = opaque || null
    this.factory = factory
    this.callback = callback
    this.res = null
    this.abort = null
    this.context = null
    this.trailers = null
    this.body = body
    this.onInfo = onInfo || null
    this.throwOnError = throwOnError || false

    if (util.isStream(body)) {
      body.on('error', (err) => {
        this.onError(err)
      })
    }

    addSignal(this, signal)
  }

  onConnect (abort, context) {
    if (!this.callback) {
      throw new RequestAbortedError()
    }

    this.abort = abort
    this.context = context
  }

  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
    const { factory, opaque, context, callback, responseHeaders } = this

    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)

    if (statusCode < 200) {
      if (this.onInfo) {
        this.onInfo({ statusCode, headers })
      }
      return
    }

    this.factory = null

    let res

    if (this.throwOnError && statusCode >= 400) {
      const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers
      const contentType = parsedHeaders['content-type']
      res = new PassThrough()

      this.callback = null
      this.runInAsyncScope(getResolveErrorBodyCallback, null,
        { callback, body: res, contentType, statusCode, statusMessage, headers }
      )
    } else {
      if (factory === null) {
        return
      }

      res = this.runInAsyncScope(factory, null, {
        statusCode,
        headers,
        opaque,
        context
      })

      if (
        !res ||
        typeof res.write !== 'function' ||
        typeof res.end !== 'function' ||
        typeof res.on !== 'function'
      ) {
        throw new InvalidReturnValueError('expected Writable')
      }

      // TODO: Avoid finished. It registers an unnecessary amount of listeners.
      finished(res, { readable: false }, (err) => {
        const { callback, res, opaque, trailers, abort } = this

        this.res = null
        if (err || !res.readable) {
          util.destroy(res, err)
        }

        this.callback = null
        this.runInAsyncScope(callback, null, err || null, { opaque, trailers })

        if (err) {
          abort()
        }
      })
    }

    res.on('drain', resume)

    this.res = res

    const needDrain = res.writableNeedDrain !== undefined
      ? res.writableNeedDrain
      : res._writableState?.needDrain

    return needDrain !== true
  }

  onData (chunk) {
    const { res } = this

    return res ? res.write(chunk) : true
  }

  onComplete (trailers) {
    const { res } = this

    removeSignal(this)

    if (!res) {
      return
    }

    this.trailers = util.parseHeaders(trailers)

    res.end()
  }

  onError (err) {
    const { res, callback, opaque, body } = this

    removeSignal(this)

    this.factory = null

    if (res) {
      this.res = null
      util.destroy(res, err)
    } else if (callback) {
      this.callback = null
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque })
      })
    }

    if (body) {
      this.body = null
      util.destroy(body, err)
    }
  }
}

function stream (opts, factory, callback) {
  if (callback === undefined) {
    return new Promise((resolve, reject) => {
      stream.call(this, opts, factory, (err, data) => {
        return err ? reject(err) : resolve(data)
      })
    })
  }

  try {
    this.dispatch(opts, new StreamHandler(opts, factory, callback))
  } catch (err) {
    if (typeof callback !== 'function') {
      throw err
    }
    const opaque = opts?.opaque
    queueMicrotask(() => callback(err, { opaque }))
  }
}

module.exports = stream


/***/ }),

/***/ "./node_modules/undici/lib/api/api-upgrade.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-upgrade.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const { AsyncResource } = __webpack_require__(/*! node:async_hooks */ "node:async_hooks")
const util = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ "./node_modules/undici/lib/api/abort-signal.js")
const assert = __webpack_require__(/*! node:assert */ "node:assert")

class UpgradeHandler extends AsyncResource {
  constructor (opts, callback) {
    if (!opts || typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    if (typeof callback !== 'function') {
      throw new InvalidArgumentError('invalid callback')
    }

    const { signal, opaque, responseHeaders } = opts

    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
    }

    super('UNDICI_UPGRADE')

    this.responseHeaders = responseHeaders || null
    this.opaque = opaque || null
    this.callback = callback
    this.abort = null
    this.context = null

    addSignal(this, signal)
  }

  onConnect (abort, context) {
    if (!this.callback) {
      throw new RequestAbortedError()
    }

    this.abort = abort
    this.context = null
  }

  onHeaders () {
    throw new SocketError('bad upgrade', null)
  }

  onUpgrade (statusCode, rawHeaders, socket) {
    const { callback, opaque, context } = this

    assert.strictEqual(statusCode, 101)

    removeSignal(this)

    this.callback = null
    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)
    this.runInAsyncScope(callback, null, null, {
      headers,
      socket,
      opaque,
      context
    })
  }

  onError (err) {
    const { callback, opaque } = this

    removeSignal(this)

    if (callback) {
      this.callback = null
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque })
      })
    }
  }
}

function upgrade (opts, callback) {
  if (callback === undefined) {
    return new Promise((resolve, reject) => {
      upgrade.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve(data)
      })
    })
  }

  try {
    const upgradeHandler = new UpgradeHandler(opts, callback)
    this.dispatch({
      ...opts,
      method: opts.method || 'GET',
      upgrade: opts.protocol || 'Websocket'
    }, upgradeHandler)
  } catch (err) {
    if (typeof callback !== 'function') {
      throw err
    }
    const opaque = opts?.opaque
    queueMicrotask(() => callback(err, { opaque }))
  }
}

module.exports = upgrade


/***/ }),

/***/ "./node_modules/undici/lib/api/index.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/api/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports.request = __webpack_require__(/*! ./api-request */ "./node_modules/undici/lib/api/api-request.js")
module.exports.stream = __webpack_require__(/*! ./api-stream */ "./node_modules/undici/lib/api/api-stream.js")
module.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ "./node_modules/undici/lib/api/api-pipeline.js")
module.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ "./node_modules/undici/lib/api/api-upgrade.js")
module.exports.connect = __webpack_require__(/*! ./api-connect */ "./node_modules/undici/lib/api/api-connect.js")


/***/ }),

/***/ "./node_modules/undici/lib/api/readable.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/api/readable.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];
// Ported from https://github.com/nodejs/undici/pull/907



const assert = __webpack_require__(/*! node:assert */ "node:assert")
const { Readable } = __webpack_require__(/*! node:stream */ "node:stream")
const { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const { ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")

const kConsume = Symbol('kConsume')
const kReading = Symbol('kReading')
const kBody = Symbol('kBody')
const kAbort = Symbol('abort')
const kContentType = Symbol('kContentType')

const noop = () => {}

module.exports = class BodyReadable extends Readable {
  constructor ({
    resume,
    abort,
    contentType = '',
    highWaterMark = 64 * 1024 // Same as nodejs fs streams.
  }) {
    super({
      autoDestroy: true,
      read: resume,
      highWaterMark
    })

    this._readableState.dataEmitted = false

    this[kAbort] = abort
    this[kConsume] = null
    this[kBody] = null
    this[kContentType] = contentType

    // Is stream being consumed through Readable API?
    // This is an optimization so that we avoid checking
    // for 'data' and 'readable' listeners in the hot path
    // inside push().
    this[kReading] = false
  }

  destroy (err) {
    if (!err && !this._readableState.endEmitted) {
      err = new RequestAbortedError()
    }

    if (err) {
      this[kAbort]()
    }

    return super.destroy(err)
  }

  _destroy (err, callback) {
    // Workaround for Node "bug". If the stream is destroyed in same
    // tick as it is created, then a user who is waiting for a
    // promise (i.e micro tick) for installing a 'error' listener will
    // never get a chance and will always encounter an unhandled exception.
    // - tick => process.nextTick(fn)
    // - micro tick => queueMicrotask(fn)
    queueMicrotask(() => {
      callback(err)
    })
  }

  on (ev, ...args) {
    if (ev === 'data' || ev === 'readable') {
      this[kReading] = true
    }
    return super.on(ev, ...args)
  }

  addListener (ev, ...args) {
    return this.on(ev, ...args)
  }

  off (ev, ...args) {
    const ret = super.off(ev, ...args)
    if (ev === 'data' || ev === 'readable') {
      this[kReading] = (
        this.listenerCount('data') > 0 ||
        this.listenerCount('readable') > 0
      )
    }
    return ret
  }

  removeListener (ev, ...args) {
    return this.off(ev, ...args)
  }

  push (chunk) {
    if (this[kConsume] && chunk !== null) {
      consumePush(this[kConsume], chunk)
      return this[kReading] ? super.push(chunk) : true
    }
    return super.push(chunk)
  }

  // https://fetch.spec.whatwg.org/#dom-body-text
  async text () {
    return consume(this, 'text')
  }

  // https://fetch.spec.whatwg.org/#dom-body-json
  async json () {
    return consume(this, 'json')
  }

  // https://fetch.spec.whatwg.org/#dom-body-blob
  async blob () {
    return consume(this, 'blob')
  }

  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
  async arrayBuffer () {
    return consume(this, 'arrayBuffer')
  }

  // https://fetch.spec.whatwg.org/#dom-body-formdata
  async formData () {
    // TODO: Implement.
    throw new NotSupportedError()
  }

  // https://fetch.spec.whatwg.org/#dom-body-bodyused
  get bodyUsed () {
    return util.isDisturbed(this)
  }

  // https://fetch.spec.whatwg.org/#dom-body-body
  get body () {
    if (!this[kBody]) {
      this[kBody] = ReadableStreamFrom(this)
      if (this[kConsume]) {
        // TODO: Is this the best way to force a lock?
        this[kBody].getReader() // Ensure stream is locked.
        assert(this[kBody].locked)
      }
    }
    return this[kBody]
  }

  async dump (opts) {
    let limit = Number.isFinite(opts?.limit) ? opts.limit : 262144
    const signal = opts?.signal

    if (signal != null && (typeof signal !== 'object' || !('aborted' in signal))) {
      throw new InvalidArgumentError('signal must be an AbortSignal')
    }

    signal?.throwIfAborted()

    if (this._readableState.closeEmitted) {
      return null
    }

    return await new Promise((resolve, reject) => {
      const onAbort = () => {
        this.destroy(signal.reason ?? new AbortError())
      }
      signal?.addEventListener('abort', onAbort)

      this
        .on('close', function () {
          signal?.removeEventListener('abort', onAbort)
          if (signal?.aborted) {
            reject(signal.reason ?? new AbortError())
          } else {
            resolve(null)
          }
        })
        .on('error', noop)
        .on('data', function (chunk) {
          limit -= chunk.length
          if (limit <= 0) {
            this.destroy()
          }
        })
        .resume()
    })
  }
}

// https://streams.spec.whatwg.org/#readablestream-locked
function isLocked (self) {
  // Consume is an implicit lock.
  return (self[kBody] && self[kBody].locked === true) || self[kConsume]
}

// https://fetch.spec.whatwg.org/#body-unusable
function isUnusable (self) {
  return util.isDisturbed(self) || isLocked(self)
}

async function consume (stream, type) {
  assert(!stream[kConsume])

  return new Promise((resolve, reject) => {
    if (isUnusable(stream)) {
      const rState = stream._readableState
      if (rState.destroyed && rState.closeEmitted === false) {
        stream
          .on('error', err => {
            reject(err)
          })
          .on('close', () => {
            reject(new TypeError('unusable'))
          })
      } else {
        reject(rState.errored ?? new TypeError('unusable'))
      }
    } else {
      queueMicrotask(() => {
        stream[kConsume] = {
          type,
          stream,
          resolve,
          reject,
          length: 0,
          body: []
        }

        stream
          .on('error', function (err) {
            consumeFinish(this[kConsume], err)
          })
          .on('close', function () {
            if (this[kConsume].body !== null) {
              consumeFinish(this[kConsume], new RequestAbortedError())
            }
          })

        consumeStart(stream[kConsume])
      })
    }
  })
}

function consumeStart (consume) {
  if (consume.body === null) {
    return
  }

  const { _readableState: state } = consume.stream

  if (state.bufferIndex) {
    const start = state.bufferIndex
    const end = state.buffer.length
    for (let n = start; n < end; n++) {
      consumePush(consume, state.buffer[n])
    }
  } else {
    for (const chunk of state.buffer) {
      consumePush(consume, chunk)
    }
  }

  if (state.endEmitted) {
    consumeEnd(this[kConsume])
  } else {
    consume.stream.on('end', function () {
      consumeEnd(this[kConsume])
    })
  }

  consume.stream.resume()

  while (consume.stream.read() != null) {
    // Loop
  }
}

/**
 * @param {Buffer[]} chunks
 * @param {number} length
 */
function chunksDecode (chunks, length) {
  if (chunks.length === 0 || length === 0) {
    return ''
  }
  const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length)

  const start =
   buffer.length >= 3 &&
   // Skip BOM.
      buffer[0] === 0xef &&
      buffer[1] === 0xbb &&
      buffer[2] === 0xbf
     ? 3
     : 0
  return buffer.utf8Slice(start, buffer.length - start)
}

function consumeEnd (consume) {
  const { type, body, resolve, stream, length } = consume

  try {
    if (type === 'text') {
      resolve(chunksDecode(body, length))
    } else if (type === 'json') {
      resolve(JSON.parse(chunksDecode(body, length)))
    } else if (type === 'arrayBuffer') {
      const dst = new Uint8Array(length)

      let pos = 0
      for (const buf of body) {
        dst.set(buf, pos)
        pos += buf.byteLength
      }

      resolve(dst.buffer)
    } else if (type === 'blob') {
      resolve(new Blob(body, { type: stream[kContentType] }))
    }

    consumeFinish(consume)
  } catch (err) {
    stream.destroy(err)
  }
}

function consumePush (consume, chunk) {
  consume.length += chunk.length
  consume.body.push(chunk)
}

function consumeFinish (consume, err) {
  if (consume.body === null) {
    return
  }

  if (err) {
    consume.reject(err)
  } else {
    consume.resolve()
  }

  consume.type = null
  consume.stream = null
  consume.resolve = null
  consume.reject = null
  consume.length = 0
  consume.body = null
}


/***/ }),

/***/ "./node_modules/undici/lib/api/util.js":
/*!*********************************************!*\
  !*** ./node_modules/undici/lib/api/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];
const assert = __webpack_require__(/*! node:assert */ "node:assert")
const {
  ResponseStatusCodeError
} = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const { toUSVString } = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")

async function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {
  assert(body)

  let chunks = []
  let limit = 0

  for await (const chunk of body) {
    chunks.push(chunk)
    limit += chunk.length
    if (limit > 128 * 1024) {
      chunks = null
      break
    }
  }

  if (statusCode === 204 || !contentType || !chunks) {
    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers))
    return
  }

  try {
    if (contentType.startsWith('application/json')) {
      const payload = JSON.parse(toUSVString(Buffer.concat(chunks)))
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload))
      return
    }

    if (contentType.startsWith('text/')) {
      const payload = toUSVString(Buffer.concat(chunks))
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload))
      return
    }
  } catch (err) {
    // Process in a fallback if error
  }

  process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers))
}

module.exports = { getResolveErrorBodyCallback }


/***/ }),

/***/ "./node_modules/undici/lib/core/connect.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/connect.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const net = __webpack_require__(/*! node:net */ "node:net")
const assert = __webpack_require__(/*! node:assert */ "node:assert")
const util = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/core/util.js")
const { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ "./node_modules/undici/lib/core/errors.js")

let tls // include tls conditionally since it is not always available

// TODO: session re-use does not wait for the first
// connection to resolve the session and might therefore
// resolve the same servername multiple times even when
// re-use is enabled.

let SessionCache
// FIXME: remove workaround when the Node bug is fixed
// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
if (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {
  SessionCache = class WeakSessionCache {
    constructor (maxCachedSessions) {
      this._maxCachedSessions = maxCachedSessions
      this._sessionCache = new Map()
      this._sessionRegistry = new global.FinalizationRegistry((key) => {
        if (this._sessionCache.size < this._maxCachedSessions) {
          return
        }

        const ref = this._sessionCache.get(key)
        if (ref !== undefined && ref.deref() === undefined) {
          this._sessionCache.delete(key)
        }
      })
    }

    get (sessionKey) {
      const ref = this._sessionCache.get(sessionKey)
      return ref ? ref.deref() : null
    }

    set (sessionKey, session) {
      if (this._maxCachedSessions === 0) {
        return
      }

      this._sessionCache.set(sessionKey, new WeakRef(session))
      this._sessionRegistry.register(session, sessionKey)
    }
  }
} else {
  SessionCache = class SimpleSessionCache {
    constructor (maxCachedSessions) {
      this._maxCachedSessions = maxCachedSessions
      this._sessionCache = new Map()
    }

    get (sessionKey) {
      return this._sessionCache.get(sessionKey)
    }

    set (sessionKey, session) {
      if (this._maxCachedSessions === 0) {
        return
      }

      if (this._sessionCache.size >= this._maxCachedSessions) {
        // remove the oldest session
        const { value: oldestKey } = this._sessionCache.keys().next()
        this._sessionCache.delete(oldestKey)
      }

      this._sessionCache.set(sessionKey, session)
    }
  }
}

function buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')
  }

  const options = { path: socketPath, ...opts }
  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)
  timeout = timeout == null ? 10e3 : timeout
  allowH2 = allowH2 != null ? allowH2 : false
  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
    let socket
    if (protocol === 'https:') {
      if (!tls) {
        tls = __webpack_require__(/*! node:tls */ "node:tls")
      }
      servername = servername || options.servername || util.getServerName(host) || null

      const sessionKey = servername || hostname
      const session = sessionCache.get(sessionKey) || null

      assert(sessionKey)

      socket = tls.connect({
        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...
        ...options,
        servername,
        session,
        localAddress,
        // TODO(HTTP/2): Add support for h2c
        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],
        socket: httpSocket, // upgrade socket connection
        port: port || 443,
        host: hostname
      })

      socket
        .on('session', function (session) {
          // TODO (fix): Can a session become invalid once established? Don't think so?
          sessionCache.set(sessionKey, session)
        })
    } else {
      assert(!httpSocket, 'httpSocket can only be sent on TLS update')
      socket = net.connect({
        highWaterMark: 64 * 1024, // Same as nodejs fs streams.
        ...options,
        localAddress,
        port: port || 80,
        host: hostname
      })
    }

    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket
    if (options.keepAlive == null || options.keepAlive) {
      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay
      socket.setKeepAlive(true, keepAliveInitialDelay)
    }

    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout)

    socket
      .setNoDelay(true)
      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {
        cancelTimeout()

        if (callback) {
          const cb = callback
          callback = null
          cb(null, this)
        }
      })
      .on('error', function (err) {
        cancelTimeout()

        if (callback) {
          const cb = callback
          callback = null
          cb(err)
        }
      })

    return socket
  }
}

function setupTimeout (onConnectTimeout, timeout) {
  if (!timeout) {
    return () => {}
  }

  let s1 = null
  let s2 = null
  const timeoutId = setTimeout(() => {
    // setImmediate is added to make sure that we priotorise socket error events over timeouts
    s1 = setImmediate(() => {
      if (process.platform === 'win32') {
        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic
        s2 = setImmediate(() => onConnectTimeout())
      } else {
        onConnectTimeout()
      }
    })
  }, timeout)
  return () => {
    clearTimeout(timeoutId)
    clearImmediate(s1)
    clearImmediate(s2)
  }
}

function onConnectTimeout (socket) {
  let message = 'Connect Timeout Error'
  if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
    message = +` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(', ')})`
  }
  util.destroy(socket, new ConnectTimeoutError(message))
}

module.exports = buildConnector


/***/ }),

/***/ "./node_modules/undici/lib/core/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/core/constants.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


/** @type {Record<string, string | undefined>} */
const headerNameLowerCasedRecord = {}

// https://developer.mozilla.org/docs/Web/HTTP/Headers
const wellknownHeaderNames = [
  'Accept',
  'Accept-Encoding',
  'Accept-Language',
  'Accept-Ranges',
  'Access-Control-Allow-Credentials',
  'Access-Control-Allow-Headers',
  'Access-Control-Allow-Methods',
  'Access-Control-Allow-Origin',
  'Access-Control-Expose-Headers',
  'Access-Control-Max-Age',
  'Access-Control-Request-Headers',
  'Access-Control-Request-Method',
  'Age',
  'Allow',
  'Alt-Svc',
  'Alt-Used',
  'Authorization',
  'Cache-Control',
  'Clear-Site-Data',
  'Connection',
  'Content-Disposition',
  'Content-Encoding',
  'Content-Language',
  'Content-Length',
  'Content-Location',
  'Content-Range',
  'Content-Security-Policy',
  'Content-Security-Policy-Report-Only',
  'Content-Type',
  'Cookie',
  'Cross-Origin-Embedder-Policy',
  'Cross-Origin-Opener-Policy',
  'Cross-Origin-Resource-Policy',
  'Date',
  'Device-Memory',
  'Downlink',
  'ECT',
  'ETag',
  'Expect',
  'Expect-CT',
  'Expires',
  'Forwarded',
  'From',
  'Host',
  'If-Match',
  'If-Modified-Since',
  'If-None-Match',
  'If-Range',
  'If-Unmodified-Since',
  'Keep-Alive',
  'Last-Modified',
  'Link',
  'Location',
  'Max-Forwards',
  'Origin',
  'Permissions-Policy',
  'Pragma',
  'Proxy-Authenticate',
  'Proxy-Authorization',
  'RTT',
  'Range',
  'Referer',
  'Referrer-Policy',
  'Refresh',
  'Retry-After',
  'Sec-WebSocket-Accept',
  'Sec-WebSocket-Extensions',
  'Sec-WebSocket-Key',
  'Sec-WebSocket-Protocol',
  'Sec-WebSocket-Version',
  'Server',
  'Server-Timing',
  'Service-Worker-Allowed',
  'Service-Worker-Navigation-Preload',
  'Set-Cookie',
  'SourceMap',
  'Strict-Transport-Security',
  'Supports-Loading-Mode',
  'TE',
  'Timing-Allow-Origin',
  'Trailer',
  'Transfer-Encoding',
  'Upgrade',
  'Upgrade-Insecure-Requests',
  'User-Agent',
  'Vary',
  'Via',
  'WWW-Authenticate',
  'X-Content-Type-Options',
  'X-DNS-Prefetch-Control',
  'X-Frame-Options',
  'X-Permitted-Cross-Domain-Policies',
  'X-Powered-By',
  'X-Requested-With',
  'X-XSS-Protection'
]

for (let i = 0; i < wellknownHeaderNames.length; ++i) {
  const key = wellknownHeaderNames[i]
  const lowerCasedKey = key.toLowerCase()
  headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] =
    lowerCasedKey
}

// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
Object.setPrototypeOf(headerNameLowerCasedRecord, null)

module.exports = {
  wellknownHeaderNames,
  headerNameLowerCasedRecord
}


/***/ }),

/***/ "./node_modules/undici/lib/core/diagnostics.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/core/diagnostics.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const diagnosticsChannel = __webpack_require__(/*! node:diagnostics_channel */ "node:diagnostics_channel")
const util = __webpack_require__(/*! node:util */ "node:util")

const undiciDebugLog = util.debuglog('undici')
const fetchDebuglog = util.debuglog('fetch')
const websocketDebuglog = util.debuglog('websocket')
let isClientSet = false
const channels = {
  // Client
  beforeConnect: diagnosticsChannel.channel('undici:client:beforeConnect'),
  connected: diagnosticsChannel.channel('undici:client:connected'),
  connectError: diagnosticsChannel.channel('undici:client:connectError'),
  sendHeaders: diagnosticsChannel.channel('undici:client:sendHeaders'),
  // Request
  create: diagnosticsChannel.channel('undici:request:create'),
  bodySent: diagnosticsChannel.channel('undici:request:bodySent'),
  headers: diagnosticsChannel.channel('undici:request:headers'),
  trailers: diagnosticsChannel.channel('undici:request:trailers'),
  error: diagnosticsChannel.channel('undici:request:error'),
  // WebSocket
  open: diagnosticsChannel.channel('undici:websocket:open'),
  close: diagnosticsChannel.channel('undici:websocket:close'),
  socketError: diagnosticsChannel.channel('undici:websocket:socket_error'),
  ping: diagnosticsChannel.channel('undici:websocket:ping'),
  pong: diagnosticsChannel.channel('undici:websocket:pong')
}

if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
  const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog

  // Track all Client events
  diagnosticsChannel.channel('undici:client:beforeConnect').subscribe(evt => {
    const {
      connectParams: { version, protocol, port, host }
    } = evt
    debuglog(
      'connecting to %s using %s%s',
      `${host}${port ? `:${port}` : ''}`,
      protocol,
      version
    )
  })

  diagnosticsChannel.channel('undici:client:connected').subscribe(evt => {
    const {
      connectParams: { version, protocol, port, host }
    } = evt
    debuglog(
      'connected to %s using %s%s',
      `${host}${port ? `:${port}` : ''}`,
      protocol,
      version
    )
  })

  diagnosticsChannel.channel('undici:client:connectError').subscribe(evt => {
    const {
      connectParams: { version, protocol, port, host },
      error
    } = evt
    debuglog(
      'connection to %s using %s%s errored - %s',
      `${host}${port ? `:${port}` : ''}`,
      protocol,
      version,
      error.message
    )
  })

  diagnosticsChannel.channel('undici:client:sendHeaders').subscribe(evt => {
    const {
      request: { method, path, origin }
    } = evt
    debuglog('sending request to %s %s/%s', method, origin, path)
  })

  // Track Request events
  diagnosticsChannel.channel('undici:request:headers').subscribe(evt => {
    const {
      request: { method, path, origin },
      response: { statusCode }
    } = evt
    debuglog(
      'received response to %s %s/%s - HTTP %d',
      method,
      origin,
      path,
      statusCode
    )
  })

  diagnosticsChannel.channel('undici:request:trailers').subscribe(evt => {
    const {
      request: { method, path, origin }
    } = evt
    debuglog('trailers received from %s %s/%s', method, origin, path)
  })

  diagnosticsChannel.channel('undici:request:error').subscribe(evt => {
    const {
      request: { method, path, origin },
      error
    } = evt
    debuglog(
      'request to %s %s/%s errored - %s',
      method,
      origin,
      path,
      error.message
    )
  })

  isClientSet = true
}

if (websocketDebuglog.enabled) {
  if (!isClientSet) {
    const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog
    diagnosticsChannel.channel('undici:client:beforeConnect').subscribe(evt => {
      const {
        connectParams: { version, protocol, port, host }
      } = evt
      debuglog(
        'connecting to %s%s using %s%s',
        host,
        port ? `:${port}` : '',
        protocol,
        version
      )
    })

    diagnosticsChannel.channel('undici:client:connected').subscribe(evt => {
      const {
        connectParams: { version, protocol, port, host }
      } = evt
      debuglog(
        'connected to %s%s using %s%s',
        host,
        port ? `:${port}` : '',
        protocol,
        version
      )
    })

    diagnosticsChannel.channel('undici:client:connectError').subscribe(evt => {
      const {
        connectParams: { version, protocol, port, host },
        error
      } = evt
      debuglog(
        'connection to %s%s using %s%s errored - %s',
        host,
        port ? `:${port}` : '',
        protocol,
        version,
        error.message
      )
    })

    diagnosticsChannel.channel('undici:client:sendHeaders').subscribe(evt => {
      const {
        request: { method, path, origin }
      } = evt
      debuglog('sending request to %s %s/%s', method, origin, path)
    })
  }

  // Track all WebSocket events
  diagnosticsChannel.channel('undici:websocket:open').subscribe(evt => {
    const {
      address: { address, port }
    } = evt
    websocketDebuglog('connection opened %s%s', address, port ? `:${port}` : '')
  })

  diagnosticsChannel.channel('undici:websocket:close').subscribe(evt => {
    const { websocket, code, reason } = evt
    websocketDebuglog(
      'closed connection to %s - %s %s',
      websocket.url,
      code,
      reason
    )
  })

  diagnosticsChannel.channel('undici:websocket:socket_error').subscribe(err => {
    websocketDebuglog('connection errored - %s', err.message)
  })

  diagnosticsChannel.channel('undici:websocket:ping').subscribe(evt => {
    websocketDebuglog('ping received')
  })

  diagnosticsChannel.channel('undici:websocket:pong').subscribe(evt => {
    websocketDebuglog('pong received')
  })
}

module.exports = {
  channels
}


/***/ }),

/***/ "./node_modules/undici/lib/core/errors.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/core/errors.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


class UndiciError extends Error {
  constructor (message) {
    super(message)
    this.name = 'UndiciError'
    this.code = 'UND_ERR'
  }
}

class ConnectTimeoutError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'ConnectTimeoutError'
    this.message = message || 'Connect Timeout Error'
    this.code = 'UND_ERR_CONNECT_TIMEOUT'
  }
}

class HeadersTimeoutError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'HeadersTimeoutError'
    this.message = message || 'Headers Timeout Error'
    this.code = 'UND_ERR_HEADERS_TIMEOUT'
  }
}

class HeadersOverflowError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'HeadersOverflowError'
    this.message = message || 'Headers Overflow Error'
    this.code = 'UND_ERR_HEADERS_OVERFLOW'
  }
}

class BodyTimeoutError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'BodyTimeoutError'
    this.message = message || 'Body Timeout Error'
    this.code = 'UND_ERR_BODY_TIMEOUT'
  }
}

class ResponseStatusCodeError extends UndiciError {
  constructor (message, statusCode, headers, body) {
    super(message)
    this.name = 'ResponseStatusCodeError'
    this.message = message || 'Response Status Code Error'
    this.code = 'UND_ERR_RESPONSE_STATUS_CODE'
    this.body = body
    this.status = statusCode
    this.statusCode = statusCode
    this.headers = headers
  }
}

class InvalidArgumentError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'InvalidArgumentError'
    this.message = message || 'Invalid Argument Error'
    this.code = 'UND_ERR_INVALID_ARG'
  }
}

class InvalidReturnValueError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'InvalidReturnValueError'
    this.message = message || 'Invalid Return Value Error'
    this.code = 'UND_ERR_INVALID_RETURN_VALUE'
  }
}

class AbortError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'AbortError'
    this.message = message || 'The operation was aborted'
  }
}

class RequestAbortedError extends AbortError {
  constructor (message) {
    super(message)
    this.name = 'AbortError'
    this.message = message || 'Request aborted'
    this.code = 'UND_ERR_ABORTED'
  }
}

class InformationalError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'InformationalError'
    this.message = message || 'Request information'
    this.code = 'UND_ERR_INFO'
  }
}

class RequestContentLengthMismatchError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'RequestContentLengthMismatchError'
    this.message = message || 'Request body length does not match content-length header'
    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH'
  }
}

class ResponseContentLengthMismatchError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'ResponseContentLengthMismatchError'
    this.message = message || 'Response body length does not match content-length header'
    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH'
  }
}

class ClientDestroyedError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'ClientDestroyedError'
    this.message = message || 'The client is destroyed'
    this.code = 'UND_ERR_DESTROYED'
  }
}

class ClientClosedError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'ClientClosedError'
    this.message = message || 'The client is closed'
    this.code = 'UND_ERR_CLOSED'
  }
}

class SocketError extends UndiciError {
  constructor (message, socket) {
    super(message)
    this.name = 'SocketError'
    this.message = message || 'Socket error'
    this.code = 'UND_ERR_SOCKET'
    this.socket = socket
  }
}

class NotSupportedError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'NotSupportedError'
    this.message = message || 'Not supported error'
    this.code = 'UND_ERR_NOT_SUPPORTED'
  }
}

class BalancedPoolMissingUpstreamError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'MissingUpstreamError'
    this.message = message || 'No upstream has been added to the BalancedPool'
    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM'
  }
}

class HTTPParserError extends Error {
  constructor (message, code, data) {
    super(message)
    this.name = 'HTTPParserError'
    this.code = code ? `HPE_${code}` : undefined
    this.data = data ? data.toString() : undefined
  }
}

class ResponseExceededMaxSizeError extends UndiciError {
  constructor (message) {
    super(message)
    this.name = 'ResponseExceededMaxSizeError'
    this.message = message || 'Response content exceeded max size'
    this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE'
  }
}

class RequestRetryError extends UndiciError {
  constructor (message, code, { headers, data }) {
    super(message)
    this.name = 'RequestRetryError'
    this.message = message || 'Request retry error'
    this.code = 'UND_ERR_REQ_RETRY'
    this.statusCode = code
    this.data = data
    this.headers = headers
  }
}

module.exports = {
  AbortError,
  HTTPParserError,
  UndiciError,
  HeadersTimeoutError,
  HeadersOverflowError,
  BodyTimeoutError,
  RequestContentLengthMismatchError,
  ConnectTimeoutError,
  ResponseStatusCodeError,
  InvalidArgumentError,
  InvalidReturnValueError,
  RequestAbortedError,
  ClientDestroyedError,
  ClientClosedError,
  InformationalError,
  SocketError,
  NotSupportedError,
  ResponseContentLengthMismatchError,
  BalancedPoolMissingUpstreamError,
  ResponseExceededMaxSizeError,
  RequestRetryError
}


/***/ }),

/***/ "./node_modules/undici/lib/core/request.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const {
  InvalidArgumentError,
  NotSupportedError
} = __webpack_require__(/*! ./errors */ "./node_modules/undici/lib/core/errors.js")
const assert = __webpack_require__(/*! node:assert */ "node:assert")
const {
  isValidHTTPToken,
  isValidHeaderChar,
  isStream,
  destroy,
  isBuffer,
  isFormDataLike,
  isIterable,
  isBlobLike,
  buildURL,
  validateHandler,
  getServerName
} = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/core/util.js")
const { channels } = __webpack_require__(/*! ./diagnostics.js */ "./node_modules/undici/lib/core/diagnostics.js")
const { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/core/constants.js")

// Verifies that a given path is valid does not contain control chars \x00 to \x20
const invalidPathRegex = /[^\u0021-\u00ff]/

const kHandler = Symbol('handler')

class Request {
  constructor (origin, {
    path,
    method,
    body,
    headers,
    query,
    idempotent,
    blocking,
    upgrade,
    headersTimeout,
    bodyTimeout,
    reset,
    throwOnError,
    expectContinue
  }, handler) {
    if (typeof path !== 'string') {
      throw new InvalidArgumentError('path must be a string')
    } else if (
      path[0] !== '/' &&
      !(path.startsWith('http://') || path.startsWith('https://')) &&
      method !== 'CONNECT'
    ) {
      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')
    } else if (invalidPathRegex.exec(path) !== null) {
      throw new InvalidArgumentError('invalid request path')
    }

    if (typeof method !== 'string') {
      throw new InvalidArgumentError('method must be a string')
    } else if (!isValidHTTPToken(method)) {
      throw new InvalidArgumentError('invalid request method')
    }

    if (upgrade && typeof upgrade !== 'string') {
      throw new InvalidArgumentError('upgrade must be a string')
    }

    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
      throw new InvalidArgumentError('invalid headersTimeout')
    }

    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
      throw new InvalidArgumentError('invalid bodyTimeout')
    }

    if (reset != null && typeof reset !== 'boolean') {
      throw new InvalidArgumentError('invalid reset')
    }

    if (expectContinue != null && typeof expectContinue !== 'boolean') {
      throw new InvalidArgumentError('invalid expectContinue')
    }

    this.headersTimeout = headersTimeout

    this.bodyTimeout = bodyTimeout

    this.throwOnError = throwOnError === true

    this.method = method

    this.abort = null

    if (body == null) {
      this.body = null
    } else if (isStream(body)) {
      this.body = body

      const rState = this.body._readableState
      if (!rState || !rState.autoDestroy) {
        this.endHandler = function autoDestroy () {
          destroy(this)
        }
        this.body.on('end', this.endHandler)
      }

      this.errorHandler = err => {
        if (this.abort) {
          this.abort(err)
        } else {
          this.error = err
        }
      }
      this.body.on('error', this.errorHandler)
    } else if (isBuffer(body)) {
      this.body = body.byteLength ? body : null
    } else if (ArrayBuffer.isView(body)) {
      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null
    } else if (body instanceof ArrayBuffer) {
      this.body = body.byteLength ? Buffer.from(body) : null
    } else if (typeof body === 'string') {
      this.body = body.length ? Buffer.from(body) : null
    } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {
      this.body = body
    } else {
      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')
    }

    this.completed = false

    this.aborted = false

    this.upgrade = upgrade || null

    this.path = query ? buildURL(path, query) : path

    this.origin = origin

    this.idempotent = idempotent == null
      ? method === 'HEAD' || method === 'GET'
      : idempotent

    this.blocking = blocking == null ? false : blocking

    this.reset = reset == null ? null : reset

    this.host = null

    this.contentLength = null

    this.contentType = null

    this.headers = []

    // Only for H2
    this.expectContinue = expectContinue != null ? expectContinue : false

    if (Array.isArray(headers)) {
      if (headers.length % 2 !== 0) {
        throw new InvalidArgumentError('headers array must be even')
      }
      for (let i = 0; i < headers.length; i += 2) {
        processHeader(this, headers[i], headers[i + 1])
      }
    } else if (headers && typeof headers === 'object') {
      if (headers[Symbol.iterator]) {
        for (const header of headers) {
          if (!Array.isArray(header) || header.length !== 2) {
            throw new InvalidArgumentError('headers must be in key-value pair format')
          }
          processHeader(this, header[0], header[1])
        }
      } else {
        const keys = Object.keys(headers)
        for (let i = 0; i < keys.length; ++i) {
          processHeader(this, keys[i], headers[keys[i]])
        }
      }
    } else if (headers != null) {
      throw new InvalidArgumentError('headers must be an object or an array')
    }

    validateHandler(handler, method, upgrade)

    this.servername = getServerName(this.host)

    this[kHandler] = handler

    if (channels.create.hasSubscribers) {
      channels.create.publish({ request: this })
    }
  }

  onBodySent (chunk) {
    if (this[kHandler].onBodySent) {
      try {
        return this[kHandler].onBodySent(chunk)
      } catch (err) {
        this.abort(err)
      }
    }
  }

  onRequestSent () {
    if (channels.bodySent.hasSubscribers) {
      channels.bodySent.publish({ request: this })
    }

    if (this[kHandler].onRequestSent) {
      try {
        return this[kHandler].onRequestSent()
      } catch (err) {
        this.abort(err)
      }
    }
  }

  onConnect (abort) {
    assert(!this.aborted)
    assert(!this.completed)

    if (this.error) {
      abort(this.error)
    } else {
      this.abort = abort
      return this[kHandler].onConnect(abort)
    }
  }

  onResponseStarted () {
    return this[kHandler].onResponseStarted?.()
  }

  onHeaders (statusCode, headers, resume, statusText) {
    assert(!this.aborted)
    assert(!this.completed)

    if (channels.headers.hasSubscribers) {
      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })
    }

    try {
      return this[kHandler].onHeaders(statusCode, headers, resume, statusText)
    } catch (err) {
      this.abort(err)
    }
  }

  onData (chunk) {
    assert(!this.aborted)
    assert(!this.completed)

    try {
      return this[kHandler].onData(chunk)
    } catch (err) {
      this.abort(err)
      return false
    }
  }

  onUpgrade (statusCode, headers, socket) {
    assert(!this.aborted)
    assert(!this.completed)

    return this[kHandler].onUpgrade(statusCode, headers, socket)
  }

  onComplete (trailers) {
    this.onFinally()

    assert(!this.aborted)

    this.completed = true
    if (channels.trailers.hasSubscribers) {
      channels.trailers.publish({ request: this, trailers })
    }

    try {
      return this[kHandler].onComplete(trailers)
    } catch (err) {
      // TODO (fix): This might be a bad idea?
      this.onError(err)
    }
  }

  onError (error) {
    this.onFinally()

    if (channels.error.hasSubscribers) {
      channels.error.publish({ request: this, error })
    }

    if (this.aborted) {
      return
    }
    this.aborted = true

    return this[kHandler].onError(error)
  }

  onFinally () {
    if (this.errorHandler) {
      this.body.off('error', this.errorHandler)
      this.errorHandler = null
    }

    if (this.endHandler) {
      this.body.off('end', this.endHandler)
      this.endHandler = null
    }
  }

  addHeader (key, value) {
    processHeader(this, key, value)
    return this
  }
}

function processHeader (request, key, val) {
  if (val && (typeof val === 'object' && !Array.isArray(val))) {
    throw new InvalidArgumentError(`invalid ${key} header`)
  } else if (val === undefined) {
    return
  }

  let headerName = headerNameLowerCasedRecord[key]

  if (headerName === undefined) {
    headerName = key.toLowerCase()
    if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {
      throw new InvalidArgumentError('invalid header key')
    }
  }

  if (Array.isArray(val)) {
    const arr = []
    for (let i = 0; i < val.length; i++) {
      if (typeof val[i] === 'string') {
        if (!isValidHeaderChar(val[i])) {
          throw new InvalidArgumentError(`invalid ${key} header`)
        }
        arr.push(val[i])
      } else if (val[i] === null) {
        arr.push('')
      } else if (typeof val[i] === 'object') {
        throw new InvalidArgumentError(`invalid ${key} header`)
      } else {
        arr.push(`${val[i]}`)
      }
    }
    val = arr
  } else if (typeof val === 'string') {
    if (!isValidHeaderChar(val)) {
      throw new InvalidArgumentError(`invalid ${key} header`)
    }
  } else if (val === null) {
    val = ''
  } else if (typeof val === 'object') {
    throw new InvalidArgumentError(`invalid ${key} header`)
  } else {
    val = `${val}`
  }

  if (request.host === null && headerName === 'host') {
    if (typeof val !== 'string') {
      throw new InvalidArgumentError('invalid host header')
    }
    // Consumed by Client
    request.host = val
  } else if (request.contentLength === null && headerName === 'content-length') {
    request.contentLength = parseInt(val, 10)
    if (!Number.isFinite(request.contentLength)) {
      throw new InvalidArgumentError('invalid content-length header')
    }
  } else if (request.contentType === null && headerName === 'content-type') {
    request.contentType = val
    request.headers.push(key, val)
  } else if (headerName === 'transfer-encoding' || headerName === 'keep-alive' || headerName === 'upgrade') {
    throw new InvalidArgumentError(`invalid ${headerName} header`)
  } else if (headerName === 'connection') {
    const value = typeof val === 'string' ? val.toLowerCase() : null
    if (value !== 'close' && value !== 'keep-alive') {
      throw new InvalidArgumentError('invalid connection header')
    }

    if (value === 'close') {
      request.reset = true
    }
  } else if (headerName === 'expect') {
    throw new NotSupportedError('expect header not supported')
  } else {
    request.headers.push(key, val)
  }
}

module.exports = Request


/***/ }),

/***/ "./node_modules/undici/lib/core/symbols.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/symbols.js ***!
  \*************************************************/
/***/ ((module) => {

module.exports = {
  kClose: Symbol('close'),
  kDestroy: Symbol('destroy'),
  kDispatch: Symbol('dispatch'),
  kUrl: Symbol('url'),
  kWriting: Symbol('writing'),
  kResuming: Symbol('resuming'),
  kQueue: Symbol('queue'),
  kConnect: Symbol('connect'),
  kConnecting: Symbol('connecting'),
  kHeadersList: Symbol('headers list'),
  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),
  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),
  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),
  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),
  kKeepAlive: Symbol('keep alive'),
  kHeadersTimeout: Symbol('headers timeout'),
  kBodyTimeout: Symbol('body timeout'),
  kServerName: Symbol('server name'),
  kLocalAddress: Symbol('local address'),
  kHost: Symbol('host'),
  kNoRef: Symbol('no ref'),
  kBodyUsed: Symbol('used'),
  kRunning: Symbol('running'),
  kBlocking: Symbol('blocking'),
  kPending: Symbol('pending'),
  kSize: Symbol('size'),
  kBusy: Symbol('busy'),
  kQueued: Symbol('queued'),
  kFree: Symbol('free'),
  kConnected: Symbol('connected'),
  kClosed: Symbol('closed'),
  kNeedDrain: Symbol('need drain'),
  kReset: Symbol('reset'),
  kDestroyed: Symbol.for('nodejs.stream.destroyed'),
  kResume: Symbol('resume'),
  kOnError: Symbol('on error'),
  kMaxHeadersSize: Symbol('max headers size'),
  kRunningIdx: Symbol('running index'),
  kPendingIdx: Symbol('pending index'),
  kError: Symbol('error'),
  kClients: Symbol('clients'),
  kClient: Symbol('client'),
  kParser: Symbol('parser'),
  kOnDestroyed: Symbol('destroy callbacks'),
  kPipelining: Symbol('pipelining'),
  kSocket: Symbol('socket'),
  kHostHeader: Symbol('host header'),
  kConnector: Symbol('connector'),
  kStrictContentLength: Symbol('strict content length'),
  kMaxRedirections: Symbol('maxRedirections'),
  kMaxRequests: Symbol('maxRequestsPerClient'),
  kProxy: Symbol('proxy agent options'),
  kCounter: Symbol('socket request counter'),
  kInterceptors: Symbol('dispatch interceptors'),
  kMaxResponseSize: Symbol('max response size'),
  kHTTP2Session: Symbol('http2Session'),
  kHTTP2SessionState: Symbol('http2Session state'),
  kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),
  kConstruct: Symbol('constructable'),
  kListeners: Symbol('listeners'),
  kHTTPContext: Symbol('http context'),
  kMaxConcurrentStreams: Symbol('max concurrent streams')
}


/***/ }),

/***/ "./node_modules/undici/lib/core/tree.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/tree.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  wellknownHeaderNames,
  headerNameLowerCasedRecord
} = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/core/constants.js")

class TstNode {
  /** @type {any} */
  value = null
  /** @type {null | TstNode} */
  left = null
  /** @type {null | TstNode} */
  middle = null
  /** @type {null | TstNode} */
  right = null
  /** @type {number} */
  code
  /**
   * @param {string} key
   * @param {any} value
   * @param {number} index
   */
  constructor (key, value, index) {
    if (index === undefined || index >= key.length) {
      throw new TypeError('Unreachable')
    }
    const code = this.code = key.charCodeAt(index)
    // check code is ascii string
    if (code > 0x7F) {
      throw new TypeError('key must be ascii string')
    }
    if (key.length !== ++index) {
      this.middle = new TstNode(key, value, index)
    } else {
      this.value = value
    }
  }

  /**
   * @param {string} key
   * @param {any} value
   */
  add (key, value) {
    const length = key.length
    if (length === 0) {
      throw new TypeError('Unreachable')
    }
    let index = 0
    let node = this
    while (true) {
      const code = key.charCodeAt(index)
      // check code is ascii string
      if (code > 0x7F) {
        throw new TypeError('key must be ascii string')
      }
      if (node.code === code) {
        if (length === ++index) {
          node.value = value
          break
        } else if (node.middle !== null) {
          node = node.middle
        } else {
          node.middle = new TstNode(key, value, index)
          break
        }
      } else if (node.code < code) {
        if (node.left !== null) {
          node = node.left
        } else {
          node.left = new TstNode(key, value, index)
          break
        }
      } else if (node.right !== null) {
        node = node.right
      } else {
        node.right = new TstNode(key, value, index)
        break
      }
    }
  }

  /**
   * @param {Uint8Array} key
   * @return {TstNode | null}
   */
  search (key) {
    const keylength = key.length
    let index = 0
    let node = this
    while (node !== null && index < keylength) {
      let code = key[index]
      // A-Z
      // First check if it is bigger than 0x5a.
      // Lowercase letters have higher char codes than uppercase ones.
      // Also we assume that headers will mostly contain lowercase characters.
      if (code <= 0x5a && code >= 0x41) {
        // Lowercase for uppercase.
        code |= 32
      }
      while (node !== null) {
        if (code === node.code) {
          if (keylength === ++index) {
            // Returns Node since it is the last key.
            return node
          }
          node = node.middle
          break
        }
        node = node.code < code ? node.left : node.right
      }
    }
    return null
  }
}

class TernarySearchTree {
  /** @type {TstNode | null} */
  node = null

  /**
   * @param {string} key
   * @param {any} value
   * */
  insert (key, value) {
    if (this.node === null) {
      this.node = new TstNode(key, value, 0)
    } else {
      this.node.add(key, value)
    }
  }

  /**
   * @param {Uint8Array} key
   * @return {any}
   */
  lookup (key) {
    return this.node?.search(key)?.value ?? null
  }
}

const tree = new TernarySearchTree()

for (let i = 0; i < wellknownHeaderNames.length; ++i) {
  const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]]
  tree.insert(key, key)
}

module.exports = {
  TernarySearchTree,
  tree
}


/***/ }),

/***/ "./node_modules/undici/lib/core/util.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const assert = __webpack_require__(/*! node:assert */ "node:assert")
const { kDestroyed, kBodyUsed } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/core/symbols.js")
const { IncomingMessage } = __webpack_require__(/*! node:http */ "node:http")
const stream = __webpack_require__(/*! node:stream */ "node:stream")
const net = __webpack_require__(/*! node:net */ "node:net")
const { InvalidArgumentError } = __webpack_require__(/*! ./errors */ "./node_modules/undici/lib/core/errors.js")
const { Blob } = __webpack_require__(/*! node:buffer */ "node:buffer")
const nodeUtil = __webpack_require__(/*! node:util */ "node:util")
const { stringify } = __webpack_require__(/*! node:querystring */ "node:querystring")
const { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/core/constants.js")
const { tree } = __webpack_require__(/*! ./tree */ "./node_modules/undici/lib/core/tree.js")

const [nodeMajor, nodeMinor] = process.versions.node.split('.').map(v => Number(v))

function nop () {}

function isStream (obj) {
  return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function'
}

// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)
function isBlobLike (object) {
  return (Blob && object instanceof Blob) || (
    object &&
    typeof object === 'object' &&
    (typeof object.stream === 'function' ||
      typeof object.arrayBuffer === 'function') &&
    /^(Blob|File)$/.test(object[Symbol.toStringTag])
  )
}

function buildURL (url, queryParams) {
  if (url.includes('?') || url.includes('#')) {
    throw new Error('Query params cannot be passed when url already contains "?" or "#".')
  }

  const stringified = stringify(queryParams)

  if (stringified) {
    url += '?' + stringified
  }

  return url
}

function parseURL (url) {
  if (typeof url === 'string') {
    url = new URL(url)

    if (!/^https?:/.test(url.origin || url.protocol)) {
      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')
    }

    return url
  }

  if (!url || typeof url !== 'object') {
    throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.')
  }

  if (!/^https?:/.test(url.origin || url.protocol)) {
    throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')
  }

  if (!(url instanceof URL)) {
    if (url.port != null && url.port !== '' && !Number.isFinite(parseInt(url.port))) {
      throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.')
    }

    if (url.path != null && typeof url.path !== 'string') {
      throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.')
    }

    if (url.pathname != null && typeof url.pathname !== 'string') {
      throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.')
    }

    if (url.hostname != null && typeof url.hostname !== 'string') {
      throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.')
    }

    if (url.origin != null && typeof url.origin !== 'string') {
      throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.')
    }

    const port = url.port != null
      ? url.port
      : (url.protocol === 'https:' ? 443 : 80)
    let origin = url.origin != null
      ? url.origin
      : `${url.protocol}//${url.hostname}:${port}`
    let path = url.path != null
      ? url.path
      : `${url.pathname || ''}${url.search || ''}`

    if (origin.endsWith('/')) {
      origin = origin.substring(0, origin.length - 1)
    }

    if (path && !path.startsWith('/')) {
      path = `/${path}`
    }
    // new URL(path, origin) is unsafe when `path` contains an absolute URL
    // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:
    // If first parameter is a relative URL, second param is required, and will be used as the base URL.
    // If first parameter is an absolute URL, a given second param will be ignored.
    url = new URL(origin + path)
  }

  return url
}

function parseOrigin (url) {
  url = parseURL(url)

  if (url.pathname !== '/' || url.search || url.hash) {
    throw new InvalidArgumentError('invalid url')
  }

  return url
}

function getHostname (host) {
  if (host[0] === '[') {
    const idx = host.indexOf(']')

    assert(idx !== -1)
    return host.substring(1, idx)
  }

  const idx = host.indexOf(':')
  if (idx === -1) return host

  return host.substring(0, idx)
}

// IP addresses are not valid server names per RFC6066
// > Currently, the only server names supported are DNS hostnames
function getServerName (host) {
  if (!host) {
    return null
  }

  assert.strictEqual(typeof host, 'string')

  const servername = getHostname(host)
  if (net.isIP(servername)) {
    return ''
  }

  return servername
}

function deepClone (obj) {
  return JSON.parse(JSON.stringify(obj))
}

function isAsyncIterable (obj) {
  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')
}

function isIterable (obj) {
  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))
}

function bodyLength (body) {
  if (body == null) {
    return 0
  } else if (isStream(body)) {
    const state = body._readableState
    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length)
      ? state.length
      : null
  } else if (isBlobLike(body)) {
    return body.size != null ? body.size : null
  } else if (isBuffer(body)) {
    return body.byteLength
  }

  return null
}

function isDestroyed (body) {
  return body && !!(body.destroyed || body[kDestroyed] || (stream.isDestroyed?.(body)))
}

function isReadableAborted (stream) {
  const state = stream?._readableState
  return isDestroyed(stream) && state && !state.endEmitted
}

function destroy (stream, err) {
  if (stream == null || !isStream(stream) || isDestroyed(stream)) {
    return
  }

  if (typeof stream.destroy === 'function') {
    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {
      // See: https://github.com/nodejs/node/pull/38505/files
      stream.socket = null
    }

    stream.destroy(err)
  } else if (err) {
    queueMicrotask(() => {
      stream.emit('error', err)
    })
  }

  if (stream.destroyed !== true) {
    stream[kDestroyed] = true
  }
}

const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/
function parseKeepAliveTimeout (val) {
  const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR)
  return m ? parseInt(m[1], 10) * 1000 : null
}

/**
 * Retrieves a header name and returns its lowercase value.
 * @param {string | Buffer} value Header name
 * @returns {string}
 */
function headerNameToString (value) {
  return typeof value === 'string'
    ? headerNameLowerCasedRecord[value] ?? value.toLowerCase()
    : tree.lookup(value) ?? value.toString('latin1').toLowerCase()
}

/**
 * Receive the buffer as a string and return its lowercase value.
 * @param {Buffer} value Header name
 * @returns {string}
 */
function bufferToLowerCasedHeaderName (value) {
  return tree.lookup(value) ?? value.toString('latin1').toLowerCase()
}

/**
 * @param {Record<string, string | string[]> | (Buffer | string | (Buffer | string)[])[]} headers
 * @param {Record<string, string | string[]>} [obj]
 * @returns {Record<string, string | string[]>}
 */
function parseHeaders (headers, obj) {
  // For H2 support
  if (!Array.isArray(headers)) return headers

  if (obj === undefined) obj = {}
  for (let i = 0; i < headers.length; i += 2) {
    const key = headerNameToString(headers[i])
    let val = obj[key]

    if (val) {
      if (typeof val === 'string') {
        val = [val]
        obj[key] = val
      }
      val.push(headers[i + 1].toString('utf8'))
    } else {
      const headersValue = headers[i + 1]
      if (typeof headersValue === 'string') {
        obj[key] = headersValue
      } else {
        obj[key] = Array.isArray(headersValue) ? headersValue.map(x => x.toString('utf8')) : headersValue.toString('utf8')
      }
    }
  }

  // See https://github.com/nodejs/node/pull/46528
  if ('content-length' in obj && 'content-disposition' in obj) {
    obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1')
  }

  return obj
}

function parseRawHeaders (headers) {
  const len = headers.length
  const ret = new Array(len)

  let hasContentLength = false
  let contentDispositionIdx = -1
  let key
  let val
  let kLen = 0

  for (let n = 0; n < headers.length; n += 2) {
    key = headers[n]
    val = headers[n + 1]

    typeof key !== 'string' && (key = key.toString())
    typeof val !== 'string' && (val = val.toString('utf8'))

    kLen = key.length
    if (kLen === 14 && key[7] === '-' && (key === 'content-length' || key.toLowerCase() === 'content-length')) {
      hasContentLength = true
    } else if (kLen === 19 && key[7] === '-' && (key === 'content-disposition' || key.toLowerCase() === 'content-disposition')) {
      contentDispositionIdx = n + 1
    }
    ret[n] = key
    ret[n + 1] = val
  }

  // See https://github.com/nodejs/node/pull/46528
  if (hasContentLength && contentDispositionIdx !== -1) {
    ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1')
  }

  return ret
}

function isBuffer (buffer) {
  // See, https://github.com/mcollina/undici/pull/319
  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)
}

function validateHandler (handler, method, upgrade) {
  if (!handler || typeof handler !== 'object') {
    throw new InvalidArgumentError('handler must be an object')
  }

  if (typeof handler.onConnect !== 'function') {
    throw new InvalidArgumentError('invalid onConnect method')
  }

  if (typeof handler.onError !== 'function') {
    throw new InvalidArgumentError('invalid onError method')
  }

  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {
    throw new InvalidArgumentError('invalid onBodySent method')
  }

  if (upgrade || method === 'CONNECT') {
    if (typeof handler.onUpgrade !== 'function') {
      throw new InvalidArgumentError('invalid onUpgrade method')
    }
  } else {
    if (typeof handler.onHeaders !== 'function') {
      throw new InvalidArgumentError('invalid onHeaders method')
    }

    if (typeof handler.onData !== 'function') {
      throw new InvalidArgumentError('invalid onData method')
    }

    if (typeof handler.onComplete !== 'function') {
      throw new InvalidArgumentError('invalid onComplete method')
    }
  }
}

// A body is disturbed if it has been read from and it cannot
// be re-used without losing state or data.
function isDisturbed (body) {
  // TODO (fix): Why is body[kBodyUsed] needed?
  return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]))
}

function isErrored (body) {
  return !!(body && stream.isErrored(body))
}

function isReadable (body) {
  return !!(body && stream.isReadable(body))
}

function getSocketInfo (socket) {
  return {
    localAddress: socket.localAddress,
    localPort: socket.localPort,
    remoteAddress: socket.remoteAddress,
    remotePort: socket.remotePort,
    remoteFamily: socket.remoteFamily,
    timeout: socket.timeout,
    bytesWritten: socket.bytesWritten,
    bytesRead: socket.bytesRead
  }
}

/** @type {globalThis['ReadableStream']} */
function ReadableStreamFrom (iterable) {
  // We cannot use ReadableStream.from here because it does not return a byte stream.

  let iterator
  return new ReadableStream(
    {
      async start () {
        iterator = iterable[Symbol.asyncIterator]()
      },
      async pull (controller) {
        const { done, value } = await iterator.next()
        if (done) {
          queueMicrotask(() => {
            controller.close()
            controller.byobRequest?.respond(0)
          })
        } else {
          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)
          if (buf.byteLength) {
            controller.enqueue(new Uint8Array(buf))
          }
        }
        return controller.desiredSize > 0
      },
      async cancel (reason) {
        await iterator.return()
      },
      type: 'bytes'
    }
  )
}

// The chunk should be a FormData instance and contains
// all the required methods.
function isFormDataLike (object) {
  return (
    object &&
    typeof object === 'object' &&
    typeof object.append === 'function' &&
    typeof object.delete === 'function' &&
    typeof object.get === 'function' &&
    typeof object.getAll === 'function' &&
    typeof object.has === 'function' &&
    typeof object.set === 'function' &&
    object[Symbol.toStringTag] === 'FormData'
  )
}

function addAbortListener (signal, listener) {
  if ('addEventListener' in signal) {
    signal.addEventListener('abort', listener, { once: true })
    return () => signal.removeEventListener('abort', listener)
  }
  signal.addListener('abort', listener)
  return () => signal.removeListener('abort', listener)
}

const hasToWellFormed = !!String.prototype.toWellFormed

/**
 * @param {string} val
 */
function toUSVString (val) {
  return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val)
}

/**
 * @see https://tools.ietf.org/html/rfc7230#section-3.2.6
 * @param {number} c
 */
function isTokenCharCode (c) {
  switch (c) {
    case 0x22:
    case 0x28:
    case 0x29:
    case 0x2c:
    case 0x2f:
    case 0x3a:
    case 0x3b:
    case 0x3c:
    case 0x3d:
    case 0x3e:
    case 0x3f:
    case 0x40:
    case 0x5b:
    case 0x5c:
    case 0x5d:
    case 0x7b:
    case 0x7d:
      // DQUOTE and "(),/:;<=>?@[\]{}"
      return false
    default:
      // VCHAR %x21-7E
      return c >= 0x21 && c <= 0x7e
  }
}

/**
 * @param {string} characters
 */
function isValidHTTPToken (characters) {
  if (characters.length === 0) {
    return false
  }
  for (let i = 0; i < characters.length; ++i) {
    if (!isTokenCharCode(characters.charCodeAt(i))) {
      return false
    }
  }
  return true
}

// headerCharRegex have been lifted from
// https://github.com/nodejs/node/blob/main/lib/_http_common.js

/**
 * Matches if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 */
const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/

/**
 * @param {string} characters
 */
function isValidHeaderChar (characters) {
  return !headerCharRegex.test(characters)
}

// Parsed accordingly to RFC 9110
// https://www.rfc-editor.org/rfc/rfc9110#field.content-range
function parseRangeHeader (range) {
  if (range == null || range === '') return { start: 0, end: null, size: null }

  const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null
  return m
    ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      }
    : null
}

const kEnumerableProperty = Object.create(null)
kEnumerableProperty.enumerable = true

module.exports = {
  kEnumerableProperty,
  nop,
  isDisturbed,
  isErrored,
  isReadable,
  toUSVString,
  isReadableAborted,
  isBlobLike,
  parseOrigin,
  parseURL,
  getServerName,
  isStream,
  isIterable,
  isAsyncIterable,
  isDestroyed,
  headerNameToString,
  bufferToLowerCasedHeaderName,
  parseRawHeaders,
  parseHeaders,
  parseKeepAliveTimeout,
  destroy,
  bodyLength,
  deepClone,
  ReadableStreamFrom,
  isBuffer,
  validateHandler,
  getSocketInfo,
  isFormDataLike,
  buildURL,
  addAbortListener,
  isValidHTTPToken,
  isValidHeaderChar,
  isTokenCharCode,
  parseRangeHeader,
  nodeMajor,
  nodeMinor,
  nodeHasAutoSelectFamily: nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 13),
  safeHTTPMethods: ['GET', 'HEAD', 'OPTIONS', 'TRACE']
}


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/agent.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ "./node_modules/undici/lib/dispatcher/dispatcher-base.js")
const Pool = __webpack_require__(/*! ./pool */ "./node_modules/undici/lib/dispatcher/pool.js")
const Client = __webpack_require__(/*! ./client */ "./node_modules/undici/lib/dispatcher/client.js")
const util = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const createRedirectInterceptor = __webpack_require__(/*! ../interceptor/redirect-interceptor */ "./node_modules/undici/lib/interceptor/redirect-interceptor.js")

const kOnConnect = Symbol('onConnect')
const kOnDisconnect = Symbol('onDisconnect')
const kOnConnectionError = Symbol('onConnectionError')
const kMaxRedirections = Symbol('maxRedirections')
const kOnDrain = Symbol('onDrain')
const kFactory = Symbol('factory')
const kOptions = Symbol('options')

function defaultFactory (origin, opts) {
  return opts && opts.connections === 1
    ? new Client(origin, opts)
    : new Pool(origin, opts)
}

class Agent extends DispatcherBase {
  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
    super()

    if (typeof factory !== 'function') {
      throw new InvalidArgumentError('factory must be a function.')
    }

    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
      throw new InvalidArgumentError('connect must be a function or an object')
    }

    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
      throw new InvalidArgumentError('maxRedirections must be a positive number')
    }

    if (connect && typeof connect !== 'function') {
      connect = { ...connect }
    }

    this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent)
      ? options.interceptors.Agent
      : [createRedirectInterceptor({ maxRedirections })]

    this[kOptions] = { ...util.deepClone(options), connect }
    this[kOptions].interceptors = options.interceptors
      ? { ...options.interceptors }
      : undefined
    this[kMaxRedirections] = maxRedirections
    this[kFactory] = factory
    this[kClients] = new Map()

    this[kOnDrain] = (origin, targets) => {
      this.emit('drain', origin, [this, ...targets])
    }

    this[kOnConnect] = (origin, targets) => {
      this.emit('connect', origin, [this, ...targets])
    }

    this[kOnDisconnect] = (origin, targets, err) => {
      this.emit('disconnect', origin, [this, ...targets], err)
    }

    this[kOnConnectionError] = (origin, targets, err) => {
      this.emit('connectionError', origin, [this, ...targets], err)
    }
  }

  get [kRunning] () {
    let ret = 0
    for (const client of this[kClients].values()) {
      ret += client[kRunning]
    }
    return ret
  }

  [kDispatch] (opts, handler) {
    let key
    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {
      key = String(opts.origin)
    } else {
      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')
    }

    let dispatcher = this[kClients].get(key)

    if (!dispatcher) {
      dispatcher = this[kFactory](opts.origin, this[kOptions])
        .on('drain', this[kOnDrain])
        .on('connect', this[kOnConnect])
        .on('disconnect', this[kOnDisconnect])
        .on('connectionError', this[kOnConnectionError])

      // This introduces a tiny memory leak, as dispatchers are never removed from the map.
      // TODO(mcollina): remove te timer when the client/pool do not have any more
      // active connections.
      this[kClients].set(key, dispatcher)
    }

    return dispatcher.dispatch(opts, handler)
  }

  async [kClose] () {
    const closePromises = []
    for (const client of this[kClients].values()) {
      closePromises.push(client.close())
    }
    this[kClients].clear()

    await Promise.all(closePromises)
  }

  async [kDestroy] (err) {
    const destroyPromises = []
    for (const client of this[kClients].values()) {
      destroyPromises.push(client.destroy(err))
    }
    this[kClients].clear()

    await Promise.all(destroyPromises)
  }
}

module.exports = Agent


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/balanced-pool.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/balanced-pool.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BalancedPoolMissingUpstreamError,
  InvalidArgumentError
} = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const {
  PoolBase,
  kClients,
  kNeedDrain,
  kAddClient,
  kRemoveClient,
  kGetDispatcher
} = __webpack_require__(/*! ./pool-base */ "./node_modules/undici/lib/dispatcher/pool-base.js")
const Pool = __webpack_require__(/*! ./pool */ "./node_modules/undici/lib/dispatcher/pool.js")
const { kUrl, kInterceptors } = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const { parseOrigin } = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const kFactory = Symbol('factory')

const kOptions = Symbol('options')
const kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')
const kCurrentWeight = Symbol('kCurrentWeight')
const kIndex = Symbol('kIndex')
const kWeight = Symbol('kWeight')
const kMaxWeightPerServer = Symbol('kMaxWeightPerServer')
const kErrorPenalty = Symbol('kErrorPenalty')

function getGreatestCommonDivisor (a, b) {
  if (b === 0) return a
  return getGreatestCommonDivisor(b, a % b)
}

function defaultFactory (origin, opts) {
  return new Pool(origin, opts)
}

class BalancedPool extends PoolBase {
  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {
    super()

    this[kOptions] = opts
    this[kIndex] = -1
    this[kCurrentWeight] = 0

    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100
    this[kErrorPenalty] = this[kOptions].errorPenalty || 15

    if (!Array.isArray(upstreams)) {
      upstreams = [upstreams]
    }

    if (typeof factory !== 'function') {
      throw new InvalidArgumentError('factory must be a function.')
    }

    this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)
      ? opts.interceptors.BalancedPool
      : []
    this[kFactory] = factory

    for (const upstream of upstreams) {
      this.addUpstream(upstream)
    }
    this._updateBalancedPoolStats()
  }

  addUpstream (upstream) {
    const upstreamOrigin = parseOrigin(upstream).origin

    if (this[kClients].find((pool) => (
      pool[kUrl].origin === upstreamOrigin &&
      pool.closed !== true &&
      pool.destroyed !== true
    ))) {
      return this
    }
    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))

    this[kAddClient](pool)
    pool.on('connect', () => {
      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])
    })

    pool.on('connectionError', () => {
      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])
      this._updateBalancedPoolStats()
    })

    pool.on('disconnect', (...args) => {
      const err = args[2]
      if (err && err.code === 'UND_ERR_SOCKET') {
        // decrease the weight of the pool.
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])
        this._updateBalancedPoolStats()
      }
    })

    for (const client of this[kClients]) {
      client[kWeight] = this[kMaxWeightPerServer]
    }

    this._updateBalancedPoolStats()

    return this
  }

  _updateBalancedPoolStats () {
    this[kGreatestCommonDivisor] = this[kClients].map(p => p[kWeight]).reduce(getGreatestCommonDivisor, 0)
  }

  removeUpstream (upstream) {
    const upstreamOrigin = parseOrigin(upstream).origin

    const pool = this[kClients].find((pool) => (
      pool[kUrl].origin === upstreamOrigin &&
      pool.closed !== true &&
      pool.destroyed !== true
    ))

    if (pool) {
      this[kRemoveClient](pool)
    }

    return this
  }

  get upstreams () {
    return this[kClients]
      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)
      .map((p) => p[kUrl].origin)
  }

  [kGetDispatcher] () {
    // We validate that pools is greater than 0,
    // otherwise we would have to wait until an upstream
    // is added, which might never happen.
    if (this[kClients].length === 0) {
      throw new BalancedPoolMissingUpstreamError()
    }

    const dispatcher = this[kClients].find(dispatcher => (
      !dispatcher[kNeedDrain] &&
      dispatcher.closed !== true &&
      dispatcher.destroyed !== true
    ))

    if (!dispatcher) {
      return
    }

    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)

    if (allClientsBusy) {
      return
    }

    let counter = 0

    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])

    while (counter++ < this[kClients].length) {
      this[kIndex] = (this[kIndex] + 1) % this[kClients].length
      const pool = this[kClients][this[kIndex]]

      // find pool index with the largest weight
      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
        maxWeightIndex = this[kIndex]
      }

      // decrease the current weight every `this[kClients].length`.
      if (this[kIndex] === 0) {
        // Set the current weight to the next lower weight.
        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]

        if (this[kCurrentWeight] <= 0) {
          this[kCurrentWeight] = this[kMaxWeightPerServer]
        }
      }
      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {
        return pool
      }
    }

    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]
    this[kIndex] = maxWeightIndex
    return this[kClients][maxWeightIndex]
  }
}

module.exports = BalancedPool


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/client-h1.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h1.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


/* global WebAssembly */

const assert = __webpack_require__(/*! node:assert */ "node:assert")
const util = __webpack_require__(/*! ../core/util.js */ "./node_modules/undici/lib/core/util.js")
const { channels } = __webpack_require__(/*! ../core/diagnostics.js */ "./node_modules/undici/lib/core/diagnostics.js")
const timers = __webpack_require__(/*! ../util/timers.js */ "./node_modules/undici/lib/util/timers.js")
const {
  RequestContentLengthMismatchError,
  ResponseContentLengthMismatchError,
  RequestAbortedError,
  HeadersTimeoutError,
  HeadersOverflowError,
  SocketError,
  InformationalError,
  BodyTimeoutError,
  HTTPParserError,
  ResponseExceededMaxSizeError
} = __webpack_require__(/*! ../core/errors.js */ "./node_modules/undici/lib/core/errors.js")
const {
  kUrl,
  kReset,
  kClient,
  kParser,
  kBlocking,
  kRunning,
  kPending,
  kSize,
  kWriting,
  kQueue,
  kNoRef,
  kKeepAliveDefaultTimeout,
  kHostHeader,
  kPendingIdx,
  kRunningIdx,
  kError,
  kPipelining,
  kSocket,
  kKeepAliveTimeoutValue,
  kMaxHeadersSize,
  kKeepAliveMaxTimeout,
  kKeepAliveTimeoutThreshold,
  kHeadersTimeout,
  kBodyTimeout,
  kStrictContentLength,
  kMaxRequests,
  kCounter,
  kMaxResponseSize,
  kListeners,
  kOnError,
  kResume,
  kHTTPContext
} = __webpack_require__(/*! ../core/symbols.js */ "./node_modules/undici/lib/core/symbols.js")

const constants = __webpack_require__(/*! ../llhttp/constants.js */ "./node_modules/undici/lib/llhttp/constants.js")
const EMPTY_BUF = Buffer.alloc(0)
const FastBuffer = Buffer[Symbol.species]

let extractBody

function addListener (obj, name, listener) {
  const listeners = (obj[kListeners] ??= [])
  listeners.push([name, listener])
  obj.on(name, listener)
  return obj
}

function removeAllListeners (obj) {
  for (const [name, listener] of obj[kListeners] ?? []) {
    obj.removeListener(name, listener)
  }
  obj[kListeners] = null
}

async function lazyllhttp () {
  const mod = await WebAssembly.compile(__webpack_require__(/*! ../llhttp/llhttp_simd-wasm.js */ "./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"))

  return await WebAssembly.instantiate(mod, {
    env: {
      /* eslint-disable camelcase */

      wasm_on_url: (p, at, len) => {
        /* istanbul ignore next */
        return 0
      },
      wasm_on_status: (p, at, len) => {
        assert.strictEqual(currentParser.ptr, p)
        const start = at - currentBufferPtr + currentBufferRef.byteOffset
        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
      },
      wasm_on_message_begin: (p) => {
        assert.strictEqual(currentParser.ptr, p)
        return currentParser.onMessageBegin() || 0
      },
      wasm_on_header_field: (p, at, len) => {
        assert.strictEqual(currentParser.ptr, p)
        const start = at - currentBufferPtr + currentBufferRef.byteOffset
        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
      },
      wasm_on_header_value: (p, at, len) => {
        assert.strictEqual(currentParser.ptr, p)
        const start = at - currentBufferPtr + currentBufferRef.byteOffset
        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
      },
      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
        assert.strictEqual(currentParser.ptr, p)
        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0
      },
      wasm_on_body: (p, at, len) => {
        assert.strictEqual(currentParser.ptr, p)
        const start = at - currentBufferPtr + currentBufferRef.byteOffset
        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
      },
      wasm_on_message_complete: (p) => {
        assert.strictEqual(currentParser.ptr, p)
        return currentParser.onMessageComplete() || 0
      }

      /* eslint-enable camelcase */
    }
  })
}

let llhttpInstance = null
let llhttpPromise = lazyllhttp()
llhttpPromise.catch()

let currentParser = null
let currentBufferRef = null
let currentBufferSize = 0
let currentBufferPtr = null

const TIMEOUT_HEADERS = 1
const TIMEOUT_BODY = 2
const TIMEOUT_IDLE = 3

class Parser {
  constructor (client, socket, { exports }) {
    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)

    this.llhttp = exports
    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)
    this.client = client
    this.socket = socket
    this.timeout = null
    this.timeoutValue = null
    this.timeoutType = null
    this.statusCode = null
    this.statusText = ''
    this.upgrade = false
    this.headers = []
    this.headersSize = 0
    this.headersMaxSize = client[kMaxHeadersSize]
    this.shouldKeepAlive = false
    this.paused = false
    this.resume = this.resume.bind(this)

    this.bytesRead = 0

    this.keepAlive = ''
    this.contentLength = ''
    this.connection = ''
    this.maxResponseSize = client[kMaxResponseSize]
  }

  setTimeout (value, type) {
    this.timeoutType = type
    if (value !== this.timeoutValue) {
      timers.clearTimeout(this.timeout)
      if (value) {
        this.timeout = timers.setTimeout(onParserTimeout, value, this)
        // istanbul ignore else: only for jest
        if (this.timeout.unref) {
          this.timeout.unref()
        }
      } else {
        this.timeout = null
      }
      this.timeoutValue = value
    } else if (this.timeout) {
      // istanbul ignore else: only for jest
      if (this.timeout.refresh) {
        this.timeout.refresh()
      }
    }
  }

  resume () {
    if (this.socket.destroyed || !this.paused) {
      return
    }

    assert(this.ptr != null)
    assert(currentParser == null)

    this.llhttp.llhttp_resume(this.ptr)

    assert(this.timeoutType === TIMEOUT_BODY)
    if (this.timeout) {
      // istanbul ignore else: only for jest
      if (this.timeout.refresh) {
        this.timeout.refresh()
      }
    }

    this.paused = false
    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.
    this.readMore()
  }

  readMore () {
    while (!this.paused && this.ptr) {
      const chunk = this.socket.read()
      if (chunk === null) {
        break
      }
      this.execute(chunk)
    }
  }

  execute (data) {
    assert(this.ptr != null)
    assert(currentParser == null)
    assert(!this.paused)

    const { socket, llhttp } = this

    if (data.length > currentBufferSize) {
      if (currentBufferPtr) {
        llhttp.free(currentBufferPtr)
      }
      currentBufferSize = Math.ceil(data.length / 4096) * 4096
      currentBufferPtr = llhttp.malloc(currentBufferSize)
    }

    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)

    // Call `execute` on the wasm parser.
    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,
    // and finally the length of bytes to parse.
    // The return value is an error code or `constants.ERROR.OK`.
    try {
      let ret

      try {
        currentBufferRef = data
        currentParser = this
        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)
        /* eslint-disable-next-line no-useless-catch */
      } catch (err) {
        /* istanbul ignore next: difficult to make a test case for */
        throw err
      } finally {
        currentParser = null
        currentBufferRef = null
      }

      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr

      if (ret === constants.ERROR.PAUSED_UPGRADE) {
        this.onUpgrade(data.slice(offset))
      } else if (ret === constants.ERROR.PAUSED) {
        this.paused = true
        socket.unshift(data.slice(offset))
      } else if (ret !== constants.ERROR.OK) {
        const ptr = llhttp.llhttp_get_error_reason(this.ptr)
        let message = ''
        /* istanbul ignore else: difficult to make a test case for */
        if (ptr) {
          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)
          message =
            'Response does not match the HTTP/1.1 protocol (' +
            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +
            ')'
        }
        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))
      }
    } catch (err) {
      util.destroy(socket, err)
    }
  }

  destroy () {
    assert(this.ptr != null)
    assert(currentParser == null)

    this.llhttp.llhttp_free(this.ptr)
    this.ptr = null

    timers.clearTimeout(this.timeout)
    this.timeout = null
    this.timeoutValue = null
    this.timeoutType = null

    this.paused = false
  }

  onStatus (buf) {
    this.statusText = buf.toString()
  }

  onMessageBegin () {
    const { socket, client } = this

    /* istanbul ignore next: difficult to make a test case for */
    if (socket.destroyed) {
      return -1
    }

    const request = client[kQueue][client[kRunningIdx]]
    if (!request) {
      return -1
    }
    request.onResponseStarted()
  }

  onHeaderField (buf) {
    const len = this.headers.length

    if ((len & 1) === 0) {
      this.headers.push(buf)
    } else {
      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])
    }

    this.trackHeader(buf.length)
  }

  onHeaderValue (buf) {
    let len = this.headers.length

    if ((len & 1) === 1) {
      this.headers.push(buf)
      len += 1
    } else {
      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])
    }

    const key = this.headers[len - 2]
    if (key.length === 10) {
      const headerName = util.bufferToLowerCasedHeaderName(key)
      if (headerName === 'keep-alive') {
        this.keepAlive += buf.toString()
      } else if (headerName === 'connection') {
        this.connection += buf.toString()
      }
    } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === 'content-length') {
      this.contentLength += buf.toString()
    }

    this.trackHeader(buf.length)
  }

  trackHeader (len) {
    this.headersSize += len
    if (this.headersSize >= this.headersMaxSize) {
      util.destroy(this.socket, new HeadersOverflowError())
    }
  }

  onUpgrade (head) {
    const { upgrade, client, socket, headers, statusCode } = this

    assert(upgrade)

    const request = client[kQueue][client[kRunningIdx]]
    assert(request)

    assert(!socket.destroyed)
    assert(socket === client[kSocket])
    assert(!this.paused)
    assert(request.upgrade || request.method === 'CONNECT')

    this.statusCode = null
    this.statusText = ''
    this.shouldKeepAlive = null

    assert(this.headers.length % 2 === 0)
    this.headers = []
    this.headersSize = 0

    socket.unshift(head)

    socket[kParser].destroy()
    socket[kParser] = null

    socket[kClient] = null
    socket[kError] = null

    removeAllListeners(socket)

    client[kSocket] = null
    client[kHTTPContext] = null // TODO (fix): This is hacky...
    client[kQueue][client[kRunningIdx]++] = null
    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))

    try {
      request.onUpgrade(statusCode, headers, socket)
    } catch (err) {
      util.destroy(socket, err)
    }

    client[kResume]()
  }

  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {
    const { client, socket, headers, statusText } = this

    /* istanbul ignore next: difficult to make a test case for */
    if (socket.destroyed) {
      return -1
    }

    const request = client[kQueue][client[kRunningIdx]]

    /* istanbul ignore next: difficult to make a test case for */
    if (!request) {
      return -1
    }

    assert(!this.upgrade)
    assert(this.statusCode < 200)

    if (statusCode === 100) {
      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))
      return -1
    }

    /* this can only happen if server is misbehaving */
    if (upgrade && !request.upgrade) {
      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))
      return -1
    }

    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)

    this.statusCode = statusCode
    this.shouldKeepAlive = (
      shouldKeepAlive ||
      // Override llhttp value which does not allow keepAlive for HEAD.
      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')
    )

    if (this.statusCode >= 200) {
      const bodyTimeout = request.bodyTimeout != null
        ? request.bodyTimeout
        : client[kBodyTimeout]
      this.setTimeout(bodyTimeout, TIMEOUT_BODY)
    } else if (this.timeout) {
      // istanbul ignore else: only for jest
      if (this.timeout.refresh) {
        this.timeout.refresh()
      }
    }

    if (request.method === 'CONNECT') {
      assert(client[kRunning] === 1)
      this.upgrade = true
      return 2
    }

    if (upgrade) {
      assert(client[kRunning] === 1)
      this.upgrade = true
      return 2
    }

    assert(this.headers.length % 2 === 0)
    this.headers = []
    this.headersSize = 0

    if (this.shouldKeepAlive && client[kPipelining]) {
      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null

      if (keepAliveTimeout != null) {
        const timeout = Math.min(
          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
          client[kKeepAliveMaxTimeout]
        )
        if (timeout <= 0) {
          socket[kReset] = true
        } else {
          client[kKeepAliveTimeoutValue] = timeout
        }
      } else {
        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]
      }
    } else {
      // Stop more requests from being dispatched.
      socket[kReset] = true
    }

    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false

    if (request.aborted) {
      return -1
    }

    if (request.method === 'HEAD') {
      return 1
    }

    if (statusCode < 200) {
      return 1
    }

    if (socket[kBlocking]) {
      socket[kBlocking] = false
      client[kResume]()
    }

    return pause ? constants.ERROR.PAUSED : 0
  }

  onBody (buf) {
    const { client, socket, statusCode, maxResponseSize } = this

    if (socket.destroyed) {
      return -1
    }

    const request = client[kQueue][client[kRunningIdx]]
    assert(request)

    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)
    if (this.timeout) {
      // istanbul ignore else: only for jest
      if (this.timeout.refresh) {
        this.timeout.refresh()
      }
    }

    assert(statusCode >= 200)

    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
      util.destroy(socket, new ResponseExceededMaxSizeError())
      return -1
    }

    this.bytesRead += buf.length

    if (request.onData(buf) === false) {
      return constants.ERROR.PAUSED
    }
  }

  onMessageComplete () {
    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this

    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
      return -1
    }

    if (upgrade) {
      return
    }

    const request = client[kQueue][client[kRunningIdx]]
    assert(request)

    assert(statusCode >= 100)

    this.statusCode = null
    this.statusText = ''
    this.bytesRead = 0
    this.contentLength = ''
    this.keepAlive = ''
    this.connection = ''

    assert(this.headers.length % 2 === 0)
    this.headers = []
    this.headersSize = 0

    if (statusCode < 200) {
      return
    }

    /* istanbul ignore next: should be handled by llhttp? */
    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {
      util.destroy(socket, new ResponseContentLengthMismatchError())
      return -1
    }

    request.onComplete(headers)

    client[kQueue][client[kRunningIdx]++] = null

    if (socket[kWriting]) {
      assert.strictEqual(client[kRunning], 0)
      // Response completed before request.
      util.destroy(socket, new InformationalError('reset'))
      return constants.ERROR.PAUSED
    } else if (!shouldKeepAlive) {
      util.destroy(socket, new InformationalError('reset'))
      return constants.ERROR.PAUSED
    } else if (socket[kReset] && client[kRunning] === 0) {
      // Destroy socket once all requests have completed.
      // The request at the tail of the pipeline is the one
      // that requested reset and no further requests should
      // have been queued since then.
      util.destroy(socket, new InformationalError('reset'))
      return constants.ERROR.PAUSED
    } else if (client[kPipelining] == null || client[kPipelining] === 1) {
      // We must wait a full event loop cycle to reuse this socket to make sure
      // that non-spec compliant servers are not closing the connection even if they
      // said they won't.
      setImmediate(() => client[kResume]())
    } else {
      client[kResume]()
    }
  }
}

function onParserTimeout (parser) {
  const { socket, timeoutType, client } = parser

  /* istanbul ignore else */
  if (timeoutType === TIMEOUT_HEADERS) {
    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
      assert(!parser.paused, 'cannot be paused while waiting for headers')
      util.destroy(socket, new HeadersTimeoutError())
    }
  } else if (timeoutType === TIMEOUT_BODY) {
    if (!parser.paused) {
      util.destroy(socket, new BodyTimeoutError())
    }
  } else if (timeoutType === TIMEOUT_IDLE) {
    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])
    util.destroy(socket, new InformationalError('socket idle timeout'))
  }
}

async function connectH1 (client, socket) {
  client[kSocket] = socket

  if (!llhttpInstance) {
    llhttpInstance = await llhttpPromise
    llhttpPromise = null
  }

  socket[kNoRef] = false
  socket[kWriting] = false
  socket[kReset] = false
  socket[kBlocking] = false
  socket[kParser] = new Parser(client, socket, llhttpInstance)

  addListener(socket, 'error', function (err) {
    const parser = this[kParser]

    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')

    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded
    // to the user.
    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {
      // We treat all incoming data so for as a valid response.
      parser.onMessageComplete()
      return
    }

    this[kError] = err

    this[kClient][kOnError](err)
  })
  addListener(socket, 'readable', function () {
    const parser = this[kParser]

    if (parser) {
      parser.readMore()
    }
  })
  addListener(socket, 'end', function () {
    const parser = this[kParser]

    if (parser.statusCode && !parser.shouldKeepAlive) {
      // We treat all incoming data so far as a valid response.
      parser.onMessageComplete()
      return
    }

    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))
  })
  addListener(socket, 'close', function () {
    const client = this[kClient]
    const parser = this[kParser]

    if (parser) {
      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
        // We treat all incoming data so far as a valid response.
        parser.onMessageComplete()
      }

      this[kParser].destroy()
      this[kParser] = null
    }

    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))

    client[kSocket] = null
    client[kHTTPContext] = null // TODO (fix): This is hacky...

    if (client.destroyed) {
      assert(client[kPending] === 0)

      // Fail entire queue.
      const requests = client[kQueue].splice(client[kRunningIdx])
      for (let i = 0; i < requests.length; i++) {
        const request = requests[i]
        errorRequest(client, request, err)
      }
    } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {
      // Fail head of pipeline.
      const request = client[kQueue][client[kRunningIdx]]
      client[kQueue][client[kRunningIdx]++] = null

      errorRequest(client, request, err)
    }

    client[kPendingIdx] = client[kRunningIdx]

    assert(client[kRunning] === 0)

    client.emit('disconnect', client[kUrl], [client], err)

    client[kResume]()
  })

  let closed = false
  socket.on('close', () => {
    closed = true
  })

  return {
    version: 'h1',
    defaultPipelining: 1,
    write (...args) {
      return writeH1(client, ...args)
    },
    resume () {
      resumeH1(client)
    },
    destroy (err, callback) {
      if (closed) {
        queueMicrotask(callback)
      } else {
        socket.destroy(err).on('close', callback)
      }
    },
    get destroyed () {
      return socket.destroyed
    },
    busy (request) {
      if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {
        return true
      }

      if (request) {
        if (client[kRunning] > 0 && !request.idempotent) {
          // Non-idempotent request cannot be retried.
          // Ensure that no other requests are inflight and
          // could cause failure.
          return true
        }

        if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {
          // Don't dispatch an upgrade until all preceding requests have completed.
          // A misbehaving server might upgrade the connection before all pipelined
          // request has completed.
          return true
        }

        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&
          (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {
          // Request with stream or iterator body can error while other requests
          // are inflight and indirectly error those as well.
          // Ensure this doesn't happen by waiting for inflight
          // to complete before dispatching.

          // Request with stream or iterator body cannot be retried.
          // Ensure that no other requests are inflight and
          // could cause failure.
          return true
        }
      }

      return false
    }
  }
}

function resumeH1 (client) {
  const socket = client[kSocket]

  if (socket && !socket.destroyed) {
    if (client[kSize] === 0) {
      if (!socket[kNoRef] && socket.unref) {
        socket.unref()
        socket[kNoRef] = true
      }
    } else if (socket[kNoRef] && socket.ref) {
      socket.ref()
      socket[kNoRef] = false
    }

    if (client[kSize] === 0) {
      if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
        socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)
      }
    } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
      if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
        const request = client[kQueue][client[kRunningIdx]]
        const headersTimeout = request.headersTimeout != null
          ? request.headersTimeout
          : client[kHeadersTimeout]
        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)
      }
    }
  }
}

function errorRequest (client, request, err) {
  try {
    request.onError(err)
    assert(request.aborted)
  } catch (err) {
    client.emit('error', err)
  }
}

// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2
function shouldSendContentLength (method) {
  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'
}

function writeH1 (client, request) {
  const { method, path, host, upgrade, blocking, reset } = request

  let { body, headers, contentLength } = request

  // https://tools.ietf.org/html/rfc7231#section-4.3.1
  // https://tools.ietf.org/html/rfc7231#section-4.3.2
  // https://tools.ietf.org/html/rfc7231#section-4.3.5

  // Sending a payload body on a request that does not
  // expect it can cause undefined behavior on some
  // servers and corrupt connection state. Do not
  // re-use the connection for further requests.

  const expectsPayload = (
    method === 'PUT' ||
    method === 'POST' ||
    method === 'PATCH'
  )

  if (util.isFormDataLike(body)) {
    if (!extractBody) {
      extractBody = (__webpack_require__(/*! ../web/fetch/body.js */ "./node_modules/undici/lib/web/fetch/body.js").extractBody)
    }

    const [bodyStream, contentType] = extractBody(body)
    if (request.contentType == null) {
      headers.push('content-type', contentType)
    }
    body = bodyStream.stream
    contentLength = bodyStream.length
  } else if (util.isBlobLike(body) && request.contentType == null && body.type) {
    headers.push('content-type', body.type)
  }

  if (body && typeof body.read === 'function') {
    // Try to read EOF in order to get length.
    body.read(0)
  }

  const bodyLength = util.bodyLength(body)

  contentLength = bodyLength ?? contentLength

  if (contentLength === null) {
    contentLength = request.contentLength
  }

  if (contentLength === 0 && !expectsPayload) {
    // https://tools.ietf.org/html/rfc7230#section-3.3.2
    // A user agent SHOULD NOT send a Content-Length header field when
    // the request message does not contain a payload body and the method
    // semantics do not anticipate such a body.

    contentLength = null
  }

  // https://github.com/nodejs/undici/issues/2046
  // A user agent may send a Content-Length header with 0 value, this should be allowed.
  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
    if (client[kStrictContentLength]) {
      errorRequest(client, request, new RequestContentLengthMismatchError())
      return false
    }

    process.emitWarning(new RequestContentLengthMismatchError())
  }

  const socket = client[kSocket]

  try {
    request.onConnect((err) => {
      if (request.aborted || request.completed) {
        return
      }

      errorRequest(client, request, err || new RequestAbortedError())

      util.destroy(socket, new InformationalError('aborted'))
    })
  } catch (err) {
    errorRequest(client, request, err)
  }

  if (request.aborted) {
    util.destroy(body)
    return false
  }

  if (method === 'HEAD') {
    // https://github.com/mcollina/undici/issues/258
    // Close after a HEAD request to interop with misbehaving servers
    // that may send a body in the response.

    socket[kReset] = true
  }

  if (upgrade || method === 'CONNECT') {
    // On CONNECT or upgrade, block pipeline from dispatching further
    // requests on this connection.

    socket[kReset] = true
  }

  if (reset != null) {
    socket[kReset] = reset
  }

  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
    socket[kReset] = true
  }

  if (blocking) {
    socket[kBlocking] = true
  }

  let header = `${method} ${path} HTTP/1.1\r\n`

  if (typeof host === 'string') {
    header += `host: ${host}\r\n`
  } else {
    header += client[kHostHeader]
  }

  if (upgrade) {
    header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`
  } else if (client[kPipelining] && !socket[kReset]) {
    header += 'connection: keep-alive\r\n'
  } else {
    header += 'connection: close\r\n'
  }

  if (Array.isArray(headers)) {
    for (let n = 0; n < headers.length; n += 2) {
      const key = headers[n + 0]
      const val = headers[n + 1]

      if (Array.isArray(val)) {
        for (let i = 0; i < val.length; i++) {
          header += `${key}: ${val[i]}\r\n`
        }
      } else {
        header += `${key}: ${val}\r\n`
      }
    }
  }

  if (channels.sendHeaders.hasSubscribers) {
    channels.sendHeaders.publish({ request, headers: header, socket })
  }

  /* istanbul ignore else: assertion */
  if (!body || bodyLength === 0) {
    if (contentLength === 0) {
      socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1')
    } else {
      assert(contentLength === null, 'no body must not have content length')
      socket.write(`${header}\r\n`, 'latin1')
    }
    request.onRequestSent()
  } else if (util.isBuffer(body)) {
    assert(contentLength === body.byteLength, 'buffer body must have content length')

    socket.cork()
    socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1')
    socket.write(body)
    socket.uncork()
    request.onBodySent(body)
    request.onRequestSent()
    if (!expectsPayload) {
      socket[kReset] = true
    }
  } else if (util.isBlobLike(body)) {
    if (typeof body.stream === 'function') {
      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })
    } else {
      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })
    }
  } else if (util.isStream(body)) {
    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })
  } else if (util.isIterable(body)) {
    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })
  } else {
    assert(false)
  }

  return true
}

function writeStream ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')

  let finished = false

  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })

  const onData = function (chunk) {
    if (finished) {
      return
    }

    try {
      if (!writer.write(chunk) && this.pause) {
        this.pause()
      }
    } catch (err) {
      util.destroy(this, err)
    }
  }
  const onDrain = function () {
    if (finished) {
      return
    }

    if (body.resume) {
      body.resume()
    }
  }
  const onClose = function () {
    // 'close' might be emitted *before* 'error' for
    // broken streams. Wait a tick to avoid this case.
    queueMicrotask(() => {
      // It's only safe to remove 'error' listener after
      // 'close'.
      body.removeListener('error', onFinished)
    })

    if (!finished) {
      const err = new RequestAbortedError()
      queueMicrotask(() => onFinished(err))
    }
  }
  const onFinished = function (err) {
    if (finished) {
      return
    }

    finished = true

    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))

    socket
      .off('drain', onDrain)
      .off('error', onFinished)

    body
      .removeListener('data', onData)
      .removeListener('end', onFinished)
      .removeListener('close', onClose)

    if (!err) {
      try {
        writer.end()
      } catch (er) {
        err = er
      }
    }

    writer.destroy(err)

    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {
      util.destroy(body, err)
    } else {
      util.destroy(body)
    }
  }

  body
    .on('data', onData)
    .on('end', onFinished)
    .on('error', onFinished)
    .on('close', onClose)

  if (body.resume) {
    body.resume()
  }

  socket
    .on('drain', onDrain)
    .on('error', onFinished)

  if (body.errorEmitted ?? body.errored) {
    setImmediate(() => onFinished(body.errored))
  } else if (body.endEmitted ?? body.readableEnded) {
    setImmediate(() => onFinished(null))
  }

  if (body.closeEmitted ?? body.closed) {
    setImmediate(onClose)
  }
}

async function writeBlob ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
  assert(contentLength === body.size, 'blob body must have content length')

  try {
    if (contentLength != null && contentLength !== body.size) {
      throw new RequestContentLengthMismatchError()
    }

    const buffer = Buffer.from(await body.arrayBuffer())

    socket.cork()
    socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1')
    socket.write(buffer)
    socket.uncork()

    request.onBodySent(buffer)
    request.onRequestSent()

    if (!expectsPayload) {
      socket[kReset] = true
    }

    client[kResume]()
  } catch (err) {
    util.destroy(socket, err)
  }
}

async function writeIterable ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')

  let callback = null
  function onDrain () {
    if (callback) {
      const cb = callback
      callback = null
      cb()
    }
  }

  const waitForDrain = () => new Promise((resolve, reject) => {
    assert(callback === null)

    if (socket[kError]) {
      reject(socket[kError])
    } else {
      callback = resolve
    }
  })

  socket
    .on('close', onDrain)
    .on('drain', onDrain)

  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })
  try {
    // It's up to the user to somehow abort the async iterable.
    for await (const chunk of body) {
      if (socket[kError]) {
        throw socket[kError]
      }

      if (!writer.write(chunk)) {
        await waitForDrain()
      }
    }

    writer.end()
  } catch (err) {
    writer.destroy(err)
  } finally {
    socket
      .off('close', onDrain)
      .off('drain', onDrain)
  }
}

class AsyncWriter {
  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {
    this.socket = socket
    this.request = request
    this.contentLength = contentLength
    this.client = client
    this.bytesWritten = 0
    this.expectsPayload = expectsPayload
    this.header = header

    socket[kWriting] = true
  }

  write (chunk) {
    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this

    if (socket[kError]) {
      throw socket[kError]
    }

    if (socket.destroyed) {
      return false
    }

    const len = Buffer.byteLength(chunk)
    if (!len) {
      return true
    }

    // We should defer writing chunks.
    if (contentLength !== null && bytesWritten + len > contentLength) {
      if (client[kStrictContentLength]) {
        throw new RequestContentLengthMismatchError()
      }

      process.emitWarning(new RequestContentLengthMismatchError())
    }

    socket.cork()

    if (bytesWritten === 0) {
      if (!expectsPayload) {
        socket[kReset] = true
      }

      if (contentLength === null) {
        socket.write(`${header}transfer-encoding: chunked\r\n`, 'latin1')
      } else {
        socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1')
      }
    }

    if (contentLength === null) {
      socket.write(`\r\n${len.toString(16)}\r\n`, 'latin1')
    }

    this.bytesWritten += len

    const ret = socket.write(chunk)

    socket.uncork()

    request.onBodySent(chunk)

    if (!ret) {
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        // istanbul ignore else: only for jest
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh()
        }
      }
    }

    return ret
  }

  end () {
    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this
    request.onRequestSent()

    socket[kWriting] = false

    if (socket[kError]) {
      throw socket[kError]
    }

    if (socket.destroyed) {
      return
    }

    if (bytesWritten === 0) {
      if (expectsPayload) {
        // https://tools.ietf.org/html/rfc7230#section-3.3.2
        // A user agent SHOULD send a Content-Length in a request message when
        // no Transfer-Encoding is sent and the request method defines a meaning
        // for an enclosed payload body.

        socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1')
      } else {
        socket.write(`${header}\r\n`, 'latin1')
      }
    } else if (contentLength === null) {
      socket.write('\r\n0\r\n\r\n', 'latin1')
    }

    if (contentLength !== null && bytesWritten !== contentLength) {
      if (client[kStrictContentLength]) {
        throw new RequestContentLengthMismatchError()
      } else {
        process.emitWarning(new RequestContentLengthMismatchError())
      }
    }

    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
      // istanbul ignore else: only for jest
      if (socket[kParser].timeout.refresh) {
        socket[kParser].timeout.refresh()
      }
    }

    client[kResume]()
  }

  destroy (err) {
    const { socket, client } = this

    socket[kWriting] = false

    if (err) {
      assert(client[kRunning] <= 1, 'pipeline should only contain this request')
      util.destroy(socket, err)
    }
  }
}

module.exports = connectH1


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/client-h2.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h2.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const assert = __webpack_require__(/*! node:assert */ "node:assert")
const { pipeline } = __webpack_require__(/*! node:stream */ "node:stream")
const util = __webpack_require__(/*! ../core/util.js */ "./node_modules/undici/lib/core/util.js")
const {
  RequestContentLengthMismatchError,
  RequestAbortedError,
  SocketError,
  InformationalError
} = __webpack_require__(/*! ../core/errors.js */ "./node_modules/undici/lib/core/errors.js")
const {
  kUrl,
  kReset,
  kClient,
  kRunning,
  kPending,
  kQueue,
  kPendingIdx,
  kRunningIdx,
  kError,
  kSocket,
  kStrictContentLength,
  kOnError,
  // HTTP2
  kMaxConcurrentStreams,
  kHTTP2Session,
  kResume
} = __webpack_require__(/*! ../core/symbols.js */ "./node_modules/undici/lib/core/symbols.js")

const kOpenStreams = Symbol('open streams')

// Experimental
let h2ExperimentalWarned = false

/** @type {import('http2')} */
let http2
try {
  http2 = __webpack_require__(/*! node:http2 */ "node:http2")
} catch {
  // @ts-ignore
  http2 = { constants: {} }
}

const {
  constants: {
    HTTP2_HEADER_AUTHORITY,
    HTTP2_HEADER_METHOD,
    HTTP2_HEADER_PATH,
    HTTP2_HEADER_SCHEME,
    HTTP2_HEADER_CONTENT_LENGTH,
    HTTP2_HEADER_EXPECT,
    HTTP2_HEADER_STATUS
  }
} = http2

async function connectH2 (client, socket) {
  client[kSocket] = socket

  if (!h2ExperimentalWarned) {
    h2ExperimentalWarned = true
    process.emitWarning('H2 support is experimental, expect them to change at any time.', {
      code: 'UNDICI-H2'
    })
  }

  const session = http2.connect(client[kUrl], {
    createConnection: () => socket,
    peerMaxConcurrentStreams: client[kMaxConcurrentStreams]
  })

  session[kOpenStreams] = 0
  session[kClient] = client
  session[kSocket] = socket
  session.on('error', onHttp2SessionError)
  session.on('frameError', onHttp2FrameError)
  session.on('end', onHttp2SessionEnd)
  session.on('goaway', onHTTP2GoAway)
  session.on('close', function () {
    const { [kClient]: client } = this

    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))

    client[kSocket] = null

    assert(client[kPending] === 0)

    // Fail entire queue.
    const requests = client[kQueue].splice(client[kRunningIdx])
    for (let i = 0; i < requests.length; i++) {
      const request = requests[i]
      errorRequest(client, request, err)
    }

    client[kPendingIdx] = client[kRunningIdx]

    assert(client[kRunning] === 0)

    client.emit('disconnect', client[kUrl], [client], err)

    client[kResume]()
  })
  session.unref()

  client[kHTTP2Session] = session
  socket[kHTTP2Session] = session

  socket.on('error', function (err) {
    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')

    this[kError] = err

    this[kClient][kOnError](err)
  })
  socket.on('end', function () {
    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))
  })

  let closed = false
  socket.on('close', () => {
    closed = true
  })

  return {
    version: 'h2',
    defaultPipelining: Infinity,
    write (...args) {
      // TODO (fix): return
      writeH2(client, ...args)
    },
    resume () {

    },
    destroy (err, callback) {
      session.destroy(err)
      if (closed) {
        queueMicrotask(callback)
      } else {
        socket.destroy(err).on('close', callback)
      }
    },
    get destroyed () {
      return socket.destroyed
    },
    busy () {
      return false
    }
  }
}

function onHttp2SessionError (err) {
  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')

  this[kSocket][kError] = err

  this[kClient][kOnError](err)
}

function onHttp2FrameError (type, code, id) {
  const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`)

  if (id === 0) {
    this[kSocket][kError] = err
    this[kClient][kOnError](err)
  }
}

function onHttp2SessionEnd () {
  this.destroy(new SocketError('other side closed'))
  util.destroy(this[kSocket], new SocketError('other side closed'))
}

function onHTTP2GoAway (code) {
  const client = this[kClient]
  const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`)
  client[kSocket] = null
  client[kHTTP2Session] = null

  if (client.destroyed) {
    assert(this[kPending] === 0)

    // Fail entire queue.
    const requests = client[kQueue].splice(client[kRunningIdx])
    for (let i = 0; i < requests.length; i++) {
      const request = requests[i]
      errorRequest(this, request, err)
    }
  } else if (client[kRunning] > 0) {
    // Fail head of pipeline.
    const request = client[kQueue][client[kRunningIdx]]
    client[kQueue][client[kRunningIdx]++] = null

    errorRequest(client, request, err)
  }

  client[kPendingIdx] = client[kRunningIdx]

  assert(client[kRunning] === 0)

  client.emit('disconnect',
    client[kUrl],
    [client],
    err
  )

  client[kResume]()
}

function errorRequest (client, request, err) {
  try {
    request.onError(err)
    assert(request.aborted)
  } catch (err) {
    client.emit('error', err)
  }
}

// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2
function shouldSendContentLength (method) {
  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'
}

function writeH2 (client, request) {
  const session = client[kHTTP2Session]
  const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request

  if (upgrade) {
    errorRequest(client, request, new Error('Upgrade not supported for H2'))
    return false
  }

  if (request.aborted) {
    return false
  }

  const headers = {}
  for (let n = 0; n < reqHeaders.length; n += 2) {
    const key = reqHeaders[n + 0]
    const val = reqHeaders[n + 1]

    if (Array.isArray(val)) {
      for (let i = 0; i < val.length; i++) {
        if (headers[key]) {
          headers[key] += `,${val[i]}`
        } else {
          headers[key] = val[i]
        }
      }
    } else {
      headers[key] = val
    }
  }

  /** @type {import('node:http2').ClientHttp2Stream} */
  let stream

  const { hostname, port } = client[kUrl]

  headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ''}`
  headers[HTTP2_HEADER_METHOD] = method

  try {
    // We are already connected, streams are pending.
    // We can call on connect, and wait for abort
    request.onConnect((err) => {
      if (request.aborted || request.completed) {
        return
      }

      err = err || new RequestAbortedError()

      if (stream != null) {
        util.destroy(stream, err)

        session[kOpenStreams] -= 1
        if (session[kOpenStreams] === 0) {
          session.unref()
        }
      }

      errorRequest(client, request, err)
    })
  } catch (err) {
    errorRequest(client, request, err)
  }

  if (method === 'CONNECT') {
    session.ref()
    // We are already connected, streams are pending, first request
    // will create a new stream. We trigger a request to create the stream and wait until
    // `ready` event is triggered
    // We disabled endStream to allow the user to write to the stream
    stream = session.request(headers, { endStream: false, signal })

    if (stream.id && !stream.pending) {
      request.onUpgrade(null, null, stream)
      ++session[kOpenStreams]
    } else {
      stream.once('ready', () => {
        request.onUpgrade(null, null, stream)
        ++session[kOpenStreams]
      })
    }

    stream.once('close', () => {
      session[kOpenStreams] -= 1
      // TODO(HTTP/2): unref only if current streams count is 0
      if (session[kOpenStreams] === 0) session.unref()
    })

    return true
  }

  // https://tools.ietf.org/html/rfc7540#section-8.3
  // :path and :scheme headers must be omitted when sending CONNECT

  headers[HTTP2_HEADER_PATH] = path
  headers[HTTP2_HEADER_SCHEME] = 'https'

  // https://tools.ietf.org/html/rfc7231#section-4.3.1
  // https://tools.ietf.org/html/rfc7231#section-4.3.2
  // https://tools.ietf.org/html/rfc7231#section-4.3.5

  // Sending a payload body on a request that does not
  // expect it can cause undefined behavior on some
  // servers and corrupt connection state. Do not
  // re-use the connection for further requests.

  const expectsPayload = (
    method === 'PUT' ||
    method === 'POST' ||
    method === 'PATCH'
  )

  if (body && typeof body.read === 'function') {
    // Try to read EOF in order to get length.
    body.read(0)
  }

  let contentLength = util.bodyLength(body)

  if (contentLength == null) {
    contentLength = request.contentLength
  }

  if (contentLength === 0 || !expectsPayload) {
    // https://tools.ietf.org/html/rfc7230#section-3.3.2
    // A user agent SHOULD NOT send a Content-Length header field when
    // the request message does not contain a payload body and the method
    // semantics do not anticipate such a body.

    contentLength = null
  }

  // https://github.com/nodejs/undici/issues/2046
  // A user agent may send a Content-Length header with 0 value, this should be allowed.
  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
    if (client[kStrictContentLength]) {
      errorRequest(client, request, new RequestContentLengthMismatchError())
      return false
    }

    process.emitWarning(new RequestContentLengthMismatchError())
  }

  if (contentLength != null) {
    assert(body, 'no body must not have content length')
    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`
  }

  session.ref()

  const shouldEndStream = method === 'GET' || method === 'HEAD' || body === null
  if (expectContinue) {
    headers[HTTP2_HEADER_EXPECT] = '100-continue'
    stream = session.request(headers, { endStream: shouldEndStream, signal })

    stream.once('continue', writeBodyH2)
  } else {
    stream = session.request(headers, {
      endStream: shouldEndStream,
      signal
    })
    writeBodyH2()
  }

  // Increment counter as we have new several streams open
  ++session[kOpenStreams]

  stream.once('response', headers => {
    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers
    request.onResponseStarted()

    if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), '') === false) {
      stream.pause()
    }
  })

  stream.once('end', () => {
    // When state is null, it means we haven't consumed body and the stream still do not have
    // a state.
    // Present specially when using pipeline or stream
    if (stream.state?.state == null || stream.state.state < 6) {
      request.onComplete([])
      return
    }

    // Stream is closed or half-closed-remote (6), decrement counter and cleanup
    // It does not have sense to continue working with the stream as we do not
    // have yet RST_STREAM support on client-side
    session[kOpenStreams] -= 1
    if (session[kOpenStreams] === 0) {
      session.unref()
    }

    const err = new InformationalError('HTTP/2: stream half-closed (remote)')
    errorRequest(client, request, err)
    util.destroy(stream, err)
  })

  stream.on('data', (chunk) => {
    if (request.onData(chunk) === false) {
      stream.pause()
    }
  })

  stream.once('close', () => {
    session[kOpenStreams] -= 1
    // TODO(HTTP/2): unref only if current streams count is 0
    if (session[kOpenStreams] === 0) {
      session.unref()
    }
  })

  stream.once('error', function (err) {
    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
      session[kOpenStreams] -= 1
      util.destroy(stream, err)
    }
  })

  stream.once('frameError', (type, code) => {
    const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`)
    errorRequest(client, request, err)

    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
      session[kOpenStreams] -= 1
      util.destroy(stream, err)
    }
  })

  // stream.on('aborted', () => {
  //   // TODO(HTTP/2): Support aborted
  // })

  // stream.on('timeout', () => {
  //   // TODO(HTTP/2): Support timeout
  // })

  // stream.on('push', headers => {
  //   // TODO(HTTP/2): Support push
  // })

  // stream.on('trailers', headers => {
  //   // TODO(HTTP/2): Support trailers
  // })

  return true

  function writeBodyH2 () {
    /* istanbul ignore else: assertion */
    if (!body) {
      request.onRequestSent()
    } else if (util.isBuffer(body)) {
      assert(contentLength === body.byteLength, 'buffer body must have content length')
      stream.cork()
      stream.write(body)
      stream.uncork()
      stream.end()
      request.onBodySent(body)
      request.onRequestSent()
    } else if (util.isBlobLike(body)) {
      if (typeof body.stream === 'function') {
        writeIterable({
          client,
          request,
          contentLength,
          h2stream: stream,
          expectsPayload,
          body: body.stream(),
          socket: client[kSocket],
          header: ''
        })
      } else {
        writeBlob({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          h2stream: stream,
          header: '',
          socket: client[kSocket]
        })
      }
    } else if (util.isStream(body)) {
      writeStream({
        body,
        client,
        request,
        contentLength,
        expectsPayload,
        socket: client[kSocket],
        h2stream: stream,
        header: ''
      })
    } else if (util.isIterable(body)) {
      writeIterable({
        body,
        client,
        request,
        contentLength,
        expectsPayload,
        header: '',
        h2stream: stream,
        socket: client[kSocket]
      })
    } else {
      assert(false)
    }
  }
}

function writeStream ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')

  // For HTTP/2, is enough to pipe the stream
  const pipe = pipeline(
    body,
    h2stream,
    (err) => {
      if (err) {
        util.destroy(body, err)
        util.destroy(h2stream, err)
      } else {
        request.onRequestSent()
      }
    }
  )

  pipe.on('data', onPipeData)
  pipe.once('end', () => {
    pipe.removeListener('data', onPipeData)
    util.destroy(pipe)
  })

  function onPipeData (chunk) {
    request.onBodySent(chunk)
  }
}

async function writeBlob ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
  assert(contentLength === body.size, 'blob body must have content length')

  try {
    if (contentLength != null && contentLength !== body.size) {
      throw new RequestContentLengthMismatchError()
    }

    const buffer = Buffer.from(await body.arrayBuffer())

    h2stream.cork()
    h2stream.write(buffer)
    h2stream.uncork()

    request.onBodySent(buffer)
    request.onRequestSent()

    if (!expectsPayload) {
      socket[kReset] = true
    }

    client[kResume]()
  } catch (err) {
    util.destroy(h2stream)
  }
}

async function writeIterable ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')

  let callback = null
  function onDrain () {
    if (callback) {
      const cb = callback
      callback = null
      cb()
    }
  }

  const waitForDrain = () => new Promise((resolve, reject) => {
    assert(callback === null)

    if (socket[kError]) {
      reject(socket[kError])
    } else {
      callback = resolve
    }
  })

  h2stream
    .on('close', onDrain)
    .on('drain', onDrain)

  try {
    // It's up to the user to somehow abort the async iterable.
    for await (const chunk of body) {
      if (socket[kError]) {
        throw socket[kError]
      }

      const res = h2stream.write(chunk)
      request.onBodySent(chunk)
      if (!res) {
        await waitForDrain()
      }
    }
  } catch (err) {
    h2stream.destroy(err)
  } finally {
    request.onRequestSent()
    h2stream.end()
    h2stream
      .off('close', onDrain)
      .off('drain', onDrain)
  }
}

module.exports = connectH2


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/client.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// @ts-check



const assert = __webpack_require__(/*! node:assert */ "node:assert")
const net = __webpack_require__(/*! node:net */ "node:net")
const http = __webpack_require__(/*! node:http */ "node:http")
const util = __webpack_require__(/*! ../core/util.js */ "./node_modules/undici/lib/core/util.js")
const { channels } = __webpack_require__(/*! ../core/diagnostics.js */ "./node_modules/undici/lib/core/diagnostics.js")
const Request = __webpack_require__(/*! ../core/request.js */ "./node_modules/undici/lib/core/request.js")
const DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ "./node_modules/undici/lib/dispatcher/dispatcher-base.js")
const {
  InvalidArgumentError,
  InformationalError,
  ClientDestroyedError
} = __webpack_require__(/*! ../core/errors.js */ "./node_modules/undici/lib/core/errors.js")
const buildConnector = __webpack_require__(/*! ../core/connect.js */ "./node_modules/undici/lib/core/connect.js")
const {
  kUrl,
  kServerName,
  kClient,
  kBusy,
  kConnect,
  kResuming,
  kRunning,
  kPending,
  kSize,
  kQueue,
  kConnected,
  kConnecting,
  kNeedDrain,
  kKeepAliveDefaultTimeout,
  kHostHeader,
  kPendingIdx,
  kRunningIdx,
  kError,
  kPipelining,
  kKeepAliveTimeoutValue,
  kMaxHeadersSize,
  kKeepAliveMaxTimeout,
  kKeepAliveTimeoutThreshold,
  kHeadersTimeout,
  kBodyTimeout,
  kStrictContentLength,
  kConnector,
  kMaxRedirections,
  kMaxRequests,
  kCounter,
  kClose,
  kDestroy,
  kDispatch,
  kInterceptors,
  kLocalAddress,
  kMaxResponseSize,
  kOnError,
  kHTTPContext,
  kMaxConcurrentStreams,
  kResume
} = __webpack_require__(/*! ../core/symbols.js */ "./node_modules/undici/lib/core/symbols.js")
const connectH1 = __webpack_require__(/*! ./client-h1.js */ "./node_modules/undici/lib/dispatcher/client-h1.js")
const connectH2 = __webpack_require__(/*! ./client-h2.js */ "./node_modules/undici/lib/dispatcher/client-h2.js")

const kClosedResolve = Symbol('kClosedResolve')

function getPipelining (client) {
  return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1
}

/**
 * @type {import('../../types/client.js').default}
 */
class Client extends DispatcherBase {
  /**
   *
   * @param {string|URL} url
   * @param {import('../../types/client.js').Client.Options} options
   */
  constructor (url, {
    interceptors,
    maxHeaderSize,
    headersTimeout,
    socketTimeout,
    requestTimeout,
    connectTimeout,
    bodyTimeout,
    idleTimeout,
    keepAlive,
    keepAliveTimeout,
    maxKeepAliveTimeout,
    keepAliveMaxTimeout,
    keepAliveTimeoutThreshold,
    socketPath,
    pipelining,
    tls,
    strictContentLength,
    maxCachedSessions,
    maxRedirections,
    connect,
    maxRequestsPerClient,
    localAddress,
    maxResponseSize,
    autoSelectFamily,
    autoSelectFamilyAttemptTimeout,
    // h2
    maxConcurrentStreams,
    allowH2
  } = {}) {
    super()

    if (keepAlive !== undefined) {
      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')
    }

    if (socketTimeout !== undefined) {
      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')
    }

    if (requestTimeout !== undefined) {
      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')
    }

    if (idleTimeout !== undefined) {
      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')
    }

    if (maxKeepAliveTimeout !== undefined) {
      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')
    }

    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
      throw new InvalidArgumentError('invalid maxHeaderSize')
    }

    if (socketPath != null && typeof socketPath !== 'string') {
      throw new InvalidArgumentError('invalid socketPath')
    }

    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
      throw new InvalidArgumentError('invalid connectTimeout')
    }

    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
      throw new InvalidArgumentError('invalid keepAliveTimeout')
    }

    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')
    }

    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')
    }

    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')
    }

    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')
    }

    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
      throw new InvalidArgumentError('connect must be a function or an object')
    }

    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
      throw new InvalidArgumentError('maxRedirections must be a positive number')
    }

    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')
    }

    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {
      throw new InvalidArgumentError('localAddress must be valid string IP address')
    }

    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
      throw new InvalidArgumentError('maxResponseSize must be a positive number')
    }

    if (
      autoSelectFamilyAttemptTimeout != null &&
      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)
    ) {
      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')
    }

    // h2
    if (allowH2 != null && typeof allowH2 !== 'boolean') {
      throw new InvalidArgumentError('allowH2 must be a valid boolean value')
    }

    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {
      throw new InvalidArgumentError('maxConcurrentStreams must be a positive integer, greater than 0')
    }

    if (typeof connect !== 'function') {
      connect = buildConnector({
        ...tls,
        maxCachedSessions,
        allowH2,
        socketPath,
        timeout: connectTimeout,
        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),
        ...connect
      })
    }

    this[kInterceptors] = interceptors?.Client && Array.isArray(interceptors.Client)
      ? interceptors.Client
      : [createRedirectInterceptor({ maxRedirections })]
    this[kUrl] = util.parseOrigin(url)
    this[kConnector] = connect
    this[kPipelining] = pipelining != null ? pipelining : 1
    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize
    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout
    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout
    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold
    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]
    this[kServerName] = null
    this[kLocalAddress] = localAddress != null ? localAddress : null
    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming
    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming
    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\r\n`
    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3
    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3
    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength
    this[kMaxRedirections] = maxRedirections
    this[kMaxRequests] = maxRequestsPerClient
    this[kClosedResolve] = null
    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1
    this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server
    this[kHTTPContext] = null

    // kQueue is built up of 3 sections separated by
    // the kRunningIdx and kPendingIdx indices.
    // |   complete   |   running   |   pending   |
    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length
    // kRunningIdx points to the first running element.
    // kPendingIdx points to the first pending element.
    // This implements a fast queue with an amortized
    // time of O(1).

    this[kQueue] = []
    this[kRunningIdx] = 0
    this[kPendingIdx] = 0

    this[kResume] = (sync) => resume(this, sync)
    this[kOnError] = (err) => onError(this, err)
  }

  get pipelining () {
    return this[kPipelining]
  }

  set pipelining (value) {
    this[kPipelining] = value
    this[kResume](true)
  }

  get [kPending] () {
    return this[kQueue].length - this[kPendingIdx]
  }

  get [kRunning] () {
    return this[kPendingIdx] - this[kRunningIdx]
  }

  get [kSize] () {
    return this[kQueue].length - this[kRunningIdx]
  }

  get [kConnected] () {
    return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed
  }

  get [kBusy] () {
    return Boolean(
      this[kHTTPContext]?.busy(null) ||
      (this[kSize] >= (getPipelining(this) || 1)) ||
      this[kPending] > 0
    )
  }

  /* istanbul ignore: only used for test */
  [kConnect] (cb) {
    connect(this)
    this.once('connect', cb)
  }

  [kDispatch] (opts, handler) {
    const origin = opts.origin || this[kUrl].origin
    const request = new Request(origin, opts, handler)

    this[kQueue].push(request)
    if (this[kResuming]) {
      // Do nothing.
    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
      // Wait a tick in case stream/iterator is ended in the same tick.
      this[kResuming] = 1
      queueMicrotask(() => resume(this))
    } else {
      this[kResume](true)
    }

    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
      this[kNeedDrain] = 2
    }

    return this[kNeedDrain] < 2
  }

  async [kClose] () {
    // TODO: for H2 we need to gracefully flush the remaining enqueued
    // request and close each stream.
    return new Promise((resolve) => {
      if (this[kSize]) {
        this[kClosedResolve] = resolve
      } else {
        resolve(null)
      }
    })
  }

  async [kDestroy] (err) {
    return new Promise((resolve) => {
      const requests = this[kQueue].splice(this[kPendingIdx])
      for (let i = 0; i < requests.length; i++) {
        const request = requests[i]
        errorRequest(this, request, err)
      }

      const callback = () => {
        if (this[kClosedResolve]) {
          // TODO (fix): Should we error here with ClientDestroyedError?
          this[kClosedResolve]()
          this[kClosedResolve] = null
        }
        resolve(null)
      }

      if (this[kHTTPContext]) {
        this[kHTTPContext].destroy(err, callback)
        this[kHTTPContext] = null
      } else {
        queueMicrotask(callback)
      }

      this[kResume]()
    })
  }
}

const createRedirectInterceptor = __webpack_require__(/*! ../interceptor/redirect-interceptor.js */ "./node_modules/undici/lib/interceptor/redirect-interceptor.js")

function onError (client, err) {
  if (
    client[kRunning] === 0 &&
    err.code !== 'UND_ERR_INFO' &&
    err.code !== 'UND_ERR_SOCKET'
  ) {
    // Error is not caused by running request and not a recoverable
    // socket error.

    assert(client[kPendingIdx] === client[kRunningIdx])

    const requests = client[kQueue].splice(client[kRunningIdx])
    for (let i = 0; i < requests.length; i++) {
      const request = requests[i]
      errorRequest(client, request, err)
    }
    assert(client[kSize] === 0)
  }
}

async function connect (client) {
  assert(!client[kConnecting])
  assert(!client[kHTTPContext])

  let { host, hostname, protocol, port } = client[kUrl]

  // Resolve ipv6
  if (hostname[0] === '[') {
    const idx = hostname.indexOf(']')

    assert(idx !== -1)
    const ip = hostname.substring(1, idx)

    assert(net.isIP(ip))
    hostname = ip
  }

  client[kConnecting] = true

  if (channels.beforeConnect.hasSubscribers) {
    channels.beforeConnect.publish({
      connectParams: {
        host,
        hostname,
        protocol,
        port,
        version: client[kHTTPContext]?.version,
        servername: client[kServerName],
        localAddress: client[kLocalAddress]
      },
      connector: client[kConnector]
    })
  }

  try {
    const socket = await new Promise((resolve, reject) => {
      client[kConnector]({
        host,
        hostname,
        protocol,
        port,
        servername: client[kServerName],
        localAddress: client[kLocalAddress]
      }, (err, socket) => {
        if (err) {
          reject(err)
        } else {
          resolve(socket)
        }
      })
    })

    if (client.destroyed) {
      util.destroy(socket.on('error', () => {}), new ClientDestroyedError())
      return
    }

    assert(socket)

    try {
      client[kHTTPContext] = socket.alpnProtocol === 'h2'
        ? await connectH2(client, socket)
        : await connectH1(client, socket)
    } catch (err) {
      socket.destroy().on('error', () => {})
      throw err
    }

    client[kConnecting] = false

    socket[kCounter] = 0
    socket[kMaxRequests] = client[kMaxRequests]
    socket[kClient] = client
    socket[kError] = null

    if (channels.connected.hasSubscribers) {
      channels.connected.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: client[kHTTPContext]?.version,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector],
        socket
      })
    }
    client.emit('connect', client[kUrl], [client])
  } catch (err) {
    if (client.destroyed) {
      return
    }

    client[kConnecting] = false

    if (channels.connectError.hasSubscribers) {
      channels.connectError.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: client[kHTTPContext]?.version,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector],
        error: err
      })
    }

    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {
      assert(client[kRunning] === 0)
      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
        const request = client[kQueue][client[kPendingIdx]++]
        errorRequest(client, request, err)
      }
    } else {
      onError(client, err)
    }

    client.emit('connectionError', client[kUrl], [client], err)
  }

  client[kResume]()
}

function emitDrain (client) {
  client[kNeedDrain] = 0
  client.emit('drain', client[kUrl], [client])
}

function resume (client, sync) {
  if (client[kResuming] === 2) {
    return
  }

  client[kResuming] = 2

  _resume(client, sync)
  client[kResuming] = 0

  if (client[kRunningIdx] > 256) {
    client[kQueue].splice(0, client[kRunningIdx])
    client[kPendingIdx] -= client[kRunningIdx]
    client[kRunningIdx] = 0
  }
}

function _resume (client, sync) {
  while (true) {
    if (client.destroyed) {
      assert(client[kPending] === 0)
      return
    }

    if (client[kClosedResolve] && !client[kSize]) {
      client[kClosedResolve]()
      client[kClosedResolve] = null
      return
    }

    if (client[kHTTPContext]) {
      client[kHTTPContext].resume()
    }

    if (client[kBusy]) {
      client[kNeedDrain] = 2
    } else if (client[kNeedDrain] === 2) {
      if (sync) {
        client[kNeedDrain] = 1
        queueMicrotask(() => emitDrain(client))
      } else {
        emitDrain(client)
      }
      continue
    }

    if (client[kPending] === 0) {
      return
    }

    if (client[kRunning] >= (getPipelining(client) || 1)) {
      return
    }

    const request = client[kQueue][client[kPendingIdx]]

    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {
      if (client[kRunning] > 0) {
        return
      }

      client[kServerName] = request.servername
      client[kHTTPContext]?.destroy(new InformationalError('servername changed'))
    }

    if (client[kConnecting]) {
      return
    }

    if (!client[kHTTPContext]) {
      connect(client)
      return
    }

    if (client[kHTTPContext].destroyed) {
      return
    }

    if (client[kHTTPContext].busy(request)) {
      return
    }

    if (!request.aborted && client[kHTTPContext].write(request)) {
      client[kPendingIdx]++
    } else {
      client[kQueue].splice(client[kPendingIdx], 1)
    }
  }
}

function errorRequest (client, request, err) {
  try {
    request.onError(err)
    assert(request.aborted)
  } catch (err) {
    client.emit('error', err)
  }
}

module.exports = Client


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/dispatcher-base.js":
/*!***************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher-base.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Dispatcher = __webpack_require__(/*! ./dispatcher */ "./node_modules/undici/lib/dispatcher/dispatcher.js")
const {
  ClientDestroyedError,
  ClientClosedError,
  InvalidArgumentError
} = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const { kDestroy, kClose, kDispatch, kInterceptors } = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")

const kDestroyed = Symbol('destroyed')
const kClosed = Symbol('closed')
const kOnDestroyed = Symbol('onDestroyed')
const kOnClosed = Symbol('onClosed')
const kInterceptedDispatch = Symbol('Intercepted Dispatch')

class DispatcherBase extends Dispatcher {
  constructor () {
    super()

    this[kDestroyed] = false
    this[kOnDestroyed] = null
    this[kClosed] = false
    this[kOnClosed] = []
  }

  get destroyed () {
    return this[kDestroyed]
  }

  get closed () {
    return this[kClosed]
  }

  get interceptors () {
    return this[kInterceptors]
  }

  set interceptors (newInterceptors) {
    if (newInterceptors) {
      for (let i = newInterceptors.length - 1; i >= 0; i--) {
        const interceptor = this[kInterceptors][i]
        if (typeof interceptor !== 'function') {
          throw new InvalidArgumentError('interceptor must be an function')
        }
      }
    }

    this[kInterceptors] = newInterceptors
  }

  close (callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        this.close((err, data) => {
          return err ? reject(err) : resolve(data)
        })
      })
    }

    if (typeof callback !== 'function') {
      throw new InvalidArgumentError('invalid callback')
    }

    if (this[kDestroyed]) {
      queueMicrotask(() => callback(new ClientDestroyedError(), null))
      return
    }

    if (this[kClosed]) {
      if (this[kOnClosed]) {
        this[kOnClosed].push(callback)
      } else {
        queueMicrotask(() => callback(null, null))
      }
      return
    }

    this[kClosed] = true
    this[kOnClosed].push(callback)

    const onClosed = () => {
      const callbacks = this[kOnClosed]
      this[kOnClosed] = null
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i](null, null)
      }
    }

    // Should not error.
    this[kClose]()
      .then(() => this.destroy())
      .then(() => {
        queueMicrotask(onClosed)
      })
  }

  destroy (err, callback) {
    if (typeof err === 'function') {
      callback = err
      err = null
    }

    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        this.destroy(err, (err, data) => {
          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)
        })
      })
    }

    if (typeof callback !== 'function') {
      throw new InvalidArgumentError('invalid callback')
    }

    if (this[kDestroyed]) {
      if (this[kOnDestroyed]) {
        this[kOnDestroyed].push(callback)
      } else {
        queueMicrotask(() => callback(null, null))
      }
      return
    }

    if (!err) {
      err = new ClientDestroyedError()
    }

    this[kDestroyed] = true
    this[kOnDestroyed] = this[kOnDestroyed] || []
    this[kOnDestroyed].push(callback)

    const onDestroyed = () => {
      const callbacks = this[kOnDestroyed]
      this[kOnDestroyed] = null
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i](null, null)
      }
    }

    // Should not error.
    this[kDestroy](err).then(() => {
      queueMicrotask(onDestroyed)
    })
  }

  [kInterceptedDispatch] (opts, handler) {
    if (!this[kInterceptors] || this[kInterceptors].length === 0) {
      this[kInterceptedDispatch] = this[kDispatch]
      return this[kDispatch](opts, handler)
    }

    let dispatch = this[kDispatch].bind(this)
    for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
      dispatch = this[kInterceptors][i](dispatch)
    }
    this[kInterceptedDispatch] = dispatch
    return dispatch(opts, handler)
  }

  dispatch (opts, handler) {
    if (!handler || typeof handler !== 'object') {
      throw new InvalidArgumentError('handler must be an object')
    }

    try {
      if (!opts || typeof opts !== 'object') {
        throw new InvalidArgumentError('opts must be an object.')
      }

      if (this[kDestroyed] || this[kOnDestroyed]) {
        throw new ClientDestroyedError()
      }

      if (this[kClosed]) {
        throw new ClientClosedError()
      }

      return this[kInterceptedDispatch](opts, handler)
    } catch (err) {
      if (typeof handler.onError !== 'function') {
        throw new InvalidArgumentError('invalid onError method')
      }

      handler.onError(err)

      return false
    }
  }
}

module.exports = DispatcherBase


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/dispatcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(/*! node:events */ "node:events")

class Dispatcher extends EventEmitter {
  dispatch () {
    throw new Error('not implemented')
  }

  close () {
    throw new Error('not implemented')
  }

  destroy () {
    throw new Error('not implemented')
  }
}

module.exports = Dispatcher


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/fixed-queue.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/fixed-queue.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
/* eslint-disable */



// Extracted from node/lib/internal/fixed_queue.js

// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.
const kSize = 2048;
const kMask = kSize - 1;

// The FixedQueue is implemented as a singly-linked list of fixed-size
// circular buffers. It looks something like this:
//
//  head                                                       tail
//    |                                                          |
//    v                                                          v
// +-----------+ <-----\       +-----------+ <------\         +-----------+
// |  [null]   |        \----- |   next    |         \------- |   next    |
// +-----------+               +-----------+                  +-----------+
// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |
// |   item    |               |   item    |                  |  [empty]  |
// |   item    |               |   item    |                  |  [empty]  |
// |   item    |               |   item    |                  |  [empty]  |
// |   item    |               |   item    |       bottom --> |   item    |
// |   item    |               |   item    |                  |   item    |
// |    ...    |               |    ...    |                  |    ...    |
// |   item    |               |   item    |                  |   item    |
// |   item    |               |   item    |                  |   item    |
// |  [empty]  | <-- top       |   item    |                  |   item    |
// |  [empty]  |               |   item    |                  |   item    |
// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |
// +-----------+               +-----------+                  +-----------+
//
// Or, if there is only one circular buffer, it looks something
// like either of these:
//
//  head   tail                                 head   tail
//    |     |                                     |     |
//    v     v                                     v     v
// +-----------+                               +-----------+
// |  [null]   |                               |  [null]   |
// +-----------+                               +-----------+
// |  [empty]  |                               |   item    |
// |  [empty]  |                               |   item    |
// |   item    | <-- bottom            top --> |  [empty]  |
// |   item    |                               |  [empty]  |
// |  [empty]  | <-- top            bottom --> |   item    |
// |  [empty]  |                               |   item    |
// +-----------+                               +-----------+
//
// Adding a value means moving `top` forward by one, removing means
// moving `bottom` forward by one. After reaching the end, the queue
// wraps around.
//
// When `top === bottom` the current queue is empty and when
// `top + 1 === bottom` it's full. This wastes a single space of storage
// but allows much quicker checks.

class FixedCircularBuffer {
  constructor() {
    this.bottom = 0;
    this.top = 0;
    this.list = new Array(kSize);
    this.next = null;
  }

  isEmpty() {
    return this.top === this.bottom;
  }

  isFull() {
    return ((this.top + 1) & kMask) === this.bottom;
  }

  push(data) {
    this.list[this.top] = data;
    this.top = (this.top + 1) & kMask;
  }

  shift() {
    const nextItem = this.list[this.bottom];
    if (nextItem === undefined)
      return null;
    this.list[this.bottom] = undefined;
    this.bottom = (this.bottom + 1) & kMask;
    return nextItem;
  }
}

module.exports = class FixedQueue {
  constructor() {
    this.head = this.tail = new FixedCircularBuffer();
  }

  isEmpty() {
    return this.head.isEmpty();
  }

  push(data) {
    if (this.head.isFull()) {
      // Head is full: Creates a new queue, sets the old queue's `.next` to it,
      // and sets it as the new main queue.
      this.head = this.head.next = new FixedCircularBuffer();
    }
    this.head.push(data);
  }

  shift() {
    const tail = this.tail;
    const next = tail.shift();
    if (tail.isEmpty() && tail.next !== null) {
      // If there is another queue, it forms the new tail.
      this.tail = tail.next;
    }
    return next;
  }
};


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/pool-base.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ "./node_modules/undici/lib/dispatcher/dispatcher-base.js")
const FixedQueue = __webpack_require__(/*! ./fixed-queue */ "./node_modules/undici/lib/dispatcher/fixed-queue.js")
const { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const PoolStats = __webpack_require__(/*! ./pool-stats */ "./node_modules/undici/lib/dispatcher/pool-stats.js")

const kClients = Symbol('clients')
const kNeedDrain = Symbol('needDrain')
const kQueue = Symbol('queue')
const kClosedResolve = Symbol('closed resolve')
const kOnDrain = Symbol('onDrain')
const kOnConnect = Symbol('onConnect')
const kOnDisconnect = Symbol('onDisconnect')
const kOnConnectionError = Symbol('onConnectionError')
const kGetDispatcher = Symbol('get dispatcher')
const kAddClient = Symbol('add client')
const kRemoveClient = Symbol('remove client')
const kStats = Symbol('stats')

class PoolBase extends DispatcherBase {
  constructor () {
    super()

    this[kQueue] = new FixedQueue()
    this[kClients] = []
    this[kQueued] = 0

    const pool = this

    this[kOnDrain] = function onDrain (origin, targets) {
      const queue = pool[kQueue]

      let needDrain = false

      while (!needDrain) {
        const item = queue.shift()
        if (!item) {
          break
        }
        pool[kQueued]--
        needDrain = !this.dispatch(item.opts, item.handler)
      }

      this[kNeedDrain] = needDrain

      if (!this[kNeedDrain] && pool[kNeedDrain]) {
        pool[kNeedDrain] = false
        pool.emit('drain', origin, [pool, ...targets])
      }

      if (pool[kClosedResolve] && queue.isEmpty()) {
        Promise
          .all(pool[kClients].map(c => c.close()))
          .then(pool[kClosedResolve])
      }
    }

    this[kOnConnect] = (origin, targets) => {
      pool.emit('connect', origin, [pool, ...targets])
    }

    this[kOnDisconnect] = (origin, targets, err) => {
      pool.emit('disconnect', origin, [pool, ...targets], err)
    }

    this[kOnConnectionError] = (origin, targets, err) => {
      pool.emit('connectionError', origin, [pool, ...targets], err)
    }

    this[kStats] = new PoolStats(this)
  }

  get [kBusy] () {
    return this[kNeedDrain]
  }

  get [kConnected] () {
    return this[kClients].filter(client => client[kConnected]).length
  }

  get [kFree] () {
    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length
  }

  get [kPending] () {
    let ret = this[kQueued]
    for (const { [kPending]: pending } of this[kClients]) {
      ret += pending
    }
    return ret
  }

  get [kRunning] () {
    let ret = 0
    for (const { [kRunning]: running } of this[kClients]) {
      ret += running
    }
    return ret
  }

  get [kSize] () {
    let ret = this[kQueued]
    for (const { [kSize]: size } of this[kClients]) {
      ret += size
    }
    return ret
  }

  get stats () {
    return this[kStats]
  }

  async [kClose] () {
    if (this[kQueue].isEmpty()) {
      return Promise.all(this[kClients].map(c => c.close()))
    } else {
      return new Promise((resolve) => {
        this[kClosedResolve] = resolve
      })
    }
  }

  async [kDestroy] (err) {
    while (true) {
      const item = this[kQueue].shift()
      if (!item) {
        break
      }
      item.handler.onError(err)
    }

    return Promise.all(this[kClients].map(c => c.destroy(err)))
  }

  [kDispatch] (opts, handler) {
    const dispatcher = this[kGetDispatcher]()

    if (!dispatcher) {
      this[kNeedDrain] = true
      this[kQueue].push({ opts, handler })
      this[kQueued]++
    } else if (!dispatcher.dispatch(opts, handler)) {
      dispatcher[kNeedDrain] = true
      this[kNeedDrain] = !this[kGetDispatcher]()
    }

    return !this[kNeedDrain]
  }

  [kAddClient] (client) {
    client
      .on('drain', this[kOnDrain])
      .on('connect', this[kOnConnect])
      .on('disconnect', this[kOnDisconnect])
      .on('connectionError', this[kOnConnectionError])

    this[kClients].push(client)

    if (this[kNeedDrain]) {
      queueMicrotask(() => {
        if (this[kNeedDrain]) {
          this[kOnDrain](client[kUrl], [this, client])
        }
      })
    }

    return this
  }

  [kRemoveClient] (client) {
    client.close(() => {
      const idx = this[kClients].indexOf(client)
      if (idx !== -1) {
        this[kClients].splice(idx, 1)
      }
    })

    this[kNeedDrain] = this[kClients].some(dispatcher => (
      !dispatcher[kNeedDrain] &&
      dispatcher.closed !== true &&
      dispatcher.destroyed !== true
    ))
  }
}

module.exports = {
  PoolBase,
  kClients,
  kNeedDrain,
  kAddClient,
  kRemoveClient,
  kGetDispatcher
}


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/pool-stats.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-stats.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const kPool = Symbol('pool')

class PoolStats {
  constructor (pool) {
    this[kPool] = pool
  }

  get connected () {
    return this[kPool][kConnected]
  }

  get free () {
    return this[kPool][kFree]
  }

  get pending () {
    return this[kPool][kPending]
  }

  get queued () {
    return this[kPool][kQueued]
  }

  get running () {
    return this[kPool][kRunning]
  }

  get size () {
    return this[kPool][kSize]
  }
}

module.exports = PoolStats


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/pool.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  PoolBase,
  kClients,
  kNeedDrain,
  kAddClient,
  kGetDispatcher
} = __webpack_require__(/*! ./pool-base */ "./node_modules/undici/lib/dispatcher/pool-base.js")
const Client = __webpack_require__(/*! ./client */ "./node_modules/undici/lib/dispatcher/client.js")
const {
  InvalidArgumentError
} = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const { kUrl, kInterceptors } = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const buildConnector = __webpack_require__(/*! ../core/connect */ "./node_modules/undici/lib/core/connect.js")

const kOptions = Symbol('options')
const kConnections = Symbol('connections')
const kFactory = Symbol('factory')

function defaultFactory (origin, opts) {
  return new Client(origin, opts)
}

class Pool extends PoolBase {
  constructor (origin, {
    connections,
    factory = defaultFactory,
    connect,
    connectTimeout,
    tls,
    maxCachedSessions,
    socketPath,
    autoSelectFamily,
    autoSelectFamilyAttemptTimeout,
    allowH2,
    ...options
  } = {}) {
    super()

    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
      throw new InvalidArgumentError('invalid connections')
    }

    if (typeof factory !== 'function') {
      throw new InvalidArgumentError('factory must be a function.')
    }

    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
      throw new InvalidArgumentError('connect must be a function or an object')
    }

    if (typeof connect !== 'function') {
      connect = buildConnector({
        ...tls,
        maxCachedSessions,
        allowH2,
        socketPath,
        timeout: connectTimeout,
        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),
        ...connect
      })
    }

    this[kInterceptors] = options.interceptors?.Pool && Array.isArray(options.interceptors.Pool)
      ? options.interceptors.Pool
      : []
    this[kConnections] = connections || null
    this[kUrl] = util.parseOrigin(origin)
    this[kOptions] = { ...util.deepClone(options), connect, allowH2 }
    this[kOptions].interceptors = options.interceptors
      ? { ...options.interceptors }
      : undefined
    this[kFactory] = factory
  }

  [kGetDispatcher] () {
    for (const client of this[kClients]) {
      if (!client[kNeedDrain]) {
        return client
      }
    }

    if (!this[kConnections] || this[kClients].length < this[kConnections]) {
      const dispatcher = this[kFactory](this[kUrl], this[kOptions])
      this[kAddClient](dispatcher)
      return dispatcher
    }
  }
}

module.exports = Pool


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/proxy-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/proxy-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const { kProxy, kClose, kDestroy, kInterceptors } = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const { URL } = __webpack_require__(/*! node:url */ "node:url")
const Agent = __webpack_require__(/*! ./agent */ "./node_modules/undici/lib/dispatcher/agent.js")
const Pool = __webpack_require__(/*! ./pool */ "./node_modules/undici/lib/dispatcher/pool.js")
const DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ "./node_modules/undici/lib/dispatcher/dispatcher-base.js")
const { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const buildConnector = __webpack_require__(/*! ../core/connect */ "./node_modules/undici/lib/core/connect.js")

const kAgent = Symbol('proxy agent')
const kClient = Symbol('proxy client')
const kProxyHeaders = Symbol('proxy headers')
const kRequestTls = Symbol('request tls settings')
const kProxyTls = Symbol('proxy tls settings')
const kConnectEndpoint = Symbol('connect endpoint function')

function defaultProtocolPort (protocol) {
  return protocol === 'https:' ? 443 : 80
}

function defaultFactory (origin, opts) {
  return new Pool(origin, opts)
}

class ProxyAgent extends DispatcherBase {
  constructor (opts) {
    super()

    if (!opts || (typeof opts === 'object' && !(opts instanceof URL) && !opts.uri)) {
      throw new InvalidArgumentError('Proxy uri is mandatory')
    }

    const { clientFactory = defaultFactory } = opts
    if (typeof clientFactory !== 'function') {
      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')
    }

    const url = this.#getUrl(opts)
    const { href, origin, port, protocol, username, password } = url

    this[kProxy] = { uri: href, protocol }
    this[kAgent] = new Agent(opts)
    this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)
      ? opts.interceptors.ProxyAgent
      : []
    this[kRequestTls] = opts.requestTls
    this[kProxyTls] = opts.proxyTls
    this[kProxyHeaders] = opts.headers || {}

    if (opts.auth && opts.token) {
      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')
    } else if (opts.auth) {
      /* @deprecated in favour of opts.token */
      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`
    } else if (opts.token) {
      this[kProxyHeaders]['proxy-authorization'] = opts.token
    } else if (username && password) {
      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`
    }

    const connect = buildConnector({ ...opts.proxyTls })
    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })
    this[kClient] = clientFactory(url, { connect })
    this[kAgent] = new Agent({
      ...opts,
      connect: async (opts, callback) => {
        let requestedHost = opts.host
        if (!opts.port) {
          requestedHost += `:${defaultProtocolPort(opts.protocol)}`
        }
        try {
          const { socket, statusCode } = await this[kClient].connect({
            origin,
            port,
            path: requestedHost,
            signal: opts.signal,
            headers: {
              ...this[kProxyHeaders],
              host: requestedHost
            }
          })
          if (statusCode !== 200) {
            socket.on('error', () => {}).destroy()
            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))
          }
          if (opts.protocol !== 'https:') {
            callback(null, socket)
            return
          }
          let servername
          if (this[kRequestTls]) {
            servername = this[kRequestTls].servername
          } else {
            servername = opts.servername
          }
          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)
        } catch (err) {
          callback(err)
        }
      }
    })
  }

  dispatch (opts, handler) {
    const { host } = new URL(opts.origin)
    const headers = buildHeaders(opts.headers)
    throwIfProxyAuthIsSent(headers)
    return this[kAgent].dispatch(
      {
        ...opts,
        headers: {
          ...headers,
          host
        }
      },
      handler
    )
  }

  /**
   * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts
   * @returns {URL}
   */
  #getUrl (opts) {
    if (typeof opts === 'string') {
      return new URL(opts)
    } else if (opts instanceof URL) {
      return opts
    } else {
      return new URL(opts.uri)
    }
  }

  async [kClose] () {
    await this[kAgent].close()
    await this[kClient].close()
  }

  async [kDestroy] () {
    await this[kAgent].destroy()
    await this[kClient].destroy()
  }
}

/**
 * @param {string[] | Record<string, string>} headers
 * @returns {Record<string, string>}
 */
function buildHeaders (headers) {
  // When using undici.fetch, the headers list is stored
  // as an array.
  if (Array.isArray(headers)) {
    /** @type {Record<string, string>} */
    const headersPair = {}

    for (let i = 0; i < headers.length; i += 2) {
      headersPair[headers[i]] = headers[i + 1]
    }

    return headersPair
  }

  return headers
}

/**
 * @param {Record<string, string>} headers
 *
 * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
 * Nevertheless, it was changed and to avoid a security vulnerability by end users
 * this check was created.
 * It should be removed in the next major version for performance reasons
 */
function throwIfProxyAuthIsSent (headers) {
  const existProxyAuth = headers && Object.keys(headers)
    .find((key) => key.toLowerCase() === 'proxy-authorization')
  if (existProxyAuth) {
    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')
  }
}

module.exports = ProxyAgent


/***/ }),

/***/ "./node_modules/undici/lib/dispatcher/retry-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/retry-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Dispatcher = __webpack_require__(/*! ./dispatcher */ "./node_modules/undici/lib/dispatcher/dispatcher.js")
const RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ "./node_modules/undici/lib/handler/retry-handler.js")

class RetryAgent extends Dispatcher {
  #agent = null
  #options = null
  constructor (agent, options = {}) {
    super(options)
    this.#agent = agent
    this.#options = options
  }

  dispatch (opts, handler) {
    const retry = new RetryHandler({
      ...opts,
      retryOptions: this.#options
    }, {
      dispatch: this.#agent.dispatch.bind(this.#agent),
      handler
    })
    return this.#agent.dispatch(opts, retry)
  }

  close () {
    return this.#agent.close()
  }

  destroy () {
    return this.#agent.destroy()
  }
}

module.exports = RetryAgent


/***/ }),

/***/ "./node_modules/undici/lib/global.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/global.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// We include a version number for the Dispatcher API. In case of breaking changes,
// this version number must be increased to avoid conflicts.
const globalDispatcher = Symbol.for('undici.globalDispatcher.1')
const { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ "./node_modules/undici/lib/core/errors.js")
const Agent = __webpack_require__(/*! ./dispatcher/agent */ "./node_modules/undici/lib/dispatcher/agent.js")

if (getGlobalDispatcher() === undefined) {
  setGlobalDispatcher(new Agent())
}

function setGlobalDispatcher (agent) {
  if (!agent || typeof agent.dispatch !== 'function') {
    throw new InvalidArgumentError('Argument agent must implement Agent')
  }
  Object.defineProperty(globalThis, globalDispatcher, {
    value: agent,
    writable: true,
    enumerable: false,
    configurable: false
  })
}

function getGlobalDispatcher () {
  return globalThis[globalDispatcher]
}

module.exports = {
  setGlobalDispatcher,
  getGlobalDispatcher
}


/***/ }),

/***/ "./node_modules/undici/lib/handler/decorator-handler.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/handler/decorator-handler.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


module.exports = class DecoratorHandler {
  constructor (handler) {
    this.handler = handler
  }

  onConnect (...args) {
    return this.handler.onConnect(...args)
  }

  onError (...args) {
    return this.handler.onError(...args)
  }

  onUpgrade (...args) {
    return this.handler.onUpgrade(...args)
  }

  onHeaders (...args) {
    return this.handler.onHeaders(...args)
  }

  onData (...args) {
    return this.handler.onData(...args)
  }

  onComplete (...args) {
    return this.handler.onComplete(...args)
  }

  onBodySent (...args) {
    return this.handler.onBodySent(...args)
  }
}


/***/ }),

/***/ "./node_modules/undici/lib/handler/redirect-handler.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/handler/redirect-handler.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const assert = __webpack_require__(/*! node:assert */ "node:assert")
const { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const EE = __webpack_require__(/*! node:events */ "node:events")

const redirectableStatusCodes = [300, 301, 302, 303, 307, 308]

const kBody = Symbol('body')

class BodyAsyncIterable {
  constructor (body) {
    this[kBody] = body
    this[kBodyUsed] = false
  }

  async * [Symbol.asyncIterator] () {
    assert(!this[kBodyUsed], 'disturbed')
    this[kBodyUsed] = true
    yield * this[kBody]
  }
}

class RedirectHandler {
  constructor (dispatch, maxRedirections, opts, handler) {
    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
      throw new InvalidArgumentError('maxRedirections must be a positive number')
    }

    util.validateHandler(handler, opts.method, opts.upgrade)

    this.dispatch = dispatch
    this.location = null
    this.abort = null
    this.opts = { ...opts, maxRedirections: 0 } // opts must be a copy
    this.maxRedirections = maxRedirections
    this.handler = handler
    this.history = []
    this.redirectionLimitReached = false

    if (util.isStream(this.opts.body)) {
      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp
      // so that it can be dispatched again?
      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?
      if (util.bodyLength(this.opts.body) === 0) {
        this.opts.body
          .on('data', function () {
            assert(false)
          })
      }

      if (typeof this.opts.body.readableDidRead !== 'boolean') {
        this.opts.body[kBodyUsed] = false
        EE.prototype.on.call(this.opts.body, 'data', function () {
          this[kBodyUsed] = true
        })
      }
    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {
      // TODO (fix): We can't access ReadableStream internal state
      // to determine whether or not it has been disturbed. This is just
      // a workaround.
      this.opts.body = new BodyAsyncIterable(this.opts.body)
    } else if (
      this.opts.body &&
      typeof this.opts.body !== 'string' &&
      !ArrayBuffer.isView(this.opts.body) &&
      util.isIterable(this.opts.body)
    ) {
      // TODO: Should we allow re-using iterable if !this.opts.idempotent
      // or through some other flag?
      this.opts.body = new BodyAsyncIterable(this.opts.body)
    }
  }

  onConnect (abort) {
    this.abort = abort
    this.handler.onConnect(abort, { history: this.history })
  }

  onUpgrade (statusCode, headers, socket) {
    this.handler.onUpgrade(statusCode, headers, socket)
  }

  onError (error) {
    this.handler.onError(error)
  }

  onHeaders (statusCode, headers, resume, statusText) {
    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)
      ? null
      : parseLocation(statusCode, headers)

    if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
      if (this.request) {
        this.request.abort(new Error('max redirects'))
      }

      this.redirectionLimitReached = true
      this.abort(new Error('max redirects'))
      return
    }

    if (this.opts.origin) {
      this.history.push(new URL(this.opts.path, this.opts.origin))
    }

    if (!this.location) {
      return this.handler.onHeaders(statusCode, headers, resume, statusText)
    }

    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)))
    const path = search ? `${pathname}${search}` : pathname

    // Remove headers referring to the original URL.
    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.
    // https://tools.ietf.org/html/rfc7231#section-6.4
    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin)
    this.opts.path = path
    this.opts.origin = origin
    this.opts.maxRedirections = 0
    this.opts.query = null

    // https://tools.ietf.org/html/rfc7231#section-6.4.4
    // In case of HTTP 303, always replace method to be either HEAD or GET
    if (statusCode === 303 && this.opts.method !== 'HEAD') {
      this.opts.method = 'GET'
      this.opts.body = null
    }
  }

  onData (chunk) {
    if (this.location) {
      /*
        https://tools.ietf.org/html/rfc7231#section-6.4

        TLDR: undici always ignores 3xx response bodies.

        Redirection is used to serve the requested resource from another URL, so it is assumes that
        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.

        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually
        (which means it's optional and not mandated) contain just an hyperlink to the value of
        the Location response header, so the body can be ignored safely.

        For status 300, which is "Multiple Choices", the spec mentions both generating a Location
        response header AND a response body with the other possible location to follow.
        Since the spec explicitly chooses not to specify a format for such body and leave it to
        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.
      */
    } else {
      return this.handler.onData(chunk)
    }
  }

  onComplete (trailers) {
    if (this.location) {
      /*
        https://tools.ietf.org/html/rfc7231#section-6.4

        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections
        and neither are useful if present.

        See comment on onData method above for more detailed information.
      */

      this.location = null
      this.abort = null

      this.dispatch(this.opts, this)
    } else {
      this.handler.onComplete(trailers)
    }
  }

  onBodySent (chunk) {
    if (this.handler.onBodySent) {
      this.handler.onBodySent(chunk)
    }
  }
}

function parseLocation (statusCode, headers) {
  if (redirectableStatusCodes.indexOf(statusCode) === -1) {
    return null
  }

  for (let i = 0; i < headers.length; i += 2) {
    if (headers[i].length === 8 && util.headerNameToString(headers[i]) === 'location') {
      return headers[i + 1]
    }
  }
}

// https://tools.ietf.org/html/rfc7231#section-6.4.4
function shouldRemoveHeader (header, removeContent, unknownOrigin) {
  if (header.length === 4) {
    return util.headerNameToString(header) === 'host'
  }
  if (removeContent && util.headerNameToString(header).startsWith('content-')) {
    return true
  }
  if (unknownOrigin && (header.length === 13 || header.length === 6)) {
    const name = util.headerNameToString(header)
    return name === 'authorization' || name === 'cookie'
  }
  return false
}

// https://tools.ietf.org/html/rfc7231#section-6.4
function cleanRequestHeaders (headers, removeContent, unknownOrigin) {
  const ret = []
  if (Array.isArray(headers)) {
    for (let i = 0; i < headers.length; i += 2) {
      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
        ret.push(headers[i], headers[i + 1])
      }
    }
  } else if (headers && typeof headers === 'object') {
    for (const key of Object.keys(headers)) {
      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
        ret.push(key, headers[key])
      }
    }
  } else {
    assert(headers == null, 'headers must be an object or an array')
  }
  return ret
}

module.exports = RedirectHandler


/***/ }),

/***/ "./node_modules/undici/lib/handler/retry-handler.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/handler/retry-handler.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const assert = __webpack_require__(/*! node:assert */ "node:assert")

const { kRetryHandlerDefaultRetry } = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const { RequestRetryError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const { isDisturbed, parseHeaders, parseRangeHeader } = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")

function calculateRetryAfterHeader (retryAfter) {
  const current = Date.now()
  const diff = new Date(retryAfter).getTime() - current

  return diff
}

class RetryHandler {
  constructor (opts, handlers) {
    const { retryOptions, ...dispatchOpts } = opts
    const {
      // Retry scoped
      retry: retryFn,
      maxRetries,
      maxTimeout,
      minTimeout,
      timeoutFactor,
      // Response scoped
      methods,
      errorCodes,
      retryAfter,
      statusCodes
    } = retryOptions ?? {}

    this.dispatch = handlers.dispatch
    this.handler = handlers.handler
    this.opts = dispatchOpts
    this.abort = null
    this.aborted = false
    this.retryOpts = {
      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
      retryAfter: retryAfter ?? true,
      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,
      timeout: minTimeout ?? 500, // .5s
      timeoutFactor: timeoutFactor ?? 2,
      maxRetries: maxRetries ?? 5,
      // What errors we should retry
      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],
      // Indicates which errors to retry
      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
      // List of errors to retry
      errorCodes: errorCodes ?? [
        'ECONNRESET',
        'ECONNREFUSED',
        'ENOTFOUND',
        'ENETDOWN',
        'ENETUNREACH',
        'EHOSTDOWN',
        'EHOSTUNREACH',
        'EPIPE',
        'UND_ERR_SOCKET'
      ]
    }

    this.retryCount = 0
    this.start = 0
    this.end = null
    this.etag = null
    this.resume = null

    // Handle possible onConnect duplication
    this.handler.onConnect(reason => {
      this.aborted = true
      if (this.abort) {
        this.abort(reason)
      } else {
        this.reason = reason
      }
    })
  }

  onRequestSent () {
    if (this.handler.onRequestSent) {
      this.handler.onRequestSent()
    }
  }

  onUpgrade (statusCode, headers, socket) {
    if (this.handler.onUpgrade) {
      this.handler.onUpgrade(statusCode, headers, socket)
    }
  }

  onConnect (abort) {
    if (this.aborted) {
      abort(this.reason)
    } else {
      this.abort = abort
    }
  }

  onBodySent (chunk) {
    if (this.handler.onBodySent) return this.handler.onBodySent(chunk)
  }

  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {
    const { statusCode, code, headers } = err
    const { method, retryOptions } = opts
    const {
      maxRetries,
      timeout,
      maxTimeout,
      timeoutFactor,
      statusCodes,
      errorCodes,
      methods
    } = retryOptions
    let { counter, currentTimeout } = state

    currentTimeout =
      currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout

    // Any code that is not a Undici's originated and allowed to retry
    if (
      code &&
      code !== 'UND_ERR_REQ_RETRY' &&
      !errorCodes.includes(code)
    ) {
      cb(err)
      return
    }

    // If a set of method are provided and the current method is not in the list
    if (Array.isArray(methods) && !methods.includes(method)) {
      cb(err)
      return
    }

    // If a set of status code are provided and the current status code is not in the list
    if (
      statusCode != null &&
      Array.isArray(statusCodes) &&
      !statusCodes.includes(statusCode)
    ) {
      cb(err)
      return
    }

    // If we reached the max number of retries
    if (counter > maxRetries) {
      cb(err)
      return
    }

    let retryAfterHeader = headers?.['retry-after']
    if (retryAfterHeader) {
      retryAfterHeader = Number(retryAfterHeader)
      retryAfterHeader = Number.isNaN(retryAfterHeader)
        ? calculateRetryAfterHeader(retryAfterHeader)
        : retryAfterHeader * 1e3 // Retry-After is in seconds
    }

    const retryTimeout =
      retryAfterHeader > 0
        ? Math.min(retryAfterHeader, maxTimeout)
        : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout)

    state.currentTimeout = retryTimeout

    setTimeout(() => cb(null), retryTimeout)
  }

  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
    const headers = parseHeaders(rawHeaders)

    this.retryCount += 1

    if (statusCode >= 300) {
      if (this.retryOpts.statusCodes.includes(statusCode) === false) {
        return this.handler.onHeaders(
          statusCode,
          rawHeaders,
          resume,
          statusMessage
        )
      } else {
        this.abort(
          new RequestRetryError('Request failed', statusCode, {
            headers,
            count: this.retryCount
          })
        )
        return false
      }
    }

    // Checkpoint for resume from where we left it
    if (this.resume != null) {
      this.resume = null

      if (statusCode !== 206) {
        return true
      }

      const contentRange = parseRangeHeader(headers['content-range'])
      // If no content range
      if (!contentRange) {
        this.abort(
          new RequestRetryError('Content-Range mismatch', statusCode, {
            headers,
            count: this.retryCount
          })
        )
        return false
      }

      // Let's start with a weak etag check
      if (this.etag != null && this.etag !== headers.etag) {
        this.abort(
          new RequestRetryError('ETag mismatch', statusCode, {
            headers,
            count: this.retryCount
          })
        )
        return false
      }

      const { start, size, end = size } = contentRange

      assert(this.start === start, 'content-range mismatch')
      assert(this.end == null || this.end === end, 'content-range mismatch')

      this.resume = resume
      return true
    }

    if (this.end == null) {
      if (statusCode === 206) {
        // First time we receive 206
        const range = parseRangeHeader(headers['content-range'])

        if (range == null) {
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          )
        }

        const { start, size, end = size } = range

        assert(
          start != null && Number.isFinite(start) && this.start !== start,
          'content-range mismatch'
        )
        assert(Number.isFinite(start))
        assert(
          end != null && Number.isFinite(end) && this.end !== end,
          'invalid content-length'
        )

        this.start = start
        this.end = end
      }

      // We make our best to checkpoint the body for further range headers
      if (this.end == null) {
        const contentLength = headers['content-length']
        this.end = contentLength != null ? Number(contentLength) : null
      }

      assert(Number.isFinite(this.start))
      assert(
        this.end == null || Number.isFinite(this.end),
        'invalid content-length'
      )

      this.resume = resume
      this.etag = headers.etag != null ? headers.etag : null

      return this.handler.onHeaders(
        statusCode,
        rawHeaders,
        resume,
        statusMessage
      )
    }

    const err = new RequestRetryError('Request failed', statusCode, {
      headers,
      count: this.retryCount
    })

    this.abort(err)

    return false
  }

  onData (chunk) {
    this.start += chunk.length

    return this.handler.onData(chunk)
  }

  onComplete (rawTrailers) {
    this.retryCount = 0
    return this.handler.onComplete(rawTrailers)
  }

  onError (err) {
    if (this.aborted || isDisturbed(this.opts.body)) {
      return this.handler.onError(err)
    }

    this.retryOpts.retry(
      err,
      {
        state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      },
      onRetry.bind(this)
    )

    function onRetry (err) {
      if (err != null || this.aborted || isDisturbed(this.opts.body)) {
        return this.handler.onError(err)
      }

      if (this.start !== 0) {
        this.opts = {
          ...this.opts,
          headers: {
            ...this.opts.headers,
            range: `bytes=${this.start}-${this.end ?? ''}`
          }
        }
      }

      try {
        this.dispatch(this.opts, this)
      } catch (err) {
        this.handler.onError(err)
      }
    }
  }
}

module.exports = RetryHandler


/***/ }),

/***/ "./node_modules/undici/lib/interceptor/redirect-interceptor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirect-interceptor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const RedirectHandler = __webpack_require__(/*! ../handler/redirect-handler */ "./node_modules/undici/lib/handler/redirect-handler.js")

function createRedirectInterceptor ({ maxRedirections: defaultMaxRedirections }) {
  return (dispatch) => {
    return function Intercept (opts, handler) {
      const { maxRedirections = defaultMaxRedirections } = opts

      if (!maxRedirections) {
        return dispatch(opts, handler)
      }

      const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler)
      opts = { ...opts, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.
      return dispatch(opts, redirectHandler)
    }
  }
}

module.exports = createRedirectInterceptor


/***/ }),

/***/ "./node_modules/undici/lib/llhttp/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/undici/lib/llhttp/utils.js");
// C headers
var ERROR;
(function (ERROR) {
    ERROR[ERROR["OK"] = 0] = "OK";
    ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
    ERROR[ERROR["STRICT"] = 2] = "STRICT";
    ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
    ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
    ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
    ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
    ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
    ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
    ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
    ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
    ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
    ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
    ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
    ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
    ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
    ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
    ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
    ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
    ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
    ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
    ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
    ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
    ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
    ERROR[ERROR["USER"] = 24] = "USER";
})(ERROR = exports.ERROR || (exports.ERROR = {}));
var TYPE;
(function (TYPE) {
    TYPE[TYPE["BOTH"] = 0] = "BOTH";
    TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
    TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
})(TYPE = exports.TYPE || (exports.TYPE = {}));
var FLAGS;
(function (FLAGS) {
    FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
    FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
    FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
    FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
    FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
    FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
    FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
    FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
    // 1 << 8 is unused
    FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
var LENIENT_FLAGS;
(function (LENIENT_FLAGS) {
    LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
    LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
    LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
var METHODS;
(function (METHODS) {
    METHODS[METHODS["DELETE"] = 0] = "DELETE";
    METHODS[METHODS["GET"] = 1] = "GET";
    METHODS[METHODS["HEAD"] = 2] = "HEAD";
    METHODS[METHODS["POST"] = 3] = "POST";
    METHODS[METHODS["PUT"] = 4] = "PUT";
    /* pathological */
    METHODS[METHODS["CONNECT"] = 5] = "CONNECT";
    METHODS[METHODS["OPTIONS"] = 6] = "OPTIONS";
    METHODS[METHODS["TRACE"] = 7] = "TRACE";
    /* WebDAV */
    METHODS[METHODS["COPY"] = 8] = "COPY";
    METHODS[METHODS["LOCK"] = 9] = "LOCK";
    METHODS[METHODS["MKCOL"] = 10] = "MKCOL";
    METHODS[METHODS["MOVE"] = 11] = "MOVE";
    METHODS[METHODS["PROPFIND"] = 12] = "PROPFIND";
    METHODS[METHODS["PROPPATCH"] = 13] = "PROPPATCH";
    METHODS[METHODS["SEARCH"] = 14] = "SEARCH";
    METHODS[METHODS["UNLOCK"] = 15] = "UNLOCK";
    METHODS[METHODS["BIND"] = 16] = "BIND";
    METHODS[METHODS["REBIND"] = 17] = "REBIND";
    METHODS[METHODS["UNBIND"] = 18] = "UNBIND";
    METHODS[METHODS["ACL"] = 19] = "ACL";
    /* subversion */
    METHODS[METHODS["REPORT"] = 20] = "REPORT";
    METHODS[METHODS["MKACTIVITY"] = 21] = "MKACTIVITY";
    METHODS[METHODS["CHECKOUT"] = 22] = "CHECKOUT";
    METHODS[METHODS["MERGE"] = 23] = "MERGE";
    /* upnp */
    METHODS[METHODS["M-SEARCH"] = 24] = "M-SEARCH";
    METHODS[METHODS["NOTIFY"] = 25] = "NOTIFY";
    METHODS[METHODS["SUBSCRIBE"] = 26] = "SUBSCRIBE";
    METHODS[METHODS["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
    /* RFC-5789 */
    METHODS[METHODS["PATCH"] = 28] = "PATCH";
    METHODS[METHODS["PURGE"] = 29] = "PURGE";
    /* CalDAV */
    METHODS[METHODS["MKCALENDAR"] = 30] = "MKCALENDAR";
    /* RFC-2068, section 19.6.1.2 */
    METHODS[METHODS["LINK"] = 31] = "LINK";
    METHODS[METHODS["UNLINK"] = 32] = "UNLINK";
    /* icecast */
    METHODS[METHODS["SOURCE"] = 33] = "SOURCE";
    /* RFC-7540, section 11.6 */
    METHODS[METHODS["PRI"] = 34] = "PRI";
    /* RFC-2326 RTSP */
    METHODS[METHODS["DESCRIBE"] = 35] = "DESCRIBE";
    METHODS[METHODS["ANNOUNCE"] = 36] = "ANNOUNCE";
    METHODS[METHODS["SETUP"] = 37] = "SETUP";
    METHODS[METHODS["PLAY"] = 38] = "PLAY";
    METHODS[METHODS["PAUSE"] = 39] = "PAUSE";
    METHODS[METHODS["TEARDOWN"] = 40] = "TEARDOWN";
    METHODS[METHODS["GET_PARAMETER"] = 41] = "GET_PARAMETER";
    METHODS[METHODS["SET_PARAMETER"] = 42] = "SET_PARAMETER";
    METHODS[METHODS["REDIRECT"] = 43] = "REDIRECT";
    METHODS[METHODS["RECORD"] = 44] = "RECORD";
    /* RAOP */
    METHODS[METHODS["FLUSH"] = 45] = "FLUSH";
})(METHODS = exports.METHODS || (exports.METHODS = {}));
exports.METHODS_HTTP = [
    METHODS.DELETE,
    METHODS.GET,
    METHODS.HEAD,
    METHODS.POST,
    METHODS.PUT,
    METHODS.CONNECT,
    METHODS.OPTIONS,
    METHODS.TRACE,
    METHODS.COPY,
    METHODS.LOCK,
    METHODS.MKCOL,
    METHODS.MOVE,
    METHODS.PROPFIND,
    METHODS.PROPPATCH,
    METHODS.SEARCH,
    METHODS.UNLOCK,
    METHODS.BIND,
    METHODS.REBIND,
    METHODS.UNBIND,
    METHODS.ACL,
    METHODS.REPORT,
    METHODS.MKACTIVITY,
    METHODS.CHECKOUT,
    METHODS.MERGE,
    METHODS['M-SEARCH'],
    METHODS.NOTIFY,
    METHODS.SUBSCRIBE,
    METHODS.UNSUBSCRIBE,
    METHODS.PATCH,
    METHODS.PURGE,
    METHODS.MKCALENDAR,
    METHODS.LINK,
    METHODS.UNLINK,
    METHODS.PRI,
    // TODO(indutny): should we allow it with HTTP?
    METHODS.SOURCE,
];
exports.METHODS_ICE = [
    METHODS.SOURCE,
];
exports.METHODS_RTSP = [
    METHODS.OPTIONS,
    METHODS.DESCRIBE,
    METHODS.ANNOUNCE,
    METHODS.SETUP,
    METHODS.PLAY,
    METHODS.PAUSE,
    METHODS.TEARDOWN,
    METHODS.GET_PARAMETER,
    METHODS.SET_PARAMETER,
    METHODS.REDIRECT,
    METHODS.RECORD,
    METHODS.FLUSH,
    // For AirPlay
    METHODS.GET,
    METHODS.POST,
];
exports.METHOD_MAP = utils_1.enumToMap(METHODS);
exports.H_METHOD_MAP = {};
Object.keys(exports.METHOD_MAP).forEach((key) => {
    if (/^H/.test(key)) {
        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
    }
});
var FINISH;
(function (FINISH) {
    FINISH[FINISH["SAFE"] = 0] = "SAFE";
    FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
    FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
})(FINISH = exports.FINISH || (exports.FINISH = {}));
exports.ALPHA = [];
for (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {
    // Upper case
    exports.ALPHA.push(String.fromCharCode(i));
    // Lower case
    exports.ALPHA.push(String.fromCharCode(i + 0x20));
}
exports.NUM_MAP = {
    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,
    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
};
exports.HEX_MAP = {
    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,
    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,
    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,
};
exports.NUM = [
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
];
exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
exports.MARK = ['-', '_', '.', '!', '~', '*', '\'', '(', ')'];
exports.USERINFO_CHARS = exports.ALPHANUM
    .concat(exports.MARK)
    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);
// TODO(indutny): use RFC
exports.STRICT_URL_CHAR = [
    '!', '"', '$', '%', '&', '\'',
    '(', ')', '*', '+', ',', '-', '.', '/',
    ':', ';', '<', '=', '>',
    '@', '[', '\\', ']', '^', '_',
    '`',
    '{', '|', '}', '~',
].concat(exports.ALPHANUM);
exports.URL_CHAR = exports.STRICT_URL_CHAR
    .concat(['\t', '\f']);
// All characters with 0x80 bit set to 1
for (let i = 0x80; i <= 0xff; i++) {
    exports.URL_CHAR.push(i);
}
exports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);
/* Tokens as defined by rfc 2616. Also lowercases them.
 *        token       = 1*<any CHAR except CTLs or separators>
 *     separators     = "(" | ")" | "<" | ">" | "@"
 *                    | "," | ";" | ":" | "\" | <">
 *                    | "/" | "[" | "]" | "?" | "="
 *                    | "{" | "}" | SP | HT
 */
exports.STRICT_TOKEN = [
    '!', '#', '$', '%', '&', '\'',
    '*', '+', '-', '.',
    '^', '_', '`',
    '|', '~',
].concat(exports.ALPHANUM);
exports.TOKEN = exports.STRICT_TOKEN.concat([' ']);
/*
 * Verify that a char is a valid visible (printable) US-ASCII
 * character or %x80-FF
 */
exports.HEADER_CHARS = ['\t'];
for (let i = 32; i <= 255; i++) {
    if (i !== 127) {
        exports.HEADER_CHARS.push(i);
    }
}
// ',' = \x44
exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
exports.MAJOR = exports.NUM_MAP;
exports.MINOR = exports.MAJOR;
var HEADER_STATE;
(function (HEADER_STATE) {
    HEADER_STATE[HEADER_STATE["GENERAL"] = 0] = "GENERAL";
    HEADER_STATE[HEADER_STATE["CONNECTION"] = 1] = "CONNECTION";
    HEADER_STATE[HEADER_STATE["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
    HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
    HEADER_STATE[HEADER_STATE["UPGRADE"] = 4] = "UPGRADE";
    HEADER_STATE[HEADER_STATE["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
    HEADER_STATE[HEADER_STATE["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
    HEADER_STATE[HEADER_STATE["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
    HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
exports.SPECIAL_HEADERS = {
    'connection': HEADER_STATE.CONNECTION,
    'content-length': HEADER_STATE.CONTENT_LENGTH,
    'proxy-connection': HEADER_STATE.CONNECTION,
    'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,
    'upgrade': HEADER_STATE.UPGRADE,
};


/***/ }),

/***/ "./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Buffer } = __webpack_require__(/*! node:buffer */ "node:buffer")

module.exports = Buffer.from('AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==', 'base64')


/***/ }),

/***/ "./node_modules/undici/lib/llhttp/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.enumToMap = void 0;
function enumToMap(obj) {
    const res = {};
    Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === 'number') {
            res[key] = value;
        }
    });
    return res;
}
exports.enumToMap = enumToMap;


/***/ }),

/***/ "./node_modules/undici/lib/mock/mock-agent.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kClients } = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const Agent = __webpack_require__(/*! ../dispatcher/agent */ "./node_modules/undici/lib/dispatcher/agent.js")
const {
  kAgent,
  kMockAgentSet,
  kMockAgentGet,
  kDispatches,
  kIsMockActive,
  kNetConnect,
  kGetNetConnect,
  kOptions,
  kFactory
} = __webpack_require__(/*! ./mock-symbols */ "./node_modules/undici/lib/mock/mock-symbols.js")
const MockClient = __webpack_require__(/*! ./mock-client */ "./node_modules/undici/lib/mock/mock-client.js")
const MockPool = __webpack_require__(/*! ./mock-pool */ "./node_modules/undici/lib/mock/mock-pool.js")
const { matchValue, buildMockOptions } = __webpack_require__(/*! ./mock-utils */ "./node_modules/undici/lib/mock/mock-utils.js")
const { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const Dispatcher = __webpack_require__(/*! ../dispatcher/dispatcher */ "./node_modules/undici/lib/dispatcher/dispatcher.js")
const Pluralizer = __webpack_require__(/*! ./pluralizer */ "./node_modules/undici/lib/mock/pluralizer.js")
const PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ "./node_modules/undici/lib/mock/pending-interceptors-formatter.js")

class MockAgent extends Dispatcher {
  constructor (opts) {
    super(opts)

    this[kNetConnect] = true
    this[kIsMockActive] = true

    // Instantiate Agent and encapsulate
    if ((opts?.agent && typeof opts.agent.dispatch !== 'function')) {
      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
    }
    const agent = opts?.agent ? opts.agent : new Agent(opts)
    this[kAgent] = agent

    this[kClients] = agent[kClients]
    this[kOptions] = buildMockOptions(opts)
  }

  get (origin) {
    let dispatcher = this[kMockAgentGet](origin)

    if (!dispatcher) {
      dispatcher = this[kFactory](origin)
      this[kMockAgentSet](origin, dispatcher)
    }
    return dispatcher
  }

  dispatch (opts, handler) {
    // Call MockAgent.get to perform additional setup before dispatching as normal
    this.get(opts.origin)
    return this[kAgent].dispatch(opts, handler)
  }

  async close () {
    await this[kAgent].close()
    this[kClients].clear()
  }

  deactivate () {
    this[kIsMockActive] = false
  }

  activate () {
    this[kIsMockActive] = true
  }

  enableNetConnect (matcher) {
    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {
      if (Array.isArray(this[kNetConnect])) {
        this[kNetConnect].push(matcher)
      } else {
        this[kNetConnect] = [matcher]
      }
    } else if (typeof matcher === 'undefined') {
      this[kNetConnect] = true
    } else {
      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')
    }
  }

  disableNetConnect () {
    this[kNetConnect] = false
  }

  // This is required to bypass issues caused by using global symbols - see:
  // https://github.com/nodejs/undici/issues/1447
  get isMockActive () {
    return this[kIsMockActive]
  }

  [kMockAgentSet] (origin, dispatcher) {
    this[kClients].set(origin, dispatcher)
  }

  [kFactory] (origin) {
    const mockOptions = Object.assign({ agent: this }, this[kOptions])
    return this[kOptions] && this[kOptions].connections === 1
      ? new MockClient(origin, mockOptions)
      : new MockPool(origin, mockOptions)
  }

  [kMockAgentGet] (origin) {
    // First check if we can immediately find it
    const client = this[kClients].get(origin)
    if (client) {
      return client
    }

    // If the origin is not a string create a dummy parent pool and return to user
    if (typeof origin !== 'string') {
      const dispatcher = this[kFactory]('http://localhost:9999')
      this[kMockAgentSet](origin, dispatcher)
      return dispatcher
    }

    // If we match, create a pool and assign the same dispatches
    for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) {
      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {
        const dispatcher = this[kFactory](origin)
        this[kMockAgentSet](origin, dispatcher)
        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]
        return dispatcher
      }
    }
  }

  [kGetNetConnect] () {
    return this[kNetConnect]
  }

  pendingInterceptors () {
    const mockAgentClients = this[kClients]

    return Array.from(mockAgentClients.entries())
      .flatMap(([origin, scope]) => scope[kDispatches].map(dispatch => ({ ...dispatch, origin })))
      .filter(({ pending }) => pending)
  }

  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
    const pending = this.pendingInterceptors()

    if (pending.length === 0) {
      return
    }

    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length)

    throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim())
  }
}

module.exports = MockAgent


/***/ }),

/***/ "./node_modules/undici/lib/mock/mock-client.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-client.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { promisify } = __webpack_require__(/*! node:util */ "node:util")
const Client = __webpack_require__(/*! ../dispatcher/client */ "./node_modules/undici/lib/dispatcher/client.js")
const { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ "./node_modules/undici/lib/mock/mock-utils.js")
const {
  kDispatches,
  kMockAgent,
  kClose,
  kOriginalClose,
  kOrigin,
  kOriginalDispatch,
  kConnected
} = __webpack_require__(/*! ./mock-symbols */ "./node_modules/undici/lib/mock/mock-symbols.js")
const { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ "./node_modules/undici/lib/mock/mock-interceptor.js")
const Symbols = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")

/**
 * MockClient provides an API that extends the Client to influence the mockDispatches.
 */
class MockClient extends Client {
  constructor (origin, opts) {
    super(origin, opts)

    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
    }

    this[kMockAgent] = opts.agent
    this[kOrigin] = origin
    this[kDispatches] = []
    this[kConnected] = 1
    this[kOriginalDispatch] = this.dispatch
    this[kOriginalClose] = this.close.bind(this)

    this.dispatch = buildMockDispatch.call(this)
    this.close = this[kClose]
  }

  get [Symbols.kConnected] () {
    return this[kConnected]
  }

  /**
   * Sets up the base interceptor for mocking replies from undici.
   */
  intercept (opts) {
    return new MockInterceptor(opts, this[kDispatches])
  }

  async [kClose] () {
    await promisify(this[kOriginalClose])()
    this[kConnected] = 0
    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])
  }
}

module.exports = MockClient


/***/ }),

/***/ "./node_modules/undici/lib/mock/mock-errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-errors.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { UndiciError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")

class MockNotMatchedError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, MockNotMatchedError)
    this.name = 'MockNotMatchedError'
    this.message = message || 'The request does not match any registered mock dispatches'
    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED'
  }
}

module.exports = {
  MockNotMatchedError
}


/***/ }),

/***/ "./node_modules/undici/lib/mock/mock-interceptor.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-interceptor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ "./node_modules/undici/lib/mock/mock-utils.js")
const {
  kDispatches,
  kDispatchKey,
  kDefaultHeaders,
  kDefaultTrailers,
  kContentLength,
  kMockDispatch
} = __webpack_require__(/*! ./mock-symbols */ "./node_modules/undici/lib/mock/mock-symbols.js")
const { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")
const { buildURL } = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")

/**
 * Defines the scope API for an interceptor reply
 */
class MockScope {
  constructor (mockDispatch) {
    this[kMockDispatch] = mockDispatch
  }

  /**
   * Delay a reply by a set amount in ms.
   */
  delay (waitInMs) {
    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {
      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')
    }

    this[kMockDispatch].delay = waitInMs
    return this
  }

  /**
   * For a defined reply, never mark as consumed.
   */
  persist () {
    this[kMockDispatch].persist = true
    return this
  }

  /**
   * Allow one to define a reply for a set amount of matching requests.
   */
  times (repeatTimes) {
    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')
    }

    this[kMockDispatch].times = repeatTimes
    return this
  }
}

/**
 * Defines an interceptor for a Mock
 */
class MockInterceptor {
  constructor (opts, mockDispatches) {
    if (typeof opts !== 'object') {
      throw new InvalidArgumentError('opts must be an object')
    }
    if (typeof opts.path === 'undefined') {
      throw new InvalidArgumentError('opts.path must be defined')
    }
    if (typeof opts.method === 'undefined') {
      opts.method = 'GET'
    }
    // See https://github.com/nodejs/undici/issues/1245
    // As per RFC 3986, clients are not supposed to send URI
    // fragments to servers when they retrieve a document,
    if (typeof opts.path === 'string') {
      if (opts.query) {
        opts.path = buildURL(opts.path, opts.query)
      } else {
        // Matches https://github.com/nodejs/undici/blob/main/lib/web/fetch/index.js#L1811
        const parsedURL = new URL(opts.path, 'data://')
        opts.path = parsedURL.pathname + parsedURL.search
      }
    }
    if (typeof opts.method === 'string') {
      opts.method = opts.method.toUpperCase()
    }

    this[kDispatchKey] = buildKey(opts)
    this[kDispatches] = mockDispatches
    this[kDefaultHeaders] = {}
    this[kDefaultTrailers] = {}
    this[kContentLength] = false
  }

  createMockScopeDispatchData (statusCode, data, responseOptions = {}) {
    const responseData = getResponseData(data)
    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}
    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }
    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }

    return { statusCode, data, headers, trailers }
  }

  validateReplyParameters (statusCode, data, responseOptions) {
    if (typeof statusCode === 'undefined') {
      throw new InvalidArgumentError('statusCode must be defined')
    }
    if (typeof data === 'undefined') {
      throw new InvalidArgumentError('data must be defined')
    }
    if (typeof responseOptions !== 'object' || responseOptions === null) {
      throw new InvalidArgumentError('responseOptions must be an object')
    }
  }

  /**
   * Mock an undici request with a defined reply.
   */
  reply (replyData) {
    // Values of reply aren't available right now as they
    // can only be available when the reply callback is invoked.
    if (typeof replyData === 'function') {
      // We'll first wrap the provided callback in another function,
      // this function will properly resolve the data from the callback
      // when invoked.
      const wrappedDefaultsCallback = (opts) => {
        // Our reply options callback contains the parameter for statusCode, data and options.
        const resolvedData = replyData(opts)

        // Check if it is in the right format
        if (typeof resolvedData !== 'object') {
          throw new InvalidArgumentError('reply options callback must return an object')
        }

        const { statusCode, data = '', responseOptions = {} } = resolvedData
        this.validateReplyParameters(statusCode, data, responseOptions)
        // Since the values can be obtained immediately we return them
        // from this higher order function that will be resolved later.
        return {
          ...this.createMockScopeDispatchData(statusCode, data, responseOptions)
        }
      }

      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback)
      return new MockScope(newMockDispatch)
    }

    // We can have either one or three parameters, if we get here,
    // we should have 1-3 parameters. So we spread the arguments of
    // this function to obtain the parameters, since replyData will always
    // just be the statusCode.
    const [statusCode, data = '', responseOptions = {}] = [...arguments]
    this.validateReplyParameters(statusCode, data, responseOptions)

    // Send in-already provided data like usual
    const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions)
    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData)
    return new MockScope(newMockDispatch)
  }

  /**
   * Mock an undici request with a defined error.
   */
  replyWithError (error) {
    if (typeof error === 'undefined') {
      throw new InvalidArgumentError('error must be defined')
    }

    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error })
    return new MockScope(newMockDispatch)
  }

  /**
   * Set default reply headers on the interceptor for subsequent replies
   */
  defaultReplyHeaders (headers) {
    if (typeof headers === 'undefined') {
      throw new InvalidArgumentError('headers must be defined')
    }

    this[kDefaultHeaders] = headers
    return this
  }

  /**
   * Set default reply trailers on the interceptor for subsequent replies
   */
  defaultReplyTrailers (trailers) {
    if (typeof trailers === 'undefined') {
      throw new InvalidArgumentError('trailers must be defined')
    }

    this[kDefaultTrailers] = trailers
    return this
  }

  /**
   * Set reply content length header for replies on the interceptor
   */
  replyContentLength () {
    this[kContentLength] = true
    return this
  }
}

module.exports.MockInterceptor = MockInterceptor
module.exports.MockScope = MockScope


/***/ }),

/***/ "./node_modules/undici/lib/mock/mock-pool.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-pool.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { promisify } = __webpack_require__(/*! node:util */ "node:util")
const Pool = __webpack_require__(/*! ../dispatcher/pool */ "./node_modules/undici/lib/dispatcher/pool.js")
const { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ "./node_modules/undici/lib/mock/mock-utils.js")
const {
  kDispatches,
  kMockAgent,
  kClose,
  kOriginalClose,
  kOrigin,
  kOriginalDispatch,
  kConnected
} = __webpack_require__(/*! ./mock-symbols */ "./node_modules/undici/lib/mock/mock-symbols.js")
const { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ "./node_modules/undici/lib/mock/mock-interceptor.js")
const Symbols = __webpack_require__(/*! ../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ "./node_modules/undici/lib/core/errors.js")

/**
 * MockPool provides an API that extends the Pool to influence the mockDispatches.
 */
class MockPool extends Pool {
  constructor (origin, opts) {
    super(origin, opts)

    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
    }

    this[kMockAgent] = opts.agent
    this[kOrigin] = origin
    this[kDispatches] = []
    this[kConnected] = 1
    this[kOriginalDispatch] = this.dispatch
    this[kOriginalClose] = this.close.bind(this)

    this.dispatch = buildMockDispatch.call(this)
    this.close = this[kClose]
  }

  get [Symbols.kConnected] () {
    return this[kConnected]
  }

  /**
   * Sets up the base interceptor for mocking replies from undici.
   */
  intercept (opts) {
    return new MockInterceptor(opts, this[kDispatches])
  }

  async [kClose] () {
    await promisify(this[kOriginalClose])()
    this[kConnected] = 0
    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])
  }
}

module.exports = MockPool


/***/ }),

/***/ "./node_modules/undici/lib/mock/mock-symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  kAgent: Symbol('agent'),
  kOptions: Symbol('options'),
  kFactory: Symbol('factory'),
  kDispatches: Symbol('dispatches'),
  kDispatchKey: Symbol('dispatch key'),
  kDefaultHeaders: Symbol('default headers'),
  kDefaultTrailers: Symbol('default trailers'),
  kContentLength: Symbol('content length'),
  kMockAgent: Symbol('mock agent'),
  kMockAgentSet: Symbol('mock agent set'),
  kMockAgentGet: Symbol('mock agent get'),
  kMockDispatch: Symbol('mock dispatch'),
  kClose: Symbol('close'),
  kOriginalClose: Symbol('original agent close'),
  kOrigin: Symbol('origin'),
  kIsMockActive: Symbol('is mock active'),
  kNetConnect: Symbol('net connect'),
  kGetNetConnect: Symbol('get net connect'),
  kConnected: Symbol('connected')
}


/***/ }),

/***/ "./node_modules/undici/lib/mock/mock-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ "./node_modules/undici/lib/mock/mock-errors.js")
const {
  kDispatches,
  kMockAgent,
  kOriginalDispatch,
  kOrigin,
  kGetNetConnect
} = __webpack_require__(/*! ./mock-symbols */ "./node_modules/undici/lib/mock/mock-symbols.js")
const { buildURL, nop } = __webpack_require__(/*! ../core/util */ "./node_modules/undici/lib/core/util.js")
const { STATUS_CODES } = __webpack_require__(/*! node:http */ "node:http")
const {
  types: {
    isPromise
  }
} = __webpack_require__(/*! node:util */ "node:util")

function matchValue (match, value) {
  if (typeof match === 'string') {
    return match === value
  }
  if (match instanceof RegExp) {
    return match.test(value)
  }
  if (typeof match === 'function') {
    return match(value) === true
  }
  return false
}

function lowerCaseEntries (headers) {
  return Object.fromEntries(
    Object.entries(headers).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue]
    })
  )
}

/**
 * @param {import('../../index').Headers|string[]|Record<string, string>} headers
 * @param {string} key
 */
function getHeaderByName (headers, key) {
  if (Array.isArray(headers)) {
    for (let i = 0; i < headers.length; i += 2) {
      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
        return headers[i + 1]
      }
    }

    return undefined
  } else if (typeof headers.get === 'function') {
    return headers.get(key)
  } else {
    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]
  }
}

/** @param {string[]} headers */
function buildHeadersFromArray (headers) { // fetch HeadersList
  const clone = headers.slice()
  const entries = []
  for (let index = 0; index < clone.length; index += 2) {
    entries.push([clone[index], clone[index + 1]])
  }
  return Object.fromEntries(entries)
}

function matchHeaders (mockDispatch, headers) {
  if (typeof mockDispatch.headers === 'function') {
    if (Array.isArray(headers)) { // fetch HeadersList
      headers = buildHeadersFromArray(headers)
    }
    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})
  }
  if (typeof mockDispatch.headers === 'undefined') {
    return true
  }
  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {
    return false
  }

  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {
    const headerValue = getHeaderByName(headers, matchHeaderName)

    if (!matchValue(matchHeaderValue, headerValue)) {
      return false
    }
  }
  return true
}

function safeUrl (path) {
  if (typeof path !== 'string') {
    return path
  }

  const pathSegments = path.split('?')

  if (pathSegments.length !== 2) {
    return path
  }

  const qp = new URLSearchParams(pathSegments.pop())
  qp.sort()
  return [...pathSegments, qp.toString()].join('?')
}

function matchKey (mockDispatch, { path, method, body, headers }) {
  const pathMatch = matchValue(mockDispatch.path, path)
  const methodMatch = matchValue(mockDispatch.method, method)
  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true
  const headersMatch = matchHeaders(mockDispatch, headers)
  return pathMatch && methodMatch && bodyMatch && headersMatch
}

function getResponseData (data) {
  if (Buffer.isBuffer(data)) {
    return data
  } else if (typeof data === 'object') {
    return JSON.stringify(data)
  } else {
    return data.toString()
  }
}

function getMockDispatch (mockDispatches, key) {
  const basePath = key.query ? buildURL(key.path, key.query) : key.path
  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath

  // Match path
  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath))
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)
  }

  // Match method
  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`)
  }

  // Match body
  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`)
  }

  // Match headers
  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))
  if (matchedMockDispatches.length === 0) {
    const headers = typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers
    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`)
  }

  return matchedMockDispatches[0]
}

function addMockDispatch (mockDispatches, key, data) {
  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false }
  const replyData = typeof data === 'function' ? { callback: data } : { ...data }
  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }
  mockDispatches.push(newMockDispatch)
  return newMockDispatch
}

function deleteMockDispatch (mockDispatches, key) {
  const index = mockDispatches.findIndex(dispatch => {
    if (!dispatch.consumed) {
      return false
    }
    return matchKey(dispatch, key)
  })
  if (index !== -1) {
    mockDispatches.splice(index, 1)
  }
}

function buildKey (opts) {
  const { path, method, body, headers, query } = opts
  return {
    path,
    method,
    body,
    headers,
    query
  }
}

function generateKeyValues (data) {
  const keys = Object.keys(data)
  const result = []
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i]
    const value = data[key]
    const name = Buffer.from(`${key}`)
    if (Array.isArray(value)) {
      for (let j = 0; j < value.length; ++j) {
        result.push(name, Buffer.from(`${value[j]}`))
      }
    } else {
      result.push(name, Buffer.from(`${value}`))
    }
  }
  return result
}

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
 * @param {number} statusCode
 */
function getStatusText (statusCode) {
  return STATUS_CODES[statusCode] || 'unknown'
}

async function getResponse (body) {
  const buffers = []
  for await (const data of body) {
    buffers.push(data)
  }
  return Buffer.concat(buffers).toString('utf8')
}

/**
 * Mock dispatch function used to simulate undici dispatches
 */
function mockDispatch (opts, handler) {
  // Get mock dispatch from built key
  const key = buildKey(opts)
  const mockDispatch = getMockDispatch(this[kDispatches], key)

  mockDispatch.timesInvoked++

  // Here's where we resolve a callback if a callback is present for the dispatch data.
  if (mockDispatch.data.callback) {
    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }
  }

  // Parse mockDispatch data
  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch
  const { timesInvoked, times } = mockDispatch

  // If it's used up and not persistent, mark as consumed
  mockDispatch.consumed = !persist && timesInvoked >= times
  mockDispatch.pending = timesInvoked < times

  // If specified, trigger dispatch error
  if (error !== null) {
    deleteMockDispatch(this[kDispatches], key)
    handler.onError(error)
    return true
  }

  // Handle the request with a delay if necessary
  if (typeof delay === 'number' && delay > 0) {
    setTimeout(() => {
      handleReply(this[kDispatches])
    }, delay)
  } else {
    handleReply(this[kDispatches])
  }

  function handleReply (mockDispatches, _data = data) {
    // fetch's HeadersList is a 1D string array
    const optsHeaders = Array.isArray(opts.headers)
      ? buildHeadersFromArray(opts.headers)
      : opts.headers
    const body = typeof _data === 'function'
      ? _data({ ...opts, headers: optsHeaders })
      : _data

    // util.types.isPromise is likely needed for jest.
    if (isPromise(body)) {
      // If handleReply is asynchronous, throwing an error
      // in the callback will reject the promise, rather than
      // synchronously throw the error, which breaks some tests.
      // Rather, we wait for the callback to resolve if it is a
      // promise, and then re-run handleReply with the new body.
      body.then((newData) => handleReply(mockDispatches, newData))
      return
    }

    const responseData = getResponseData(body)
    const responseHeaders = generateKeyValues(headers)
    const responseTrailers = generateKeyValues(trailers)

    handler.abort = nop
    handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode))
    handler.onData(Buffer.from(responseData))
    handler.onComplete(responseTrailers)
    deleteMockDispatch(mockDispatches, key)
  }

  function resume () {}

  return true
}

function buildMockDispatch () {
  const agent = this[kMockAgent]
  const origin = this[kOrigin]
  const originalDispatch = this[kOriginalDispatch]

  return function dispatch (opts, handler) {
    if (agent.isMockActive) {
      try {
        mockDispatch.call(this, opts, handler)
      } catch (error) {
        if (error instanceof MockNotMatchedError) {
          const netConnect = agent[kGetNetConnect]()
          if (netConnect === false) {
            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)
          }
          if (checkNetConnect(netConnect, origin)) {
            originalDispatch.call(this, opts, handler)
          } else {
            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)
          }
        } else {
          throw error
        }
      }
    } else {
      originalDispatch.call(this, opts, handler)
    }
  }
}

function checkNetConnect (netConnect, origin) {
  const url = new URL(origin)
  if (netConnect === true) {
    return true
  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
    return true
  }
  return false
}

function buildMockOptions (opts) {
  if (opts) {
    const { agent, ...mockOptions } = opts
    return mockOptions
  }
}

module.exports = {
  getResponseData,
  getMockDispatch,
  addMockDispatch,
  deleteMockDispatch,
  buildKey,
  generateKeyValues,
  matchValue,
  getResponse,
  getStatusText,
  mockDispatch,
  buildMockDispatch,
  checkNetConnect,
  buildMockOptions,
  getHeaderByName,
  buildHeadersFromArray
}


/***/ }),

/***/ "./node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!************************************************************************!*\
  !*** ./node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Transform } = __webpack_require__(/*! node:stream */ "node:stream")
const { Console } = __webpack_require__(/*! node:console */ "node:console")

/**
 * Gets the output of `console.table(…)` as a string.
 */
module.exports = class PendingInterceptorsFormatter {
  constructor ({ disableColors } = {}) {
    this.transform = new Transform({
      transform (chunk, _enc, cb) {
        cb(null, chunk)
      }
    })

    this.logger = new Console({
      stdout: this.transform,
      inspectOptions: {
        colors: !disableColors && !process.env.CI
      }
    })
  }

  format (pendingInterceptors) {
    const withPrettyHeaders = pendingInterceptors.map(
      ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path,
        'Status code': statusCode,
        Persistent: persist ? '✅' : '❌',
        Invocations: timesInvoked,
        Remaining: persist ? Infinity : times - timesInvoked
      }))

    this.logger.table(withPrettyHeaders)
    return this.transform.read().toString()
  }
}


/***/ }),

/***/ "./node_modules/undici/lib/mock/pluralizer.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/pluralizer.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";


const singulars = {
  pronoun: 'it',
  is: 'is',
  was: 'was',
  this: 'this'
}

const plurals = {
  pronoun: 'they',
  is: 'are',
  was: 'were',
  this: 'these'
}

module.exports = class Pluralizer {
  constructor (singular, plural) {
    this.singular = singular
    this.plural = plural
  }

  pluralize (count) {
    const one = count === 1
    const keys = one ? singulars : plurals
    const noun = one ? this.singular : this.plural
    return { ...keys, count, noun }
  }
}


/***/ }),

/***/ "./node_modules/undici/lib/util/timers.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/util/timers.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


let fastNow = Date.now()
let fastNowTimeout

const fastTimers = []

function onTimeout () {
  fastNow = Date.now()

  let len = fastTimers.length
  let idx = 0
  while (idx < len) {
    const timer = fastTimers[idx]

    if (timer.state === 0) {
      timer.state = fastNow + timer.delay
    } else if (timer.state > 0 && fastNow >= timer.state) {
      timer.state = -1
      timer.callback(timer.opaque)
    }

    if (timer.state === -1) {
      timer.state = -2
      if (idx !== len - 1) {
        fastTimers[idx] = fastTimers.pop()
      } else {
        fastTimers.pop()
      }
      len -= 1
    } else {
      idx += 1
    }
  }

  if (fastTimers.length > 0) {
    refreshTimeout()
  }
}

function refreshTimeout () {
  if (fastNowTimeout?.refresh) {
    fastNowTimeout.refresh()
  } else {
    clearTimeout(fastNowTimeout)
    fastNowTimeout = setTimeout(onTimeout, 1e3)
    if (fastNowTimeout.unref) {
      fastNowTimeout.unref()
    }
  }
}

class Timeout {
  constructor (callback, delay, opaque) {
    this.callback = callback
    this.delay = delay
    this.opaque = opaque

    //  -2 not in timer list
    //  -1 in timer list but inactive
    //   0 in timer list waiting for time
    // > 0 in timer list waiting for time to expire
    this.state = -2

    this.refresh()
  }

  refresh () {
    if (this.state === -2) {
      fastTimers.push(this)
      if (!fastNowTimeout || fastTimers.length === 1) {
        refreshTimeout()
      }
    }

    this.state = 0
  }

  clear () {
    this.state = -1
  }
}

module.exports = {
  setTimeout (callback, delay, opaque) {
    return delay < 1e3
      ? setTimeout(callback, delay, opaque)
      : new Timeout(callback, delay, opaque)
  },
  clearTimeout (timeout) {
    if (timeout instanceof Timeout) {
      timeout.clear()
    } else {
      clearTimeout(timeout)
    }
  }
}


/***/ }),

/***/ "./node_modules/undici/lib/web/cache/cache.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cache.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kConstruct } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/cache/symbols.js")
const { urlEquals, getFieldValues } = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/cache/util.js")
const { kEnumerableProperty, isDisturbed } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const { webidl } = __webpack_require__(/*! ../fetch/webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { Response, cloneResponse, fromInnerResponse } = __webpack_require__(/*! ../fetch/response */ "./node_modules/undici/lib/web/fetch/response.js")
const { Request, fromInnerRequest } = __webpack_require__(/*! ../fetch/request */ "./node_modules/undici/lib/web/fetch/request.js")
const { kState } = __webpack_require__(/*! ../fetch/symbols */ "./node_modules/undici/lib/web/fetch/symbols.js")
const { fetching } = __webpack_require__(/*! ../fetch/index */ "./node_modules/undici/lib/web/fetch/index.js")
const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__(/*! ../fetch/util */ "./node_modules/undici/lib/web/fetch/util.js")
const assert = __webpack_require__(/*! node:assert */ "node:assert")

/**
 * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation
 * @typedef {Object} CacheBatchOperation
 * @property {'delete' | 'put'} type
 * @property {any} request
 * @property {any} response
 * @property {import('../../types/cache').CacheQueryOptions} options
 */

/**
 * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list
 * @typedef {[any, any][]} requestResponseList
 */

class Cache {
  /**
   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
   * @type {requestResponseList}
   */
  #relevantRequestResponseList

  constructor () {
    if (arguments[0] !== kConstruct) {
      webidl.illegalConstructor()
    }

    this.#relevantRequestResponseList = arguments[1]
  }

  async match (request, options = {}) {
    webidl.brandCheck(this, Cache)
    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.match' })

    request = webidl.converters.RequestInfo(request)
    options = webidl.converters.CacheQueryOptions(options)

    const p = this.#internalMatchAll(request, options, 1)

    if (p.length === 0) {
      return
    }

    return p[0]
  }

  async matchAll (request = undefined, options = {}) {
    webidl.brandCheck(this, Cache)

    if (request !== undefined) request = webidl.converters.RequestInfo(request)
    options = webidl.converters.CacheQueryOptions(options)

    return this.#internalMatchAll(request, options)
  }

  async add (request) {
    webidl.brandCheck(this, Cache)
    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.add' })

    request = webidl.converters.RequestInfo(request)

    // 1.
    const requests = [request]

    // 2.
    const responseArrayPromise = this.addAll(requests)

    // 3.
    return await responseArrayPromise
  }

  async addAll (requests) {
    webidl.brandCheck(this, Cache)
    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.addAll' })

    // 1.
    const responsePromises = []

    // 2.
    const requestList = []

    // 3.
    for (let request of requests) {
      if (request === undefined) {
        throw webidl.errors.conversionFailed({
          prefix: 'Cache.addAll',
          argument: 'Argument 1',
          types: ['undefined is not allowed']
        })
      }

      request = webidl.converters.RequestInfo(request)

      if (typeof request === 'string') {
        continue
      }

      // 3.1
      const r = request[kState]

      // 3.2
      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {
        throw webidl.errors.exception({
          header: 'Cache.addAll',
          message: 'Expected http/s scheme when method is not GET.'
        })
      }
    }

    // 4.
    /** @type {ReturnType<typeof fetching>[]} */
    const fetchControllers = []

    // 5.
    for (const request of requests) {
      // 5.1
      const r = new Request(request)[kState]

      // 5.2
      if (!urlIsHttpHttpsScheme(r.url)) {
        throw webidl.errors.exception({
          header: 'Cache.addAll',
          message: 'Expected http/s scheme.'
        })
      }

      // 5.4
      r.initiator = 'fetch'
      r.destination = 'subresource'

      // 5.5
      requestList.push(r)

      // 5.6
      const responsePromise = createDeferredPromise()

      // 5.7
      fetchControllers.push(fetching({
        request: r,
        processResponse (response) {
          // 1.
          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {
            responsePromise.reject(webidl.errors.exception({
              header: 'Cache.addAll',
              message: 'Received an invalid status code or the request failed.'
            }))
          } else if (response.headersList.contains('vary')) { // 2.
            // 2.1
            const fieldValues = getFieldValues(response.headersList.get('vary'))

            // 2.2
            for (const fieldValue of fieldValues) {
              // 2.2.1
              if (fieldValue === '*') {
                responsePromise.reject(webidl.errors.exception({
                  header: 'Cache.addAll',
                  message: 'invalid vary field value'
                }))

                for (const controller of fetchControllers) {
                  controller.abort()
                }

                return
              }
            }
          }
        },
        processResponseEndOfBody (response) {
          // 1.
          if (response.aborted) {
            responsePromise.reject(new DOMException('aborted', 'AbortError'))
            return
          }

          // 2.
          responsePromise.resolve(response)
        }
      }))

      // 5.8
      responsePromises.push(responsePromise.promise)
    }

    // 6.
    const p = Promise.all(responsePromises)

    // 7.
    const responses = await p

    // 7.1
    const operations = []

    // 7.2
    let index = 0

    // 7.3
    for (const response of responses) {
      // 7.3.1
      /** @type {CacheBatchOperation} */
      const operation = {
        type: 'put', // 7.3.2
        request: requestList[index], // 7.3.3
        response // 7.3.4
      }

      operations.push(operation) // 7.3.5

      index++ // 7.3.6
    }

    // 7.5
    const cacheJobPromise = createDeferredPromise()

    // 7.6.1
    let errorData = null

    // 7.6.2
    try {
      this.#batchCacheOperations(operations)
    } catch (e) {
      errorData = e
    }

    // 7.6.3
    queueMicrotask(() => {
      // 7.6.3.1
      if (errorData === null) {
        cacheJobPromise.resolve(undefined)
      } else {
        // 7.6.3.2
        cacheJobPromise.reject(errorData)
      }
    })

    // 7.7
    return cacheJobPromise.promise
  }

  async put (request, response) {
    webidl.brandCheck(this, Cache)
    webidl.argumentLengthCheck(arguments, 2, { header: 'Cache.put' })

    request = webidl.converters.RequestInfo(request)
    response = webidl.converters.Response(response)

    // 1.
    let innerRequest = null

    // 2.
    if (request instanceof Request) {
      innerRequest = request[kState]
    } else { // 3.
      innerRequest = new Request(request)[kState]
    }

    // 4.
    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {
      throw webidl.errors.exception({
        header: 'Cache.put',
        message: 'Expected an http/s scheme when method is not GET'
      })
    }

    // 5.
    const innerResponse = response[kState]

    // 6.
    if (innerResponse.status === 206) {
      throw webidl.errors.exception({
        header: 'Cache.put',
        message: 'Got 206 status'
      })
    }

    // 7.
    if (innerResponse.headersList.contains('vary')) {
      // 7.1.
      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'))

      // 7.2.
      for (const fieldValue of fieldValues) {
        // 7.2.1
        if (fieldValue === '*') {
          throw webidl.errors.exception({
            header: 'Cache.put',
            message: 'Got * vary field value'
          })
        }
      }
    }

    // 8.
    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
      throw webidl.errors.exception({
        header: 'Cache.put',
        message: 'Response body is locked or disturbed'
      })
    }

    // 9.
    const clonedResponse = cloneResponse(innerResponse)

    // 10.
    const bodyReadPromise = createDeferredPromise()

    // 11.
    if (innerResponse.body != null) {
      // 11.1
      const stream = innerResponse.body.stream

      // 11.2
      const reader = stream.getReader()

      // 11.3
      readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject)
    } else {
      bodyReadPromise.resolve(undefined)
    }

    // 12.
    /** @type {CacheBatchOperation[]} */
    const operations = []

    // 13.
    /** @type {CacheBatchOperation} */
    const operation = {
      type: 'put', // 14.
      request: innerRequest, // 15.
      response: clonedResponse // 16.
    }

    // 17.
    operations.push(operation)

    // 19.
    const bytes = await bodyReadPromise.promise

    if (clonedResponse.body != null) {
      clonedResponse.body.source = bytes
    }

    // 19.1
    const cacheJobPromise = createDeferredPromise()

    // 19.2.1
    let errorData = null

    // 19.2.2
    try {
      this.#batchCacheOperations(operations)
    } catch (e) {
      errorData = e
    }

    // 19.2.3
    queueMicrotask(() => {
      // 19.2.3.1
      if (errorData === null) {
        cacheJobPromise.resolve()
      } else { // 19.2.3.2
        cacheJobPromise.reject(errorData)
      }
    })

    return cacheJobPromise.promise
  }

  async delete (request, options = {}) {
    webidl.brandCheck(this, Cache)
    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.delete' })

    request = webidl.converters.RequestInfo(request)
    options = webidl.converters.CacheQueryOptions(options)

    /**
     * @type {Request}
     */
    let r = null

    if (request instanceof Request) {
      r = request[kState]

      if (r.method !== 'GET' && !options.ignoreMethod) {
        return false
      }
    } else {
      assert(typeof request === 'string')

      r = new Request(request)[kState]
    }

    /** @type {CacheBatchOperation[]} */
    const operations = []

    /** @type {CacheBatchOperation} */
    const operation = {
      type: 'delete',
      request: r,
      options
    }

    operations.push(operation)

    const cacheJobPromise = createDeferredPromise()

    let errorData = null
    let requestResponses

    try {
      requestResponses = this.#batchCacheOperations(operations)
    } catch (e) {
      errorData = e
    }

    queueMicrotask(() => {
      if (errorData === null) {
        cacheJobPromise.resolve(!!requestResponses?.length)
      } else {
        cacheJobPromise.reject(errorData)
      }
    })

    return cacheJobPromise.promise
  }

  /**
   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
   * @param {any} request
   * @param {import('../../types/cache').CacheQueryOptions} options
   * @returns {Promise<readonly Request[]>}
   */
  async keys (request = undefined, options = {}) {
    webidl.brandCheck(this, Cache)

    if (request !== undefined) request = webidl.converters.RequestInfo(request)
    options = webidl.converters.CacheQueryOptions(options)

    // 1.
    let r = null

    // 2.
    if (request !== undefined) {
      // 2.1
      if (request instanceof Request) {
        // 2.1.1
        r = request[kState]

        // 2.1.2
        if (r.method !== 'GET' && !options.ignoreMethod) {
          return []
        }
      } else if (typeof request === 'string') { // 2.2
        r = new Request(request)[kState]
      }
    }

    // 4.
    const promise = createDeferredPromise()

    // 5.
    // 5.1
    const requests = []

    // 5.2
    if (request === undefined) {
      // 5.2.1
      for (const requestResponse of this.#relevantRequestResponseList) {
        // 5.2.1.1
        requests.push(requestResponse[0])
      }
    } else { // 5.3
      // 5.3.1
      const requestResponses = this.#queryCache(r, options)

      // 5.3.2
      for (const requestResponse of requestResponses) {
        // 5.3.2.1
        requests.push(requestResponse[0])
      }
    }

    // 5.4
    queueMicrotask(() => {
      // 5.4.1
      const requestList = []

      // 5.4.2
      for (const request of requests) {
        const requestObject = fromInnerRequest(
          request,
          new AbortController().signal,
          'immutable',
          { settingsObject: request.client }
        )
        // 5.4.2.1
        requestList.push(requestObject)
      }

      // 5.4.3
      promise.resolve(Object.freeze(requestList))
    })

    return promise.promise
  }

  /**
   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
   * @param {CacheBatchOperation[]} operations
   * @returns {requestResponseList}
   */
  #batchCacheOperations (operations) {
    // 1.
    const cache = this.#relevantRequestResponseList

    // 2.
    const backupCache = [...cache]

    // 3.
    const addedItems = []

    // 4.1
    const resultList = []

    try {
      // 4.2
      for (const operation of operations) {
        // 4.2.1
        if (operation.type !== 'delete' && operation.type !== 'put') {
          throw webidl.errors.exception({
            header: 'Cache.#batchCacheOperations',
            message: 'operation type does not match "delete" or "put"'
          })
        }

        // 4.2.2
        if (operation.type === 'delete' && operation.response != null) {
          throw webidl.errors.exception({
            header: 'Cache.#batchCacheOperations',
            message: 'delete operation should not have an associated response'
          })
        }

        // 4.2.3
        if (this.#queryCache(operation.request, operation.options, addedItems).length) {
          throw new DOMException('???', 'InvalidStateError')
        }

        // 4.2.4
        let requestResponses

        // 4.2.5
        if (operation.type === 'delete') {
          // 4.2.5.1
          requestResponses = this.#queryCache(operation.request, operation.options)

          // TODO: the spec is wrong, this is needed to pass WPTs
          if (requestResponses.length === 0) {
            return []
          }

          // 4.2.5.2
          for (const requestResponse of requestResponses) {
            const idx = cache.indexOf(requestResponse)
            assert(idx !== -1)

            // 4.2.5.2.1
            cache.splice(idx, 1)
          }
        } else if (operation.type === 'put') { // 4.2.6
          // 4.2.6.1
          if (operation.response == null) {
            throw webidl.errors.exception({
              header: 'Cache.#batchCacheOperations',
              message: 'put operation should have an associated response'
            })
          }

          // 4.2.6.2
          const r = operation.request

          // 4.2.6.3
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: 'Cache.#batchCacheOperations',
              message: 'expected http or https scheme'
            })
          }

          // 4.2.6.4
          if (r.method !== 'GET') {
            throw webidl.errors.exception({
              header: 'Cache.#batchCacheOperations',
              message: 'not get method'
            })
          }

          // 4.2.6.5
          if (operation.options != null) {
            throw webidl.errors.exception({
              header: 'Cache.#batchCacheOperations',
              message: 'options must not be defined'
            })
          }

          // 4.2.6.6
          requestResponses = this.#queryCache(operation.request)

          // 4.2.6.7
          for (const requestResponse of requestResponses) {
            const idx = cache.indexOf(requestResponse)
            assert(idx !== -1)

            // 4.2.6.7.1
            cache.splice(idx, 1)
          }

          // 4.2.6.8
          cache.push([operation.request, operation.response])

          // 4.2.6.10
          addedItems.push([operation.request, operation.response])
        }

        // 4.2.7
        resultList.push([operation.request, operation.response])
      }

      // 4.3
      return resultList
    } catch (e) { // 5.
      // 5.1
      this.#relevantRequestResponseList.length = 0

      // 5.2
      this.#relevantRequestResponseList = backupCache

      // 5.3
      throw e
    }
  }

  /**
   * @see https://w3c.github.io/ServiceWorker/#query-cache
   * @param {any} requestQuery
   * @param {import('../../types/cache').CacheQueryOptions} options
   * @param {requestResponseList} targetStorage
   * @returns {requestResponseList}
   */
  #queryCache (requestQuery, options, targetStorage) {
    /** @type {requestResponseList} */
    const resultList = []

    const storage = targetStorage ?? this.#relevantRequestResponseList

    for (const requestResponse of storage) {
      const [cachedRequest, cachedResponse] = requestResponse
      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
        resultList.push(requestResponse)
      }
    }

    return resultList
  }

  /**
   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
   * @param {any} requestQuery
   * @param {any} request
   * @param {any | null} response
   * @param {import('../../types/cache').CacheQueryOptions | undefined} options
   * @returns {boolean}
   */
  #requestMatchesCachedItem (requestQuery, request, response = null, options) {
    // if (options?.ignoreMethod === false && request.method === 'GET') {
    //   return false
    // }

    const queryURL = new URL(requestQuery.url)

    const cachedURL = new URL(request.url)

    if (options?.ignoreSearch) {
      cachedURL.search = ''

      queryURL.search = ''
    }

    if (!urlEquals(queryURL, cachedURL, true)) {
      return false
    }

    if (
      response == null ||
      options?.ignoreVary ||
      !response.headersList.contains('vary')
    ) {
      return true
    }

    const fieldValues = getFieldValues(response.headersList.get('vary'))

    for (const fieldValue of fieldValues) {
      if (fieldValue === '*') {
        return false
      }

      const requestValue = request.headersList.get(fieldValue)
      const queryValue = requestQuery.headersList.get(fieldValue)

      // If one has the header and the other doesn't, or one has
      // a different value than the other, return false
      if (requestValue !== queryValue) {
        return false
      }
    }

    return true
  }

  #internalMatchAll (request, options, maxResponses = Infinity) {
    // 1.
    let r = null

    // 2.
    if (request !== undefined) {
      if (request instanceof Request) {
        // 2.1.1
        r = request[kState]

        // 2.1.2
        if (r.method !== 'GET' && !options.ignoreMethod) {
          return []
        }
      } else if (typeof request === 'string') {
        // 2.2.1
        r = new Request(request)[kState]
      }
    }

    // 5.
    // 5.1
    const responses = []

    // 5.2
    if (request === undefined) {
      // 5.2.1
      for (const requestResponse of this.#relevantRequestResponseList) {
        responses.push(requestResponse[1])
      }
    } else { // 5.3
      // 5.3.1
      const requestResponses = this.#queryCache(r, options)

      // 5.3.2
      for (const requestResponse of requestResponses) {
        responses.push(requestResponse[1])
      }
    }

    // 5.4
    // We don't implement CORs so we don't need to loop over the responses, yay!

    // 5.5.1
    const responseList = []

    // 5.5.2
    for (const response of responses) {
      // 5.5.2.1
      const responseObject = fromInnerResponse(response, 'immutable', { settingsObject: {} })

      responseList.push(responseObject.clone())

      if (responseList.length >= maxResponses) {
        break
      }
    }

    // 6.
    return Object.freeze(responseList)
  }
}

Object.defineProperties(Cache.prototype, {
  [Symbol.toStringTag]: {
    value: 'Cache',
    configurable: true
  },
  match: kEnumerableProperty,
  matchAll: kEnumerableProperty,
  add: kEnumerableProperty,
  addAll: kEnumerableProperty,
  put: kEnumerableProperty,
  delete: kEnumerableProperty,
  keys: kEnumerableProperty
})

const cacheQueryOptionConverters = [
  {
    key: 'ignoreSearch',
    converter: webidl.converters.boolean,
    defaultValue: false
  },
  {
    key: 'ignoreMethod',
    converter: webidl.converters.boolean,
    defaultValue: false
  },
  {
    key: 'ignoreVary',
    converter: webidl.converters.boolean,
    defaultValue: false
  }
]

webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters)

webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
  ...cacheQueryOptionConverters,
  {
    key: 'cacheName',
    converter: webidl.converters.DOMString
  }
])

webidl.converters.Response = webidl.interfaceConverter(Response)

webidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(
  webidl.converters.RequestInfo
)

module.exports = {
  Cache
}


/***/ }),

/***/ "./node_modules/undici/lib/web/cache/cachestorage.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cachestorage.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kConstruct } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/cache/symbols.js")
const { Cache } = __webpack_require__(/*! ./cache */ "./node_modules/undici/lib/web/cache/cache.js")
const { webidl } = __webpack_require__(/*! ../fetch/webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")

class CacheStorage {
  /**
   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
   * @type {Map<string, import('./cache').requestResponseList}
   */
  #caches = new Map()

  constructor () {
    if (arguments[0] !== kConstruct) {
      webidl.illegalConstructor()
    }
  }

  async match (request, options = {}) {
    webidl.brandCheck(this, CacheStorage)
    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.match' })

    request = webidl.converters.RequestInfo(request)
    options = webidl.converters.MultiCacheQueryOptions(options)

    // 1.
    if (options.cacheName != null) {
      // 1.1.1.1
      if (this.#caches.has(options.cacheName)) {
        // 1.1.1.1.1
        const cacheList = this.#caches.get(options.cacheName)
        const cache = new Cache(kConstruct, cacheList)

        return await cache.match(request, options)
      }
    } else { // 2.
      // 2.2
      for (const cacheList of this.#caches.values()) {
        const cache = new Cache(kConstruct, cacheList)

        // 2.2.1.2
        const response = await cache.match(request, options)

        if (response !== undefined) {
          return response
        }
      }
    }
  }

  /**
   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
   * @param {string} cacheName
   * @returns {Promise<boolean>}
   */
  async has (cacheName) {
    webidl.brandCheck(this, CacheStorage)
    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.has' })

    cacheName = webidl.converters.DOMString(cacheName)

    // 2.1.1
    // 2.2
    return this.#caches.has(cacheName)
  }

  /**
   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
   * @param {string} cacheName
   * @returns {Promise<Cache>}
   */
  async open (cacheName) {
    webidl.brandCheck(this, CacheStorage)
    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.open' })

    cacheName = webidl.converters.DOMString(cacheName)

    // 2.1
    if (this.#caches.has(cacheName)) {
      // await caches.open('v1') !== await caches.open('v1')

      // 2.1.1
      const cache = this.#caches.get(cacheName)

      // 2.1.1.1
      return new Cache(kConstruct, cache)
    }

    // 2.2
    const cache = []

    // 2.3
    this.#caches.set(cacheName, cache)

    // 2.4
    return new Cache(kConstruct, cache)
  }

  /**
   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
   * @param {string} cacheName
   * @returns {Promise<boolean>}
   */
  async delete (cacheName) {
    webidl.brandCheck(this, CacheStorage)
    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.delete' })

    cacheName = webidl.converters.DOMString(cacheName)

    return this.#caches.delete(cacheName)
  }

  /**
   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
   * @returns {Promise<string[]>}
   */
  async keys () {
    webidl.brandCheck(this, CacheStorage)

    // 2.1
    const keys = this.#caches.keys()

    // 2.2
    return [...keys]
  }
}

Object.defineProperties(CacheStorage.prototype, {
  [Symbol.toStringTag]: {
    value: 'CacheStorage',
    configurable: true
  },
  match: kEnumerableProperty,
  has: kEnumerableProperty,
  open: kEnumerableProperty,
  delete: kEnumerableProperty,
  keys: kEnumerableProperty
})

module.exports = {
  CacheStorage
}


/***/ }),

/***/ "./node_modules/undici/lib/web/cache/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/symbols.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  kConstruct: (__webpack_require__(/*! ../../core/symbols */ "./node_modules/undici/lib/core/symbols.js").kConstruct)
}


/***/ }),

/***/ "./node_modules/undici/lib/web/cache/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const assert = __webpack_require__(/*! node:assert */ "node:assert")
const { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")
const { isValidHeaderName } = __webpack_require__(/*! ../fetch/util */ "./node_modules/undici/lib/web/fetch/util.js")

/**
 * @see https://url.spec.whatwg.org/#concept-url-equals
 * @param {URL} A
 * @param {URL} B
 * @param {boolean | undefined} excludeFragment
 * @returns {boolean}
 */
function urlEquals (A, B, excludeFragment = false) {
  const serializedA = URLSerializer(A, excludeFragment)

  const serializedB = URLSerializer(B, excludeFragment)

  return serializedA === serializedB
}

/**
 * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262
 * @param {string} header
 */
function getFieldValues (header) {
  assert(header !== null)

  const values = []

  for (let value of header.split(',')) {
    value = value.trim()

    if (isValidHeaderName(value)) {
      values.push(value)
    }
  }

  return values
}

module.exports = {
  urlEquals,
  getFieldValues
}


/***/ }),

/***/ "./node_modules/undici/lib/web/cookies/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/constants.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size
const maxAttributeValueSize = 1024

// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size
const maxNameValuePairSize = 4096

module.exports = {
  maxAttributeValueSize,
  maxNameValuePairSize
}


/***/ }),

/***/ "./node_modules/undici/lib/web/cookies/index.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { parseSetCookie } = __webpack_require__(/*! ./parse */ "./node_modules/undici/lib/web/cookies/parse.js")
const { stringify, getHeadersList } = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/cookies/util.js")
const { webidl } = __webpack_require__(/*! ../fetch/webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { Headers } = __webpack_require__(/*! ../fetch/headers */ "./node_modules/undici/lib/web/fetch/headers.js")

/**
 * @typedef {Object} Cookie
 * @property {string} name
 * @property {string} value
 * @property {Date|number|undefined} expires
 * @property {number|undefined} maxAge
 * @property {string|undefined} domain
 * @property {string|undefined} path
 * @property {boolean|undefined} secure
 * @property {boolean|undefined} httpOnly
 * @property {'Strict'|'Lax'|'None'} sameSite
 * @property {string[]} unparsed
 */

/**
 * @param {Headers} headers
 * @returns {Record<string, string>}
 */
function getCookies (headers) {
  webidl.argumentLengthCheck(arguments, 1, { header: 'getCookies' })

  webidl.brandCheck(headers, Headers, { strict: false })

  const cookie = headers.get('cookie')
  const out = {}

  if (!cookie) {
    return out
  }

  for (const piece of cookie.split(';')) {
    const [name, ...value] = piece.split('=')

    out[name.trim()] = value.join('=')
  }

  return out
}

/**
 * @param {Headers} headers
 * @param {string} name
 * @param {{ path?: string, domain?: string }|undefined} attributes
 * @returns {void}
 */
function deleteCookie (headers, name, attributes) {
  webidl.argumentLengthCheck(arguments, 2, { header: 'deleteCookie' })

  webidl.brandCheck(headers, Headers, { strict: false })

  name = webidl.converters.DOMString(name)
  attributes = webidl.converters.DeleteCookieAttributes(attributes)

  // Matches behavior of
  // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278
  setCookie(headers, {
    name,
    value: '',
    expires: new Date(0),
    ...attributes
  })
}

/**
 * @param {Headers} headers
 * @returns {Cookie[]}
 */
function getSetCookies (headers) {
  webidl.argumentLengthCheck(arguments, 1, { header: 'getSetCookies' })

  webidl.brandCheck(headers, Headers, { strict: false })

  const cookies = getHeadersList(headers).cookies

  if (!cookies) {
    return []
  }

  // In older versions of undici, cookies is a list of name:value.
  return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair))
}

/**
 * @param {Headers} headers
 * @param {Cookie} cookie
 * @returns {void}
 */
function setCookie (headers, cookie) {
  webidl.argumentLengthCheck(arguments, 2, { header: 'setCookie' })

  webidl.brandCheck(headers, Headers, { strict: false })

  cookie = webidl.converters.Cookie(cookie)

  const str = stringify(cookie)

  if (str) {
    headers.append('Set-Cookie', stringify(cookie))
  }
}

webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
  {
    converter: webidl.nullableConverter(webidl.converters.DOMString),
    key: 'path',
    defaultValue: null
  },
  {
    converter: webidl.nullableConverter(webidl.converters.DOMString),
    key: 'domain',
    defaultValue: null
  }
])

webidl.converters.Cookie = webidl.dictionaryConverter([
  {
    converter: webidl.converters.DOMString,
    key: 'name'
  },
  {
    converter: webidl.converters.DOMString,
    key: 'value'
  },
  {
    converter: webidl.nullableConverter((value) => {
      if (typeof value === 'number') {
        return webidl.converters['unsigned long long'](value)
      }

      return new Date(value)
    }),
    key: 'expires',
    defaultValue: null
  },
  {
    converter: webidl.nullableConverter(webidl.converters['long long']),
    key: 'maxAge',
    defaultValue: null
  },
  {
    converter: webidl.nullableConverter(webidl.converters.DOMString),
    key: 'domain',
    defaultValue: null
  },
  {
    converter: webidl.nullableConverter(webidl.converters.DOMString),
    key: 'path',
    defaultValue: null
  },
  {
    converter: webidl.nullableConverter(webidl.converters.boolean),
    key: 'secure',
    defaultValue: null
  },
  {
    converter: webidl.nullableConverter(webidl.converters.boolean),
    key: 'httpOnly',
    defaultValue: null
  },
  {
    converter: webidl.converters.USVString,
    key: 'sameSite',
    allowedValues: ['Strict', 'Lax', 'None']
  },
  {
    converter: webidl.sequenceConverter(webidl.converters.DOMString),
    key: 'unparsed',
    defaultValue: []
  }
])

module.exports = {
  getCookies,
  deleteCookie,
  getSetCookies,
  setCookie
}


/***/ }),

/***/ "./node_modules/undici/lib/web/cookies/parse.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/parse.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/web/cookies/constants.js")
const { isCTLExcludingHtab } = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/cookies/util.js")
const { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../fetch/data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")
const assert = __webpack_require__(/*! node:assert */ "node:assert")

/**
 * @description Parses the field-value attributes of a set-cookie header string.
 * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
 * @param {string} header
 * @returns if the header is invalid, null will be returned
 */
function parseSetCookie (header) {
  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F
  //    character (CTL characters excluding HTAB): Abort these steps and
  //    ignore the set-cookie-string entirely.
  if (isCTLExcludingHtab(header)) {
    return null
  }

  let nameValuePair = ''
  let unparsedAttributes = ''
  let name = ''
  let value = ''

  // 2. If the set-cookie-string contains a %x3B (";") character:
  if (header.includes(';')) {
    // 1. The name-value-pair string consists of the characters up to,
    //    but not including, the first %x3B (";"), and the unparsed-
    //    attributes consist of the remainder of the set-cookie-string
    //    (including the %x3B (";") in question).
    const position = { position: 0 }

    nameValuePair = collectASequenceOfCodePointsFast(';', header, position)
    unparsedAttributes = header.slice(position.position)
  } else {
    // Otherwise:

    // 1. The name-value-pair string consists of all the characters
    //    contained in the set-cookie-string, and the unparsed-
    //    attributes is the empty string.
    nameValuePair = header
  }

  // 3. If the name-value-pair string lacks a %x3D ("=") character, then
  //    the name string is empty, and the value string is the value of
  //    name-value-pair.
  if (!nameValuePair.includes('=')) {
    value = nameValuePair
  } else {
    //    Otherwise, the name string consists of the characters up to, but
    //    not including, the first %x3D ("=") character, and the (possibly
    //    empty) value string consists of the characters after the first
    //    %x3D ("=") character.
    const position = { position: 0 }
    name = collectASequenceOfCodePointsFast(
      '=',
      nameValuePair,
      position
    )
    value = nameValuePair.slice(position.position + 1)
  }

  // 4. Remove any leading or trailing WSP characters from the name
  //    string and the value string.
  name = name.trim()
  value = value.trim()

  // 5. If the sum of the lengths of the name string and the value string
  //    is more than 4096 octets, abort these steps and ignore the set-
  //    cookie-string entirely.
  if (name.length + value.length > maxNameValuePairSize) {
    return null
  }

  // 6. The cookie-name is the name string, and the cookie-value is the
  //    value string.
  return {
    name, value, ...parseUnparsedAttributes(unparsedAttributes)
  }
}

/**
 * Parses the remaining attributes of a set-cookie header
 * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
 * @param {string} unparsedAttributes
 * @param {[Object.<string, unknown>]={}} cookieAttributeList
 */
function parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {
  // 1. If the unparsed-attributes string is empty, skip the rest of
  //    these steps.
  if (unparsedAttributes.length === 0) {
    return cookieAttributeList
  }

  // 2. Discard the first character of the unparsed-attributes (which
  //    will be a %x3B (";") character).
  assert(unparsedAttributes[0] === ';')
  unparsedAttributes = unparsedAttributes.slice(1)

  let cookieAv = ''

  // 3. If the remaining unparsed-attributes contains a %x3B (";")
  //    character:
  if (unparsedAttributes.includes(';')) {
    // 1. Consume the characters of the unparsed-attributes up to, but
    //    not including, the first %x3B (";") character.
    cookieAv = collectASequenceOfCodePointsFast(
      ';',
      unparsedAttributes,
      { position: 0 }
    )
    unparsedAttributes = unparsedAttributes.slice(cookieAv.length)
  } else {
    // Otherwise:

    // 1. Consume the remainder of the unparsed-attributes.
    cookieAv = unparsedAttributes
    unparsedAttributes = ''
  }

  // Let the cookie-av string be the characters consumed in this step.

  let attributeName = ''
  let attributeValue = ''

  // 4. If the cookie-av string contains a %x3D ("=") character:
  if (cookieAv.includes('=')) {
    // 1. The (possibly empty) attribute-name string consists of the
    //    characters up to, but not including, the first %x3D ("=")
    //    character, and the (possibly empty) attribute-value string
    //    consists of the characters after the first %x3D ("=")
    //    character.
    const position = { position: 0 }

    attributeName = collectASequenceOfCodePointsFast(
      '=',
      cookieAv,
      position
    )
    attributeValue = cookieAv.slice(position.position + 1)
  } else {
    // Otherwise:

    // 1. The attribute-name string consists of the entire cookie-av
    //    string, and the attribute-value string is empty.
    attributeName = cookieAv
  }

  // 5. Remove any leading or trailing WSP characters from the attribute-
  //    name string and the attribute-value string.
  attributeName = attributeName.trim()
  attributeValue = attributeValue.trim()

  // 6. If the attribute-value is longer than 1024 octets, ignore the
  //    cookie-av string and return to Step 1 of this algorithm.
  if (attributeValue.length > maxAttributeValueSize) {
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
  }

  // 7. Process the attribute-name and attribute-value according to the
  //    requirements in the following subsections.  (Notice that
  //    attributes with unrecognized attribute-names are ignored.)
  const attributeNameLowercase = attributeName.toLowerCase()

  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1
  // If the attribute-name case-insensitively matches the string
  // "Expires", the user agent MUST process the cookie-av as follows.
  if (attributeNameLowercase === 'expires') {
    // 1. Let the expiry-time be the result of parsing the attribute-value
    //    as cookie-date (see Section 5.1.1).
    const expiryTime = new Date(attributeValue)

    // 2. If the attribute-value failed to parse as a cookie date, ignore
    //    the cookie-av.

    cookieAttributeList.expires = expiryTime
  } else if (attributeNameLowercase === 'max-age') {
    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2
    // If the attribute-name case-insensitively matches the string "Max-
    // Age", the user agent MUST process the cookie-av as follows.

    // 1. If the first character of the attribute-value is not a DIGIT or a
    //    "-" character, ignore the cookie-av.
    const charCode = attributeValue.charCodeAt(0)

    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
    }

    // 2. If the remainder of attribute-value contains a non-DIGIT
    //    character, ignore the cookie-av.
    if (!/^\d+$/.test(attributeValue)) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
    }

    // 3. Let delta-seconds be the attribute-value converted to an integer.
    const deltaSeconds = Number(attributeValue)

    // 4. Let cookie-age-limit be the maximum age of the cookie (which
    //    SHOULD be 400 days or less, see Section 4.1.2.2).

    // 5. Set delta-seconds to the smaller of its present value and cookie-
    //    age-limit.
    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)

    // 6. If delta-seconds is less than or equal to zero (0), let expiry-
    //    time be the earliest representable date and time.  Otherwise, let
    //    the expiry-time be the current date and time plus delta-seconds
    //    seconds.
    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds

    // 7. Append an attribute to the cookie-attribute-list with an
    //    attribute-name of Max-Age and an attribute-value of expiry-time.
    cookieAttributeList.maxAge = deltaSeconds
  } else if (attributeNameLowercase === 'domain') {
    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3
    // If the attribute-name case-insensitively matches the string "Domain",
    // the user agent MUST process the cookie-av as follows.

    // 1. Let cookie-domain be the attribute-value.
    let cookieDomain = attributeValue

    // 2. If cookie-domain starts with %x2E ("."), let cookie-domain be
    //    cookie-domain without its leading %x2E (".").
    if (cookieDomain[0] === '.') {
      cookieDomain = cookieDomain.slice(1)
    }

    // 3. Convert the cookie-domain to lower case.
    cookieDomain = cookieDomain.toLowerCase()

    // 4. Append an attribute to the cookie-attribute-list with an
    //    attribute-name of Domain and an attribute-value of cookie-domain.
    cookieAttributeList.domain = cookieDomain
  } else if (attributeNameLowercase === 'path') {
    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4
    // If the attribute-name case-insensitively matches the string "Path",
    // the user agent MUST process the cookie-av as follows.

    // 1. If the attribute-value is empty or if the first character of the
    //    attribute-value is not %x2F ("/"):
    let cookiePath = ''
    if (attributeValue.length === 0 || attributeValue[0] !== '/') {
      // 1. Let cookie-path be the default-path.
      cookiePath = '/'
    } else {
      // Otherwise:

      // 1. Let cookie-path be the attribute-value.
      cookiePath = attributeValue
    }

    // 2. Append an attribute to the cookie-attribute-list with an
    //    attribute-name of Path and an attribute-value of cookie-path.
    cookieAttributeList.path = cookiePath
  } else if (attributeNameLowercase === 'secure') {
    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5
    // If the attribute-name case-insensitively matches the string "Secure",
    // the user agent MUST append an attribute to the cookie-attribute-list
    // with an attribute-name of Secure and an empty attribute-value.

    cookieAttributeList.secure = true
  } else if (attributeNameLowercase === 'httponly') {
    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6
    // If the attribute-name case-insensitively matches the string
    // "HttpOnly", the user agent MUST append an attribute to the cookie-
    // attribute-list with an attribute-name of HttpOnly and an empty
    // attribute-value.

    cookieAttributeList.httpOnly = true
  } else if (attributeNameLowercase === 'samesite') {
    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7
    // If the attribute-name case-insensitively matches the string
    // "SameSite", the user agent MUST process the cookie-av as follows:

    // 1. Let enforcement be "Default".
    let enforcement = 'Default'

    const attributeValueLowercase = attributeValue.toLowerCase()
    // 2. If cookie-av's attribute-value is a case-insensitive match for
    //    "None", set enforcement to "None".
    if (attributeValueLowercase.includes('none')) {
      enforcement = 'None'
    }

    // 3. If cookie-av's attribute-value is a case-insensitive match for
    //    "Strict", set enforcement to "Strict".
    if (attributeValueLowercase.includes('strict')) {
      enforcement = 'Strict'
    }

    // 4. If cookie-av's attribute-value is a case-insensitive match for
    //    "Lax", set enforcement to "Lax".
    if (attributeValueLowercase.includes('lax')) {
      enforcement = 'Lax'
    }

    // 5. Append an attribute to the cookie-attribute-list with an
    //    attribute-name of "SameSite" and an attribute-value of
    //    enforcement.
    cookieAttributeList.sameSite = enforcement
  } else {
    cookieAttributeList.unparsed ??= []

    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`)
  }

  // 8. Return to Step 1 of this algorithm.
  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
}

module.exports = {
  parseSetCookie,
  parseUnparsedAttributes
}


/***/ }),

/***/ "./node_modules/undici/lib/web/cookies/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/util.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const assert = __webpack_require__(/*! node:assert */ "node:assert")
const { kHeadersList } = __webpack_require__(/*! ../../core/symbols */ "./node_modules/undici/lib/core/symbols.js")

/**
 * @param {string} value
 * @returns {boolean}
 */
function isCTLExcludingHtab (value) {
  for (let i = 0; i < value.length; ++i) {
    const code = value.charCodeAt(i)

    if (
      (code >= 0x00 && code <= 0x08) ||
      (code >= 0x0A && code <= 0x1F) ||
      code === 0x7F
    ) {
      return true
    }
  }
  return false
}

/**
 CHAR           = <any US-ASCII character (octets 0 - 127)>
 token          = 1*<any CHAR except CTLs or separators>
 separators     = "(" | ")" | "<" | ">" | "@"
                | "," | ";" | ":" | "\" | <">
                | "/" | "[" | "]" | "?" | "="
                | "{" | "}" | SP | HT
 * @param {string} name
 */
function validateCookieName (name) {
  for (let i = 0; i < name.length; ++i) {
    const code = name.charCodeAt(i)

    if (
      code < 0x21 || // exclude CTLs (0-31), SP and HT
      code > 0x7E || // exclude non-ascii and DEL
      code === 0x22 || // "
      code === 0x28 || // (
      code === 0x29 || // )
      code === 0x3C || // <
      code === 0x3E || // >
      code === 0x40 || // @
      code === 0x2C || // ,
      code === 0x3B || // ;
      code === 0x3A || // :
      code === 0x5C || // \
      code === 0x2F || // /
      code === 0x5B || // [
      code === 0x5D || // ]
      code === 0x3F || // ?
      code === 0x3D || // =
      code === 0x7B || // {
      code === 0x7D // }
    ) {
      throw new Error('Invalid cookie name')
    }
  }
}

/**
 cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
                       ; US-ASCII characters excluding CTLs,
                       ; whitespace DQUOTE, comma, semicolon,
                       ; and backslash
 * @param {string} value
 */
function validateCookieValue (value) {
  let len = value.length
  let i = 0

  // if the value is wrapped in DQUOTE
  if (value[0] === '"') {
    if (len === 1 || value[len - 1] !== '"') {
      throw new Error('Invalid cookie value')
    }
    --len
    ++i
  }

  while (i < len) {
    const code = value.charCodeAt(i++)

    if (
      code < 0x21 || // exclude CTLs (0-31)
      code > 0x7E || // non-ascii and DEL (127)
      code === 0x22 || // "
      code === 0x2C || // ,
      code === 0x3B || // ;
      code === 0x5C // \
    ) {
      throw new Error('Invalid cookie value')
    }
  }
}

/**
 * path-value        = <any CHAR except CTLs or ";">
 * @param {string} path
 */
function validateCookiePath (path) {
  for (let i = 0; i < path.length; ++i) {
    const code = path.charCodeAt(i)

    if (
      code < 0x20 || // exclude CTLs (0-31)
      code === 0x7F || // DEL
      code === 0x3B // ;
    ) {
      throw new Error('Invalid cookie path')
    }
  }
}

/**
 * I have no idea why these values aren't allowed to be honest,
 * but Deno tests these. - Khafra
 * @param {string} domain
 */
function validateCookieDomain (domain) {
  if (
    domain.startsWith('-') ||
    domain.endsWith('.') ||
    domain.endsWith('-')
  ) {
    throw new Error('Invalid cookie domain')
  }
}

const IMFDays = [
  'Sun', 'Mon', 'Tue', 'Wed',
  'Thu', 'Fri', 'Sat'
]

const IMFMonths = [
  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
]

const IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, '0'))

/**
 * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
 * @param {number|Date} date
  IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
  ; fixed length/zone/capitalization subset of the format
  ; see Section 3.3 of [RFC5322]

  day-name     = %x4D.6F.6E ; "Mon", case-sensitive
              / %x54.75.65 ; "Tue", case-sensitive
              / %x57.65.64 ; "Wed", case-sensitive
              / %x54.68.75 ; "Thu", case-sensitive
              / %x46.72.69 ; "Fri", case-sensitive
              / %x53.61.74 ; "Sat", case-sensitive
              / %x53.75.6E ; "Sun", case-sensitive
  date1        = day SP month SP year
                  ; e.g., 02 Jun 1982

  day          = 2DIGIT
  month        = %x4A.61.6E ; "Jan", case-sensitive
              / %x46.65.62 ; "Feb", case-sensitive
              / %x4D.61.72 ; "Mar", case-sensitive
              / %x41.70.72 ; "Apr", case-sensitive
              / %x4D.61.79 ; "May", case-sensitive
              / %x4A.75.6E ; "Jun", case-sensitive
              / %x4A.75.6C ; "Jul", case-sensitive
              / %x41.75.67 ; "Aug", case-sensitive
              / %x53.65.70 ; "Sep", case-sensitive
              / %x4F.63.74 ; "Oct", case-sensitive
              / %x4E.6F.76 ; "Nov", case-sensitive
              / %x44.65.63 ; "Dec", case-sensitive
  year         = 4DIGIT

  GMT          = %x47.4D.54 ; "GMT", case-sensitive

  time-of-day  = hour ":" minute ":" second
              ; 00:00:00 - 23:59:60 (leap second)

  hour         = 2DIGIT
  minute       = 2DIGIT
  second       = 2DIGIT
 */
function toIMFDate (date) {
  if (typeof date === 'number') {
    date = new Date(date)
  }

  return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`
}

/**
 max-age-av        = "Max-Age=" non-zero-digit *DIGIT
                       ; In practice, both expires-av and max-age-av
                       ; are limited to dates representable by the
                       ; user agent.
 * @param {number} maxAge
 */
function validateCookieMaxAge (maxAge) {
  if (maxAge < 0) {
    throw new Error('Invalid cookie max-age')
  }
}

/**
 * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1
 * @param {import('./index').Cookie} cookie
 */
function stringify (cookie) {
  if (cookie.name.length === 0) {
    return null
  }

  validateCookieName(cookie.name)
  validateCookieValue(cookie.value)

  const out = [`${cookie.name}=${cookie.value}`]

  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1
  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2
  if (cookie.name.startsWith('__Secure-')) {
    cookie.secure = true
  }

  if (cookie.name.startsWith('__Host-')) {
    cookie.secure = true
    cookie.domain = null
    cookie.path = '/'
  }

  if (cookie.secure) {
    out.push('Secure')
  }

  if (cookie.httpOnly) {
    out.push('HttpOnly')
  }

  if (typeof cookie.maxAge === 'number') {
    validateCookieMaxAge(cookie.maxAge)
    out.push(`Max-Age=${cookie.maxAge}`)
  }

  if (cookie.domain) {
    validateCookieDomain(cookie.domain)
    out.push(`Domain=${cookie.domain}`)
  }

  if (cookie.path) {
    validateCookiePath(cookie.path)
    out.push(`Path=${cookie.path}`)
  }

  if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {
    out.push(`Expires=${toIMFDate(cookie.expires)}`)
  }

  if (cookie.sameSite) {
    out.push(`SameSite=${cookie.sameSite}`)
  }

  for (const part of cookie.unparsed) {
    if (!part.includes('=')) {
      throw new Error('Invalid unparsed')
    }

    const [key, ...value] = part.split('=')

    out.push(`${key.trim()}=${value.join('=')}`)
  }

  return out.join('; ')
}

let kHeadersListNode

function getHeadersList (headers) {
  if (headers[kHeadersList]) {
    return headers[kHeadersList]
  }

  if (!kHeadersListNode) {
    kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
      (symbol) => symbol.description === 'headers list'
    )

    assert(kHeadersListNode, 'Headers cannot be parsed')
  }

  const headersList = headers[kHeadersListNode]
  assert(headersList)

  return headersList
}

module.exports = {
  isCTLExcludingHtab,
  validateCookieName,
  validateCookiePath,
  validateCookieValue,
  toIMFDate,
  stringify,
  getHeadersList
}


/***/ }),

/***/ "./node_modules/undici/lib/web/eventsource/eventsource-stream.js":
/*!***********************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource-stream.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];

const { Transform } = __webpack_require__(/*! node:stream */ "node:stream")
const { isASCIINumber, isValidLastEventId } = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/eventsource/util.js")

/**
 * @type {number[]} BOM
 */
const BOM = [0xEF, 0xBB, 0xBF]
/**
 * @type {10} LF
 */
const LF = 0x0A
/**
 * @type {13} CR
 */
const CR = 0x0D
/**
 * @type {58} COLON
 */
const COLON = 0x3A
/**
 * @type {32} SPACE
 */
const SPACE = 0x20

/**
 * @typedef {object} EventSourceStreamEvent
 * @type {object}
 * @property {string} [event] The event type.
 * @property {string} [data] The data of the message.
 * @property {string} [id] A unique ID for the event.
 * @property {string} [retry] The reconnection time, in milliseconds.
 */

/**
 * @typedef eventSourceSettings
 * @type {object}
 * @property {string} lastEventId The last event ID received from the server.
 * @property {string} origin The origin of the event source.
 * @property {number} reconnectionTime The reconnection time, in milliseconds.
 */

class EventSourceStream extends Transform {
  /**
   * @type {eventSourceSettings}
   */
  state = null

  /**
   * Leading byte-order-mark check.
   * @type {boolean}
   */
  checkBOM = true

  /**
   * @type {boolean}
   */
  crlfCheck = false

  /**
   * @type {boolean}
   */
  eventEndCheck = false

  /**
   * @type {Buffer}
   */
  buffer = null

  pos = 0

  event = {
    data: undefined,
    event: undefined,
    id: undefined,
    retry: undefined
  }

  /**
   * @param {object} options
   * @param {eventSourceSettings} options.eventSourceSettings
   * @param {Function} [options.push]
   */
  constructor (options = {}) {
    // Enable object mode as EventSourceStream emits objects of shape
    // EventSourceStreamEvent
    options.readableObjectMode = true

    super(options)

    this.state = options.eventSourceSettings || {}
    if (options.push) {
      this.push = options.push
    }
  }

  /**
   * @param {Buffer} chunk
   * @param {string} _encoding
   * @param {Function} callback
   * @returns {void}
   */
  _transform (chunk, _encoding, callback) {
    if (chunk.length === 0) {
      callback()
      return
    }

    // Cache the chunk in the buffer, as the data might not be complete while
    // processing it
    // TODO: Investigate if there is a more performant way to handle
    // incoming chunks
    // see: https://github.com/nodejs/undici/issues/2630
    if (this.buffer) {
      this.buffer = Buffer.concat([this.buffer, chunk])
    } else {
      this.buffer = chunk
    }

    // Strip leading byte-order-mark if we opened the stream and started
    // the processing of the incoming data
    if (this.checkBOM) {
      switch (this.buffer.length) {
        case 1:
          // Check if the first byte is the same as the first byte of the BOM
          if (this.buffer[0] === BOM[0]) {
            // If it is, we need to wait for more data
            callback()
            return
          }
          // Set the checkBOM flag to false as we don't need to check for the
          // BOM anymore
          this.checkBOM = false

          // The buffer only contains one byte so we need to wait for more data
          callback()
          return
        case 2:
          // Check if the first two bytes are the same as the first two bytes
          // of the BOM
          if (
            this.buffer[0] === BOM[0] &&
            this.buffer[1] === BOM[1]
          ) {
            // If it is, we need to wait for more data, because the third byte
            // is needed to determine if it is the BOM or not
            callback()
            return
          }

          // Set the checkBOM flag to false as we don't need to check for the
          // BOM anymore
          this.checkBOM = false
          break
        case 3:
          // Check if the first three bytes are the same as the first three
          // bytes of the BOM
          if (
            this.buffer[0] === BOM[0] &&
            this.buffer[1] === BOM[1] &&
            this.buffer[2] === BOM[2]
          ) {
            // If it is, we can drop the buffered data, as it is only the BOM
            this.buffer = Buffer.alloc(0)
            // Set the checkBOM flag to false as we don't need to check for the
            // BOM anymore
            this.checkBOM = false

            // Await more data
            callback()
            return
          }
          // If it is not the BOM, we can start processing the data
          this.checkBOM = false
          break
        default:
          // The buffer is longer than 3 bytes, so we can drop the BOM if it is
          // present
          if (
            this.buffer[0] === BOM[0] &&
            this.buffer[1] === BOM[1] &&
            this.buffer[2] === BOM[2]
          ) {
            // Remove the BOM from the buffer
            this.buffer = this.buffer.subarray(3)
          }

          // Set the checkBOM flag to false as we don't need to check for the
          this.checkBOM = false
          break
      }
    }

    while (this.pos < this.buffer.length) {
      // If the previous line ended with an end-of-line, we need to check
      // if the next character is also an end-of-line.
      if (this.eventEndCheck) {
        // If the the current character is an end-of-line, then the event
        // is finished and we can process it

        // If the previous line ended with a carriage return, we need to
        // check if the current character is a line feed and remove it
        // from the buffer.
        if (this.crlfCheck) {
          // If the current character is a line feed, we can remove it
          // from the buffer and reset the crlfCheck flag
          if (this.buffer[this.pos] === LF) {
            this.buffer = this.buffer.subarray(this.pos + 1)
            this.pos = 0
            this.crlfCheck = false

            // It is possible that the line feed is not the end of the
            // event. We need to check if the next character is an
            // end-of-line character to determine if the event is
            // finished. We simply continue the loop to check the next
            // character.

            // As we removed the line feed from the buffer and set the
            // crlfCheck flag to false, we basically don't make any
            // distinction between a line feed and a carriage return.
            continue
          }
          this.crlfCheck = false
        }

        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
          // If the current character is a carriage return, we need to
          // set the crlfCheck flag to true, as we need to check if the
          // next character is a line feed so we can remove it from the
          // buffer
          if (this.buffer[this.pos] === CR) {
            this.crlfCheck = true
          }

          this.buffer = this.buffer.subarray(this.pos + 1)
          this.pos = 0
          if (
            this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) {
            this.processEvent(this.event)
          }
          this.clearEvent()
          continue
        }
        // If the current character is not an end-of-line, then the event
        // is not finished and we have to reset the eventEndCheck flag
        this.eventEndCheck = false
        continue
      }

      // If the current character is an end-of-line, we can process the
      // line
      if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
        // If the current character is a carriage return, we need to
        // set the crlfCheck flag to true, as we need to check if the
        // next character is a line feed
        if (this.buffer[this.pos] === CR) {
          this.crlfCheck = true
        }

        // In any case, we can process the line as we reached an
        // end-of-line character
        this.parseLine(this.buffer.subarray(0, this.pos), this.event)

        // Remove the processed line from the buffer
        this.buffer = this.buffer.subarray(this.pos + 1)
        // Reset the position as we removed the processed line from the buffer
        this.pos = 0
        // A line was processed and this could be the end of the event. We need
        // to check if the next line is empty to determine if the event is
        // finished.
        this.eventEndCheck = true
        continue
      }

      this.pos++
    }

    callback()
  }

  /**
   * @param {Buffer} line
   * @param {EventStreamEvent} event
   */
  parseLine (line, event) {
    // If the line is empty (a blank line)
    // Dispatch the event, as defined below.
    // This will be handled in the _transform method
    if (line.length === 0) {
      return
    }

    // If the line starts with a U+003A COLON character (:)
    // Ignore the line.
    const colonPosition = line.indexOf(COLON)
    if (colonPosition === 0) {
      return
    }

    let field = ''
    let value = ''

    // If the line contains a U+003A COLON character (:)
    if (colonPosition !== -1) {
      // Collect the characters on the line before the first U+003A COLON
      // character (:), and let field be that string.
      // TODO: Investigate if there is a more performant way to extract the
      // field
      // see: https://github.com/nodejs/undici/issues/2630
      field = line.subarray(0, colonPosition).toString('utf8')

      // Collect the characters on the line after the first U+003A COLON
      // character (:), and let value be that string.
      // If value starts with a U+0020 SPACE character, remove it from value.
      let valueStart = colonPosition + 1
      if (line[valueStart] === SPACE) {
        ++valueStart
      }
      // TODO: Investigate if there is a more performant way to extract the
      // value
      // see: https://github.com/nodejs/undici/issues/2630
      value = line.subarray(valueStart).toString('utf8')

      // Otherwise, the string is not empty but does not contain a U+003A COLON
      // character (:)
    } else {
      // Process the field using the steps described below, using the whole
      // line as the field name, and the empty string as the field value.
      field = line.toString('utf8')
      value = ''
    }

    // Modify the event with the field name and value. The value is also
    // decoded as UTF-8
    switch (field) {
      case 'data':
        if (event[field] === undefined) {
          event[field] = value
        } else {
          event[field] += `\n${value}`
        }
        break
      case 'retry':
        if (isASCIINumber(value)) {
          event[field] = value
        }
        break
      case 'id':
        if (isValidLastEventId(value)) {
          event[field] = value
        }
        break
      case 'event':
        if (value.length > 0) {
          event[field] = value
        }
        break
    }
  }

  /**
   * @param {EventSourceStreamEvent} event
   */
  processEvent (event) {
    if (event.retry && isASCIINumber(event.retry)) {
      this.state.reconnectionTime = parseInt(event.retry, 10)
    }

    if (event.id && isValidLastEventId(event.id)) {
      this.state.lastEventId = event.id
    }

    // only dispatch event, when data is provided
    if (event.data !== undefined) {
      this.push({
        type: event.event || 'message',
        options: {
          data: event.data,
          lastEventId: this.state.lastEventId,
          origin: this.state.origin
        }
      })
    }
  }

  clearEvent () {
    this.event = {
      data: undefined,
      event: undefined,
      id: undefined,
      retry: undefined
    }
  }
}

module.exports = {
  EventSourceStream
}


/***/ }),

/***/ "./node_modules/undici/lib/web/eventsource/eventsource.js":
/*!****************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { pipeline } = __webpack_require__(/*! node:stream */ "node:stream")
const { fetching } = __webpack_require__(/*! ../fetch */ "./node_modules/undici/lib/web/fetch/index.js")
const { makeRequest } = __webpack_require__(/*! ../fetch/request */ "./node_modules/undici/lib/web/fetch/request.js")
const { getGlobalOrigin } = __webpack_require__(/*! ../fetch/global */ "./node_modules/undici/lib/web/fetch/global.js")
const { webidl } = __webpack_require__(/*! ../fetch/webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { EventSourceStream } = __webpack_require__(/*! ./eventsource-stream */ "./node_modules/undici/lib/web/eventsource/eventsource-stream.js")
const { parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")
const { MessageEvent } = __webpack_require__(/*! ../websocket/events */ "./node_modules/undici/lib/web/websocket/events.js")
const { isNetworkError } = __webpack_require__(/*! ../fetch/response */ "./node_modules/undici/lib/web/fetch/response.js")
const { delay } = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/eventsource/util.js")

let experimentalWarned = false

/**
 * A reconnection time, in milliseconds. This must initially be an implementation-defined value,
 * probably in the region of a few seconds.
 *
 * In Comparison:
 * - Chrome uses 3000ms.
 * - Deno uses 5000ms.
 *
 * @type {3000}
 */
const defaultReconnectionTime = 3000

/**
 * The readyState attribute represents the state of the connection.
 * @enum
 * @readonly
 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#dom-eventsource-readystate-dev
 */

/**
 * The connection has not yet been established, or it was closed and the user
 * agent is reconnecting.
 * @type {0}
 */
const CONNECTING = 0

/**
 * The user agent has an open connection and is dispatching events as it
 * receives them.
 * @type {1}
 */
const OPEN = 1

/**
 * The connection is not open, and the user agent is not trying to reconnect.
 * @type {2}
 */
const CLOSED = 2

/**
 * Requests for the element will have their mode set to "cors" and their credentials mode set to "same-origin".
 * @type {'anonymous'}
 */
const ANONYMOUS = 'anonymous'

/**
 * Requests for the element will have their mode set to "cors" and their credentials mode set to "include".
 * @type {'use-credentials'}
 */
const USE_CREDENTIALS = 'use-credentials'

/**
 * @typedef {object} EventSourceInit
 * @property {boolean} [withCredentials] indicates whether the request
 * should include credentials.
 */

/**
 * The EventSource interface is used to receive server-sent events. It
 * connects to a server over HTTP and receives events in text/event-stream
 * format without closing the connection.
 * @extends {EventTarget}
 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events
 * @api public
 */
class EventSource extends EventTarget {
  #events = {
    open: null,
    error: null,
    message: null
  }

  #url = null
  #withCredentials = false

  #readyState = CONNECTING

  #request = null
  #controller = null

  /**
   * @type {object}
   * @property {string} lastEventId
   * @property {number} reconnectionTime
   * @property {any} reconnectionTimer
   */
  #settings = null

  /**
   * Creates a new EventSource object.
   * @param {string} url
   * @param {EventSourceInit} [eventSourceInitDict]
   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
   */
  constructor (url, eventSourceInitDict = {}) {
    // 1. Let ev be a new EventSource object.
    super()

    webidl.argumentLengthCheck(arguments, 1, { header: 'EventSource constructor' })

    if (!experimentalWarned) {
      experimentalWarned = true
      process.emitWarning('EventSource is experimental, expect them to change at any time.', {
        code: 'UNDICI-ES'
      })
    }

    url = webidl.converters.USVString(url)
    eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict)

    // 2. Let settings be ev's relevant settings object.
    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object
    this.#settings = {
      origin: getGlobalOrigin(),
      policyContainer: {
        referrerPolicy: 'no-referrer'
      },
      lastEventId: '',
      reconnectionTime: defaultReconnectionTime
    }

    let urlRecord

    try {
      // 3. Let urlRecord be the result of encoding-parsing a URL given url, relative to settings.
      urlRecord = new URL(url, this.#settings.origin)
      this.#settings.origin = urlRecord.origin
    } catch (e) {
      // 4. If urlRecord is failure, then throw a "SyntaxError" DOMException.
      throw new DOMException(e, 'SyntaxError')
    }

    // 5. Set ev's url to urlRecord.
    this.#url = urlRecord.href

    // 6. Let corsAttributeState be Anonymous.
    let corsAttributeState = ANONYMOUS

    // 7. If the value of eventSourceInitDict's withCredentials member is true,
    // then set corsAttributeState to Use Credentials and set ev's
    // withCredentials attribute to true.
    if (eventSourceInitDict.withCredentials) {
      corsAttributeState = USE_CREDENTIALS
      this.#withCredentials = true
    }

    // 8. Let request be the result of creating a potential-CORS request given
    // urlRecord, the empty string, and corsAttributeState.
    const initRequest = {
      redirect: 'follow',
      keepalive: true,
      // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes
      mode: 'cors',
      credentials: corsAttributeState === 'anonymous'
        ? 'same-origin'
        : 'omit',
      referrer: 'no-referrer'
    }

    // 9. Set request's client to settings.
    initRequest.client = this.#settings

    // 10. User agents may set (`Accept`, `text/event-stream`) in request's header list.
    initRequest.headersList = [['accept', { name: 'accept', value: 'text/event-stream' }]]

    // 11. Set request's cache mode to "no-store".
    initRequest.cache = 'no-store'

    // 12. Set request's initiator type to "other".
    initRequest.initiator = 'other'

    initRequest.urlList = [new URL(this.#url)]

    // 13. Set ev's request to request.
    this.#request = makeRequest(initRequest)

    this.#connect()
  }

  /**
   * Returns the state of this EventSource object's connection. It can have the
   * values described below.
   * @returns {0|1|2}
   * @readonly
   */
  get readyState () {
    return this.#readyState
  }

  /**
   * Returns the URL providing the event stream.
   * @readonly
   * @returns {string}
   */
  get url () {
    return this.#url
  }

  /**
   * Returns a boolean indicating whether the EventSource object was
   * instantiated with CORS credentials set (true), or not (false, the default).
   */
  get withCredentials () {
    return this.#withCredentials
  }

  #connect () {
    if (this.#readyState === CLOSED) return

    this.#readyState = CONNECTING

    const fetchParam = {
      request: this.#request
    }

    // 14. Let processEventSourceEndOfBody given response res be the following step: if res is not a network error, then reestablish the connection.
    const processEventSourceEndOfBody = (response) => {
      if (isNetworkError(response)) {
        this.dispatchEvent(new Event('error'))
        this.close()
      }

      this.#reconnect()
    }

    // 15. Fetch request, with processResponseEndOfBody set to processEventSourceEndOfBody...
    fetchParam.processResponseEndOfBody = processEventSourceEndOfBody

    // and processResponse set to the following steps given response res:
    fetchParam.processResponse = (response) => {
      // 1. If res is an aborted network error, then fail the connection.

      if (isNetworkError(response)) {
        // 1. When a user agent is to fail the connection, the user agent
        // must queue a task which, if the readyState attribute is set to a
        // value other than CLOSED, sets the readyState attribute to CLOSED
        // and fires an event named error at the EventSource object. Once the
        // user agent has failed the connection, it does not attempt to
        // reconnect.
        if (response.aborted) {
          this.close()
          this.dispatchEvent(new Event('error'))
          return
          // 2. Otherwise, if res is a network error, then reestablish the
          // connection, unless the user agent knows that to be futile, in
          // which case the user agent may fail the connection.
        } else {
          this.#reconnect()
          return
        }
      }

      // 3. Otherwise, if res's status is not 200, or if res's `Content-Type`
      // is not `text/event-stream`, then fail the connection.
      const contentType = response.headersList.get('content-type', true)
      const mimeType = contentType !== null ? parseMIMEType(contentType) : 'failure'
      const contentTypeValid = mimeType !== 'failure' && mimeType.essence === 'text/event-stream'
      if (
        response.status !== 200 ||
        contentTypeValid === false
      ) {
        this.close()
        this.dispatchEvent(new Event('error'))
        return
      }

      // 4. Otherwise, announce the connection and interpret res's body
      // line by line.

      // When a user agent is to announce the connection, the user agent
      // must queue a task which, if the readyState attribute is set to a
      // value other than CLOSED, sets the readyState attribute to OPEN
      // and fires an event named open at the EventSource object.
      // @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model
      this.#readyState = OPEN
      this.dispatchEvent(new Event('open'))

      // If redirected to a different origin, set the origin to the new origin.
      this.#settings.origin = response.urlList[response.urlList.length - 1].origin

      const eventSourceStream = new EventSourceStream({
        eventSourceSettings: this.#settings,
        push: (event) => {
          this.dispatchEvent(new MessageEvent(
            event.type,
            event.options
          ))
        }
      })

      pipeline(response.body.stream,
        eventSourceStream,
        (error) => {
          if (
            error?.aborted === false
          ) {
            this.close()
            this.dispatchEvent(new Event('error'))
          }
        })
    }

    this.#controller = fetching(fetchParam)
  }

  /**
   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model
   * @returns {Promise<void>}
   */
  async #reconnect () {
    // When a user agent is to reestablish the connection, the user agent must
    // run the following steps. These steps are run in parallel, not as part of
    // a task. (The tasks that it queues, of course, are run like normal tasks
    // and not themselves in parallel.)

    // 1. Queue a task to run the following steps:

    //   1. If the readyState attribute is set to CLOSED, abort the task.
    if (this.#readyState === CLOSED) return

    //   2. Set the readyState attribute to CONNECTING.
    this.#readyState = CONNECTING

    //   3. Fire an event named error at the EventSource object.
    this.dispatchEvent(new Event('error'))

    // 2. Wait a delay equal to the reconnection time of the event source.
    await delay(this.#settings.reconnectionTime)

    // 5. Queue a task to run the following steps:

    //   1. If the EventSource object's readyState attribute is not set to
    //      CONNECTING, then return.
    if (this.#readyState !== CONNECTING) return

    //   2. Let request be the EventSource object's request.
    //   3. If the EventSource object's last event ID string is not the empty
    //      string, then:
    //      1. Let lastEventIDValue be the EventSource object's last event ID
    //         string, encoded as UTF-8.
    //      2. Set (`Last-Event-ID`, lastEventIDValue) in request's header
    //         list.
    if (this.#settings.lastEventId !== '') {
      this.#request.headersList.set('last-event-id', this.#settings.lastEventId, true)
    }

    //   4. Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.
    this.#connect()
  }

  /**
   * Closes the connection, if any, and sets the readyState attribute to
   * CLOSED.
   */
  close () {
    webidl.brandCheck(this, EventSource)

    if (this.#readyState === CLOSED) return
    this.#readyState = CLOSED
    clearTimeout(this.#settings.reconnectionTimer)
    this.#controller.abort()

    if (this.#request) {
      this.#request = null
    }
  }

  get onopen () {
    return this.#events.open
  }

  set onopen (fn) {
    if (this.#events.open) {
      this.removeEventListener('open', this.#events.open)
    }

    if (typeof fn === 'function') {
      this.#events.open = fn
      this.addEventListener('open', fn)
    } else {
      this.#events.open = null
    }
  }

  get onmessage () {
    return this.#events.message
  }

  set onmessage (fn) {
    if (this.#events.message) {
      this.removeEventListener('message', this.#events.message)
    }

    if (typeof fn === 'function') {
      this.#events.message = fn
      this.addEventListener('message', fn)
    } else {
      this.#events.message = null
    }
  }

  get onerror () {
    return this.#events.error
  }

  set onerror (fn) {
    if (this.#events.error) {
      this.removeEventListener('error', this.#events.error)
    }

    if (typeof fn === 'function') {
      this.#events.error = fn
      this.addEventListener('error', fn)
    } else {
      this.#events.error = null
    }
  }
}

const constantsPropertyDescriptors = {
  CONNECTING: {
    __proto__: null,
    configurable: false,
    enumerable: true,
    value: CONNECTING,
    writable: false
  },
  OPEN: {
    __proto__: null,
    configurable: false,
    enumerable: true,
    value: OPEN,
    writable: false
  },
  CLOSED: {
    __proto__: null,
    configurable: false,
    enumerable: true,
    value: CLOSED,
    writable: false
  }
}

Object.defineProperties(EventSource, constantsPropertyDescriptors)
Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors)

webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
  { key: 'withCredentials', converter: webidl.converters.boolean, defaultValue: false }
])

module.exports = {
  EventSource,
  defaultReconnectionTime
}


/***/ }),

/***/ "./node_modules/undici/lib/web/eventsource/util.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/util.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Checks if the given value is a valid LastEventId.
 * @param {string} value
 * @returns {boolean}
 */
function isValidLastEventId (value) {
  // LastEventId should not contain U+0000 NULL
  return value.indexOf('\u0000') === -1
}

/**
 * Checks if the given value is a base 10 digit.
 * @param {string} value
 * @returns {boolean}
 */
function isASCIINumber (value) {
  if (value.length === 0) return false
  for (let i = 0; i < value.length; i++) {
    if (value.charCodeAt(i) < 0x30 || value.charCodeAt(i) > 0x39) return false
  }
  return true
}

// https://github.com/nodejs/undici/issues/2664
function delay (ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms).unref()
  })
}

module.exports = {
  isValidLastEventId,
  isASCIINumber,
  delay
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/body.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/body.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const Busboy = __webpack_require__(/*! @fastify/busboy */ "./node_modules/@fastify/busboy/lib/main.js")
const util = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const {
  ReadableStreamFrom,
  isBlobLike,
  isReadableStreamLike,
  readableStreamClose,
  createDeferredPromise,
  fullyReadBody,
  extractMimeType
} = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/fetch/util.js")
const { FormData } = __webpack_require__(/*! ./formdata */ "./node_modules/undici/lib/web/fetch/formdata.js")
const { kState } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/fetch/symbols.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { Blob, File: NativeFile } = __webpack_require__(/*! node:buffer */ "node:buffer")
const assert = __webpack_require__(/*! node:assert */ "node:assert")
const { isErrored } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const { isArrayBuffer } = __webpack_require__(/*! node:util/types */ "node:util/types")
const { File: UndiciFile } = __webpack_require__(/*! ./file */ "./node_modules/undici/lib/web/fetch/file.js")
const { serializeAMimeType } = __webpack_require__(/*! ./data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")
const { Readable } = __webpack_require__(/*! node:stream */ "node:stream")

/** @type {globalThis['File']} */
const File = NativeFile ?? UndiciFile
const textEncoder = new TextEncoder()
const textDecoder = new TextDecoder()

// https://fetch.spec.whatwg.org/#concept-bodyinit-extract
function extractBody (object, keepalive = false) {
  // 1. Let stream be null.
  let stream = null

  // 2. If object is a ReadableStream object, then set stream to object.
  if (object instanceof ReadableStream) {
    stream = object
  } else if (isBlobLike(object)) {
    // 3. Otherwise, if object is a Blob object, set stream to the
    //    result of running object’s get stream.
    stream = object.stream()
  } else {
    // 4. Otherwise, set stream to a new ReadableStream object, and set
    //    up stream with byte reading support.
    stream = new ReadableStream({
      async pull (controller) {
        const buffer = typeof source === 'string' ? textEncoder.encode(source) : source

        if (buffer.byteLength) {
          controller.enqueue(buffer)
        }

        queueMicrotask(() => readableStreamClose(controller))
      },
      start () {},
      type: 'bytes'
    })
  }

  // 5. Assert: stream is a ReadableStream object.
  assert(isReadableStreamLike(stream))

  // 6. Let action be null.
  let action = null

  // 7. Let source be null.
  let source = null

  // 8. Let length be null.
  let length = null

  // 9. Let type be null.
  let type = null

  // 10. Switch on object:
  if (typeof object === 'string') {
    // Set source to the UTF-8 encoding of object.
    // Note: setting source to a Uint8Array here breaks some mocking assumptions.
    source = object

    // Set type to `text/plain;charset=UTF-8`.
    type = 'text/plain;charset=UTF-8'
  } else if (object instanceof URLSearchParams) {
    // URLSearchParams

    // spec says to run application/x-www-form-urlencoded on body.list
    // this is implemented in Node.js as apart of an URLSearchParams instance toString method
    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490
    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100

    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.
    source = object.toString()

    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.
    type = 'application/x-www-form-urlencoded;charset=UTF-8'
  } else if (isArrayBuffer(object)) {
    // BufferSource/ArrayBuffer

    // Set source to a copy of the bytes held by object.
    source = new Uint8Array(object.slice())
  } else if (ArrayBuffer.isView(object)) {
    // BufferSource/ArrayBufferView

    // Set source to a copy of the bytes held by object.
    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))
  } else if (util.isFormDataLike(object)) {
    const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, '0')}`
    const prefix = `--${boundary}\r\nContent-Disposition: form-data`

    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
    const escape = (str) =>
      str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22')
    const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, '\r\n')

    // Set action to this step: run the multipart/form-data
    // encoding algorithm, with object’s entry list and UTF-8.
    // - This ensures that the body is immutable and can't be changed afterwords
    // - That the content-length is calculated in advance.
    // - And that all parts are pre-encoded and ready to be sent.

    const blobParts = []
    const rn = new Uint8Array([13, 10]) // '\r\n'
    length = 0
    let hasUnknownSizeValue = false

    for (const [name, value] of object) {
      if (typeof value === 'string') {
        const chunk = textEncoder.encode(prefix +
          `; name="${escape(normalizeLinefeeds(name))}"` +
          `\r\n\r\n${normalizeLinefeeds(value)}\r\n`)
        blobParts.push(chunk)
        length += chunk.byteLength
      } else {
        const chunk = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` +
          (value.name ? `; filename="${escape(value.name)}"` : '') + '\r\n' +
          `Content-Type: ${
            value.type || 'application/octet-stream'
          }\r\n\r\n`)
        blobParts.push(chunk, value, rn)
        if (typeof value.size === 'number') {
          length += chunk.byteLength + value.size + rn.byteLength
        } else {
          hasUnknownSizeValue = true
        }
      }
    }

    const chunk = textEncoder.encode(`--${boundary}--`)
    blobParts.push(chunk)
    length += chunk.byteLength
    if (hasUnknownSizeValue) {
      length = null
    }

    // Set source to object.
    source = object

    action = async function * () {
      for (const part of blobParts) {
        if (part.stream) {
          yield * part.stream()
        } else {
          yield part
        }
      }
    }

    // Set type to `multipart/form-data; boundary=`,
    // followed by the multipart/form-data boundary string generated
    // by the multipart/form-data encoding algorithm.
    type = `multipart/form-data; boundary=${boundary}`
  } else if (isBlobLike(object)) {
    // Blob

    // Set source to object.
    source = object

    // Set length to object’s size.
    length = object.size

    // If object’s type attribute is not the empty byte sequence, set
    // type to its value.
    if (object.type) {
      type = object.type
    }
  } else if (typeof object[Symbol.asyncIterator] === 'function') {
    // If keepalive is true, then throw a TypeError.
    if (keepalive) {
      throw new TypeError('keepalive')
    }

    // If object is disturbed or locked, then throw a TypeError.
    if (util.isDisturbed(object) || object.locked) {
      throw new TypeError(
        'Response body object should not be disturbed or locked'
      )
    }

    stream =
      object instanceof ReadableStream ? object : ReadableStreamFrom(object)
  }

  // 11. If source is a byte sequence, then set action to a
  // step that returns source and length to source’s length.
  if (typeof source === 'string' || util.isBuffer(source)) {
    length = Buffer.byteLength(source)
  }

  // 12. If action is non-null, then run these steps in in parallel:
  if (action != null) {
    // Run action.
    let iterator
    stream = new ReadableStream({
      async start () {
        iterator = action(object)[Symbol.asyncIterator]()
      },
      async pull (controller) {
        const { value, done } = await iterator.next()
        if (done) {
          // When running action is done, close stream.
          queueMicrotask(() => {
            controller.close()
            controller.byobRequest?.respond(0)
          })
        } else {
          // Whenever one or more bytes are available and stream is not errored,
          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available
          // bytes into stream.
          if (!isErrored(stream)) {
            const buffer = new Uint8Array(value)
            if (buffer.byteLength) {
              controller.enqueue(buffer)
            }
          }
        }
        return controller.desiredSize > 0
      },
      async cancel (reason) {
        await iterator.return()
      },
      type: 'bytes'
    })
  }

  // 13. Let body be a body whose stream is stream, source is source,
  // and length is length.
  const body = { stream, source, length }

  // 14. Return (body, type).
  return [body, type]
}

// https://fetch.spec.whatwg.org/#bodyinit-safely-extract
function safelyExtractBody (object, keepalive = false) {
  // To safely extract a body and a `Content-Type` value from
  // a byte sequence or BodyInit object object, run these steps:

  // 1. If object is a ReadableStream object, then:
  if (object instanceof ReadableStream) {
    // Assert: object is neither disturbed nor locked.
    // istanbul ignore next
    assert(!util.isDisturbed(object), 'The body has already been consumed.')
    // istanbul ignore next
    assert(!object.locked, 'The stream is locked.')
  }

  // 2. Return the results of extracting object.
  return extractBody(object, keepalive)
}

function cloneBody (body) {
  // To clone a body body, run these steps:

  // https://fetch.spec.whatwg.org/#concept-body-clone

  // 1. Let « out1, out2 » be the result of teeing body’s stream.
  const [out1, out2] = body.stream.tee()

  // 2. Set body’s stream to out1.
  body.stream = out1

  // 3. Return a body whose stream is out2 and other members are copied from body.
  return {
    stream: out2,
    length: body.length,
    source: body.source
  }
}

function throwIfAborted (state) {
  if (state.aborted) {
    throw new DOMException('The operation was aborted.', 'AbortError')
  }
}

function bodyMixinMethods (instance) {
  const methods = {
    blob () {
      // The blob() method steps are to return the result of
      // running consume body with this and the following step
      // given a byte sequence bytes: return a Blob whose
      // contents are bytes and whose type attribute is this’s
      // MIME type.
      return consumeBody(this, (bytes) => {
        let mimeType = bodyMimeType(this)

        if (mimeType === null) {
          mimeType = ''
        } else if (mimeType) {
          mimeType = serializeAMimeType(mimeType)
        }

        // Return a Blob whose contents are bytes and type attribute
        // is mimeType.
        return new Blob([bytes], { type: mimeType })
      }, instance)
    },

    arrayBuffer () {
      // The arrayBuffer() method steps are to return the result
      // of running consume body with this and the following step
      // given a byte sequence bytes: return a new ArrayBuffer
      // whose contents are bytes.
      return consumeBody(this, (bytes) => {
        return new Uint8Array(bytes).buffer
      }, instance)
    },

    text () {
      // The text() method steps are to return the result of running
      // consume body with this and UTF-8 decode.
      return consumeBody(this, utf8DecodeBytes, instance)
    },

    json () {
      // The json() method steps are to return the result of running
      // consume body with this and parse JSON from bytes.
      return consumeBody(this, parseJSONFromBytes, instance)
    },

    async formData () {
      webidl.brandCheck(this, instance)

      throwIfAborted(this[kState])

      // 1. Let mimeType be the result of get the MIME type with this.
      const mimeType = bodyMimeType(this)

      // If mimeType’s essence is "multipart/form-data", then:
      if (mimeType !== null && mimeType.essence === 'multipart/form-data') {
        const responseFormData = new FormData()

        let busboy

        try {
          busboy = new Busboy({
            headers: {
              'content-type': serializeAMimeType(mimeType)
            },
            preservePath: true
          })
        } catch (err) {
          throw new DOMException(`${err}`, 'AbortError')
        }

        busboy.on('field', (name, value) => {
          responseFormData.append(name, value)
        })
        busboy.on('file', (name, value, filename, encoding, mimeType) => {
          const chunks = []

          if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {
            let base64chunk = ''

            value.on('data', (chunk) => {
              base64chunk += chunk.toString().replace(/[\r\n]/gm, '')

              const end = base64chunk.length - base64chunk.length % 4
              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'))

              base64chunk = base64chunk.slice(end)
            })
            value.on('end', () => {
              chunks.push(Buffer.from(base64chunk, 'base64'))
              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))
            })
          } else {
            value.on('data', (chunk) => {
              chunks.push(chunk)
            })
            value.on('end', () => {
              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))
            })
          }
        })

        const busboyResolve = new Promise((resolve, reject) => {
          busboy.on('finish', resolve)
          busboy.on('error', (err) => reject(new TypeError(err)))
        })

        if (this.body !== null) {
          Readable.from(this[kState].body.stream).pipe(busboy)
        }

        await busboyResolve

        return responseFormData
      } else if (mimeType !== null && mimeType.essence === 'application/x-www-form-urlencoded') {
        // Otherwise, if mimeType’s essence is "application/x-www-form-urlencoded", then:

        // 1. Let entries be the result of parsing bytes.
        let entries
        try {
          let text = ''
          // application/x-www-form-urlencoded parser will keep the BOM.
          // https://url.spec.whatwg.org/#concept-urlencoded-parser
          // Note that streaming decoder is stateful and cannot be reused
          const stream = this[kState].body.stream.pipeThrough(new TextDecoderStream('utf-8', { ignoreBOM: true }))

          for await (const chunk of stream) {
            text += chunk
          }

          entries = new URLSearchParams(text)
        } catch (err) {
          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
          // 2. If entries is failure, then throw a TypeError.
          throw new TypeError(err)
        }

        // 3. Return a new FormData object whose entries are entries.
        const formData = new FormData()
        for (const [name, value] of entries) {
          formData.append(name, value)
        }
        return formData
      } else {
        // Wait a tick before checking if the request has been aborted.
        // Otherwise, a TypeError can be thrown when an AbortError should.
        await Promise.resolve()

        throwIfAborted(this[kState])

        // Otherwise, throw a TypeError.
        throw webidl.errors.exception({
          header: `${instance.name}.formData`,
          message: 'Could not parse content as FormData.'
        })
      }
    }
  }

  return methods
}

function mixinBody (prototype) {
  Object.assign(prototype.prototype, bodyMixinMethods(prototype))
}

/**
 * @see https://fetch.spec.whatwg.org/#concept-body-consume-body
 * @param {Response|Request} object
 * @param {(value: unknown) => unknown} convertBytesToJSValue
 * @param {Response|Request} instance
 */
async function consumeBody (object, convertBytesToJSValue, instance) {
  webidl.brandCheck(object, instance)

  throwIfAborted(object[kState])

  // 1. If object is unusable, then return a promise rejected
  //    with a TypeError.
  if (bodyUnusable(object[kState].body)) {
    throw new TypeError('Body is unusable')
  }

  // 2. Let promise be a new promise.
  const promise = createDeferredPromise()

  // 3. Let errorSteps given error be to reject promise with error.
  const errorSteps = (error) => promise.reject(error)

  // 4. Let successSteps given a byte sequence data be to resolve
  //    promise with the result of running convertBytesToJSValue
  //    with data. If that threw an exception, then run errorSteps
  //    with that exception.
  const successSteps = (data) => {
    try {
      promise.resolve(convertBytesToJSValue(data))
    } catch (e) {
      errorSteps(e)
    }
  }

  // 5. If object’s body is null, then run successSteps with an
  //    empty byte sequence.
  if (object[kState].body == null) {
    successSteps(new Uint8Array())
    return promise.promise
  }

  // 6. Otherwise, fully read object’s body given successSteps,
  //    errorSteps, and object’s relevant global object.
  await fullyReadBody(object[kState].body, successSteps, errorSteps)

  // 7. Return promise.
  return promise.promise
}

// https://fetch.spec.whatwg.org/#body-unusable
function bodyUnusable (body) {
  // An object including the Body interface mixin is
  // said to be unusable if its body is non-null and
  // its body’s stream is disturbed or locked.
  return body != null && (body.stream.locked || util.isDisturbed(body.stream))
}

/**
 * @see https://encoding.spec.whatwg.org/#utf-8-decode
 * @param {Buffer} buffer
 */
function utf8DecodeBytes (buffer) {
  if (buffer.length === 0) {
    return ''
  }

  // 1. Let buffer be the result of peeking three bytes from
  //    ioQueue, converted to a byte sequence.

  // 2. If buffer is 0xEF 0xBB 0xBF, then read three
  //    bytes from ioQueue. (Do nothing with those bytes.)
  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
    buffer = buffer.subarray(3)
  }

  // 3. Process a queue with an instance of UTF-8’s
  //    decoder, ioQueue, output, and "replacement".
  const output = textDecoder.decode(buffer)

  // 4. Return output.
  return output
}

/**
 * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value
 * @param {Uint8Array} bytes
 */
function parseJSONFromBytes (bytes) {
  return JSON.parse(utf8DecodeBytes(bytes))
}

/**
 * @see https://fetch.spec.whatwg.org/#concept-body-mime-type
 * @param {import('./response').Response|import('./request').Request} requestOrResponse
 */
function bodyMimeType (requestOrResponse) {
  // 1. Let headers be null.
  // 2. If requestOrResponse is a Request object, then set headers to requestOrResponse’s request’s header list.
  // 3. Otherwise, set headers to requestOrResponse’s response’s header list.
  /** @type {import('./headers').HeadersList} */
  const headers = requestOrResponse[kState].headersList

  // 4. Let mimeType be the result of extracting a MIME type from headers.
  const mimeType = extractMimeType(headers)

  // 5. If mimeType is failure, then return null.
  if (mimeType === 'failure') {
    return null
  }

  // 6. Return mimeType.
  return mimeType
}

module.exports = {
  extractBody,
  safelyExtractBody,
  cloneBody,
  mixinBody
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/constants.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


const corsSafeListedMethods = ['GET', 'HEAD', 'POST']
const corsSafeListedMethodsSet = new Set(corsSafeListedMethods)

const nullBodyStatus = [101, 204, 205, 304]

const redirectStatus = [301, 302, 303, 307, 308]
const redirectStatusSet = new Set(redirectStatus)

// https://fetch.spec.whatwg.org/#block-bad-port
const badPorts = [
  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',
  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',
  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',
  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',
  '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697',
  '10080'
]

const badPortsSet = new Set(badPorts)

// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies
const referrerPolicy = [
  '',
  'no-referrer',
  'no-referrer-when-downgrade',
  'same-origin',
  'origin',
  'strict-origin',
  'origin-when-cross-origin',
  'strict-origin-when-cross-origin',
  'unsafe-url'
]
const referrerPolicySet = new Set(referrerPolicy)

const requestRedirect = ['follow', 'manual', 'error']

const safeMethods = ['GET', 'HEAD', 'OPTIONS', 'TRACE']
const safeMethodsSet = new Set(safeMethods)

const requestMode = ['navigate', 'same-origin', 'no-cors', 'cors']

const requestCredentials = ['omit', 'same-origin', 'include']

const requestCache = [
  'default',
  'no-store',
  'reload',
  'no-cache',
  'force-cache',
  'only-if-cached'
]

// https://fetch.spec.whatwg.org/#request-body-header-name
const requestBodyHeader = [
  'content-encoding',
  'content-language',
  'content-location',
  'content-type',
  // See https://github.com/nodejs/undici/issues/2021
  // 'Content-Length' is a forbidden header name, which is typically
  // removed in the Headers implementation. However, undici doesn't
  // filter out headers, so we add it here.
  'content-length'
]

// https://fetch.spec.whatwg.org/#enumdef-requestduplex
const requestDuplex = [
  'half'
]

// http://fetch.spec.whatwg.org/#forbidden-method
const forbiddenMethods = ['CONNECT', 'TRACE', 'TRACK']
const forbiddenMethodsSet = new Set(forbiddenMethods)

const subresource = [
  'audio',
  'audioworklet',
  'font',
  'image',
  'manifest',
  'paintworklet',
  'script',
  'style',
  'track',
  'video',
  'xslt',
  ''
]
const subresourceSet = new Set(subresource)

module.exports = {
  subresource,
  forbiddenMethods,
  requestBodyHeader,
  referrerPolicy,
  requestRedirect,
  requestMode,
  requestCredentials,
  requestCache,
  redirectStatus,
  corsSafeListedMethods,
  nullBodyStatus,
  safeMethods,
  badPorts,
  requestDuplex,
  subresourceSet,
  badPortsSet,
  redirectStatusSet,
  corsSafeListedMethodsSet,
  safeMethodsSet,
  forbiddenMethodsSet,
  referrerPolicySet
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/data-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/data-url.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const assert = __webpack_require__(/*! node:assert */ "node:assert")

const encoder = new TextEncoder()

/**
 * @see https://mimesniff.spec.whatwg.org/#http-token-code-point
 */
const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/
const HTTP_WHITESPACE_REGEX = /[\u000A|\u000D|\u0009|\u0020]/ // eslint-disable-line
const ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g // eslint-disable-line
/**
 * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
 */
const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/ // eslint-disable-line

// https://fetch.spec.whatwg.org/#data-url-processor
/** @param {URL} dataURL */
function dataURLProcessor (dataURL) {
  // 1. Assert: dataURL’s scheme is "data".
  assert(dataURL.protocol === 'data:')

  // 2. Let input be the result of running the URL
  // serializer on dataURL with exclude fragment
  // set to true.
  let input = URLSerializer(dataURL, true)

  // 3. Remove the leading "data:" string from input.
  input = input.slice(5)

  // 4. Let position point at the start of input.
  const position = { position: 0 }

  // 5. Let mimeType be the result of collecting a
  // sequence of code points that are not equal
  // to U+002C (,), given position.
  let mimeType = collectASequenceOfCodePointsFast(
    ',',
    input,
    position
  )

  // 6. Strip leading and trailing ASCII whitespace
  // from mimeType.
  // Undici implementation note: we need to store the
  // length because if the mimetype has spaces removed,
  // the wrong amount will be sliced from the input in
  // step #9
  const mimeTypeLength = mimeType.length
  mimeType = removeASCIIWhitespace(mimeType, true, true)

  // 7. If position is past the end of input, then
  // return failure
  if (position.position >= input.length) {
    return 'failure'
  }

  // 8. Advance position by 1.
  position.position++

  // 9. Let encodedBody be the remainder of input.
  const encodedBody = input.slice(mimeTypeLength + 1)

  // 10. Let body be the percent-decoding of encodedBody.
  let body = stringPercentDecode(encodedBody)

  // 11. If mimeType ends with U+003B (;), followed by
  // zero or more U+0020 SPACE, followed by an ASCII
  // case-insensitive match for "base64", then:
  if (/;(\u0020){0,}base64$/i.test(mimeType)) {
    // 1. Let stringBody be the isomorphic decode of body.
    const stringBody = isomorphicDecode(body)

    // 2. Set body to the forgiving-base64 decode of
    // stringBody.
    body = forgivingBase64(stringBody)

    // 3. If body is failure, then return failure.
    if (body === 'failure') {
      return 'failure'
    }

    // 4. Remove the last 6 code points from mimeType.
    mimeType = mimeType.slice(0, -6)

    // 5. Remove trailing U+0020 SPACE code points from mimeType,
    // if any.
    mimeType = mimeType.replace(/(\u0020)+$/, '')

    // 6. Remove the last U+003B (;) code point from mimeType.
    mimeType = mimeType.slice(0, -1)
  }

  // 12. If mimeType starts with U+003B (;), then prepend
  // "text/plain" to mimeType.
  if (mimeType.startsWith(';')) {
    mimeType = 'text/plain' + mimeType
  }

  // 13. Let mimeTypeRecord be the result of parsing
  // mimeType.
  let mimeTypeRecord = parseMIMEType(mimeType)

  // 14. If mimeTypeRecord is failure, then set
  // mimeTypeRecord to text/plain;charset=US-ASCII.
  if (mimeTypeRecord === 'failure') {
    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')
  }

  // 15. Return a new data: URL struct whose MIME
  // type is mimeTypeRecord and body is body.
  // https://fetch.spec.whatwg.org/#data-url-struct
  return { mimeType: mimeTypeRecord, body }
}

// https://url.spec.whatwg.org/#concept-url-serializer
/**
 * @param {URL} url
 * @param {boolean} excludeFragment
 */
function URLSerializer (url, excludeFragment = false) {
  if (!excludeFragment) {
    return url.href
  }

  const href = url.href
  const hashLength = url.hash.length

  const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength)

  if (!hashLength && href.endsWith('#')) {
    return serialized.slice(0, -1)
  }

  return serialized
}

// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points
/**
 * @param {(char: string) => boolean} condition
 * @param {string} input
 * @param {{ position: number }} position
 */
function collectASequenceOfCodePoints (condition, input, position) {
  // 1. Let result be the empty string.
  let result = ''

  // 2. While position doesn’t point past the end of input and the
  // code point at position within input meets the condition condition:
  while (position.position < input.length && condition(input[position.position])) {
    // 1. Append that code point to the end of result.
    result += input[position.position]

    // 2. Advance position by 1.
    position.position++
  }

  // 3. Return result.
  return result
}

/**
 * A faster collectASequenceOfCodePoints that only works when comparing a single character.
 * @param {string} char
 * @param {string} input
 * @param {{ position: number }} position
 */
function collectASequenceOfCodePointsFast (char, input, position) {
  const idx = input.indexOf(char, position.position)
  const start = position.position

  if (idx === -1) {
    position.position = input.length
    return input.slice(start)
  }

  position.position = idx
  return input.slice(start, position.position)
}

// https://url.spec.whatwg.org/#string-percent-decode
/** @param {string} input */
function stringPercentDecode (input) {
  // 1. Let bytes be the UTF-8 encoding of input.
  const bytes = encoder.encode(input)

  // 2. Return the percent-decoding of bytes.
  return percentDecode(bytes)
}

/**
 * @param {number} byte
 */
function isHexCharByte (byte) {
  // 0-9 A-F a-f
  return (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x46) || (byte >= 0x61 && byte <= 0x66)
}

/**
 * @param {number} byte
 */
function hexByteToNumber (byte) {
  return (
    // 0-9
    byte >= 0x30 && byte <= 0x39
      ? (byte - 48)
    // Convert to uppercase
    // ((byte & 0xDF) - 65) + 10
      : ((byte & 0xDF) - 55)
  )
}

// https://url.spec.whatwg.org/#percent-decode
/** @param {Uint8Array} input */
function percentDecode (input) {
  const length = input.length
  // 1. Let output be an empty byte sequence.
  /** @type {Uint8Array} */
  const output = new Uint8Array(length)
  let j = 0
  // 2. For each byte byte in input:
  for (let i = 0; i < length; ++i) {
    const byte = input[i]

    // 1. If byte is not 0x25 (%), then append byte to output.
    if (byte !== 0x25) {
      output[j++] = byte

    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes
    // after byte in input are not in the ranges
    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),
    // and 0x61 (a) to 0x66 (f), all inclusive, append byte
    // to output.
    } else if (
      byte === 0x25 &&
      !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))
    ) {
      output[j++] = 0x25

    // 3. Otherwise:
    } else {
      // 1. Let bytePoint be the two bytes after byte in input,
      // decoded, and then interpreted as hexadecimal number.
      // 2. Append a byte whose value is bytePoint to output.
      output[j++] = (hexByteToNumber(input[i + 1]) << 4) | hexByteToNumber(input[i + 2])

      // 3. Skip the next two bytes in input.
      i += 2
    }
  }

  // 3. Return output.
  return length === j ? output : output.subarray(0, j)
}

// https://mimesniff.spec.whatwg.org/#parse-a-mime-type
/** @param {string} input */
function parseMIMEType (input) {
  // 1. Remove any leading and trailing HTTP whitespace
  // from input.
  input = removeHTTPWhitespace(input, true, true)

  // 2. Let position be a position variable for input,
  // initially pointing at the start of input.
  const position = { position: 0 }

  // 3. Let type be the result of collecting a sequence
  // of code points that are not U+002F (/) from
  // input, given position.
  const type = collectASequenceOfCodePointsFast(
    '/',
    input,
    position
  )

  // 4. If type is the empty string or does not solely
  // contain HTTP token code points, then return failure.
  // https://mimesniff.spec.whatwg.org/#http-token-code-point
  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
    return 'failure'
  }

  // 5. If position is past the end of input, then return
  // failure
  if (position.position > input.length) {
    return 'failure'
  }

  // 6. Advance position by 1. (This skips past U+002F (/).)
  position.position++

  // 7. Let subtype be the result of collecting a sequence of
  // code points that are not U+003B (;) from input, given
  // position.
  let subtype = collectASequenceOfCodePointsFast(
    ';',
    input,
    position
  )

  // 8. Remove any trailing HTTP whitespace from subtype.
  subtype = removeHTTPWhitespace(subtype, false, true)

  // 9. If subtype is the empty string or does not solely
  // contain HTTP token code points, then return failure.
  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
    return 'failure'
  }

  const typeLowercase = type.toLowerCase()
  const subtypeLowercase = subtype.toLowerCase()

  // 10. Let mimeType be a new MIME type record whose type
  // is type, in ASCII lowercase, and subtype is subtype,
  // in ASCII lowercase.
  // https://mimesniff.spec.whatwg.org/#mime-type
  const mimeType = {
    type: typeLowercase,
    subtype: subtypeLowercase,
    /** @type {Map<string, string>} */
    parameters: new Map(),
    // https://mimesniff.spec.whatwg.org/#mime-type-essence
    essence: `${typeLowercase}/${subtypeLowercase}`
  }

  // 11. While position is not past the end of input:
  while (position.position < input.length) {
    // 1. Advance position by 1. (This skips past U+003B (;).)
    position.position++

    // 2. Collect a sequence of code points that are HTTP
    // whitespace from input given position.
    collectASequenceOfCodePoints(
      // https://fetch.spec.whatwg.org/#http-whitespace
      char => HTTP_WHITESPACE_REGEX.test(char),
      input,
      position
    )

    // 3. Let parameterName be the result of collecting a
    // sequence of code points that are not U+003B (;)
    // or U+003D (=) from input, given position.
    let parameterName = collectASequenceOfCodePoints(
      (char) => char !== ';' && char !== '=',
      input,
      position
    )

    // 4. Set parameterName to parameterName, in ASCII
    // lowercase.
    parameterName = parameterName.toLowerCase()

    // 5. If position is not past the end of input, then:
    if (position.position < input.length) {
      // 1. If the code point at position within input is
      // U+003B (;), then continue.
      if (input[position.position] === ';') {
        continue
      }

      // 2. Advance position by 1. (This skips past U+003D (=).)
      position.position++
    }

    // 6. If position is past the end of input, then break.
    if (position.position > input.length) {
      break
    }

    // 7. Let parameterValue be null.
    let parameterValue = null

    // 8. If the code point at position within input is
    // U+0022 ("), then:
    if (input[position.position] === '"') {
      // 1. Set parameterValue to the result of collecting
      // an HTTP quoted string from input, given position
      // and the extract-value flag.
      parameterValue = collectAnHTTPQuotedString(input, position, true)

      // 2. Collect a sequence of code points that are not
      // U+003B (;) from input, given position.
      collectASequenceOfCodePointsFast(
        ';',
        input,
        position
      )

    // 9. Otherwise:
    } else {
      // 1. Set parameterValue to the result of collecting
      // a sequence of code points that are not U+003B (;)
      // from input, given position.
      parameterValue = collectASequenceOfCodePointsFast(
        ';',
        input,
        position
      )

      // 2. Remove any trailing HTTP whitespace from parameterValue.
      parameterValue = removeHTTPWhitespace(parameterValue, false, true)

      // 3. If parameterValue is the empty string, then continue.
      if (parameterValue.length === 0) {
        continue
      }
    }

    // 10. If all of the following are true
    // - parameterName is not the empty string
    // - parameterName solely contains HTTP token code points
    // - parameterValue solely contains HTTP quoted-string token code points
    // - mimeType’s parameters[parameterName] does not exist
    // then set mimeType’s parameters[parameterName] to parameterValue.
    if (
      parameterName.length !== 0 &&
      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&
      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&
      !mimeType.parameters.has(parameterName)
    ) {
      mimeType.parameters.set(parameterName, parameterValue)
    }
  }

  // 12. Return mimeType.
  return mimeType
}

// https://infra.spec.whatwg.org/#forgiving-base64-decode
/** @param {string} data */
function forgivingBase64 (data) {
  // 1. Remove all ASCII whitespace from data.
  data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, '')  // eslint-disable-line

  let dataLength = data.length
  // 2. If data’s code point length divides by 4 leaving
  // no remainder, then:
  if (dataLength % 4 === 0) {
    // 1. If data ends with one or two U+003D (=) code points,
    // then remove them from data.
    if (data.charCodeAt(dataLength - 1) === 0x003D) {
      --dataLength
      if (data.charCodeAt(dataLength - 1) === 0x003D) {
        --dataLength
      }
    }
  }

  // 3. If data’s code point length divides by 4 leaving
  // a remainder of 1, then return failure.
  if (dataLength % 4 === 1) {
    return 'failure'
  }

  // 4. If data contains a code point that is not one of
  //  U+002B (+)
  //  U+002F (/)
  //  ASCII alphanumeric
  // then return failure.
  if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {
    return 'failure'
  }

  const buffer = Buffer.from(data, 'base64')
  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength)
}

// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string
// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string
/**
 * @param {string} input
 * @param {{ position: number }} position
 * @param {boolean?} extractValue
 */
function collectAnHTTPQuotedString (input, position, extractValue) {
  // 1. Let positionStart be position.
  const positionStart = position.position

  // 2. Let value be the empty string.
  let value = ''

  // 3. Assert: the code point at position within input
  // is U+0022 (").
  assert(input[position.position] === '"')

  // 4. Advance position by 1.
  position.position++

  // 5. While true:
  while (true) {
    // 1. Append the result of collecting a sequence of code points
    // that are not U+0022 (") or U+005C (\) from input, given
    // position, to value.
    value += collectASequenceOfCodePoints(
      (char) => char !== '"' && char !== '\\',
      input,
      position
    )

    // 2. If position is past the end of input, then break.
    if (position.position >= input.length) {
      break
    }

    // 3. Let quoteOrBackslash be the code point at position within
    // input.
    const quoteOrBackslash = input[position.position]

    // 4. Advance position by 1.
    position.position++

    // 5. If quoteOrBackslash is U+005C (\), then:
    if (quoteOrBackslash === '\\') {
      // 1. If position is past the end of input, then append
      // U+005C (\) to value and break.
      if (position.position >= input.length) {
        value += '\\'
        break
      }

      // 2. Append the code point at position within input to value.
      value += input[position.position]

      // 3. Advance position by 1.
      position.position++

    // 6. Otherwise:
    } else {
      // 1. Assert: quoteOrBackslash is U+0022 (").
      assert(quoteOrBackslash === '"')

      // 2. Break.
      break
    }
  }

  // 6. If the extract-value flag is set, then return value.
  if (extractValue) {
    return value
  }

  // 7. Return the code points from positionStart to position,
  // inclusive, within input.
  return input.slice(positionStart, position.position)
}

/**
 * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
 */
function serializeAMimeType (mimeType) {
  assert(mimeType !== 'failure')
  const { parameters, essence } = mimeType

  // 1. Let serialization be the concatenation of mimeType’s
  //    type, U+002F (/), and mimeType’s subtype.
  let serialization = essence

  // 2. For each name → value of mimeType’s parameters:
  for (let [name, value] of parameters.entries()) {
    // 1. Append U+003B (;) to serialization.
    serialization += ';'

    // 2. Append name to serialization.
    serialization += name

    // 3. Append U+003D (=) to serialization.
    serialization += '='

    // 4. If value does not solely contain HTTP token code
    //    points or value is the empty string, then:
    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
      // 1. Precede each occurrence of U+0022 (") or
      //    U+005C (\) in value with U+005C (\).
      value = value.replace(/(\\|")/g, '\\$1')

      // 2. Prepend U+0022 (") to value.
      value = '"' + value

      // 3. Append U+0022 (") to value.
      value += '"'
    }

    // 5. Append value to serialization.
    serialization += value
  }

  // 3. Return serialization.
  return serialization
}

/**
 * @see https://fetch.spec.whatwg.org/#http-whitespace
 * @param {number} char
 */
function isHTTPWhiteSpace (char) {
  // "\r\n\t "
  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x020
}

/**
 * @see https://fetch.spec.whatwg.org/#http-whitespace
 * @param {string} str
 * @param {boolean} [leading=true]
 * @param {boolean} [trailing=true]
 */
function removeHTTPWhitespace (str, leading = true, trailing = true) {
  return removeChars(str, leading, trailing, isHTTPWhiteSpace)
}

/**
 * @see https://infra.spec.whatwg.org/#ascii-whitespace
 * @param {number} char
 */
function isASCIIWhitespace (char) {
  // "\r\n\t\f "
  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x00c || char === 0x020
}

/**
 * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace
 * @param {string} str
 * @param {boolean} [leading=true]
 * @param {boolean} [trailing=true]
 */
function removeASCIIWhitespace (str, leading = true, trailing = true) {
  return removeChars(str, leading, trailing, isASCIIWhitespace)
}

/**
 *
 * @param {string} str
 * @param {boolean} leading
 * @param {boolean} trailing
 * @param {(charCode: number) => boolean} predicate
 * @returns
 */
function removeChars (str, leading, trailing, predicate) {
  let lead = 0
  let trail = str.length - 1

  if (leading) {
    while (lead < str.length && predicate(str.charCodeAt(lead))) lead++
  }

  if (trailing) {
    while (trail > 0 && predicate(str.charCodeAt(trail))) trail--
  }

  return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1)
}

/**
 * @see https://infra.spec.whatwg.org/#isomorphic-decode
 * @param {Uint8Array} input
 * @returns {string}
 */
function isomorphicDecode (input) {
  // 1. To isomorphic decode a byte sequence input, return a string whose code point
  //    length is equal to input’s length and whose code points have the same values
  //    as the values of input’s bytes, in the same order.
  const length = input.length
  if ((2 << 15) - 1 > length) {
    return String.fromCharCode.apply(null, input)
  }
  let result = ''; let i = 0
  let addition = (2 << 15) - 1
  while (i < length) {
    if (i + addition > length) {
      addition = length - i
    }
    result += String.fromCharCode.apply(null, input.subarray(i, i += addition))
  }
  return result
}

/**
 * @see https://mimesniff.spec.whatwg.org/#minimize-a-supported-mime-type
 * @param {Exclude<ReturnType<typeof parseMIMEType>, 'failure'>} mimeType
 */
function minimizeSupportedMimeType (mimeType) {
  switch (mimeType.essence) {
    case 'application/ecmascript':
    case 'application/javascript':
    case 'application/x-ecmascript':
    case 'application/x-javascript':
    case 'text/ecmascript':
    case 'text/javascript':
    case 'text/javascript1.0':
    case 'text/javascript1.1':
    case 'text/javascript1.2':
    case 'text/javascript1.3':
    case 'text/javascript1.4':
    case 'text/javascript1.5':
    case 'text/jscript':
    case 'text/livescript':
    case 'text/x-ecmascript':
    case 'text/x-javascript':
      // 1. If mimeType is a JavaScript MIME type, then return "text/javascript".
      return 'text/javascript'
    case 'application/json':
    case 'text/json':
      // 2. If mimeType is a JSON MIME type, then return "application/json".
      return 'application/json'
    case 'image/svg+xml':
      // 3. If mimeType’s essence is "image/svg+xml", then return "image/svg+xml".
      return 'image/svg+xml'
    case 'text/xml':
    case 'application/xml':
      // 4. If mimeType is an XML MIME type, then return "application/xml".
      return 'application/xml'
  }

  // 2. If mimeType is a JSON MIME type, then return "application/json".
  if (mimeType.subtype.endsWith('+json')) {
    return 'application/json'
  }

  // 4. If mimeType is an XML MIME type, then return "application/xml".
  if (mimeType.subtype.endsWith('+xml')) {
    return 'application/xml'
  }

  // 5. If mimeType is supported by the user agent, then return mimeType’s essence.
  // Technically, node doesn't support any mimetypes.

  // 6. Return the empty string.
  return ''
}

module.exports = {
  dataURLProcessor,
  URLSerializer,
  collectASequenceOfCodePoints,
  collectASequenceOfCodePointsFast,
  stringPercentDecode,
  parseMIMEType,
  collectAnHTTPQuotedString,
  serializeAMimeType,
  removeChars,
  minimizeSupportedMimeType
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/dispatcher-weakref.js":
/*!*****************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/dispatcher-weakref.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kConnected, kSize } = __webpack_require__(/*! ../../core/symbols */ "./node_modules/undici/lib/core/symbols.js")

class CompatWeakRef {
  constructor (value) {
    this.value = value
  }

  deref () {
    return this.value[kConnected] === 0 && this.value[kSize] === 0
      ? undefined
      : this.value
  }
}

class CompatFinalizer {
  constructor (finalizer) {
    this.finalizer = finalizer
  }

  register (dispatcher, key) {
    if (dispatcher.on) {
      dispatcher.on('disconnect', () => {
        if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
          this.finalizer(key)
        }
      })
    }
  }

  unregister (key) {}
}

module.exports = function () {
  // FIXME: remove workaround when the Node bug is fixed
  // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
  if (process.env.NODE_V8_COVERAGE) {
    return {
      WeakRef: CompatWeakRef,
      FinalizationRegistry: CompatFinalizer
    }
  }
  return { WeakRef, FinalizationRegistry }
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/file.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/file.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Blob, File: NativeFile } = __webpack_require__(/*! node:buffer */ "node:buffer")
const { types } = __webpack_require__(/*! node:util */ "node:util")
const { kState } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/fetch/symbols.js")
const { isBlobLike } = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/fetch/util.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")
const { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const encoder = new TextEncoder()

class File extends Blob {
  constructor (fileBits, fileName, options = {}) {
    // The File constructor is invoked with two or three parameters, depending
    // on whether the optional dictionary parameter is used. When the File()
    // constructor is invoked, user agents must run the following steps:
    webidl.argumentLengthCheck(arguments, 2, { header: 'File constructor' })

    fileBits = webidl.converters['sequence<BlobPart>'](fileBits)
    fileName = webidl.converters.USVString(fileName)
    options = webidl.converters.FilePropertyBag(options)

    // 1. Let bytes be the result of processing blob parts given fileBits and
    // options.
    // Note: Blob handles this for us

    // 2. Let n be the fileName argument to the constructor.
    const n = fileName

    // 3. Process FilePropertyBag dictionary argument by running the following
    // substeps:

    //    1. If the type member is provided and is not the empty string, let t
    //    be set to the type dictionary member. If t contains any characters
    //    outside the range U+0020 to U+007E, then set t to the empty string
    //    and return from these substeps.
    //    2. Convert every character in t to ASCII lowercase.
    let t = options.type
    let d

    // eslint-disable-next-line no-labels
    substep: {
      if (t) {
        t = parseMIMEType(t)

        if (t === 'failure') {
          t = ''
          // eslint-disable-next-line no-labels
          break substep
        }

        t = serializeAMimeType(t).toLowerCase()
      }

      //    3. If the lastModified member is provided, let d be set to the
      //    lastModified dictionary member. If it is not provided, set d to the
      //    current date and time represented as the number of milliseconds since
      //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
      d = options.lastModified
    }

    // 4. Return a new File object F such that:
    // F refers to the bytes byte sequence.
    // F.size is set to the number of total bytes in bytes.
    // F.name is set to n.
    // F.type is set to t.
    // F.lastModified is set to d.

    super(processBlobParts(fileBits, options), { type: t })
    this[kState] = {
      name: n,
      lastModified: d,
      type: t
    }
  }

  get name () {
    webidl.brandCheck(this, File)

    return this[kState].name
  }

  get lastModified () {
    webidl.brandCheck(this, File)

    return this[kState].lastModified
  }

  get type () {
    webidl.brandCheck(this, File)

    return this[kState].type
  }
}

class FileLike {
  constructor (blobLike, fileName, options = {}) {
    // TODO: argument idl type check

    // The File constructor is invoked with two or three parameters, depending
    // on whether the optional dictionary parameter is used. When the File()
    // constructor is invoked, user agents must run the following steps:

    // 1. Let bytes be the result of processing blob parts given fileBits and
    // options.

    // 2. Let n be the fileName argument to the constructor.
    const n = fileName

    // 3. Process FilePropertyBag dictionary argument by running the following
    // substeps:

    //    1. If the type member is provided and is not the empty string, let t
    //    be set to the type dictionary member. If t contains any characters
    //    outside the range U+0020 to U+007E, then set t to the empty string
    //    and return from these substeps.
    //    TODO
    const t = options.type

    //    2. Convert every character in t to ASCII lowercase.
    //    TODO

    //    3. If the lastModified member is provided, let d be set to the
    //    lastModified dictionary member. If it is not provided, set d to the
    //    current date and time represented as the number of milliseconds since
    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
    const d = options.lastModified ?? Date.now()

    // 4. Return a new File object F such that:
    // F refers to the bytes byte sequence.
    // F.size is set to the number of total bytes in bytes.
    // F.name is set to n.
    // F.type is set to t.
    // F.lastModified is set to d.

    this[kState] = {
      blobLike,
      name: n,
      type: t,
      lastModified: d
    }
  }

  stream (...args) {
    webidl.brandCheck(this, FileLike)

    return this[kState].blobLike.stream(...args)
  }

  arrayBuffer (...args) {
    webidl.brandCheck(this, FileLike)

    return this[kState].blobLike.arrayBuffer(...args)
  }

  slice (...args) {
    webidl.brandCheck(this, FileLike)

    return this[kState].blobLike.slice(...args)
  }

  text (...args) {
    webidl.brandCheck(this, FileLike)

    return this[kState].blobLike.text(...args)
  }

  get size () {
    webidl.brandCheck(this, FileLike)

    return this[kState].blobLike.size
  }

  get type () {
    webidl.brandCheck(this, FileLike)

    return this[kState].blobLike.type
  }

  get name () {
    webidl.brandCheck(this, FileLike)

    return this[kState].name
  }

  get lastModified () {
    webidl.brandCheck(this, FileLike)

    return this[kState].lastModified
  }

  get [Symbol.toStringTag] () {
    return 'File'
  }
}

Object.defineProperties(File.prototype, {
  [Symbol.toStringTag]: {
    value: 'File',
    configurable: true
  },
  name: kEnumerableProperty,
  lastModified: kEnumerableProperty
})

webidl.converters.Blob = webidl.interfaceConverter(Blob)

webidl.converters.BlobPart = function (V, opts) {
  if (webidl.util.Type(V) === 'Object') {
    if (isBlobLike(V)) {
      return webidl.converters.Blob(V, { strict: false })
    }

    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
      return webidl.converters.BufferSource(V, opts)
    }
  }

  return webidl.converters.USVString(V, opts)
}

webidl.converters['sequence<BlobPart>'] = webidl.sequenceConverter(
  webidl.converters.BlobPart
)

// https://www.w3.org/TR/FileAPI/#dfn-FilePropertyBag
webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
  {
    key: 'lastModified',
    converter: webidl.converters['long long'],
    get defaultValue () {
      return Date.now()
    }
  },
  {
    key: 'type',
    converter: webidl.converters.DOMString,
    defaultValue: ''
  },
  {
    key: 'endings',
    converter: (value) => {
      value = webidl.converters.DOMString(value)
      value = value.toLowerCase()

      if (value !== 'native') {
        value = 'transparent'
      }

      return value
    },
    defaultValue: 'transparent'
  }
])

/**
 * @see https://www.w3.org/TR/FileAPI/#process-blob-parts
 * @param {(NodeJS.TypedArray|Blob|string)[]} parts
 * @param {{ type: string, endings: string }} options
 */
function processBlobParts (parts, options) {
  // 1. Let bytes be an empty sequence of bytes.
  /** @type {NodeJS.TypedArray[]} */
  const bytes = []

  // 2. For each element in parts:
  for (const element of parts) {
    // 1. If element is a USVString, run the following substeps:
    if (typeof element === 'string') {
      // 1. Let s be element.
      let s = element

      // 2. If the endings member of options is "native", set s
      //    to the result of converting line endings to native
      //    of element.
      if (options.endings === 'native') {
        s = convertLineEndingsNative(s)
      }

      // 3. Append the result of UTF-8 encoding s to bytes.
      bytes.push(encoder.encode(s))
    } else if (ArrayBuffer.isView(element) || types.isArrayBuffer(element)) {
      // 2. If element is a BufferSource, get a copy of the
      //    bytes held by the buffer source, and append those
      //    bytes to bytes.
      if (element.buffer) {
        bytes.push(
          new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
        )
      } else { // ArrayBuffer
        bytes.push(new Uint8Array(element))
      }
    } else if (isBlobLike(element)) {
      // 3. If element is a Blob, append the bytes it represents
      //    to bytes.
      bytes.push(element)
    }
  }

  // 3. Return bytes.
  return bytes
}

/**
 * @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native
 * @param {string} s
 */
function convertLineEndingsNative (s) {
  // 1. Let native line ending be be the code point U+000A LF.
  let nativeLineEnding = '\n'

  // 2. If the underlying platform’s conventions are to
  //    represent newlines as a carriage return and line feed
  //    sequence, set native line ending to the code point
  //    U+000D CR followed by the code point U+000A LF.
  if (process.platform === 'win32') {
    nativeLineEnding = '\r\n'
  }

  return s.replace(/\r?\n/g, nativeLineEnding)
}

// If this function is moved to ./util.js, some tools (such as
// rollup) will warn about circular dependencies. See:
// https://github.com/nodejs/undici/issues/1629
function isFileLike (object) {
  return (
    (NativeFile && object instanceof NativeFile) ||
    object instanceof File || (
      object &&
      (typeof object.stream === 'function' ||
      typeof object.arrayBuffer === 'function') &&
      object[Symbol.toStringTag] === 'File'
    )
  )
}

module.exports = { File, FileLike, isFileLike }


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/formdata.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isBlobLike, iteratorMixin } = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/fetch/util.js")
const { kState } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/fetch/symbols.js")
const { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const { File: UndiciFile, FileLike, isFileLike } = __webpack_require__(/*! ./file */ "./node_modules/undici/lib/web/fetch/file.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { File: NativeFile } = __webpack_require__(/*! node:buffer */ "node:buffer")

/** @type {globalThis['File']} */
const File = NativeFile ?? UndiciFile

// https://xhr.spec.whatwg.org/#formdata
class FormData {
  constructor (form) {
    if (form !== undefined) {
      throw webidl.errors.conversionFailed({
        prefix: 'FormData constructor',
        argument: 'Argument 1',
        types: ['undefined']
      })
    }

    this[kState] = []
  }

  append (name, value, filename = undefined) {
    webidl.brandCheck(this, FormData)

    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.append' })

    if (arguments.length === 3 && !isBlobLike(value)) {
      throw new TypeError(
        "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
      )
    }

    // 1. Let value be value if given; otherwise blobValue.

    name = webidl.converters.USVString(name)
    value = isBlobLike(value)
      ? webidl.converters.Blob(value, { strict: false })
      : webidl.converters.USVString(value)
    filename = arguments.length === 3
      ? webidl.converters.USVString(filename)
      : undefined

    // 2. Let entry be the result of creating an entry with
    // name, value, and filename if given.
    const entry = makeEntry(name, value, filename)

    // 3. Append entry to this’s entry list.
    this[kState].push(entry)
  }

  delete (name) {
    webidl.brandCheck(this, FormData)

    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.delete' })

    name = webidl.converters.USVString(name)

    // The delete(name) method steps are to remove all entries whose name
    // is name from this’s entry list.
    this[kState] = this[kState].filter(entry => entry.name !== name)
  }

  get (name) {
    webidl.brandCheck(this, FormData)

    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.get' })

    name = webidl.converters.USVString(name)

    // 1. If there is no entry whose name is name in this’s entry list,
    // then return null.
    const idx = this[kState].findIndex((entry) => entry.name === name)
    if (idx === -1) {
      return null
    }

    // 2. Return the value of the first entry whose name is name from
    // this’s entry list.
    return this[kState][idx].value
  }

  getAll (name) {
    webidl.brandCheck(this, FormData)

    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.getAll' })

    name = webidl.converters.USVString(name)

    // 1. If there is no entry whose name is name in this’s entry list,
    // then return the empty list.
    // 2. Return the values of all entries whose name is name, in order,
    // from this’s entry list.
    return this[kState]
      .filter((entry) => entry.name === name)
      .map((entry) => entry.value)
  }

  has (name) {
    webidl.brandCheck(this, FormData)

    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.has' })

    name = webidl.converters.USVString(name)

    // The has(name) method steps are to return true if there is an entry
    // whose name is name in this’s entry list; otherwise false.
    return this[kState].findIndex((entry) => entry.name === name) !== -1
  }

  set (name, value, filename = undefined) {
    webidl.brandCheck(this, FormData)

    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.set' })

    if (arguments.length === 3 && !isBlobLike(value)) {
      throw new TypeError(
        "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
      )
    }

    // The set(name, value) and set(name, blobValue, filename) method steps
    // are:

    // 1. Let value be value if given; otherwise blobValue.

    name = webidl.converters.USVString(name)
    value = isBlobLike(value)
      ? webidl.converters.Blob(value, { strict: false })
      : webidl.converters.USVString(value)
    filename = arguments.length === 3
      ? webidl.converters.USVString(filename)
      : undefined

    // 2. Let entry be the result of creating an entry with name, value, and
    // filename if given.
    const entry = makeEntry(name, value, filename)

    // 3. If there are entries in this’s entry list whose name is name, then
    // replace the first such entry with entry and remove the others.
    const idx = this[kState].findIndex((entry) => entry.name === name)
    if (idx !== -1) {
      this[kState] = [
        ...this[kState].slice(0, idx),
        entry,
        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)
      ]
    } else {
      // 4. Otherwise, append entry to this’s entry list.
      this[kState].push(entry)
    }
  }
}

iteratorMixin('FormData', FormData, kState, 'name', 'value')

Object.defineProperties(FormData.prototype, {
  append: kEnumerableProperty,
  delete: kEnumerableProperty,
  get: kEnumerableProperty,
  getAll: kEnumerableProperty,
  has: kEnumerableProperty,
  set: kEnumerableProperty,
  [Symbol.toStringTag]: {
    value: 'FormData',
    configurable: true
  }
})

/**
 * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
 * @param {string} name
 * @param {string|Blob} value
 * @param {?string} filename
 * @returns
 */
function makeEntry (name, value, filename) {
  // 1. Set name to the result of converting name into a scalar value string.
  // Note: This operation was done by the webidl converter USVString.

  // 2. If value is a string, then set value to the result of converting
  //    value into a scalar value string.
  if (typeof value === 'string') {
    // Note: This operation was done by the webidl converter USVString.
  } else {
    // 3. Otherwise:

    // 1. If value is not a File object, then set value to a new File object,
    //    representing the same bytes, whose name attribute value is "blob"
    if (!isFileLike(value)) {
      value = value instanceof Blob
        ? new File([value], 'blob', { type: value.type })
        : new FileLike(value, 'blob', { type: value.type })
    }

    // 2. If filename is given, then set value to a new File object,
    //    representing the same bytes, whose name attribute is filename.
    if (filename !== undefined) {
      /** @type {FilePropertyBag} */
      const options = {
        type: value.type,
        lastModified: value.lastModified
      }

      value = (NativeFile && value instanceof NativeFile) || value instanceof UndiciFile
        ? new File([value], filename, options)
        : new FileLike(value, filename, options)
    }
  }

  // 4. Return an entry whose name is name and whose value is value.
  return { name, value }
}

module.exports = { FormData }


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/global.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/global.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


// In case of breaking changes, increase the version
// number to avoid conflicts.
const globalOrigin = Symbol.for('undici.globalOrigin.1')

function getGlobalOrigin () {
  return globalThis[globalOrigin]
}

function setGlobalOrigin (newOrigin) {
  if (newOrigin === undefined) {
    Object.defineProperty(globalThis, globalOrigin, {
      value: undefined,
      writable: true,
      enumerable: false,
      configurable: false
    })

    return
  }

  const parsedURL = new URL(newOrigin)

  if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {
    throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`)
  }

  Object.defineProperty(globalThis, globalOrigin, {
    value: parsedURL,
    writable: true,
    enumerable: false,
    configurable: false
  })
}

module.exports = {
  getGlobalOrigin,
  setGlobalOrigin
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/headers.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/headers.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// https://github.com/Ethan-Arrowood/undici-fetch



const { kHeadersList, kConstruct } = __webpack_require__(/*! ../../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const { kGuard } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/fetch/symbols.js")
const { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const {
  iteratorMixin,
  isValidHeaderName,
  isValidHeaderValue
} = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/fetch/util.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const assert = __webpack_require__(/*! node:assert */ "node:assert")

const kHeadersMap = Symbol('headers map')
const kHeadersSortedMap = Symbol('headers map sorted')

/**
 * @param {number} code
 */
function isHTTPWhiteSpaceCharCode (code) {
  return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020
}

/**
 * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
 * @param {string} potentialValue
 */
function headerValueNormalize (potentialValue) {
  //  To normalize a byte sequence potentialValue, remove
  //  any leading and trailing HTTP whitespace bytes from
  //  potentialValue.
  let i = 0; let j = potentialValue.length

  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j
  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i

  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)
}

function fill (headers, object) {
  // To fill a Headers object headers with a given object object, run these steps:

  // 1. If object is a sequence, then for each header in object:
  // Note: webidl conversion to array has already been done.
  if (Array.isArray(object)) {
    for (let i = 0; i < object.length; ++i) {
      const header = object[i]
      // 1. If header does not contain exactly two items, then throw a TypeError.
      if (header.length !== 2) {
        throw webidl.errors.exception({
          header: 'Headers constructor',
          message: `expected name/value pair to be length 2, found ${header.length}.`
        })
      }

      // 2. Append (header’s first item, header’s second item) to headers.
      appendHeader(headers, header[0], header[1])
    }
  } else if (typeof object === 'object' && object !== null) {
    // Note: null should throw

    // 2. Otherwise, object is a record, then for each key → value in object,
    //    append (key, value) to headers
    const keys = Object.keys(object)
    for (let i = 0; i < keys.length; ++i) {
      appendHeader(headers, keys[i], object[keys[i]])
    }
  } else {
    throw webidl.errors.conversionFailed({
      prefix: 'Headers constructor',
      argument: 'Argument 1',
      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']
    })
  }
}

/**
 * @see https://fetch.spec.whatwg.org/#concept-headers-append
 */
function appendHeader (headers, name, value) {
  // 1. Normalize value.
  value = headerValueNormalize(value)

  // 2. If name is not a header name or value is not a
  //    header value, then throw a TypeError.
  if (!isValidHeaderName(name)) {
    throw webidl.errors.invalidArgument({
      prefix: 'Headers.append',
      value: name,
      type: 'header name'
    })
  } else if (!isValidHeaderValue(value)) {
    throw webidl.errors.invalidArgument({
      prefix: 'Headers.append',
      value,
      type: 'header value'
    })
  }

  // 3. If headers’s guard is "immutable", then throw a TypeError.
  // 4. Otherwise, if headers’s guard is "request" and name is a
  //    forbidden header name, return.
  // Note: undici does not implement forbidden header names
  if (headers[kGuard] === 'immutable') {
    throw new TypeError('immutable')
  } else if (headers[kGuard] === 'request-no-cors') {
    // 5. Otherwise, if headers’s guard is "request-no-cors":
    // TODO
  }

  // 6. Otherwise, if headers’s guard is "response" and name is a
  //    forbidden response-header name, return.

  // 7. Append (name, value) to headers’s header list.
  return headers[kHeadersList].append(name, value, false)

  // 8. If headers’s guard is "request-no-cors", then remove
  //    privileged no-CORS request headers from headers
}

function compareHeaderName (a, b) {
  return a[0] < b[0] ? -1 : 1
}

class HeadersList {
  /** @type {[string, string][]|null} */
  cookies = null

  constructor (init) {
    if (init instanceof HeadersList) {
      this[kHeadersMap] = new Map(init[kHeadersMap])
      this[kHeadersSortedMap] = init[kHeadersSortedMap]
      this.cookies = init.cookies === null ? null : [...init.cookies]
    } else {
      this[kHeadersMap] = new Map(init)
      this[kHeadersSortedMap] = null
    }
  }

  /**
   * @see https://fetch.spec.whatwg.org/#header-list-contains
   * @param {string} name
   * @param {boolean} isLowerCase
   */
  contains (name, isLowerCase) {
    // A header list list contains a header name name if list
    // contains a header whose name is a byte-case-insensitive
    // match for name.

    return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase())
  }

  clear () {
    this[kHeadersMap].clear()
    this[kHeadersSortedMap] = null
    this.cookies = null
  }

  /**
   * @see https://fetch.spec.whatwg.org/#concept-header-list-append
   * @param {string} name
   * @param {string} value
   * @param {boolean} isLowerCase
   */
  append (name, value, isLowerCase) {
    this[kHeadersSortedMap] = null

    // 1. If list contains name, then set name to the first such
    //    header’s name.
    const lowercaseName = isLowerCase ? name : name.toLowerCase()
    const exists = this[kHeadersMap].get(lowercaseName)

    // 2. Append (name, value) to list.
    if (exists) {
      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '
      this[kHeadersMap].set(lowercaseName, {
        name: exists.name,
        value: `${exists.value}${delimiter}${value}`
      })
    } else {
      this[kHeadersMap].set(lowercaseName, { name, value })
    }

    if (lowercaseName === 'set-cookie') {
      (this.cookies ??= []).push(value)
    }
  }

  /**
   * @see https://fetch.spec.whatwg.org/#concept-header-list-set
   * @param {string} name
   * @param {string} value
   * @param {boolean} isLowerCase
   */
  set (name, value, isLowerCase) {
    this[kHeadersSortedMap] = null
    const lowercaseName = isLowerCase ? name : name.toLowerCase()

    if (lowercaseName === 'set-cookie') {
      this.cookies = [value]
    }

    // 1. If list contains name, then set the value of
    //    the first such header to value and remove the
    //    others.
    // 2. Otherwise, append header (name, value) to list.
    this[kHeadersMap].set(lowercaseName, { name, value })
  }

  /**
   * @see https://fetch.spec.whatwg.org/#concept-header-list-delete
   * @param {string} name
   * @param {boolean} isLowerCase
   */
  delete (name, isLowerCase) {
    this[kHeadersSortedMap] = null
    if (!isLowerCase) name = name.toLowerCase()

    if (name === 'set-cookie') {
      this.cookies = null
    }

    this[kHeadersMap].delete(name)
  }

  /**
   * @see https://fetch.spec.whatwg.org/#concept-header-list-get
   * @param {string} name
   * @param {boolean} isLowerCase
   * @returns {string | null}
   */
  get (name, isLowerCase) {
    // 1. If list does not contain name, then return null.
    // 2. Return the values of all headers in list whose name
    //    is a byte-case-insensitive match for name,
    //    separated from each other by 0x2C 0x20, in order.
    return this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())?.value ?? null
  }

  * [Symbol.iterator] () {
    // use the lowercased name
    for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
      yield [name, value]
    }
  }

  get entries () {
    const headers = {}

    if (this[kHeadersMap].size) {
      for (const { name, value } of this[kHeadersMap].values()) {
        headers[name] = value
      }
    }

    return headers
  }

  // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set
  toSortedArray () {
    const size = this[kHeadersMap].size
    const array = new Array(size)
    // In most cases, you will use the fast-path.
    // fast-path: Use binary insertion sort for small arrays.
    if (size <= 32) {
      if (size === 0) {
        // If empty, it is an empty array. To avoid the first index assignment.
        return array
      }
      // Improve performance by unrolling loop and avoiding double-loop.
      // Double-loop-less version of the binary insertion sort.
      const iterator = this[kHeadersMap][Symbol.iterator]()
      const firstValue = iterator.next().value
      // set [name, value] to first index.
      array[0] = [firstValue[0], firstValue[1].value]
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      // 3.2.2. Assert: value is non-null.
      assert(firstValue[1].value !== null)
      for (
        let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value;
        i < size;
        ++i
      ) {
        // get next value
        value = iterator.next().value
        // set [name, value] to current index.
        x = array[i] = [value[0], value[1].value]
        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
        // 3.2.2. Assert: value is non-null.
        assert(x[1] !== null)
        left = 0
        right = i
        // binary search
        while (left < right) {
          // middle index
          pivot = left + ((right - left) >> 1)
          // compare header name
          if (array[pivot][0] <= x[0]) {
            left = pivot + 1
          } else {
            right = pivot
          }
        }
        if (i !== pivot) {
          j = i
          while (j > left) {
            array[j] = array[--j]
          }
          array[left] = x
        }
      }
      /* c8 ignore next 4 */
      if (!iterator.next().done) {
        // This is for debugging and will never be called.
        throw new TypeError('Unreachable')
      }
      return array
    } else {
      // This case would be a rare occurrence.
      // slow-path: fallback
      let i = 0
      for (const { 0: name, 1: { value } } of this[kHeadersMap]) {
        array[i++] = [name, value]
        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
        // 3.2.2. Assert: value is non-null.
        assert(value !== null)
      }
      return array.sort(compareHeaderName)
    }
  }
}

// https://fetch.spec.whatwg.org/#headers-class
class Headers {
  constructor (init = undefined) {
    if (init === kConstruct) {
      return
    }
    this[kHeadersList] = new HeadersList()

    // The new Headers(init) constructor steps are:

    // 1. Set this’s guard to "none".
    this[kGuard] = 'none'

    // 2. If init is given, then fill this with init.
    if (init !== undefined) {
      init = webidl.converters.HeadersInit(init)
      fill(this, init)
    }
  }

  // https://fetch.spec.whatwg.org/#dom-headers-append
  append (name, value) {
    webidl.brandCheck(this, Headers)

    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.append' })

    name = webidl.converters.ByteString(name)
    value = webidl.converters.ByteString(value)

    return appendHeader(this, name, value)
  }

  // https://fetch.spec.whatwg.org/#dom-headers-delete
  delete (name) {
    webidl.brandCheck(this, Headers)

    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.delete' })

    name = webidl.converters.ByteString(name)

    // 1. If name is not a header name, then throw a TypeError.
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: 'Headers.delete',
        value: name,
        type: 'header name'
      })
    }

    // 2. If this’s guard is "immutable", then throw a TypeError.
    // 3. Otherwise, if this’s guard is "request" and name is a
    //    forbidden header name, return.
    // 4. Otherwise, if this’s guard is "request-no-cors", name
    //    is not a no-CORS-safelisted request-header name, and
    //    name is not a privileged no-CORS request-header name,
    //    return.
    // 5. Otherwise, if this’s guard is "response" and name is
    //    a forbidden response-header name, return.
    // Note: undici does not implement forbidden header names
    if (this[kGuard] === 'immutable') {
      throw new TypeError('immutable')
    } else if (this[kGuard] === 'request-no-cors') {
      // TODO
    }

    // 6. If this’s header list does not contain name, then
    //    return.
    if (!this[kHeadersList].contains(name, false)) {
      return
    }

    // 7. Delete name from this’s header list.
    // 8. If this’s guard is "request-no-cors", then remove
    //    privileged no-CORS request headers from this.
    this[kHeadersList].delete(name, false)
  }

  // https://fetch.spec.whatwg.org/#dom-headers-get
  get (name) {
    webidl.brandCheck(this, Headers)

    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.get' })

    name = webidl.converters.ByteString(name)

    // 1. If name is not a header name, then throw a TypeError.
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: 'Headers.get',
        value: name,
        type: 'header name'
      })
    }

    // 2. Return the result of getting name from this’s header
    //    list.
    return this[kHeadersList].get(name, false)
  }

  // https://fetch.spec.whatwg.org/#dom-headers-has
  has (name) {
    webidl.brandCheck(this, Headers)

    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.has' })

    name = webidl.converters.ByteString(name)

    // 1. If name is not a header name, then throw a TypeError.
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: 'Headers.has',
        value: name,
        type: 'header name'
      })
    }

    // 2. Return true if this’s header list contains name;
    //    otherwise false.
    return this[kHeadersList].contains(name, false)
  }

  // https://fetch.spec.whatwg.org/#dom-headers-set
  set (name, value) {
    webidl.brandCheck(this, Headers)

    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.set' })

    name = webidl.converters.ByteString(name)
    value = webidl.converters.ByteString(value)

    // 1. Normalize value.
    value = headerValueNormalize(value)

    // 2. If name is not a header name or value is not a
    //    header value, then throw a TypeError.
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: 'Headers.set',
        value: name,
        type: 'header name'
      })
    } else if (!isValidHeaderValue(value)) {
      throw webidl.errors.invalidArgument({
        prefix: 'Headers.set',
        value,
        type: 'header value'
      })
    }

    // 3. If this’s guard is "immutable", then throw a TypeError.
    // 4. Otherwise, if this’s guard is "request" and name is a
    //    forbidden header name, return.
    // 5. Otherwise, if this’s guard is "request-no-cors" and
    //    name/value is not a no-CORS-safelisted request-header,
    //    return.
    // 6. Otherwise, if this’s guard is "response" and name is a
    //    forbidden response-header name, return.
    // Note: undici does not implement forbidden header names
    if (this[kGuard] === 'immutable') {
      throw new TypeError('immutable')
    } else if (this[kGuard] === 'request-no-cors') {
      // TODO
    }

    // 7. Set (name, value) in this’s header list.
    // 8. If this’s guard is "request-no-cors", then remove
    //    privileged no-CORS request headers from this
    this[kHeadersList].set(name, value, false)
  }

  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
  getSetCookie () {
    webidl.brandCheck(this, Headers)

    // 1. If this’s header list does not contain `Set-Cookie`, then return « ».
    // 2. Return the values of all headers in this’s header list whose name is
    //    a byte-case-insensitive match for `Set-Cookie`, in order.

    const list = this[kHeadersList].cookies

    if (list) {
      return [...list]
    }

    return []
  }

  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
  get [kHeadersSortedMap] () {
    if (this[kHeadersList][kHeadersSortedMap]) {
      return this[kHeadersList][kHeadersSortedMap]
    }

    // 1. Let headers be an empty list of headers with the key being the name
    //    and value the value.
    const headers = []

    // 2. Let names be the result of convert header names to a sorted-lowercase
    //    set with all the names of the headers in list.
    const names = this[kHeadersList].toSortedArray()

    const cookies = this[kHeadersList].cookies

    // fast-path
    if (cookies === null || cookies.length === 1) {
      // Note: The non-null assertion of value has already been done by `HeadersList#toSortedArray`
      return (this[kHeadersList][kHeadersSortedMap] = names)
    }

    // 3. For each name of names:
    for (let i = 0; i < names.length; ++i) {
      const { 0: name, 1: value } = names[i]
      // 1. If name is `set-cookie`, then:
      if (name === 'set-cookie') {
        // 1. Let values be a list of all values of headers in list whose name
        //    is a byte-case-insensitive match for name, in order.

        // 2. For each value of values:
        // 1. Append (name, value) to headers.
        for (let j = 0; j < cookies.length; ++j) {
          headers.push([name, cookies[j]])
        }
      } else {
        // 2. Otherwise:

        // 1. Let value be the result of getting name from list.

        // 2. Assert: value is non-null.
        // Note: This operation was done by `HeadersList#toSortedArray`.

        // 3. Append (name, value) to headers.
        headers.push([name, value])
      }
    }

    // 4. Return headers.
    return (this[kHeadersList][kHeadersSortedMap] = headers)
  }

  [Symbol.for('nodejs.util.inspect.custom')] () {
    webidl.brandCheck(this, Headers)

    return this[kHeadersList]
  }
}

iteratorMixin('Headers', Headers, kHeadersSortedMap, 0, 1)

Object.defineProperties(Headers.prototype, {
  append: kEnumerableProperty,
  delete: kEnumerableProperty,
  get: kEnumerableProperty,
  has: kEnumerableProperty,
  set: kEnumerableProperty,
  getSetCookie: kEnumerableProperty,
  [Symbol.toStringTag]: {
    value: 'Headers',
    configurable: true
  }
})

webidl.converters.HeadersInit = function (V) {
  if (webidl.util.Type(V) === 'Object') {
    const iterator = Reflect.get(V, Symbol.iterator)

    if (typeof iterator === 'function') {
      return webidl.converters['sequence<sequence<ByteString>>'](V, iterator.bind(V))
    }

    return webidl.converters['record<ByteString, ByteString>'](V)
  }

  throw webidl.errors.conversionFailed({
    prefix: 'Headers constructor',
    argument: 'Argument 1',
    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']
  })
}

module.exports = {
  fill,
  // for test.
  compareHeaderName,
  Headers,
  HeadersList
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/index.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// https://github.com/Ethan-Arrowood/undici-fetch



const {
  makeNetworkError,
  makeAppropriateNetworkError,
  filterResponse,
  makeResponse,
  fromInnerResponse
} = __webpack_require__(/*! ./response */ "./node_modules/undici/lib/web/fetch/response.js")
const { HeadersList } = __webpack_require__(/*! ./headers */ "./node_modules/undici/lib/web/fetch/headers.js")
const { Request, cloneRequest } = __webpack_require__(/*! ./request */ "./node_modules/undici/lib/web/fetch/request.js")
const zlib = __webpack_require__(/*! node:zlib */ "node:zlib")
const {
  bytesMatch,
  makePolicyContainer,
  clonePolicyContainer,
  requestBadPort,
  TAOCheck,
  appendRequestOriginHeader,
  responseLocationURL,
  requestCurrentURL,
  setRequestReferrerPolicyOnRedirect,
  tryUpgradeRequestToAPotentiallyTrustworthyURL,
  createOpaqueTimingInfo,
  appendFetchMetadata,
  corsCheck,
  crossOriginResourcePolicyCheck,
  determineRequestsReferrer,
  coarsenedSharedCurrentTime,
  createDeferredPromise,
  isBlobLike,
  sameOrigin,
  isCancelled,
  isAborted,
  isErrorLike,
  fullyReadBody,
  readableStreamClose,
  isomorphicEncode,
  urlIsLocal,
  urlIsHttpHttpsScheme,
  urlHasHttpsScheme,
  clampAndCoarsenConnectionTimingInfo,
  simpleRangeHeaderValue,
  buildContentRange,
  createInflate,
  extractMimeType
} = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/fetch/util.js")
const { kState, kDispatcher } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/fetch/symbols.js")
const assert = __webpack_require__(/*! node:assert */ "node:assert")
const { safelyExtractBody, extractBody } = __webpack_require__(/*! ./body */ "./node_modules/undici/lib/web/fetch/body.js")
const {
  redirectStatusSet,
  nullBodyStatus,
  safeMethodsSet,
  requestBodyHeader,
  subresourceSet
} = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/web/fetch/constants.js")
const EE = __webpack_require__(/*! node:events */ "node:events")
const { Readable, pipeline } = __webpack_require__(/*! node:stream */ "node:stream")
const { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor, bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = __webpack_require__(/*! ./data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")
const { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ "./node_modules/undici/lib/global.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { STATUS_CODES } = __webpack_require__(/*! node:http */ "node:http")
const GET_OR_HEAD = ['GET', 'HEAD']

const defaultUserAgent = typeof __UNDICI_IS_NODE__ !== 'undefined' || typeof esbuildDetection !== 'undefined'
  ? 'node'
  : 'undici'

/** @type {import('buffer').resolveObjectURL} */
let resolveObjectURL

class Fetch extends EE {
  constructor (dispatcher) {
    super()

    this.dispatcher = dispatcher
    this.connection = null
    this.dump = false
    this.state = 'ongoing'
  }

  terminate (reason) {
    if (this.state !== 'ongoing') {
      return
    }

    this.state = 'terminated'
    this.connection?.destroy(reason)
    this.emit('terminated', reason)
  }

  // https://fetch.spec.whatwg.org/#fetch-controller-abort
  abort (error) {
    if (this.state !== 'ongoing') {
      return
    }

    // 1. Set controller’s state to "aborted".
    this.state = 'aborted'

    // 2. Let fallbackError be an "AbortError" DOMException.
    // 3. Set error to fallbackError if it is not given.
    if (!error) {
      error = new DOMException('The operation was aborted.', 'AbortError')
    }

    // 4. Let serializedError be StructuredSerialize(error).
    //    If that threw an exception, catch it, and let
    //    serializedError be StructuredSerialize(fallbackError).

    // 5. Set controller’s serialized abort reason to serializedError.
    this.serializedAbortReason = error

    this.connection?.destroy(error)
    this.emit('terminated', error)
  }
}

// https://fetch.spec.whatwg.org/#fetch-method
function fetch (input, init = undefined) {
  webidl.argumentLengthCheck(arguments, 1, { header: 'globalThis.fetch' })

  // 1. Let p be a new promise.
  const p = createDeferredPromise()

  // 2. Let requestObject be the result of invoking the initial value of
  // Request as constructor with input and init as arguments. If this throws
  // an exception, reject p with it and return p.
  let requestObject

  try {
    requestObject = new Request(input, init)
  } catch (e) {
    p.reject(e)
    return p.promise
  }

  // 3. Let request be requestObject’s request.
  const request = requestObject[kState]

  // 4. If requestObject’s signal’s aborted flag is set, then:
  if (requestObject.signal.aborted) {
    // 1. Abort the fetch() call with p, request, null, and
    //    requestObject’s signal’s abort reason.
    abortFetch(p, request, null, requestObject.signal.reason)

    // 2. Return p.
    return p.promise
  }

  // 5. Let globalObject be request’s client’s global object.
  const globalObject = request.client.globalObject

  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set
  // request’s service-workers mode to "none".
  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {
    request.serviceWorkers = 'none'
  }

  // 7. Let responseObject be null.
  let responseObject = null

  // 8. Let relevantRealm be this’s relevant Realm.
  const relevantRealm = null

  // 9. Let locallyAborted be false.
  let locallyAborted = false

  // 10. Let controller be null.
  let controller = null

  // 11. Add the following abort steps to requestObject’s signal:
  addAbortListener(
    requestObject.signal,
    () => {
      // 1. Set locallyAborted to true.
      locallyAborted = true

      // 2. Assert: controller is non-null.
      assert(controller != null)

      // 3. Abort controller with requestObject’s signal’s abort reason.
      controller.abort(requestObject.signal.reason)

      // 4. Abort the fetch() call with p, request, responseObject,
      //    and requestObject’s signal’s abort reason.
      abortFetch(p, request, responseObject, requestObject.signal.reason)
    }
  )

  // 12. Let handleFetchDone given response response be to finalize and
  // report timing with response, globalObject, and "fetch".
  const handleFetchDone = (response) =>
    finalizeAndReportTiming(response, 'fetch')

  // 13. Set controller to the result of calling fetch given request,
  // with processResponseEndOfBody set to handleFetchDone, and processResponse
  // given response being these substeps:

  const processResponse = (response) => {
    // 1. If locallyAborted is true, terminate these substeps.
    if (locallyAborted) {
      return
    }

    // 2. If response’s aborted flag is set, then:
    if (response.aborted) {
      // 1. Let deserializedError be the result of deserialize a serialized
      //    abort reason given controller’s serialized abort reason and
      //    relevantRealm.

      // 2. Abort the fetch() call with p, request, responseObject, and
      //    deserializedError.

      abortFetch(p, request, responseObject, controller.serializedAbortReason)
      return
    }

    // 3. If response is a network error, then reject p with a TypeError
    // and terminate these substeps.
    if (response.type === 'error') {
      p.reject(new TypeError('fetch failed', { cause: response.error }))
      return
    }

    // 4. Set responseObject to the result of creating a Response object,
    // given response, "immutable", and relevantRealm.
    responseObject = fromInnerResponse(response, 'immutable', relevantRealm)

    // 5. Resolve p with responseObject.
    p.resolve(responseObject)
  }

  controller = fetching({
    request,
    processResponseEndOfBody: handleFetchDone,
    processResponse,
    dispatcher: requestObject[kDispatcher] // undici
  })

  // 14. Return p.
  return p.promise
}

// https://fetch.spec.whatwg.org/#finalize-and-report-timing
function finalizeAndReportTiming (response, initiatorType = 'other') {
  // 1. If response is an aborted network error, then return.
  if (response.type === 'error' && response.aborted) {
    return
  }

  // 2. If response’s URL list is null or empty, then return.
  if (!response.urlList?.length) {
    return
  }

  // 3. Let originalURL be response’s URL list[0].
  const originalURL = response.urlList[0]

  // 4. Let timingInfo be response’s timing info.
  let timingInfo = response.timingInfo

  // 5. Let cacheState be response’s cache state.
  let cacheState = response.cacheState

  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.
  if (!urlIsHttpHttpsScheme(originalURL)) {
    return
  }

  // 7. If timingInfo is null, then return.
  if (timingInfo === null) {
    return
  }

  // 8. If response’s timing allow passed flag is not set, then:
  if (!response.timingAllowPassed) {
    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.
    timingInfo = createOpaqueTimingInfo({
      startTime: timingInfo.startTime
    })

    //  2. Set cacheState to the empty string.
    cacheState = ''
  }

  // 9. Set timingInfo’s end time to the coarsened shared current time
  // given global’s relevant settings object’s cross-origin isolated
  // capability.
  // TODO: given global’s relevant settings object’s cross-origin isolated
  // capability?
  timingInfo.endTime = coarsenedSharedCurrentTime()

  // 10. Set response’s timing info to timingInfo.
  response.timingInfo = timingInfo

  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,
  // global, and cacheState.
  markResourceTiming(
    timingInfo,
    originalURL.href,
    initiatorType,
    globalThis,
    cacheState
  )
}

// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing
const markResourceTiming = (nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 2))
  ? performance.markResourceTiming
  : () => {}

// https://fetch.spec.whatwg.org/#abort-fetch
function abortFetch (p, request, responseObject, error) {
  // 1. Reject promise with error.
  p.reject(error)

  // 2. If request’s body is not null and is readable, then cancel request’s
  // body with error.
  if (request.body != null && isReadable(request.body?.stream)) {
    request.body.stream.cancel(error).catch((err) => {
      if (err.code === 'ERR_INVALID_STATE') {
        // Node bug?
        return
      }
      throw err
    })
  }

  // 3. If responseObject is null, then return.
  if (responseObject == null) {
    return
  }

  // 4. Let response be responseObject’s response.
  const response = responseObject[kState]

  // 5. If response’s body is not null and is readable, then error response’s
  // body with error.
  if (response.body != null && isReadable(response.body?.stream)) {
    response.body.stream.cancel(error).catch((err) => {
      if (err.code === 'ERR_INVALID_STATE') {
        // Node bug?
        return
      }
      throw err
    })
  }
}

// https://fetch.spec.whatwg.org/#fetching
function fetching ({
  request,
  processRequestBodyChunkLength,
  processRequestEndOfBody,
  processResponse,
  processResponseEndOfBody,
  processResponseConsumeBody,
  useParallelQueue = false,
  dispatcher = getGlobalDispatcher() // undici
}) {
  // Ensure that the dispatcher is set accordingly
  assert(dispatcher)

  // 1. Let taskDestination be null.
  let taskDestination = null

  // 2. Let crossOriginIsolatedCapability be false.
  let crossOriginIsolatedCapability = false

  // 3. If request’s client is non-null, then:
  if (request.client != null) {
    // 1. Set taskDestination to request’s client’s global object.
    taskDestination = request.client.globalObject

    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin
    // isolated capability.
    crossOriginIsolatedCapability =
      request.client.crossOriginIsolatedCapability
  }

  // 4. If useParallelQueue is true, then set taskDestination to the result of
  // starting a new parallel queue.
  // TODO

  // 5. Let timingInfo be a new fetch timing info whose start time and
  // post-redirect start time are the coarsened shared current time given
  // crossOriginIsolatedCapability.
  const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)
  const timingInfo = createOpaqueTimingInfo({
    startTime: currentTime
  })

  // 6. Let fetchParams be a new fetch params whose
  // request is request,
  // timing info is timingInfo,
  // process request body chunk length is processRequestBodyChunkLength,
  // process request end-of-body is processRequestEndOfBody,
  // process response is processResponse,
  // process response consume body is processResponseConsumeBody,
  // process response end-of-body is processResponseEndOfBody,
  // task destination is taskDestination,
  // and cross-origin isolated capability is crossOriginIsolatedCapability.
  const fetchParams = {
    controller: new Fetch(dispatcher),
    request,
    timingInfo,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseConsumeBody,
    processResponseEndOfBody,
    taskDestination,
    crossOriginIsolatedCapability
  }

  // 7. If request’s body is a byte sequence, then set request’s body to
  //    request’s body as a body.
  // NOTE: Since fetching is only called from fetch, body should already be
  // extracted.
  assert(!request.body || request.body.stream)

  // 8. If request’s window is "client", then set request’s window to request’s
  // client, if request’s client’s global object is a Window object; otherwise
  // "no-window".
  if (request.window === 'client') {
    // TODO: What if request.client is null?
    request.window =
      request.client?.globalObject?.constructor?.name === 'Window'
        ? request.client
        : 'no-window'
  }

  // 9. If request’s origin is "client", then set request’s origin to request’s
  // client’s origin.
  if (request.origin === 'client') {
    // TODO: What if request.client is null?
    request.origin = request.client?.origin
  }

  // 10. If all of the following conditions are true:
  // TODO

  // 11. If request’s policy container is "client", then:
  if (request.policyContainer === 'client') {
    // 1. If request’s client is non-null, then set request’s policy
    // container to a clone of request’s client’s policy container. [HTML]
    if (request.client != null) {
      request.policyContainer = clonePolicyContainer(
        request.client.policyContainer
      )
    } else {
      // 2. Otherwise, set request’s policy container to a new policy
      // container.
      request.policyContainer = makePolicyContainer()
    }
  }

  // 12. If request’s header list does not contain `Accept`, then:
  if (!request.headersList.contains('accept', true)) {
    // 1. Let value be `*/*`.
    const value = '*/*'

    // 2. A user agent should set value to the first matching statement, if
    // any, switching on request’s destination:
    // "document"
    // "frame"
    // "iframe"
    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`
    // "image"
    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`
    // "style"
    // `text/css,*/*;q=0.1`
    // TODO

    // 3. Append `Accept`/value to request’s header list.
    request.headersList.append('accept', value, true)
  }

  // 13. If request’s header list does not contain `Accept-Language`, then
  // user agents should append `Accept-Language`/an appropriate value to
  // request’s header list.
  if (!request.headersList.contains('accept-language', true)) {
    request.headersList.append('accept-language', '*', true)
  }

  // 14. If request’s priority is null, then use request’s initiator and
  // destination appropriately in setting request’s priority to a
  // user-agent-defined object.
  if (request.priority === null) {
    // TODO
  }

  // 15. If request is a subresource request, then:
  if (subresourceSet.has(request.destination)) {
    // TODO
  }

  // 16. Run main fetch given fetchParams.
  mainFetch(fetchParams)
    .catch(err => {
      fetchParams.controller.terminate(err)
    })

  // 17. Return fetchParam's controller
  return fetchParams.controller
}

// https://fetch.spec.whatwg.org/#concept-main-fetch
async function mainFetch (fetchParams, recursive = false) {
  // 1. Let request be fetchParams’s request.
  const request = fetchParams.request

  // 2. Let response be null.
  let response = null

  // 3. If request’s local-URLs-only flag is set and request’s current URL is
  // not local, then set response to a network error.
  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
    response = makeNetworkError('local URLs only')
  }

  // 4. Run report Content Security Policy violations for request.
  // TODO

  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.
  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)

  // 6. If should request be blocked due to a bad port, should fetching request
  // be blocked as mixed content, or should request be blocked by Content
  // Security Policy returns blocked, then set response to a network error.
  if (requestBadPort(request) === 'blocked') {
    response = makeNetworkError('bad port')
  }
  // TODO: should fetching request be blocked as mixed content?
  // TODO: should request be blocked by Content Security Policy?

  // 7. If request’s referrer policy is the empty string, then set request’s
  // referrer policy to request’s policy container’s referrer policy.
  if (request.referrerPolicy === '') {
    request.referrerPolicy = request.policyContainer.referrerPolicy
  }

  // 8. If request’s referrer is not "no-referrer", then set request’s
  // referrer to the result of invoking determine request’s referrer.
  if (request.referrer !== 'no-referrer') {
    request.referrer = determineRequestsReferrer(request)
  }

  // 9. Set request’s current URL’s scheme to "https" if all of the following
  // conditions are true:
  // - request’s current URL’s scheme is "http"
  // - request’s current URL’s host is a domain
  // - Matching request’s current URL’s host per Known HSTS Host Domain Name
  //   Matching results in either a superdomain match with an asserted
  //   includeSubDomains directive or a congruent match (with or without an
  //   asserted includeSubDomains directive). [HSTS]
  // TODO

  // 10. If recursive is false, then run the remaining steps in parallel.
  // TODO

  // 11. If response is null, then set response to the result of running
  // the steps corresponding to the first matching statement:
  if (response === null) {
    response = await (async () => {
      const currentURL = requestCurrentURL(request)

      if (
        // - request’s current URL’s origin is same origin with request’s origin,
        //   and request’s response tainting is "basic"
        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||
        // request’s current URL’s scheme is "data"
        (currentURL.protocol === 'data:') ||
        // - request’s mode is "navigate" or "websocket"
        (request.mode === 'navigate' || request.mode === 'websocket')
      ) {
        // 1. Set request’s response tainting to "basic".
        request.responseTainting = 'basic'

        // 2. Return the result of running scheme fetch given fetchParams.
        return await schemeFetch(fetchParams)
      }

      // request’s mode is "same-origin"
      if (request.mode === 'same-origin') {
        // 1. Return a network error.
        return makeNetworkError('request mode cannot be "same-origin"')
      }

      // request’s mode is "no-cors"
      if (request.mode === 'no-cors') {
        // 1. If request’s redirect mode is not "follow", then return a network
        // error.
        if (request.redirect !== 'follow') {
          return makeNetworkError(
            'redirect mode cannot be "follow" for "no-cors" request'
          )
        }

        // 2. Set request’s response tainting to "opaque".
        request.responseTainting = 'opaque'

        // 3. Return the result of running scheme fetch given fetchParams.
        return await schemeFetch(fetchParams)
      }

      // request’s current URL’s scheme is not an HTTP(S) scheme
      if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
        // Return a network error.
        return makeNetworkError('URL scheme must be a HTTP(S) scheme')
      }

      // - request’s use-CORS-preflight flag is set
      // - request’s unsafe-request flag is set and either request’s method is
      //   not a CORS-safelisted method or CORS-unsafe request-header names with
      //   request’s header list is not empty
      //    1. Set request’s response tainting to "cors".
      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch
      //    given fetchParams and true.
      //    3. If corsWithPreflightResponse is a network error, then clear cache
      //    entries using request.
      //    4. Return corsWithPreflightResponse.
      // TODO

      // Otherwise
      //    1. Set request’s response tainting to "cors".
      request.responseTainting = 'cors'

      //    2. Return the result of running HTTP fetch given fetchParams.
      return await httpFetch(fetchParams)
    })()
  }

  // 12. If recursive is true, then return response.
  if (recursive) {
    return response
  }

  // 13. If response is not a network error and response is not a filtered
  // response, then:
  if (response.status !== 0 && !response.internalResponse) {
    // If request’s response tainting is "cors", then:
    if (request.responseTainting === 'cors') {
      // 1. Let headerNames be the result of extracting header list values
      // given `Access-Control-Expose-Headers` and response’s header list.
      // TODO
      // 2. If request’s credentials mode is not "include" and headerNames
      // contains `*`, then set response’s CORS-exposed header-name list to
      // all unique header names in response’s header list.
      // TODO
      // 3. Otherwise, if headerNames is not null or failure, then set
      // response’s CORS-exposed header-name list to headerNames.
      // TODO
    }

    // Set response to the following filtered response with response as its
    // internal response, depending on request’s response tainting:
    if (request.responseTainting === 'basic') {
      response = filterResponse(response, 'basic')
    } else if (request.responseTainting === 'cors') {
      response = filterResponse(response, 'cors')
    } else if (request.responseTainting === 'opaque') {
      response = filterResponse(response, 'opaque')
    } else {
      assert(false)
    }
  }

  // 14. Let internalResponse be response, if response is a network error,
  // and response’s internal response otherwise.
  let internalResponse =
    response.status === 0 ? response : response.internalResponse

  // 15. If internalResponse’s URL list is empty, then set it to a clone of
  // request’s URL list.
  if (internalResponse.urlList.length === 0) {
    internalResponse.urlList.push(...request.urlList)
  }

  // 16. If request’s timing allow failed flag is unset, then set
  // internalResponse’s timing allow passed flag.
  if (!request.timingAllowFailed) {
    response.timingAllowPassed = true
  }

  // 17. If response is not a network error and any of the following returns
  // blocked
  // - should internalResponse to request be blocked as mixed content
  // - should internalResponse to request be blocked by Content Security Policy
  // - should internalResponse to request be blocked due to its MIME type
  // - should internalResponse to request be blocked due to nosniff
  // TODO

  // 18. If response’s type is "opaque", internalResponse’s status is 206,
  // internalResponse’s range-requested flag is set, and request’s header
  // list does not contain `Range`, then set response and internalResponse
  // to a network error.
  if (
    response.type === 'opaque' &&
    internalResponse.status === 206 &&
    internalResponse.rangeRequested &&
    !request.headers.contains('range', true)
  ) {
    response = internalResponse = makeNetworkError()
  }

  // 19. If response is not a network error and either request’s method is
  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,
  // set internalResponse’s body to null and disregard any enqueuing toward
  // it (if any).
  if (
    response.status !== 0 &&
    (request.method === 'HEAD' ||
      request.method === 'CONNECT' ||
      nullBodyStatus.includes(internalResponse.status))
  ) {
    internalResponse.body = null
    fetchParams.controller.dump = true
  }

  // 20. If request’s integrity metadata is not the empty string, then:
  if (request.integrity) {
    // 1. Let processBodyError be this step: run fetch finale given fetchParams
    // and a network error.
    const processBodyError = (reason) =>
      fetchFinale(fetchParams, makeNetworkError(reason))

    // 2. If request’s response tainting is "opaque", or response’s body is null,
    // then run processBodyError and abort these steps.
    if (request.responseTainting === 'opaque' || response.body == null) {
      processBodyError(response.error)
      return
    }

    // 3. Let processBody given bytes be these steps:
    const processBody = (bytes) => {
      // 1. If bytes do not match request’s integrity metadata,
      // then run processBodyError and abort these steps. [SRI]
      if (!bytesMatch(bytes, request.integrity)) {
        processBodyError('integrity mismatch')
        return
      }

      // 2. Set response’s body to bytes as a body.
      response.body = safelyExtractBody(bytes)[0]

      // 3. Run fetch finale given fetchParams and response.
      fetchFinale(fetchParams, response)
    }

    // 4. Fully read response’s body given processBody and processBodyError.
    await fullyReadBody(response.body, processBody, processBodyError)
  } else {
    // 21. Otherwise, run fetch finale given fetchParams and response.
    fetchFinale(fetchParams, response)
  }
}

// https://fetch.spec.whatwg.org/#concept-scheme-fetch
// given a fetch params fetchParams
function schemeFetch (fetchParams) {
  // Note: since the connection is destroyed on redirect, which sets fetchParams to a
  // cancelled state, we do not want this condition to trigger *unless* there have been
  // no redirects. See https://github.com/nodejs/undici/issues/1776
  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
    return Promise.resolve(makeAppropriateNetworkError(fetchParams))
  }

  // 2. Let request be fetchParams’s request.
  const { request } = fetchParams

  const { protocol: scheme } = requestCurrentURL(request)

  // 3. Switch on request’s current URL’s scheme and run the associated steps:
  switch (scheme) {
    case 'about:': {
      // If request’s current URL’s path is the string "blank", then return a new response
      // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,
      // and body is the empty byte sequence as a body.

      // Otherwise, return a network error.
      return Promise.resolve(makeNetworkError('about scheme is not supported'))
    }
    case 'blob:': {
      if (!resolveObjectURL) {
        resolveObjectURL = (__webpack_require__(/*! node:buffer */ "node:buffer").resolveObjectURL)
      }

      // 1. Let blobURLEntry be request’s current URL’s blob URL entry.
      const blobURLEntry = requestCurrentURL(request)

      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56
      // Buffer.resolveObjectURL does not ignore URL queries.
      if (blobURLEntry.search.length !== 0) {
        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))
      }

      const blob = resolveObjectURL(blobURLEntry.toString())

      // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s
      //    object is not a Blob object, then return a network error.
      if (request.method !== 'GET' || !isBlobLike(blob)) {
        return Promise.resolve(makeNetworkError('invalid method'))
      }

      // 3. Let blob be blobURLEntry’s object.
      // Note: done above

      // 4. Let response be a new response.
      const response = makeResponse()

      // 5. Let fullLength be blob’s size.
      const fullLength = blob.size

      // 6. Let serializedFullLength be fullLength, serialized and isomorphic encoded.
      const serializedFullLength = isomorphicEncode(`${fullLength}`)

      // 7. Let type be blob’s type.
      const type = blob.type

      // 8. If request’s header list does not contain `Range`:
      // 9. Otherwise:
      if (!request.headersList.contains('range', true)) {
        // 1. Let bodyWithType be the result of safely extracting blob.
        // Note: in the FileAPI a blob "object" is a Blob *or* a MediaSource.
        // In node, this can only ever be a Blob. Therefore we can safely
        // use extractBody directly.
        const bodyWithType = extractBody(blob)

        // 2. Set response’s status message to `OK`.
        response.statusText = 'OK'

        // 3. Set response’s body to bodyWithType’s body.
        response.body = bodyWithType[0]

        // 4. Set response’s header list to « (`Content-Length`, serializedFullLength), (`Content-Type`, type) ».
        response.headersList.set('content-length', serializedFullLength, true)
        response.headersList.set('content-type', type, true)
      } else {
        // 1. Set response’s range-requested flag.
        response.rangeRequested = true

        // 2. Let rangeHeader be the result of getting `Range` from request’s header list.
        const rangeHeader = request.headersList.get('range', true)

        // 3. Let rangeValue be the result of parsing a single range header value given rangeHeader and true.
        const rangeValue = simpleRangeHeaderValue(rangeHeader, true)

        // 4. If rangeValue is failure, then return a network error.
        if (rangeValue === 'failure') {
          return Promise.resolve(makeNetworkError('failed to fetch the data URL'))
        }

        // 5. Let (rangeStart, rangeEnd) be rangeValue.
        let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue

        // 6. If rangeStart is null:
        // 7. Otherwise:
        if (rangeStart === null) {
          // 1. Set rangeStart to fullLength − rangeEnd.
          rangeStart = fullLength - rangeEnd

          // 2. Set rangeEnd to rangeStart + rangeEnd − 1.
          rangeEnd = rangeStart + rangeEnd - 1
        } else {
          // 1. If rangeStart is greater than or equal to fullLength, then return a network error.
          if (rangeStart >= fullLength) {
            return Promise.resolve(makeNetworkError('Range start is greater than the blob\'s size.'))
          }

          // 2. If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set
          //    rangeEnd to fullLength − 1.
          if (rangeEnd === null || rangeEnd >= fullLength) {
            rangeEnd = fullLength - 1
          }
        }

        // 8. Let slicedBlob be the result of invoking slice blob given blob, rangeStart,
        //    rangeEnd + 1, and type.
        const slicedBlob = blob.slice(rangeStart, rangeEnd, type)

        // 9. Let slicedBodyWithType be the result of safely extracting slicedBlob.
        // Note: same reason as mentioned above as to why we use extractBody
        const slicedBodyWithType = extractBody(slicedBlob)

        // 10. Set response’s body to slicedBodyWithType’s body.
        response.body = slicedBodyWithType[0]

        // 11. Let serializedSlicedLength be slicedBlob’s size, serialized and isomorphic encoded.
        const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`)

        // 12. Let contentRange be the result of invoking build a content range given rangeStart,
        //     rangeEnd, and fullLength.
        const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength)

        // 13. Set response’s status to 206.
        response.status = 206

        // 14. Set response’s status message to `Partial Content`.
        response.statusText = 'Partial Content'

        // 15. Set response’s header list to « (`Content-Length`, serializedSlicedLength),
        //     (`Content-Type`, type), (`Content-Range`, contentRange) ».
        response.headersList.set('content-length', serializedSlicedLength, true)
        response.headersList.set('content-type', type, true)
        response.headersList.set('content-range', contentRange, true)
      }

      // 10. Return response.
      return Promise.resolve(response)
    }
    case 'data:': {
      // 1. Let dataURLStruct be the result of running the
      //    data: URL processor on request’s current URL.
      const currentURL = requestCurrentURL(request)
      const dataURLStruct = dataURLProcessor(currentURL)

      // 2. If dataURLStruct is failure, then return a
      //    network error.
      if (dataURLStruct === 'failure') {
        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))
      }

      // 3. Let mimeType be dataURLStruct’s MIME type, serialized.
      const mimeType = serializeAMimeType(dataURLStruct.mimeType)

      // 4. Return a response whose status message is `OK`,
      //    header list is « (`Content-Type`, mimeType) »,
      //    and body is dataURLStruct’s body as a body.
      return Promise.resolve(makeResponse({
        statusText: 'OK',
        headersList: [
          ['content-type', { name: 'Content-Type', value: mimeType }]
        ],
        body: safelyExtractBody(dataURLStruct.body)[0]
      }))
    }
    case 'file:': {
      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.
      // When in doubt, return a network error.
      return Promise.resolve(makeNetworkError('not implemented... yet...'))
    }
    case 'http:':
    case 'https:': {
      // Return the result of running HTTP fetch given fetchParams.

      return httpFetch(fetchParams)
        .catch((err) => makeNetworkError(err))
    }
    default: {
      return Promise.resolve(makeNetworkError('unknown scheme'))
    }
  }
}

// https://fetch.spec.whatwg.org/#finalize-response
function finalizeResponse (fetchParams, response) {
  // 1. Set fetchParams’s request’s done flag.
  fetchParams.request.done = true

  // 2, If fetchParams’s process response done is not null, then queue a fetch
  // task to run fetchParams’s process response done given response, with
  // fetchParams’s task destination.
  if (fetchParams.processResponseDone != null) {
    queueMicrotask(() => fetchParams.processResponseDone(response))
  }
}

// https://fetch.spec.whatwg.org/#fetch-finale
function fetchFinale (fetchParams, response) {
  // 1. Let timingInfo be fetchParams’s timing info.
  let timingInfo = fetchParams.timingInfo

  // 2. If response is not a network error and fetchParams’s request’s client is a secure context,
  //    then set timingInfo’s server-timing headers to the result of getting, decoding, and splitting
  //    `Server-Timing` from response’s internal response’s header list.
  // TODO

  // 3. Let processResponseEndOfBody be the following steps:
  const processResponseEndOfBody = () => {
    // 1. Let unsafeEndTime be the unsafe shared current time.
    const unsafeEndTime = Date.now() // ?

    // 2. If fetchParams’s request’s destination is "document", then set fetchParams’s controller’s
    //    full timing info to fetchParams’s timing info.
    if (fetchParams.request.destination === 'document') {
      fetchParams.controller.fullTimingInfo = timingInfo
    }

    // 3. Set fetchParams’s controller’s report timing steps to the following steps given a global object global:
    fetchParams.controller.reportTimingSteps = () => {
      // 1. If fetchParams’s request’s URL’s scheme is not an HTTP(S) scheme, then return.
      if (fetchParams.request.url.protocol !== 'https:') {
        return
      }

      // 2. Set timingInfo’s end time to the relative high resolution time given unsafeEndTime and global.
      timingInfo.endTime = unsafeEndTime

      // 3. Let cacheState be response’s cache state.
      let cacheState = response.cacheState

      // 4. Let bodyInfo be response’s body info.
      const bodyInfo = response.bodyInfo

      // 5. If response’s timing allow passed flag is not set, then set timingInfo to the result of creating an
      //    opaque timing info for timingInfo and set cacheState to the empty string.
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo(timingInfo)

        cacheState = ''
      }

      // 6. Let responseStatus be 0.
      let responseStatus = 0

      // 7. If fetchParams’s request’s mode is not "navigate" or response’s has-cross-origin-redirects is false:
      if (fetchParams.request.mode !== 'navigator' || !response.hasCrossOriginRedirects) {
        // 1. Set responseStatus to response’s status.
        responseStatus = response.status

        // 2. Let mimeType be the result of extracting a MIME type from response’s header list.
        const mimeType = extractMimeType(response.headersList)

        // 3. If mimeType is not failure, then set bodyInfo’s content type to the result of minimizing a supported MIME type given mimeType.
        if (mimeType !== 'failure') {
          bodyInfo.contentType = minimizeSupportedMimeType(mimeType)
        }
      }

      // 8. If fetchParams’s request’s initiator type is non-null, then mark resource timing given timingInfo,
      //    fetchParams’s request’s URL, fetchParams’s request’s initiator type, global, cacheState, bodyInfo,
      //    and responseStatus.
      if (fetchParams.request.initiatorType != null) {
        // TODO: update markresourcetiming
        markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus)
      }
    }

    // 4. Let processResponseEndOfBodyTask be the following steps:
    const processResponseEndOfBodyTask = () => {
      // 1. Set fetchParams’s request’s done flag.
      fetchParams.request.done = true

      // 2. If fetchParams’s process response end-of-body is non-null, then run fetchParams’s process
      //    response end-of-body given response.
      if (fetchParams.processResponseEndOfBody != null) {
        queueMicrotask(() => fetchParams.processResponseEndOfBody(response))
      }

      // 3. If fetchParams’s request’s initiator type is non-null and fetchParams’s request’s client’s
      //    global object is fetchParams’s task destination, then run fetchParams’s controller’s report
      //    timing steps given fetchParams’s request’s client’s global object.
      if (fetchParams.request.initiatorType != null) {
        fetchParams.controller.reportTimingSteps()
      }
    }

    // 5. Queue a fetch task to run processResponseEndOfBodyTask with fetchParams’s task destination
    queueMicrotask(() => processResponseEndOfBodyTask())
  }

  // 4. If fetchParams’s process response is non-null, then queue a fetch task to run fetchParams’s
  //    process response given response, with fetchParams’s task destination.
  if (fetchParams.processResponse != null) {
    queueMicrotask(() => fetchParams.processResponse(response))
  }

  // 5. Let internalResponse be response, if response is a network error; otherwise response’s internal response.
  const internalResponse = response.type === 'error' ? response : (response.internalResponse ?? response)

  // 6. If internalResponse’s body is null, then run processResponseEndOfBody.
  // 7. Otherwise:
  if (internalResponse.body == null) {
    processResponseEndOfBody()
  } else {
    // 1. Let transformStream be a new TransformStream.
    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.
    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm
    //    set to processResponseEndOfBody.
    const transformStream = new TransformStream({
      start () { },
      transform (chunk, controller) {
        controller.enqueue(chunk)
      },
      flush: processResponseEndOfBody
    })

    // 4. Set internalResponse’s body’s stream to the result of internalResponse’s body’s stream piped through transformStream.
    internalResponse.body.stream.pipeThrough(transformStream)

    const byteStream = new ReadableStream({
      readableStream: transformStream.readable,
      async start () {
        this._bodyReader = this.readableStream.getReader()
      },
      async pull (controller) {
        while (controller.desiredSize >= 0) {
          const { done, value } = await this._bodyReader.read()

          if (done) {
            queueMicrotask(() => readableStreamClose(controller))
            break
          }

          controller.enqueue(value)
        }
      },
      type: 'bytes'
    })

    internalResponse.body.stream = byteStream
  }
}

// https://fetch.spec.whatwg.org/#http-fetch
async function httpFetch (fetchParams) {
  // 1. Let request be fetchParams’s request.
  const request = fetchParams.request

  // 2. Let response be null.
  let response = null

  // 3. Let actualResponse be null.
  let actualResponse = null

  // 4. Let timingInfo be fetchParams’s timing info.
  const timingInfo = fetchParams.timingInfo

  // 5. If request’s service-workers mode is "all", then:
  if (request.serviceWorkers === 'all') {
    // TODO
  }

  // 6. If response is null, then:
  if (response === null) {
    // 1. If makeCORSPreflight is true and one of these conditions is true:
    // TODO

    // 2. If request’s redirect mode is "follow", then set request’s
    // service-workers mode to "none".
    if (request.redirect === 'follow') {
      request.serviceWorkers = 'none'
    }

    // 3. Set response and actualResponse to the result of running
    // HTTP-network-or-cache fetch given fetchParams.
    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)

    // 4. If request’s response tainting is "cors" and a CORS check
    // for request and response returns failure, then return a network error.
    if (
      request.responseTainting === 'cors' &&
      corsCheck(request, response) === 'failure'
    ) {
      return makeNetworkError('cors failure')
    }

    // 5. If the TAO check for request and response returns failure, then set
    // request’s timing allow failed flag.
    if (TAOCheck(request, response) === 'failure') {
      request.timingAllowFailed = true
    }
  }

  // 7. If either request’s response tainting or response’s type
  // is "opaque", and the cross-origin resource policy check with
  // request’s origin, request’s client, request’s destination,
  // and actualResponse returns blocked, then return a network error.
  if (
    (request.responseTainting === 'opaque' || response.type === 'opaque') &&
    crossOriginResourcePolicyCheck(
      request.origin,
      request.client,
      request.destination,
      actualResponse
    ) === 'blocked'
  ) {
    return makeNetworkError('blocked')
  }

  // 8. If actualResponse’s status is a redirect status, then:
  if (redirectStatusSet.has(actualResponse.status)) {
    // 1. If actualResponse’s status is not 303, request’s body is not null,
    // and the connection uses HTTP/2, then user agents may, and are even
    // encouraged to, transmit an RST_STREAM frame.
    // See, https://github.com/whatwg/fetch/issues/1288
    if (request.redirect !== 'manual') {
      fetchParams.controller.connection.destroy(undefined, false)
    }

    // 2. Switch on request’s redirect mode:
    if (request.redirect === 'error') {
      // Set response to a network error.
      response = makeNetworkError('unexpected redirect')
    } else if (request.redirect === 'manual') {
      // Set response to an opaque-redirect filtered response whose internal
      // response is actualResponse.
      // NOTE(spec): On the web this would return an `opaqueredirect` response,
      // but that doesn't make sense server side.
      // See https://github.com/nodejs/undici/issues/1193.
      response = actualResponse
    } else if (request.redirect === 'follow') {
      // Set response to the result of running HTTP-redirect fetch given
      // fetchParams and response.
      response = await httpRedirectFetch(fetchParams, response)
    } else {
      assert(false)
    }
  }

  // 9. Set response’s timing info to timingInfo.
  response.timingInfo = timingInfo

  // 10. Return response.
  return response
}

// https://fetch.spec.whatwg.org/#http-redirect-fetch
function httpRedirectFetch (fetchParams, response) {
  // 1. Let request be fetchParams’s request.
  const request = fetchParams.request

  // 2. Let actualResponse be response, if response is not a filtered response,
  // and response’s internal response otherwise.
  const actualResponse = response.internalResponse
    ? response.internalResponse
    : response

  // 3. Let locationURL be actualResponse’s location URL given request’s current
  // URL’s fragment.
  let locationURL

  try {
    locationURL = responseLocationURL(
      actualResponse,
      requestCurrentURL(request).hash
    )

    // 4. If locationURL is null, then return response.
    if (locationURL == null) {
      return response
    }
  } catch (err) {
    // 5. If locationURL is failure, then return a network error.
    return Promise.resolve(makeNetworkError(err))
  }

  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network
  // error.
  if (!urlIsHttpHttpsScheme(locationURL)) {
    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))
  }

  // 7. If request’s redirect count is 20, then return a network error.
  if (request.redirectCount === 20) {
    return Promise.resolve(makeNetworkError('redirect count exceeded'))
  }

  // 8. Increase request’s redirect count by 1.
  request.redirectCount += 1

  // 9. If request’s mode is "cors", locationURL includes credentials, and
  // request’s origin is not same origin with locationURL’s origin, then return
  //  a network error.
  if (
    request.mode === 'cors' &&
    (locationURL.username || locationURL.password) &&
    !sameOrigin(request, locationURL)
  ) {
    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'))
  }

  // 10. If request’s response tainting is "cors" and locationURL includes
  // credentials, then return a network error.
  if (
    request.responseTainting === 'cors' &&
    (locationURL.username || locationURL.password)
  ) {
    return Promise.resolve(makeNetworkError(
      'URL cannot contain credentials for request mode "cors"'
    ))
  }

  // 11. If actualResponse’s status is not 303, request’s body is non-null,
  // and request’s body’s source is null, then return a network error.
  if (
    actualResponse.status !== 303 &&
    request.body != null &&
    request.body.source == null
  ) {
    return Promise.resolve(makeNetworkError())
  }

  // 12. If one of the following is true
  // - actualResponse’s status is 301 or 302 and request’s method is `POST`
  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`
  if (
    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||
    (actualResponse.status === 303 &&
      !GET_OR_HEAD.includes(request.method))
  ) {
    // then:
    // 1. Set request’s method to `GET` and request’s body to null.
    request.method = 'GET'
    request.body = null

    // 2. For each headerName of request-body-header name, delete headerName from
    // request’s header list.
    for (const headerName of requestBodyHeader) {
      request.headersList.delete(headerName)
    }
  }

  // 13. If request’s current URL’s origin is not same origin with locationURL’s
  //     origin, then for each headerName of CORS non-wildcard request-header name,
  //     delete headerName from request’s header list.
  if (!sameOrigin(requestCurrentURL(request), locationURL)) {
    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name
    request.headersList.delete('authorization', true)

    // https://fetch.spec.whatwg.org/#authentication-entries
    request.headersList.delete('proxy-authorization', true)

    // "Cookie" and "Host" are forbidden request-headers, which undici doesn't implement.
    request.headersList.delete('cookie', true)
    request.headersList.delete('host', true)
  }

  // 14. If request’s body is non-null, then set request’s body to the first return
  // value of safely extracting request’s body’s source.
  if (request.body != null) {
    assert(request.body.source != null)
    request.body = safelyExtractBody(request.body.source)[0]
  }

  // 15. Let timingInfo be fetchParams’s timing info.
  const timingInfo = fetchParams.timingInfo

  // 16. Set timingInfo’s redirect end time and post-redirect start time to the
  // coarsened shared current time given fetchParams’s cross-origin isolated
  // capability.
  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =
    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)

  // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s
  //  redirect start time to timingInfo’s start time.
  if (timingInfo.redirectStartTime === 0) {
    timingInfo.redirectStartTime = timingInfo.startTime
  }

  // 18. Append locationURL to request’s URL list.
  request.urlList.push(locationURL)

  // 19. Invoke set request’s referrer policy on redirect on request and
  // actualResponse.
  setRequestReferrerPolicyOnRedirect(request, actualResponse)

  // 20. Return the result of running main fetch given fetchParams and true.
  return mainFetch(fetchParams, true)
}

// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch
async function httpNetworkOrCacheFetch (
  fetchParams,
  isAuthenticationFetch = false,
  isNewConnectionFetch = false
) {
  // 1. Let request be fetchParams’s request.
  const request = fetchParams.request

  // 2. Let httpFetchParams be null.
  let httpFetchParams = null

  // 3. Let httpRequest be null.
  let httpRequest = null

  // 4. Let response be null.
  let response = null

  // 5. Let storedResponse be null.
  // TODO: cache

  // 6. Let httpCache be null.
  const httpCache = null

  // 7. Let the revalidatingFlag be unset.
  const revalidatingFlag = false

  // 8. Run these steps, but abort when the ongoing fetch is terminated:

  //    1. If request’s window is "no-window" and request’s redirect mode is
  //    "error", then set httpFetchParams to fetchParams and httpRequest to
  //    request.
  if (request.window === 'no-window' && request.redirect === 'error') {
    httpFetchParams = fetchParams
    httpRequest = request
  } else {
    // Otherwise:

    // 1. Set httpRequest to a clone of request.
    httpRequest = cloneRequest(request)

    // 2. Set httpFetchParams to a copy of fetchParams.
    httpFetchParams = { ...fetchParams }

    // 3. Set httpFetchParams’s request to httpRequest.
    httpFetchParams.request = httpRequest
  }

  //    3. Let includeCredentials be true if one of
  const includeCredentials =
    request.credentials === 'include' ||
    (request.credentials === 'same-origin' &&
      request.responseTainting === 'basic')

  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s
  //    body is non-null; otherwise null.
  const contentLength = httpRequest.body ? httpRequest.body.length : null

  //    5. Let contentLengthHeaderValue be null.
  let contentLengthHeaderValue = null

  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or
  //    `PUT`, then set contentLengthHeaderValue to `0`.
  if (
    httpRequest.body == null &&
    ['POST', 'PUT'].includes(httpRequest.method)
  ) {
    contentLengthHeaderValue = '0'
  }

  //    7. If contentLength is non-null, then set contentLengthHeaderValue to
  //    contentLength, serialized and isomorphic encoded.
  if (contentLength != null) {
    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)
  }

  //    8. If contentLengthHeaderValue is non-null, then append
  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header
  //    list.
  if (contentLengthHeaderValue != null) {
    httpRequest.headersList.append('content-length', contentLengthHeaderValue, true)
  }

  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,
  //    contentLengthHeaderValue) to httpRequest’s header list.

  //    10. If contentLength is non-null and httpRequest’s keepalive is true,
  //    then:
  if (contentLength != null && httpRequest.keepalive) {
    // NOTE: keepalive is a noop outside of browser context.
  }

  //    11. If httpRequest’s referrer is a URL, then append
  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,
  //     to httpRequest’s header list.
  if (httpRequest.referrer instanceof URL) {
    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href), true)
  }

  //    12. Append a request `Origin` header for httpRequest.
  appendRequestOriginHeader(httpRequest)

  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]
  appendFetchMetadata(httpRequest)

  //    14. If httpRequest’s header list does not contain `User-Agent`, then
  //    user agents should append `User-Agent`/default `User-Agent` value to
  //    httpRequest’s header list.
  if (!httpRequest.headersList.contains('user-agent', true)) {
    httpRequest.headersList.append('user-agent', defaultUserAgent)
  }

  //    15. If httpRequest’s cache mode is "default" and httpRequest’s header
  //    list contains `If-Modified-Since`, `If-None-Match`,
  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set
  //    httpRequest’s cache mode to "no-store".
  if (
    httpRequest.cache === 'default' &&
    (httpRequest.headersList.contains('if-modified-since', true) ||
      httpRequest.headersList.contains('if-none-match', true) ||
      httpRequest.headersList.contains('if-unmodified-since', true) ||
      httpRequest.headersList.contains('if-match', true) ||
      httpRequest.headersList.contains('if-range', true))
  ) {
    httpRequest.cache = 'no-store'
  }

  //    16. If httpRequest’s cache mode is "no-cache", httpRequest’s prevent
  //    no-cache cache-control header modification flag is unset, and
  //    httpRequest’s header list does not contain `Cache-Control`, then append
  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.
  if (
    httpRequest.cache === 'no-cache' &&
    !httpRequest.preventNoCacheCacheControlHeaderModification &&
    !httpRequest.headersList.contains('cache-control', true)
  ) {
    httpRequest.headersList.append('cache-control', 'max-age=0', true)
  }

  //    17. If httpRequest’s cache mode is "no-store" or "reload", then:
  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {
    // 1. If httpRequest’s header list does not contain `Pragma`, then append
    // `Pragma`/`no-cache` to httpRequest’s header list.
    if (!httpRequest.headersList.contains('pragma', true)) {
      httpRequest.headersList.append('pragma', 'no-cache', true)
    }

    // 2. If httpRequest’s header list does not contain `Cache-Control`,
    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.
    if (!httpRequest.headersList.contains('cache-control', true)) {
      httpRequest.headersList.append('cache-control', 'no-cache', true)
    }
  }

  //    18. If httpRequest’s header list contains `Range`, then append
  //    `Accept-Encoding`/`identity` to httpRequest’s header list.
  if (httpRequest.headersList.contains('range', true)) {
    httpRequest.headersList.append('accept-encoding', 'identity', true)
  }

  //    19. Modify httpRequest’s header list per HTTP. Do not append a given
  //    header if httpRequest’s header list contains that header’s name.
  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129
  if (!httpRequest.headersList.contains('accept-encoding', true)) {
    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate', true)
    } else {
      httpRequest.headersList.append('accept-encoding', 'gzip, deflate', true)
    }
  }

  httpRequest.headersList.delete('host', true)

  //    20. If includeCredentials is true, then:
  if (includeCredentials) {
    // 1. If the user agent is not configured to block cookies for httpRequest
    // (see section 7 of [COOKIES]), then:
    // TODO: credentials
    // 2. If httpRequest’s header list does not contain `Authorization`, then:
    // TODO: credentials
  }

  //    21. If there’s a proxy-authentication entry, use it as appropriate.
  //    TODO: proxy-authentication

  //    22. Set httpCache to the result of determining the HTTP cache
  //    partition, given httpRequest.
  //    TODO: cache

  //    23. If httpCache is null, then set httpRequest’s cache mode to
  //    "no-store".
  if (httpCache == null) {
    httpRequest.cache = 'no-store'
  }

  //    24. If httpRequest’s cache mode is neither "no-store" nor "reload",
  //    then:
  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {
    // TODO: cache
  }

  // 9. If aborted, then return the appropriate network error for fetchParams.
  // TODO

  // 10. If response is null, then:
  if (response == null) {
    // 1. If httpRequest’s cache mode is "only-if-cached", then return a
    // network error.
    if (httpRequest.mode === 'only-if-cached') {
      return makeNetworkError('only if cached')
    }

    // 2. Let forwardResponse be the result of running HTTP-network fetch
    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.
    const forwardResponse = await httpNetworkFetch(
      httpFetchParams,
      includeCredentials,
      isNewConnectionFetch
    )

    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is
    // in the range 200 to 399, inclusive, invalidate appropriate stored
    // responses in httpCache, as per the "Invalidation" chapter of HTTP
    // Caching, and set storedResponse to null. [HTTP-CACHING]
    if (
      !safeMethodsSet.has(httpRequest.method) &&
      forwardResponse.status >= 200 &&
      forwardResponse.status <= 399
    ) {
      // TODO: cache
    }

    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,
    // then:
    if (revalidatingFlag && forwardResponse.status === 304) {
      // TODO: cache
    }

    // 5. If response is null, then:
    if (response == null) {
      // 1. Set response to forwardResponse.
      response = forwardResponse

      // 2. Store httpRequest and forwardResponse in httpCache, as per the
      // "Storing Responses in Caches" chapter of HTTP Caching. [HTTP-CACHING]
      // TODO: cache
    }
  }

  // 11. Set response’s URL list to a clone of httpRequest’s URL list.
  response.urlList = [...httpRequest.urlList]

  // 12. If httpRequest’s header list contains `Range`, then set response’s
  // range-requested flag.
  if (httpRequest.headersList.contains('range', true)) {
    response.rangeRequested = true
  }

  // 13. Set response’s request-includes-credentials to includeCredentials.
  response.requestIncludesCredentials = includeCredentials

  // 14. If response’s status is 401, httpRequest’s response tainting is not
  // "cors", includeCredentials is true, and request’s window is an environment
  // settings object, then:
  // TODO

  // 15. If response’s status is 407, then:
  if (response.status === 407) {
    // 1. If request’s window is "no-window", then return a network error.
    if (request.window === 'no-window') {
      return makeNetworkError()
    }

    // 2. ???

    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.
    if (isCancelled(fetchParams)) {
      return makeAppropriateNetworkError(fetchParams)
    }

    // 4. Prompt the end user as appropriate in request’s window and store
    // the result as a proxy-authentication entry. [HTTP-AUTH]
    // TODO: Invoke some kind of callback?

    // 5. Set response to the result of running HTTP-network-or-cache fetch given
    // fetchParams.
    // TODO
    return makeNetworkError('proxy authentication required')
  }

  // 16. If all of the following are true
  if (
    // response’s status is 421
    response.status === 421 &&
    // isNewConnectionFetch is false
    !isNewConnectionFetch &&
    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
    (request.body == null || request.body.source != null)
  ) {
    // then:

    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
    if (isCancelled(fetchParams)) {
      return makeAppropriateNetworkError(fetchParams)
    }

    // 2. Set response to the result of running HTTP-network-or-cache
    // fetch given fetchParams, isAuthenticationFetch, and true.

    // TODO (spec): The spec doesn't specify this but we need to cancel
    // the active response before we can start a new one.
    // https://github.com/whatwg/fetch/issues/1293
    fetchParams.controller.connection.destroy()

    response = await httpNetworkOrCacheFetch(
      fetchParams,
      isAuthenticationFetch,
      true
    )
  }

  // 17. If isAuthenticationFetch is true, then create an authentication entry
  if (isAuthenticationFetch) {
    // TODO
  }

  // 18. Return response.
  return response
}

// https://fetch.spec.whatwg.org/#http-network-fetch
async function httpNetworkFetch (
  fetchParams,
  includeCredentials = false,
  forceNewConnection = false
) {
  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)

  fetchParams.controller.connection = {
    abort: null,
    destroyed: false,
    destroy (err, abort = true) {
      if (!this.destroyed) {
        this.destroyed = true
        if (abort) {
          this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))
        }
      }
    }
  }

  // 1. Let request be fetchParams’s request.
  const request = fetchParams.request

  // 2. Let response be null.
  let response = null

  // 3. Let timingInfo be fetchParams’s timing info.
  const timingInfo = fetchParams.timingInfo

  // 4. Let httpCache be the result of determining the HTTP cache partition,
  // given request.
  // TODO: cache
  const httpCache = null

  // 5. If httpCache is null, then set request’s cache mode to "no-store".
  if (httpCache == null) {
    request.cache = 'no-store'
  }

  // 6. Let networkPartitionKey be the result of determining the network
  // partition key given request.
  // TODO

  // 7. Let newConnection be "yes" if forceNewConnection is true; otherwise
  // "no".
  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars

  // 8. Switch on request’s mode:
  if (request.mode === 'websocket') {
    // Let connection be the result of obtaining a WebSocket connection,
    // given request’s current URL.
    // TODO
  } else {
    // Let connection be the result of obtaining a connection, given
    // networkPartitionKey, request’s current URL’s origin,
    // includeCredentials, and forceNewConnection.
    // TODO
  }

  // 9. Run these steps, but abort when the ongoing fetch is terminated:

  //    1. If connection is failure, then return a network error.

  //    2. Set timingInfo’s final connection timing info to the result of
  //    calling clamp and coarsen connection timing info with connection’s
  //    timing info, timingInfo’s post-redirect start time, and fetchParams’s
  //    cross-origin isolated capability.

  //    3. If connection is not an HTTP/2 connection, request’s body is non-null,
  //    and request’s body’s source is null, then append (`Transfer-Encoding`,
  //    `chunked`) to request’s header list.

  //    4. Set timingInfo’s final network-request start time to the coarsened
  //    shared current time given fetchParams’s cross-origin isolated
  //    capability.

  //    5. Set response to the result of making an HTTP request over connection
  //    using request with the following caveats:

  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]
  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]

  //        - If request’s body is non-null, and request’s body’s source is null,
  //        then the user agent may have a buffer of up to 64 kibibytes and store
  //        a part of request’s body in that buffer. If the user agent reads from
  //        request’s body beyond that buffer’s size and the user agent needs to
  //        resend request, then instead return a network error.

  //        - Set timingInfo’s final network-response start time to the coarsened
  //        shared current time given fetchParams’s cross-origin isolated capability,
  //        immediately after the user agent’s HTTP parser receives the first byte
  //        of the response (e.g., frame header bytes for HTTP/2 or response status
  //        line for HTTP/1.x).

  //        - Wait until all the headers are transmitted.

  //        - Any responses whose status is in the range 100 to 199, inclusive,
  //        and is not 101, are to be ignored, except for the purposes of setting
  //        timingInfo’s final network-response start time above.

  //    - If request’s header list contains `Transfer-Encoding`/`chunked` and
  //    response is transferred via HTTP/1.0 or older, then return a network
  //    error.

  //    - If the HTTP request results in a TLS client certificate dialog, then:

  //        1. If request’s window is an environment settings object, make the
  //        dialog available in request’s window.

  //        2. Otherwise, return a network error.

  // To transmit request’s body body, run these steps:
  let requestBody = null
  // 1. If body is null and fetchParams’s process request end-of-body is
  // non-null, then queue a fetch task given fetchParams’s process request
  // end-of-body and fetchParams’s task destination.
  if (request.body == null && fetchParams.processRequestEndOfBody) {
    queueMicrotask(() => fetchParams.processRequestEndOfBody())
  } else if (request.body != null) {
    // 2. Otherwise, if body is non-null:

    //    1. Let processBodyChunk given bytes be these steps:
    const processBodyChunk = async function * (bytes) {
      // 1. If the ongoing fetch is terminated, then abort these steps.
      if (isCancelled(fetchParams)) {
        return
      }

      // 2. Run this step in parallel: transmit bytes.
      yield bytes

      // 3. If fetchParams’s process request body is non-null, then run
      // fetchParams’s process request body given bytes’s length.
      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)
    }

    // 2. Let processEndOfBody be these steps:
    const processEndOfBody = () => {
      // 1. If fetchParams is canceled, then abort these steps.
      if (isCancelled(fetchParams)) {
        return
      }

      // 2. If fetchParams’s process request end-of-body is non-null,
      // then run fetchParams’s process request end-of-body.
      if (fetchParams.processRequestEndOfBody) {
        fetchParams.processRequestEndOfBody()
      }
    }

    // 3. Let processBodyError given e be these steps:
    const processBodyError = (e) => {
      // 1. If fetchParams is canceled, then abort these steps.
      if (isCancelled(fetchParams)) {
        return
      }

      // 2. If e is an "AbortError" DOMException, then abort fetchParams’s controller.
      if (e.name === 'AbortError') {
        fetchParams.controller.abort()
      } else {
        fetchParams.controller.terminate(e)
      }
    }

    // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,
    // processBodyError, and fetchParams’s task destination.
    requestBody = (async function * () {
      try {
        for await (const bytes of request.body.stream) {
          yield * processBodyChunk(bytes)
        }
        processEndOfBody()
      } catch (err) {
        processBodyError(err)
      }
    })()
  }

  try {
    // socket is only provided for websockets
    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody })

    if (socket) {
      response = makeResponse({ status, statusText, headersList, socket })
    } else {
      const iterator = body[Symbol.asyncIterator]()
      fetchParams.controller.next = () => iterator.next()

      response = makeResponse({ status, statusText, headersList })
    }
  } catch (err) {
    // 10. If aborted, then:
    if (err.name === 'AbortError') {
      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.
      fetchParams.controller.connection.destroy()

      // 2. Return the appropriate network error for fetchParams.
      return makeAppropriateNetworkError(fetchParams, err)
    }

    return makeNetworkError(err)
  }

  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch
  // if it is suspended.
  const pullAlgorithm = async () => {
    await fetchParams.controller.resume()
  }

  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s
  // controller with reason, given reason.
  const cancelAlgorithm = (reason) => {
    fetchParams.controller.abort(reason)
  }

  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by
  // the user agent.
  // TODO

  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object
  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.
  // TODO

  // 15. Let stream be a new ReadableStream.
  // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,
  //     cancelAlgorithm set to cancelAlgorithm.
  const stream = new ReadableStream(
    {
      async start (controller) {
        fetchParams.controller.controller = controller
      },
      async pull (controller) {
        await pullAlgorithm(controller)
      },
      async cancel (reason) {
        await cancelAlgorithm(reason)
      },
      type: 'bytes'
    }
  )

  // 17. Run these steps, but abort when the ongoing fetch is terminated:

  //    1. Set response’s body to a new body whose stream is stream.
  response.body = { stream, source: null, length: null }

  //    2. If response is not a network error and request’s cache mode is
  //    not "no-store", then update response in httpCache for request.
  //    TODO

  //    3. If includeCredentials is true and the user agent is not configured
  //    to block cookies for request (see section 7 of [COOKIES]), then run the
  //    "set-cookie-string" parsing algorithm (see section 5.2 of [COOKIES]) on
  //    the value of each header whose name is a byte-case-insensitive match for
  //    `Set-Cookie` in response’s header list, if any, and request’s current URL.
  //    TODO

  // 18. If aborted, then:
  // TODO

  // 19. Run these steps in parallel:

  //    1. Run these steps, but abort when fetchParams is canceled:
  fetchParams.controller.onAborted = onAborted
  fetchParams.controller.on('terminated', onAborted)
  fetchParams.controller.resume = async () => {
    // 1. While true
    while (true) {
      // 1-3. See onData...

      // 4. Set bytes to the result of handling content codings given
      // codings and bytes.
      let bytes
      let isFailure
      try {
        const { done, value } = await fetchParams.controller.next()

        if (isAborted(fetchParams)) {
          break
        }

        bytes = done ? undefined : value
      } catch (err) {
        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
          // zlib doesn't like empty streams.
          bytes = undefined
        } else {
          bytes = err

          // err may be propagated from the result of calling readablestream.cancel,
          // which might not be an error. https://github.com/nodejs/undici/issues/2009
          isFailure = true
        }
      }

      if (bytes === undefined) {
        // 2. Otherwise, if the bytes transmission for response’s message
        // body is done normally and stream is readable, then close
        // stream, finalize response for fetchParams and response, and
        // abort these in-parallel steps.
        readableStreamClose(fetchParams.controller.controller)

        finalizeResponse(fetchParams, response)

        return
      }

      // 5. Increase timingInfo’s decoded body size by bytes’s length.
      timingInfo.decodedBodySize += bytes?.byteLength ?? 0

      // 6. If bytes is failure, then terminate fetchParams’s controller.
      if (isFailure) {
        fetchParams.controller.terminate(bytes)
        return
      }

      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes
      // into stream.
      const buffer = new Uint8Array(bytes)
      if (buffer.byteLength) {
        fetchParams.controller.controller.enqueue(buffer)
      }

      // 8. If stream is errored, then terminate the ongoing fetch.
      if (isErrored(stream)) {
        fetchParams.controller.terminate()
        return
      }

      // 9. If stream doesn’t need more data ask the user agent to suspend
      // the ongoing fetch.
      if (fetchParams.controller.controller.desiredSize <= 0) {
        return
      }
    }
  }

  //    2. If aborted, then:
  function onAborted (reason) {
    // 2. If fetchParams is aborted, then:
    if (isAborted(fetchParams)) {
      // 1. Set response’s aborted flag.
      response.aborted = true

      // 2. If stream is readable, then error stream with the result of
      //    deserialize a serialized abort reason given fetchParams’s
      //    controller’s serialized abort reason and an
      //    implementation-defined realm.
      if (isReadable(stream)) {
        fetchParams.controller.controller.error(
          fetchParams.controller.serializedAbortReason
        )
      }
    } else {
      // 3. Otherwise, if stream is readable, error stream with a TypeError.
      if (isReadable(stream)) {
        fetchParams.controller.controller.error(new TypeError('terminated', {
          cause: isErrorLike(reason) ? reason : undefined
        }))
      }
    }

    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.
    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.
    fetchParams.controller.connection.destroy()
  }

  // 20. Return response.
  return response

  function dispatch ({ body }) {
    const url = requestCurrentURL(request)
    /** @type {import('../..').Agent} */
    const agent = fetchParams.controller.dispatcher

    return new Promise((resolve, reject) => agent.dispatch(
      {
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
        headers: request.headersList.entries,
        maxRedirections: 0,
        upgrade: request.mode === 'websocket' ? 'websocket' : undefined
      },
      {
        body: null,
        abort: null,

        onConnect (abort) {
          // TODO (fix): Do we need connection here?
          const { connection } = fetchParams.controller

          // Set timingInfo’s final connection timing info to the result of calling clamp and coarsen
          // connection timing info with connection’s timing info, timingInfo’s post-redirect start
          // time, and fetchParams’s cross-origin isolated capability.
          // TODO: implement connection timing
          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability)

          if (connection.destroyed) {
            abort(new DOMException('The operation was aborted.', 'AbortError'))
          } else {
            fetchParams.controller.on('terminated', abort)
            this.abort = connection.abort = abort
          }

          // Set timingInfo’s final network-request start time to the coarsened shared current time given
          // fetchParams’s cross-origin isolated capability.
          timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)
        },

        onResponseStarted () {
          // Set timingInfo’s final network-response start time to the coarsened shared current
          // time given fetchParams’s cross-origin isolated capability, immediately after the
          // user agent’s HTTP parser receives the first byte of the response (e.g., frame header
          // bytes for HTTP/2 or response status line for HTTP/1.x).
          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)
        },

        onHeaders (status, rawHeaders, resume, statusText) {
          if (status < 200) {
            return
          }

          /** @type {string[]} */
          let codings = []
          let location = ''

          const headersList = new HeadersList()

          // For H2, the rawHeaders are a plain JS object
          // We distinguish between them and iterate accordingly
          if (Array.isArray(rawHeaders)) {
            for (let i = 0; i < rawHeaders.length; i += 2) {
              headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)
            }
            const contentEncoding = headersList.get('content-encoding', true)
            if (contentEncoding) {
              // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
              // "All content-coding values are case-insensitive..."
              codings = contentEncoding.toLowerCase().split(',').map((x) => x.trim())
            }
            location = headersList.get('location', true)
          } else {
            const keys = Object.keys(rawHeaders)
            for (let i = 0; i < keys.length; ++i) {
              // The header names are already in lowercase.
              const key = keys[i]
              const value = rawHeaders[key]
              if (key === 'set-cookie') {
                for (let j = 0; j < value.length; ++j) {
                  headersList.append(key, value[j], true)
                }
              } else {
                headersList.append(key, value, true)
              }
            }
            // For H2, The header names are already in lowercase,
            // so we can avoid the `HeadersList#get` call here.
            const contentEncoding = rawHeaders['content-encoding']
            if (contentEncoding) {
              // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
              // "All content-coding values are case-insensitive..."
              codings = contentEncoding.toLowerCase().split(',').map((x) => x.trim()).reverse()
            }
            location = rawHeaders.location
          }

          this.body = new Readable({ read: resume })

          const decoders = []

          const willFollow = location && request.redirect === 'follow' &&
            redirectStatusSet.has(status)

          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
          if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {
            for (let i = 0; i < codings.length; ++i) {
              const coding = codings[i]
              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2
              if (coding === 'x-gzip' || coding === 'gzip') {
                decoders.push(zlib.createGunzip({
                  // Be less strict when decoding compressed responses, since sometimes
                  // servers send slightly invalid responses that are still accepted
                  // by common browsers.
                  // Always using Z_SYNC_FLUSH is what cURL does.
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }))
              } else if (coding === 'deflate') {
                decoders.push(createInflate())
              } else if (coding === 'br') {
                decoders.push(zlib.createBrotliDecompress())
              } else {
                decoders.length = 0
                break
              }
            }
          }

          resolve({
            status,
            statusText,
            headersList,
            body: decoders.length
              ? pipeline(this.body, ...decoders, () => { })
              : this.body.on('error', () => { })
          })

          return true
        },

        onData (chunk) {
          if (fetchParams.controller.dump) {
            return
          }

          // 1. If one or more bytes have been transmitted from response’s
          // message body, then:

          //  1. Let bytes be the transmitted bytes.
          const bytes = chunk

          //  2. Let codings be the result of extracting header list values
          //  given `Content-Encoding` and response’s header list.
          //  See pullAlgorithm.

          //  3. Increase timingInfo’s encoded body size by bytes’s length.
          timingInfo.encodedBodySize += bytes.byteLength

          //  4. See pullAlgorithm...

          return this.body.push(bytes)
        },

        onComplete () {
          if (this.abort) {
            fetchParams.controller.off('terminated', this.abort)
          }

          if (fetchParams.controller.onAborted) {
            fetchParams.controller.off('terminated', fetchParams.controller.onAborted)
          }

          fetchParams.controller.ended = true

          this.body.push(null)
        },

        onError (error) {
          if (this.abort) {
            fetchParams.controller.off('terminated', this.abort)
          }

          this.body?.destroy(error)

          fetchParams.controller.terminate(error)

          reject(error)
        },

        onUpgrade (status, rawHeaders, socket) {
          if (status !== 101) {
            return
          }

          const headersList = new HeadersList()

          for (let i = 0; i < rawHeaders.length; i += 2) {
            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)
          }

          resolve({
            status,
            statusText: STATUS_CODES[status],
            headersList,
            socket
          })

          return true
        }
      }
    ))
  }
}

module.exports = {
  fetch,
  Fetch,
  fetching,
  finalizeAndReportTiming
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/request.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/request.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* globals AbortController */



const { extractBody, mixinBody, cloneBody } = __webpack_require__(/*! ./body */ "./node_modules/undici/lib/web/fetch/body.js")
const { Headers, fill: fillHeaders, HeadersList } = __webpack_require__(/*! ./headers */ "./node_modules/undici/lib/web/fetch/headers.js")
const { FinalizationRegistry } = __webpack_require__(/*! ./dispatcher-weakref */ "./node_modules/undici/lib/web/fetch/dispatcher-weakref.js")()
const util = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const {
  isValidHTTPToken,
  sameOrigin,
  normalizeMethod,
  makePolicyContainer,
  normalizeMethodRecord
} = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/fetch/util.js")
const {
  forbiddenMethodsSet,
  corsSafeListedMethodsSet,
  referrerPolicy,
  requestRedirect,
  requestMode,
  requestCredentials,
  requestCache,
  requestDuplex
} = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/web/fetch/constants.js")
const { kEnumerableProperty } = util
const { kHeaders, kSignal, kState, kGuard, kRealm, kDispatcher } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/fetch/symbols.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { getGlobalOrigin } = __webpack_require__(/*! ./global */ "./node_modules/undici/lib/web/fetch/global.js")
const { URLSerializer } = __webpack_require__(/*! ./data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")
const { kHeadersList, kConstruct } = __webpack_require__(/*! ../../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const assert = __webpack_require__(/*! node:assert */ "node:assert")
const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __webpack_require__(/*! node:events */ "node:events")

const kAbortController = Symbol('abortController')

const requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
  signal.removeEventListener('abort', abort)
})

let patchMethodWarning = false

// https://fetch.spec.whatwg.org/#request-class
class Request {
  // https://fetch.spec.whatwg.org/#dom-request
  constructor (input, init = {}) {
    if (input === kConstruct) {
      return
    }

    webidl.argumentLengthCheck(arguments, 1, { header: 'Request constructor' })

    input = webidl.converters.RequestInfo(input)
    init = webidl.converters.RequestInit(init)

    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object
    this[kRealm] = {
      settingsObject: {
        baseUrl: getGlobalOrigin(),
        get origin () {
          return this.baseUrl?.origin
        },
        policyContainer: makePolicyContainer()
      }
    }

    // 1. Let request be null.
    let request = null

    // 2. Let fallbackMode be null.
    let fallbackMode = null

    // 3. Let baseURL be this’s relevant settings object’s API base URL.
    const baseUrl = this[kRealm].settingsObject.baseUrl

    // 4. Let signal be null.
    let signal = null

    // 5. If input is a string, then:
    if (typeof input === 'string') {
      this[kDispatcher] = init.dispatcher

      // 1. Let parsedURL be the result of parsing input with baseURL.
      // 2. If parsedURL is failure, then throw a TypeError.
      let parsedURL
      try {
        parsedURL = new URL(input, baseUrl)
      } catch (err) {
        throw new TypeError('Failed to parse URL from ' + input, { cause: err })
      }

      // 3. If parsedURL includes credentials, then throw a TypeError.
      if (parsedURL.username || parsedURL.password) {
        throw new TypeError(
          'Request cannot be constructed from a URL that includes credentials: ' +
            input
        )
      }

      // 4. Set request to a new request whose URL is parsedURL.
      request = makeRequest({ urlList: [parsedURL] })

      // 5. Set fallbackMode to "cors".
      fallbackMode = 'cors'
    } else {
      this[kDispatcher] = input[kDispatcher]

      // 6. Otherwise:

      // 7. Assert: input is a Request object.
      assert(input instanceof Request)

      // 8. Set request to input’s request.
      request = input[kState]

      // 9. Set signal to input’s signal.
      signal = input[kSignal]
    }

    // 7. Let origin be this’s relevant settings object’s origin.
    const origin = this[kRealm].settingsObject.origin

    // 8. Let window be "client".
    let window = 'client'

    // 9. If request’s window is an environment settings object and its origin
    // is same origin with origin, then set window to request’s window.
    if (
      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&
      sameOrigin(request.window, origin)
    ) {
      window = request.window
    }

    // 10. If init["window"] exists and is non-null, then throw a TypeError.
    if (init.window != null) {
      throw new TypeError(`'window' option '${window}' must be null`)
    }

    // 11. If init["window"] exists, then set window to "no-window".
    if ('window' in init) {
      window = 'no-window'
    }

    // 12. Set request to a new request with the following properties:
    request = makeRequest({
      // URL request’s URL.
      // undici implementation note: this is set as the first item in request's urlList in makeRequest
      // method request’s method.
      method: request.method,
      // header list A copy of request’s header list.
      // undici implementation note: headersList is cloned in makeRequest
      headersList: request.headersList,
      // unsafe-request flag Set.
      unsafeRequest: request.unsafeRequest,
      // client This’s relevant settings object.
      client: this[kRealm].settingsObject,
      // window window.
      window,
      // priority request’s priority.
      priority: request.priority,
      // origin request’s origin. The propagation of the origin is only significant for navigation requests
      // being handled by a service worker. In this scenario a request can have an origin that is different
      // from the current client.
      origin: request.origin,
      // referrer request’s referrer.
      referrer: request.referrer,
      // referrer policy request’s referrer policy.
      referrerPolicy: request.referrerPolicy,
      // mode request’s mode.
      mode: request.mode,
      // credentials mode request’s credentials mode.
      credentials: request.credentials,
      // cache mode request’s cache mode.
      cache: request.cache,
      // redirect mode request’s redirect mode.
      redirect: request.redirect,
      // integrity metadata request’s integrity metadata.
      integrity: request.integrity,
      // keepalive request’s keepalive.
      keepalive: request.keepalive,
      // reload-navigation flag request’s reload-navigation flag.
      reloadNavigation: request.reloadNavigation,
      // history-navigation flag request’s history-navigation flag.
      historyNavigation: request.historyNavigation,
      // URL list A clone of request’s URL list.
      urlList: [...request.urlList]
    })

    const initHasKey = Object.keys(init).length !== 0

    // 13. If init is not empty, then:
    if (initHasKey) {
      // 1. If request’s mode is "navigate", then set it to "same-origin".
      if (request.mode === 'navigate') {
        request.mode = 'same-origin'
      }

      // 2. Unset request’s reload-navigation flag.
      request.reloadNavigation = false

      // 3. Unset request’s history-navigation flag.
      request.historyNavigation = false

      // 4. Set request’s origin to "client".
      request.origin = 'client'

      // 5. Set request’s referrer to "client"
      request.referrer = 'client'

      // 6. Set request’s referrer policy to the empty string.
      request.referrerPolicy = ''

      // 7. Set request’s URL to request’s current URL.
      request.url = request.urlList[request.urlList.length - 1]

      // 8. Set request’s URL list to « request’s URL ».
      request.urlList = [request.url]
    }

    // 14. If init["referrer"] exists, then:
    if (init.referrer !== undefined) {
      // 1. Let referrer be init["referrer"].
      const referrer = init.referrer

      // 2. If referrer is the empty string, then set request’s referrer to "no-referrer".
      if (referrer === '') {
        request.referrer = 'no-referrer'
      } else {
        // 1. Let parsedReferrer be the result of parsing referrer with
        // baseURL.
        // 2. If parsedReferrer is failure, then throw a TypeError.
        let parsedReferrer
        try {
          parsedReferrer = new URL(referrer, baseUrl)
        } catch (err) {
          throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err })
        }

        // 3. If one of the following is true
        // - parsedReferrer’s scheme is "about" and path is the string "client"
        // - parsedReferrer’s origin is not same origin with origin
        // then set request’s referrer to "client".
        if (
          (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||
          (origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl))
        ) {
          request.referrer = 'client'
        } else {
          // 4. Otherwise, set request’s referrer to parsedReferrer.
          request.referrer = parsedReferrer
        }
      }
    }

    // 15. If init["referrerPolicy"] exists, then set request’s referrer policy
    // to it.
    if (init.referrerPolicy !== undefined) {
      request.referrerPolicy = init.referrerPolicy
    }

    // 16. Let mode be init["mode"] if it exists, and fallbackMode otherwise.
    let mode
    if (init.mode !== undefined) {
      mode = init.mode
    } else {
      mode = fallbackMode
    }

    // 17. If mode is "navigate", then throw a TypeError.
    if (mode === 'navigate') {
      throw webidl.errors.exception({
        header: 'Request constructor',
        message: 'invalid request mode navigate.'
      })
    }

    // 18. If mode is non-null, set request’s mode to mode.
    if (mode != null) {
      request.mode = mode
    }

    // 19. If init["credentials"] exists, then set request’s credentials mode
    // to it.
    if (init.credentials !== undefined) {
      request.credentials = init.credentials
    }

    // 18. If init["cache"] exists, then set request’s cache mode to it.
    if (init.cache !== undefined) {
      request.cache = init.cache
    }

    // 21. If request’s cache mode is "only-if-cached" and request’s mode is
    // not "same-origin", then throw a TypeError.
    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {
      throw new TypeError(
        "'only-if-cached' can be set only with 'same-origin' mode"
      )
    }

    // 22. If init["redirect"] exists, then set request’s redirect mode to it.
    if (init.redirect !== undefined) {
      request.redirect = init.redirect
    }

    // 23. If init["integrity"] exists, then set request’s integrity metadata to it.
    if (init.integrity != null) {
      request.integrity = String(init.integrity)
    }

    // 24. If init["keepalive"] exists, then set request’s keepalive to it.
    if (init.keepalive !== undefined) {
      request.keepalive = Boolean(init.keepalive)
    }

    // 25. If init["method"] exists, then:
    if (init.method !== undefined) {
      // 1. Let method be init["method"].
      let method = init.method

      const mayBeNormalized = normalizeMethodRecord[method]

      if (mayBeNormalized !== undefined) {
        // Note: Bypass validation DELETE, GET, HEAD, OPTIONS, POST, PUT, PATCH and these lowercase ones
        request.method = mayBeNormalized
      } else {
        // 2. If method is not a method or method is a forbidden method, then
        // throw a TypeError.
        if (!isValidHTTPToken(method)) {
          throw new TypeError(`'${method}' is not a valid HTTP method.`)
        }

        if (forbiddenMethodsSet.has(method.toUpperCase())) {
          throw new TypeError(`'${method}' HTTP method is unsupported.`)
        }

        // 3. Normalize method.
        method = normalizeMethod(method)

        // 4. Set request’s method to method.
        request.method = method
      }

      if (!patchMethodWarning && request.method === 'patch') {
        process.emitWarning('Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.', {
          code: 'UNDICI-FETCH-patch'
        })

        patchMethodWarning = true
      }
    }

    // 26. If init["signal"] exists, then set signal to it.
    if (init.signal !== undefined) {
      signal = init.signal
    }

    // 27. Set this’s request to request.
    this[kState] = request

    // 28. Set this’s signal to a new AbortSignal object with this’s relevant
    // Realm.
    // TODO: could this be simplified with AbortSignal.any
    // (https://dom.spec.whatwg.org/#dom-abortsignal-any)
    const ac = new AbortController()
    this[kSignal] = ac.signal
    this[kSignal][kRealm] = this[kRealm]

    // 29. If signal is not null, then make this’s signal follow signal.
    if (signal != null) {
      if (
        !signal ||
        typeof signal.aborted !== 'boolean' ||
        typeof signal.addEventListener !== 'function'
      ) {
        throw new TypeError(
          "Failed to construct 'Request': member signal is not of type AbortSignal."
        )
      }

      if (signal.aborted) {
        ac.abort(signal.reason)
      } else {
        // Keep a strong ref to ac while request object
        // is alive. This is needed to prevent AbortController
        // from being prematurely garbage collected.
        // See, https://github.com/nodejs/undici/issues/1926.
        this[kAbortController] = ac

        const acRef = new WeakRef(ac)
        const abort = function () {
          const ac = acRef.deref()
          if (ac !== undefined) {
            // Currently, there is a problem with FinalizationRegistry.
            // https://github.com/nodejs/node/issues/49344
            // https://github.com/nodejs/node/issues/47748
            // In the case of abort, the first step is to unregister from it.
            // If the controller can refer to it, it is still registered.
            // It will be removed in the future.
            requestFinalizer.unregister(abort)

            // Unsubscribe a listener.
            // FinalizationRegistry will no longer be called, so this must be done.
            this.removeEventListener('abort', abort)

            ac.abort(this.reason)
          }
        }

        // Third-party AbortControllers may not work with these.
        // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.
        try {
          // If the max amount of listeners is equal to the default, increase it
          // This is only available in node >= v19.9.0
          if (typeof getMaxListeners === 'function' && getMaxListeners(signal) === defaultMaxListeners) {
            setMaxListeners(100, signal)
          } else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) {
            setMaxListeners(100, signal)
          }
        } catch {}

        util.addAbortListener(signal, abort)
        // The third argument must be a registry key to be unregistered.
        // Without it, you cannot unregister.
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry
        // abort is used as the unregister key. (because it is unique)
        requestFinalizer.register(ac, { signal, abort }, abort)
      }
    }

    // 30. Set this’s headers to a new Headers object with this’s relevant
    // Realm, whose header list is request’s header list and guard is
    // "request".
    this[kHeaders] = new Headers(kConstruct)
    this[kHeaders][kHeadersList] = request.headersList
    this[kHeaders][kGuard] = 'request'
    this[kHeaders][kRealm] = this[kRealm]

    // 31. If this’s request’s mode is "no-cors", then:
    if (mode === 'no-cors') {
      // 1. If this’s request’s method is not a CORS-safelisted method,
      // then throw a TypeError.
      if (!corsSafeListedMethodsSet.has(request.method)) {
        throw new TypeError(
          `'${request.method} is unsupported in no-cors mode.`
        )
      }

      // 2. Set this’s headers’s guard to "request-no-cors".
      this[kHeaders][kGuard] = 'request-no-cors'
    }

    // 32. If init is not empty, then:
    if (initHasKey) {
      /** @type {HeadersList} */
      const headersList = this[kHeaders][kHeadersList]
      // 1. Let headers be a copy of this’s headers and its associated header
      // list.
      // 2. If init["headers"] exists, then set headers to init["headers"].
      const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList)

      // 3. Empty this’s headers’s header list.
      headersList.clear()

      // 4. If headers is a Headers object, then for each header in its header
      // list, append header’s name/header’s value to this’s headers.
      if (headers instanceof HeadersList) {
        for (const [key, val] of headers) {
          headersList.append(key, val)
        }
        // Note: Copy the `set-cookie` meta-data.
        headersList.cookies = headers.cookies
      } else {
        // 5. Otherwise, fill this’s headers with headers.
        fillHeaders(this[kHeaders], headers)
      }
    }

    // 33. Let inputBody be input’s request’s body if input is a Request
    // object; otherwise null.
    const inputBody = input instanceof Request ? input[kState].body : null

    // 34. If either init["body"] exists and is non-null or inputBody is
    // non-null, and request’s method is `GET` or `HEAD`, then throw a
    // TypeError.
    if (
      (init.body != null || inputBody != null) &&
      (request.method === 'GET' || request.method === 'HEAD')
    ) {
      throw new TypeError('Request with GET/HEAD method cannot have body.')
    }

    // 35. Let initBody be null.
    let initBody = null

    // 36. If init["body"] exists and is non-null, then:
    if (init.body != null) {
      // 1. Let Content-Type be null.
      // 2. Set initBody and Content-Type to the result of extracting
      // init["body"], with keepalive set to request’s keepalive.
      const [extractedBody, contentType] = extractBody(
        init.body,
        request.keepalive
      )
      initBody = extractedBody

      // 3, If Content-Type is non-null and this’s headers’s header list does
      // not contain `Content-Type`, then append `Content-Type`/Content-Type to
      // this’s headers.
      if (contentType && !this[kHeaders][kHeadersList].contains('content-type', true)) {
        this[kHeaders].append('content-type', contentType)
      }
    }

    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise
    // inputBody.
    const inputOrInitBody = initBody ?? inputBody

    // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is
    // null, then:
    if (inputOrInitBody != null && inputOrInitBody.source == null) {
      // 1. If initBody is non-null and init["duplex"] does not exist,
      //    then throw a TypeError.
      if (initBody != null && init.duplex == null) {
        throw new TypeError('RequestInit: duplex option is required when sending a body.')
      }

      // 2. If this’s request’s mode is neither "same-origin" nor "cors",
      // then throw a TypeError.
      if (request.mode !== 'same-origin' && request.mode !== 'cors') {
        throw new TypeError(
          'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
        )
      }

      // 3. Set this’s request’s use-CORS-preflight flag.
      request.useCORSPreflightFlag = true
    }

    // 39. Let finalBody be inputOrInitBody.
    let finalBody = inputOrInitBody

    // 40. If initBody is null and inputBody is non-null, then:
    if (initBody == null && inputBody != null) {
      // 1. If input is unusable, then throw a TypeError.
      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
        throw new TypeError(
          'Cannot construct a Request with a Request object that has already been used.'
        )
      }

      // 2. Set finalBody to the result of creating a proxy for inputBody.
      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy
      const identityTransform = new TransformStream()
      inputBody.stream.pipeThrough(identityTransform)
      finalBody = {
        source: inputBody.source,
        length: inputBody.length,
        stream: identityTransform.readable
      }
    }

    // 41. Set this’s request’s body to finalBody.
    this[kState].body = finalBody
  }

  // Returns request’s HTTP method, which is "GET" by default.
  get method () {
    webidl.brandCheck(this, Request)

    // The method getter steps are to return this’s request’s method.
    return this[kState].method
  }

  // Returns the URL of request as a string.
  get url () {
    webidl.brandCheck(this, Request)

    // The url getter steps are to return this’s request’s URL, serialized.
    return URLSerializer(this[kState].url)
  }

  // Returns a Headers object consisting of the headers associated with request.
  // Note that headers added in the network layer by the user agent will not
  // be accounted for in this object, e.g., the "Host" header.
  get headers () {
    webidl.brandCheck(this, Request)

    // The headers getter steps are to return this’s headers.
    return this[kHeaders]
  }

  // Returns the kind of resource requested by request, e.g., "document"
  // or "script".
  get destination () {
    webidl.brandCheck(this, Request)

    // The destination getter are to return this’s request’s destination.
    return this[kState].destination
  }

  // Returns the referrer of request. Its value can be a same-origin URL if
  // explicitly set in init, the empty string to indicate no referrer, and
  // "about:client" when defaulting to the global’s default. This is used
  // during fetching to determine the value of the `Referer` header of the
  // request being made.
  get referrer () {
    webidl.brandCheck(this, Request)

    // 1. If this’s request’s referrer is "no-referrer", then return the
    // empty string.
    if (this[kState].referrer === 'no-referrer') {
      return ''
    }

    // 2. If this’s request’s referrer is "client", then return
    // "about:client".
    if (this[kState].referrer === 'client') {
      return 'about:client'
    }

    // Return this’s request’s referrer, serialized.
    return this[kState].referrer.toString()
  }

  // Returns the referrer policy associated with request.
  // This is used during fetching to compute the value of the request’s
  // referrer.
  get referrerPolicy () {
    webidl.brandCheck(this, Request)

    // The referrerPolicy getter steps are to return this’s request’s referrer policy.
    return this[kState].referrerPolicy
  }

  // Returns the mode associated with request, which is a string indicating
  // whether the request will use CORS, or will be restricted to same-origin
  // URLs.
  get mode () {
    webidl.brandCheck(this, Request)

    // The mode getter steps are to return this’s request’s mode.
    return this[kState].mode
  }

  // Returns the credentials mode associated with request,
  // which is a string indicating whether credentials will be sent with the
  // request always, never, or only when sent to a same-origin URL.
  get credentials () {
    // The credentials getter steps are to return this’s request’s credentials mode.
    return this[kState].credentials
  }

  // Returns the cache mode associated with request,
  // which is a string indicating how the request will
  // interact with the browser’s cache when fetching.
  get cache () {
    webidl.brandCheck(this, Request)

    // The cache getter steps are to return this’s request’s cache mode.
    return this[kState].cache
  }

  // Returns the redirect mode associated with request,
  // which is a string indicating how redirects for the
  // request will be handled during fetching. A request
  // will follow redirects by default.
  get redirect () {
    webidl.brandCheck(this, Request)

    // The redirect getter steps are to return this’s request’s redirect mode.
    return this[kState].redirect
  }

  // Returns request’s subresource integrity metadata, which is a
  // cryptographic hash of the resource being fetched. Its value
  // consists of multiple hashes separated by whitespace. [SRI]
  get integrity () {
    webidl.brandCheck(this, Request)

    // The integrity getter steps are to return this’s request’s integrity
    // metadata.
    return this[kState].integrity
  }

  // Returns a boolean indicating whether or not request can outlive the
  // global in which it was created.
  get keepalive () {
    webidl.brandCheck(this, Request)

    // The keepalive getter steps are to return this’s request’s keepalive.
    return this[kState].keepalive
  }

  // Returns a boolean indicating whether or not request is for a reload
  // navigation.
  get isReloadNavigation () {
    webidl.brandCheck(this, Request)

    // The isReloadNavigation getter steps are to return true if this’s
    // request’s reload-navigation flag is set; otherwise false.
    return this[kState].reloadNavigation
  }

  // Returns a boolean indicating whether or not request is for a history
  // navigation (a.k.a. back-foward navigation).
  get isHistoryNavigation () {
    webidl.brandCheck(this, Request)

    // The isHistoryNavigation getter steps are to return true if this’s request’s
    // history-navigation flag is set; otherwise false.
    return this[kState].historyNavigation
  }

  // Returns the signal associated with request, which is an AbortSignal
  // object indicating whether or not request has been aborted, and its
  // abort event handler.
  get signal () {
    webidl.brandCheck(this, Request)

    // The signal getter steps are to return this’s signal.
    return this[kSignal]
  }

  get body () {
    webidl.brandCheck(this, Request)

    return this[kState].body ? this[kState].body.stream : null
  }

  get bodyUsed () {
    webidl.brandCheck(this, Request)

    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)
  }

  get duplex () {
    webidl.brandCheck(this, Request)

    return 'half'
  }

  // Returns a clone of request.
  clone () {
    webidl.brandCheck(this, Request)

    // 1. If this is unusable, then throw a TypeError.
    if (this.bodyUsed || this.body?.locked) {
      throw new TypeError('unusable')
    }

    // 2. Let clonedRequest be the result of cloning this’s request.
    const clonedRequest = cloneRequest(this[kState])

    // 3. Let clonedRequestObject be the result of creating a Request object,
    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.
    // 4. Make clonedRequestObject’s signal follow this’s signal.
    const ac = new AbortController()
    if (this.signal.aborted) {
      ac.abort(this.signal.reason)
    } else {
      util.addAbortListener(
        this.signal,
        () => {
          ac.abort(this.signal.reason)
        }
      )
    }

    // 4. Return clonedRequestObject.
    return fromInnerRequest(clonedRequest, ac.signal, this[kHeaders][kGuard], this[kRealm])
  }
}

mixinBody(Request)

function makeRequest (init) {
  // https://fetch.spec.whatwg.org/#requests
  const request = {
    method: 'GET',
    localURLsOnly: false,
    unsafeRequest: false,
    body: null,
    client: null,
    reservedClient: null,
    replacesClientId: '',
    window: 'client',
    keepalive: false,
    serviceWorkers: 'all',
    initiator: '',
    destination: '',
    priority: null,
    origin: 'client',
    policyContainer: 'client',
    referrer: 'client',
    referrerPolicy: '',
    mode: 'no-cors',
    useCORSPreflightFlag: false,
    credentials: 'same-origin',
    useCredentials: false,
    cache: 'default',
    redirect: 'follow',
    integrity: '',
    cryptoGraphicsNonceMetadata: '',
    parserMetadata: '',
    reloadNavigation: false,
    historyNavigation: false,
    userActivation: false,
    taintedOrigin: false,
    redirectCount: 0,
    responseTainting: 'basic',
    preventNoCacheCacheControlHeaderModification: false,
    done: false,
    timingAllowFailed: false,
    ...init,
    headersList: init.headersList
      ? new HeadersList(init.headersList)
      : new HeadersList()
  }
  request.url = request.urlList[0]
  return request
}

// https://fetch.spec.whatwg.org/#concept-request-clone
function cloneRequest (request) {
  // To clone a request request, run these steps:

  // 1. Let newRequest be a copy of request, except for its body.
  const newRequest = makeRequest({ ...request, body: null })

  // 2. If request’s body is non-null, set newRequest’s body to the
  // result of cloning request’s body.
  if (request.body != null) {
    newRequest.body = cloneBody(request.body)
  }

  // 3. Return newRequest.
  return newRequest
}

/**
 * @see https://fetch.spec.whatwg.org/#request-create
 * @param {any} innerRequest
 * @param {AbortSignal} signal
 * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard
 * @param {any} [realm]
 * @returns {Request}
 */
function fromInnerRequest (innerRequest, signal, guard, realm) {
  const request = new Request(kConstruct)
  request[kState] = innerRequest
  request[kRealm] = realm
  request[kSignal] = signal
  request[kSignal][kRealm] = realm
  request[kHeaders] = new Headers(kConstruct)
  request[kHeaders][kHeadersList] = innerRequest.headersList
  request[kHeaders][kGuard] = guard
  request[kHeaders][kRealm] = realm
  return request
}

Object.defineProperties(Request.prototype, {
  method: kEnumerableProperty,
  url: kEnumerableProperty,
  headers: kEnumerableProperty,
  redirect: kEnumerableProperty,
  clone: kEnumerableProperty,
  signal: kEnumerableProperty,
  duplex: kEnumerableProperty,
  destination: kEnumerableProperty,
  body: kEnumerableProperty,
  bodyUsed: kEnumerableProperty,
  isHistoryNavigation: kEnumerableProperty,
  isReloadNavigation: kEnumerableProperty,
  keepalive: kEnumerableProperty,
  integrity: kEnumerableProperty,
  cache: kEnumerableProperty,
  credentials: kEnumerableProperty,
  attribute: kEnumerableProperty,
  referrerPolicy: kEnumerableProperty,
  referrer: kEnumerableProperty,
  mode: kEnumerableProperty,
  [Symbol.toStringTag]: {
    value: 'Request',
    configurable: true
  }
})

webidl.converters.Request = webidl.interfaceConverter(
  Request
)

// https://fetch.spec.whatwg.org/#requestinfo
webidl.converters.RequestInfo = function (V) {
  if (typeof V === 'string') {
    return webidl.converters.USVString(V)
  }

  if (V instanceof Request) {
    return webidl.converters.Request(V)
  }

  return webidl.converters.USVString(V)
}

webidl.converters.AbortSignal = webidl.interfaceConverter(
  AbortSignal
)

// https://fetch.spec.whatwg.org/#requestinit
webidl.converters.RequestInit = webidl.dictionaryConverter([
  {
    key: 'method',
    converter: webidl.converters.ByteString
  },
  {
    key: 'headers',
    converter: webidl.converters.HeadersInit
  },
  {
    key: 'body',
    converter: webidl.nullableConverter(
      webidl.converters.BodyInit
    )
  },
  {
    key: 'referrer',
    converter: webidl.converters.USVString
  },
  {
    key: 'referrerPolicy',
    converter: webidl.converters.DOMString,
    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
    allowedValues: referrerPolicy
  },
  {
    key: 'mode',
    converter: webidl.converters.DOMString,
    // https://fetch.spec.whatwg.org/#concept-request-mode
    allowedValues: requestMode
  },
  {
    key: 'credentials',
    converter: webidl.converters.DOMString,
    // https://fetch.spec.whatwg.org/#requestcredentials
    allowedValues: requestCredentials
  },
  {
    key: 'cache',
    converter: webidl.converters.DOMString,
    // https://fetch.spec.whatwg.org/#requestcache
    allowedValues: requestCache
  },
  {
    key: 'redirect',
    converter: webidl.converters.DOMString,
    // https://fetch.spec.whatwg.org/#requestredirect
    allowedValues: requestRedirect
  },
  {
    key: 'integrity',
    converter: webidl.converters.DOMString
  },
  {
    key: 'keepalive',
    converter: webidl.converters.boolean
  },
  {
    key: 'signal',
    converter: webidl.nullableConverter(
      (signal) => webidl.converters.AbortSignal(
        signal,
        { strict: false }
      )
    )
  },
  {
    key: 'window',
    converter: webidl.converters.any
  },
  {
    key: 'duplex',
    converter: webidl.converters.DOMString,
    allowedValues: requestDuplex
  },
  {
    key: 'dispatcher', // undici specific option
    converter: webidl.converters.any
  }
])

module.exports = { Request, makeRequest, fromInnerRequest, cloneRequest }


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/response.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/response.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Headers, HeadersList, fill } = __webpack_require__(/*! ./headers */ "./node_modules/undici/lib/web/fetch/headers.js")
const { extractBody, cloneBody, mixinBody } = __webpack_require__(/*! ./body */ "./node_modules/undici/lib/web/fetch/body.js")
const util = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const { kEnumerableProperty } = util
const {
  isValidReasonPhrase,
  isCancelled,
  isAborted,
  isBlobLike,
  serializeJavascriptValueToJSONString,
  isErrorLike,
  isomorphicEncode
} = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/fetch/util.js")
const {
  redirectStatusSet,
  nullBodyStatus
} = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/web/fetch/constants.js")
const { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/fetch/symbols.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { FormData } = __webpack_require__(/*! ./formdata */ "./node_modules/undici/lib/web/fetch/formdata.js")
const { getGlobalOrigin } = __webpack_require__(/*! ./global */ "./node_modules/undici/lib/web/fetch/global.js")
const { URLSerializer } = __webpack_require__(/*! ./data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")
const { kHeadersList, kConstruct } = __webpack_require__(/*! ../../core/symbols */ "./node_modules/undici/lib/core/symbols.js")
const assert = __webpack_require__(/*! node:assert */ "node:assert")
const { types } = __webpack_require__(/*! node:util */ "node:util")

const textEncoder = new TextEncoder('utf-8')

// https://fetch.spec.whatwg.org/#response-class
class Response {
  // Creates network error Response.
  static error () {
    // TODO
    const relevantRealm = { settingsObject: {} }

    // The static error() method steps are to return the result of creating a
    // Response object, given a new network error, "immutable", and this’s
    // relevant Realm.
    const responseObject = fromInnerResponse(makeNetworkError(), 'immutable', relevantRealm)

    return responseObject
  }

  // https://fetch.spec.whatwg.org/#dom-response-json
  static json (data, init = {}) {
    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.json' })

    if (init !== null) {
      init = webidl.converters.ResponseInit(init)
    }

    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.
    const bytes = textEncoder.encode(
      serializeJavascriptValueToJSONString(data)
    )

    // 2. Let body be the result of extracting bytes.
    const body = extractBody(bytes)

    // 3. Let responseObject be the result of creating a Response object, given a new response,
    //    "response", and this’s relevant Realm.
    const relevantRealm = { settingsObject: {} }
    const responseObject = fromInnerResponse(makeResponse({}), 'response', relevantRealm)

    // 4. Perform initialize a response given responseObject, init, and (body, "application/json").
    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })

    // 5. Return responseObject.
    return responseObject
  }

  // Creates a redirect Response that redirects to url with status status.
  static redirect (url, status = 302) {
    const relevantRealm = { settingsObject: {} }

    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.redirect' })

    url = webidl.converters.USVString(url)
    status = webidl.converters['unsigned short'](status)

    // 1. Let parsedURL be the result of parsing url with current settings
    // object’s API base URL.
    // 2. If parsedURL is failure, then throw a TypeError.
    // TODO: base-URL?
    let parsedURL
    try {
      parsedURL = new URL(url, getGlobalOrigin())
    } catch (err) {
      throw new TypeError(`Failed to parse URL from ${url}`, { cause: err })
    }

    // 3. If status is not a redirect status, then throw a RangeError.
    if (!redirectStatusSet.has(status)) {
      throw new RangeError(`Invalid status code ${status}`)
    }

    // 4. Let responseObject be the result of creating a Response object,
    // given a new response, "immutable", and this’s relevant Realm.
    const responseObject = fromInnerResponse(makeResponse({}), 'immutable', relevantRealm)

    // 5. Set responseObject’s response’s status to status.
    responseObject[kState].status = status

    // 6. Let value be parsedURL, serialized and isomorphic encoded.
    const value = isomorphicEncode(URLSerializer(parsedURL))

    // 7. Append `Location`/value to responseObject’s response’s header list.
    responseObject[kState].headersList.append('location', value, true)

    // 8. Return responseObject.
    return responseObject
  }

  // https://fetch.spec.whatwg.org/#dom-response
  constructor (body = null, init = {}) {
    if (body === kConstruct) {
      return
    }

    if (body !== null) {
      body = webidl.converters.BodyInit(body)
    }

    init = webidl.converters.ResponseInit(init)

    // TODO
    this[kRealm] = { settingsObject: {} }

    // 1. Set this’s response to a new response.
    this[kState] = makeResponse({})

    // 2. Set this’s headers to a new Headers object with this’s relevant
    // Realm, whose header list is this’s response’s header list and guard
    // is "response".
    this[kHeaders] = new Headers(kConstruct)
    this[kHeaders][kGuard] = 'response'
    this[kHeaders][kHeadersList] = this[kState].headersList
    this[kHeaders][kRealm] = this[kRealm]

    // 3. Let bodyWithType be null.
    let bodyWithType = null

    // 4. If body is non-null, then set bodyWithType to the result of extracting body.
    if (body != null) {
      const [extractedBody, type] = extractBody(body)
      bodyWithType = { body: extractedBody, type }
    }

    // 5. Perform initialize a response given this, init, and bodyWithType.
    initializeResponse(this, init, bodyWithType)
  }

  // Returns response’s type, e.g., "cors".
  get type () {
    webidl.brandCheck(this, Response)

    // The type getter steps are to return this’s response’s type.
    return this[kState].type
  }

  // Returns response’s URL, if it has one; otherwise the empty string.
  get url () {
    webidl.brandCheck(this, Response)

    const urlList = this[kState].urlList

    // The url getter steps are to return the empty string if this’s
    // response’s URL is null; otherwise this’s response’s URL,
    // serialized with exclude fragment set to true.
    const url = urlList[urlList.length - 1] ?? null

    if (url === null) {
      return ''
    }

    return URLSerializer(url, true)
  }

  // Returns whether response was obtained through a redirect.
  get redirected () {
    webidl.brandCheck(this, Response)

    // The redirected getter steps are to return true if this’s response’s URL
    // list has more than one item; otherwise false.
    return this[kState].urlList.length > 1
  }

  // Returns response’s status.
  get status () {
    webidl.brandCheck(this, Response)

    // The status getter steps are to return this’s response’s status.
    return this[kState].status
  }

  // Returns whether response’s status is an ok status.
  get ok () {
    webidl.brandCheck(this, Response)

    // The ok getter steps are to return true if this’s response’s status is an
    // ok status; otherwise false.
    return this[kState].status >= 200 && this[kState].status <= 299
  }

  // Returns response’s status message.
  get statusText () {
    webidl.brandCheck(this, Response)

    // The statusText getter steps are to return this’s response’s status
    // message.
    return this[kState].statusText
  }

  // Returns response’s headers as Headers.
  get headers () {
    webidl.brandCheck(this, Response)

    // The headers getter steps are to return this’s headers.
    return this[kHeaders]
  }

  get body () {
    webidl.brandCheck(this, Response)

    return this[kState].body ? this[kState].body.stream : null
  }

  get bodyUsed () {
    webidl.brandCheck(this, Response)

    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)
  }

  // Returns a clone of response.
  clone () {
    webidl.brandCheck(this, Response)

    // 1. If this is unusable, then throw a TypeError.
    if (this.bodyUsed || this.body?.locked) {
      throw webidl.errors.exception({
        header: 'Response.clone',
        message: 'Body has already been consumed.'
      })
    }

    // 2. Let clonedResponse be the result of cloning this’s response.
    const clonedResponse = cloneResponse(this[kState])

    // 3. Return the result of creating a Response object, given
    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.
    return fromInnerResponse(clonedResponse, this[kHeaders][kGuard], this[kRealm])
  }
}

mixinBody(Response)

Object.defineProperties(Response.prototype, {
  type: kEnumerableProperty,
  url: kEnumerableProperty,
  status: kEnumerableProperty,
  ok: kEnumerableProperty,
  redirected: kEnumerableProperty,
  statusText: kEnumerableProperty,
  headers: kEnumerableProperty,
  clone: kEnumerableProperty,
  body: kEnumerableProperty,
  bodyUsed: kEnumerableProperty,
  [Symbol.toStringTag]: {
    value: 'Response',
    configurable: true
  }
})

Object.defineProperties(Response, {
  json: kEnumerableProperty,
  redirect: kEnumerableProperty,
  error: kEnumerableProperty
})

// https://fetch.spec.whatwg.org/#concept-response-clone
function cloneResponse (response) {
  // To clone a response response, run these steps:

  // 1. If response is a filtered response, then return a new identical
  // filtered response whose internal response is a clone of response’s
  // internal response.
  if (response.internalResponse) {
    return filterResponse(
      cloneResponse(response.internalResponse),
      response.type
    )
  }

  // 2. Let newResponse be a copy of response, except for its body.
  const newResponse = makeResponse({ ...response, body: null })

  // 3. If response’s body is non-null, then set newResponse’s body to the
  // result of cloning response’s body.
  if (response.body != null) {
    newResponse.body = cloneBody(response.body)
  }

  // 4. Return newResponse.
  return newResponse
}

function makeResponse (init) {
  return {
    aborted: false,
    rangeRequested: false,
    timingAllowPassed: false,
    requestIncludesCredentials: false,
    type: 'default',
    status: 200,
    timingInfo: null,
    cacheState: '',
    statusText: '',
    ...init,
    headersList: init?.headersList
      ? new HeadersList(init?.headersList)
      : new HeadersList(),
    urlList: init?.urlList ? [...init.urlList] : []
  }
}

function makeNetworkError (reason) {
  const isError = isErrorLike(reason)
  return makeResponse({
    type: 'error',
    status: 0,
    error: isError
      ? reason
      : new Error(reason ? String(reason) : reason),
    aborted: reason && reason.name === 'AbortError'
  })
}

// @see https://fetch.spec.whatwg.org/#concept-network-error
function isNetworkError (response) {
  return (
    // A network error is a response whose type is "error",
    response.type === 'error' &&
    // status is 0
    response.status === 0
  )
}

function makeFilteredResponse (response, state) {
  state = {
    internalResponse: response,
    ...state
  }

  return new Proxy(response, {
    get (target, p) {
      return p in state ? state[p] : target[p]
    },
    set (target, p, value) {
      assert(!(p in state))
      target[p] = value
      return true
    }
  })
}

// https://fetch.spec.whatwg.org/#concept-filtered-response
function filterResponse (response, type) {
  // Set response to the following filtered response with response as its
  // internal response, depending on request’s response tainting:
  if (type === 'basic') {
    // A basic filtered response is a filtered response whose type is "basic"
    // and header list excludes any headers in internal response’s header list
    // whose name is a forbidden response-header name.

    // Note: undici does not implement forbidden response-header names
    return makeFilteredResponse(response, {
      type: 'basic',
      headersList: response.headersList
    })
  } else if (type === 'cors') {
    // A CORS filtered response is a filtered response whose type is "cors"
    // and header list excludes any headers in internal response’s header
    // list whose name is not a CORS-safelisted response-header name, given
    // internal response’s CORS-exposed header-name list.

    // Note: undici does not implement CORS-safelisted response-header names
    return makeFilteredResponse(response, {
      type: 'cors',
      headersList: response.headersList
    })
  } else if (type === 'opaque') {
    // An opaque filtered response is a filtered response whose type is
    // "opaque", URL list is the empty list, status is 0, status message
    // is the empty byte sequence, header list is empty, and body is null.

    return makeFilteredResponse(response, {
      type: 'opaque',
      urlList: Object.freeze([]),
      status: 0,
      statusText: '',
      body: null
    })
  } else if (type === 'opaqueredirect') {
    // An opaque-redirect filtered response is a filtered response whose type
    // is "opaqueredirect", status is 0, status message is the empty byte
    // sequence, header list is empty, and body is null.

    return makeFilteredResponse(response, {
      type: 'opaqueredirect',
      status: 0,
      statusText: '',
      headersList: [],
      body: null
    })
  } else {
    assert(false)
  }
}

// https://fetch.spec.whatwg.org/#appropriate-network-error
function makeAppropriateNetworkError (fetchParams, err = null) {
  // 1. Assert: fetchParams is canceled.
  assert(isCancelled(fetchParams))

  // 2. Return an aborted network error if fetchParams is aborted;
  // otherwise return a network error.
  return isAborted(fetchParams)
    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))
    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))
}

// https://whatpr.org/fetch/1392.html#initialize-a-response
function initializeResponse (response, init, body) {
  // 1. If init["status"] is not in the range 200 to 599, inclusive, then
  //    throw a RangeError.
  if (init.status !== null && (init.status < 200 || init.status > 599)) {
    throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.')
  }

  // 2. If init["statusText"] does not match the reason-phrase token production,
  //    then throw a TypeError.
  if ('statusText' in init && init.statusText != null) {
    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:
    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )
    if (!isValidReasonPhrase(String(init.statusText))) {
      throw new TypeError('Invalid statusText')
    }
  }

  // 3. Set response’s response’s status to init["status"].
  if ('status' in init && init.status != null) {
    response[kState].status = init.status
  }

  // 4. Set response’s response’s status message to init["statusText"].
  if ('statusText' in init && init.statusText != null) {
    response[kState].statusText = init.statusText
  }

  // 5. If init["headers"] exists, then fill response’s headers with init["headers"].
  if ('headers' in init && init.headers != null) {
    fill(response[kHeaders], init.headers)
  }

  // 6. If body was given, then:
  if (body) {
    // 1. If response's status is a null body status, then throw a TypeError.
    if (nullBodyStatus.includes(response.status)) {
      throw webidl.errors.exception({
        header: 'Response constructor',
        message: `Invalid response status code ${response.status}`
      })
    }

    // 2. Set response's body to body's body.
    response[kState].body = body.body

    // 3. If body's type is non-null and response's header list does not contain
    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.
    if (body.type != null && !response[kState].headersList.contains('content-type', true)) {
      response[kState].headersList.append('content-type', body.type, true)
    }
  }
}

/**
 * @see https://fetch.spec.whatwg.org/#response-create
 * @param {any} innerResponse
 * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard
 * @param {any} [realm]
 * @returns {Response}
 */
function fromInnerResponse (innerResponse, guard, realm) {
  const response = new Response(kConstruct)
  response[kState] = innerResponse
  response[kRealm] = realm
  response[kHeaders] = new Headers(kConstruct)
  response[kHeaders][kHeadersList] = innerResponse.headersList
  response[kHeaders][kGuard] = guard
  response[kHeaders][kRealm] = realm
  return response
}

webidl.converters.ReadableStream = webidl.interfaceConverter(
  ReadableStream
)

webidl.converters.FormData = webidl.interfaceConverter(
  FormData
)

webidl.converters.URLSearchParams = webidl.interfaceConverter(
  URLSearchParams
)

// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit
webidl.converters.XMLHttpRequestBodyInit = function (V) {
  if (typeof V === 'string') {
    return webidl.converters.USVString(V)
  }

  if (isBlobLike(V)) {
    return webidl.converters.Blob(V, { strict: false })
  }

  if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
    return webidl.converters.BufferSource(V)
  }

  if (util.isFormDataLike(V)) {
    return webidl.converters.FormData(V, { strict: false })
  }

  if (V instanceof URLSearchParams) {
    return webidl.converters.URLSearchParams(V)
  }

  return webidl.converters.DOMString(V)
}

// https://fetch.spec.whatwg.org/#bodyinit
webidl.converters.BodyInit = function (V) {
  if (V instanceof ReadableStream) {
    return webidl.converters.ReadableStream(V)
  }

  // Note: the spec doesn't include async iterables,
  // this is an undici extension.
  if (V?.[Symbol.asyncIterator]) {
    return V
  }

  return webidl.converters.XMLHttpRequestBodyInit(V)
}

webidl.converters.ResponseInit = webidl.dictionaryConverter([
  {
    key: 'status',
    converter: webidl.converters['unsigned short'],
    defaultValue: 200
  },
  {
    key: 'statusText',
    converter: webidl.converters.ByteString,
    defaultValue: ''
  },
  {
    key: 'headers',
    converter: webidl.converters.HeadersInit
  }
])

module.exports = {
  isNetworkError,
  makeNetworkError,
  makeResponse,
  makeAppropriateNetworkError,
  filterResponse,
  Response,
  cloneResponse,
  fromInnerResponse
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  kUrl: Symbol('url'),
  kHeaders: Symbol('headers'),
  kSignal: Symbol('signal'),
  kState: Symbol('state'),
  kGuard: Symbol('guard'),
  kRealm: Symbol('realm'),
  kDispatcher: Symbol('dispatcher')
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const { Transform } = __webpack_require__(/*! node:stream */ "node:stream")
const zlib = __webpack_require__(/*! node:zlib */ "node:zlib")
const { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/web/fetch/constants.js")
const { getGlobalOrigin } = __webpack_require__(/*! ./global */ "./node_modules/undici/lib/web/fetch/global.js")
const { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = __webpack_require__(/*! ./data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")
const { performance } = __webpack_require__(/*! node:perf_hooks */ "node:perf_hooks")
const { isBlobLike, ReadableStreamFrom, isValidHTTPToken } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const assert = __webpack_require__(/*! node:assert */ "node:assert")
const { isUint8Array } = __webpack_require__(/*! node:util/types */ "node:util/types")
const { webidl } = __webpack_require__(/*! ./webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")

// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable
/** @type {import('crypto')} */
let crypto
try {
  crypto = __webpack_require__(/*! node:crypto */ "node:crypto")
/* c8 ignore next 3 */
} catch {

}

function responseURL (response) {
  // https://fetch.spec.whatwg.org/#responses
  // A response has an associated URL. It is a pointer to the last URL
  // in response’s URL list and null if response’s URL list is empty.
  const urlList = response.urlList
  const length = urlList.length
  return length === 0 ? null : urlList[length - 1].toString()
}

// https://fetch.spec.whatwg.org/#concept-response-location-url
function responseLocationURL (response, requestFragment) {
  // 1. If response’s status is not a redirect status, then return null.
  if (!redirectStatusSet.has(response.status)) {
    return null
  }

  // 2. Let location be the result of extracting header list values given
  // `Location` and response’s header list.
  let location = response.headersList.get('location', true)

  // 3. If location is a header value, then set location to the result of
  //    parsing location with response’s URL.
  if (location !== null && isValidHeaderValue(location)) {
    location = new URL(location, responseURL(response))
  }

  // 4. If location is a URL whose fragment is null, then set location’s
  // fragment to requestFragment.
  if (location && !location.hash) {
    location.hash = requestFragment
  }

  // 5. Return location.
  return location
}

/** @returns {URL} */
function requestCurrentURL (request) {
  return request.urlList[request.urlList.length - 1]
}

function requestBadPort (request) {
  // 1. Let url be request’s current URL.
  const url = requestCurrentURL(request)

  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,
  // then return blocked.
  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
    return 'blocked'
  }

  // 3. Return allowed.
  return 'allowed'
}

function isErrorLike (object) {
  return object instanceof Error || (
    object?.constructor?.name === 'Error' ||
    object?.constructor?.name === 'DOMException'
  )
}

// Check whether |statusText| is a ByteString and
// matches the Reason-Phrase token production.
// RFC 2616: https://tools.ietf.org/html/rfc2616
// RFC 7230: https://tools.ietf.org/html/rfc7230
// "reason-phrase = *( HTAB / SP / VCHAR / obs-text )"
// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116
function isValidReasonPhrase (statusText) {
  for (let i = 0; i < statusText.length; ++i) {
    const c = statusText.charCodeAt(i)
    if (
      !(
        (
          c === 0x09 || // HTAB
          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR
          (c >= 0x80 && c <= 0xff)
        ) // obs-text
      )
    ) {
      return false
    }
  }
  return true
}

/**
 * @see https://fetch.spec.whatwg.org/#header-name
 * @param {string} potentialValue
 */
const isValidHeaderName = isValidHTTPToken

/**
 * @see https://fetch.spec.whatwg.org/#header-value
 * @param {string} potentialValue
 */
function isValidHeaderValue (potentialValue) {
  // - Has no leading or trailing HTTP tab or space bytes.
  // - Contains no 0x00 (NUL) or HTTP newline bytes.
  if (
    potentialValue.startsWith('\t') ||
    potentialValue.startsWith(' ') ||
    potentialValue.endsWith('\t') ||
    potentialValue.endsWith(' ')
  ) {
    return false
  }

  if (
    potentialValue.includes('\0') ||
    potentialValue.includes('\r') ||
    potentialValue.includes('\n')
  ) {
    return false
  }

  return true
}

// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect
function setRequestReferrerPolicyOnRedirect (request, actualResponse) {
  //  Given a request request and a response actualResponse, this algorithm
  //  updates request’s referrer policy according to the Referrer-Policy
  //  header (if any) in actualResponse.

  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy
  // from a Referrer-Policy header on actualResponse.

  // 8.1 Parse a referrer policy from a Referrer-Policy header
  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.
  const { headersList } = actualResponse
  // 2. Let policy be the empty string.
  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.
  // 4. Return policy.
  const policyHeader = (headersList.get('referrer-policy', true) ?? '').split(',')

  // Note: As the referrer-policy can contain multiple policies
  // separated by comma, we need to loop through all of them
  // and pick the first valid one.
  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy
  let policy = ''
  if (policyHeader.length > 0) {
    // The right-most policy takes precedence.
    // The left-most policy is the fallback.
    for (let i = policyHeader.length; i !== 0; i--) {
      const token = policyHeader[i - 1].trim()
      if (referrerPolicyTokens.has(token)) {
        policy = token
        break
      }
    }
  }

  // 2. If policy is not the empty string, then set request’s referrer policy to policy.
  if (policy !== '') {
    request.referrerPolicy = policy
  }
}

// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check
function crossOriginResourcePolicyCheck () {
  // TODO
  return 'allowed'
}

// https://fetch.spec.whatwg.org/#concept-cors-check
function corsCheck () {
  // TODO
  return 'success'
}

// https://fetch.spec.whatwg.org/#concept-tao-check
function TAOCheck () {
  // TODO
  return 'success'
}

function appendFetchMetadata (httpRequest) {
  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header
  //  TODO

  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header

  //  1. Assert: r’s url is a potentially trustworthy URL.
  //  TODO

  //  2. Let header be a Structured Header whose value is a token.
  let header = null

  //  3. Set header’s value to r’s mode.
  header = httpRequest.mode

  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.
  httpRequest.headersList.set('sec-fetch-mode', header, true)

  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header
  //  TODO

  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header
  //  TODO
}

// https://fetch.spec.whatwg.org/#append-a-request-origin-header
function appendRequestOriginHeader (request) {
  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.
  let serializedOrigin = request.origin

  // 2. If request’s response tainting is "cors" or request’s mode is "websocket", then append (`Origin`, serializedOrigin) to request’s header list.
  if (request.responseTainting === 'cors' || request.mode === 'websocket') {
    if (serializedOrigin) {
      request.headersList.append('origin', serializedOrigin, true)
    }

  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:
  } else if (request.method !== 'GET' && request.method !== 'HEAD') {
    // 1. Switch on request’s referrer policy:
    switch (request.referrerPolicy) {
      case 'no-referrer':
        // Set serializedOrigin to `null`.
        serializedOrigin = null
        break
      case 'no-referrer-when-downgrade':
      case 'strict-origin':
      case 'strict-origin-when-cross-origin':
        // If request’s origin is a tuple origin, its scheme is "https", and request’s current URL’s scheme is not "https", then set serializedOrigin to `null`.
        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
          serializedOrigin = null
        }
        break
      case 'same-origin':
        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.
        if (!sameOrigin(request, requestCurrentURL(request))) {
          serializedOrigin = null
        }
        break
      default:
        // Do nothing.
    }

    if (serializedOrigin) {
      // 2. Append (`Origin`, serializedOrigin) to request’s header list.
      request.headersList.append('origin', serializedOrigin, true)
    }
  }
}

// https://w3c.github.io/hr-time/#dfn-coarsen-time
function coarsenTime (timestamp, crossOriginIsolatedCapability) {
  // TODO
  return timestamp
}

// https://fetch.spec.whatwg.org/#clamp-and-coarsen-connection-timing-info
function clampAndCoarsenConnectionTimingInfo (connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
  if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {
    return {
      domainLookupStartTime: defaultStartTime,
      domainLookupEndTime: defaultStartTime,
      connectionStartTime: defaultStartTime,
      connectionEndTime: defaultStartTime,
      secureConnectionStartTime: defaultStartTime,
      ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol
    }
  }

  return {
    domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),
    domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),
    connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),
    connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),
    secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),
    ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
  }
}

// https://w3c.github.io/hr-time/#dfn-coarsened-shared-current-time
function coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {
  return coarsenTime(performance.now(), crossOriginIsolatedCapability)
}

// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info
function createOpaqueTimingInfo (timingInfo) {
  return {
    startTime: timingInfo.startTime ?? 0,
    redirectStartTime: 0,
    redirectEndTime: 0,
    postRedirectStartTime: timingInfo.startTime ?? 0,
    finalServiceWorkerStartTime: 0,
    finalNetworkResponseStartTime: 0,
    finalNetworkRequestStartTime: 0,
    endTime: 0,
    encodedBodySize: 0,
    decodedBodySize: 0,
    finalConnectionTimingInfo: null
  }
}

// https://html.spec.whatwg.org/multipage/origin.html#policy-container
function makePolicyContainer () {
  // Note: the fetch spec doesn't make use of embedder policy or CSP list
  return {
    referrerPolicy: 'strict-origin-when-cross-origin'
  }
}

// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container
function clonePolicyContainer (policyContainer) {
  return {
    referrerPolicy: policyContainer.referrerPolicy
  }
}

// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer
function determineRequestsReferrer (request) {
  // 1. Let policy be request's referrer policy.
  const policy = request.referrerPolicy

  // Note: policy cannot (shouldn't) be null or an empty string.
  assert(policy)

  // 2. Let environment be request’s client.

  let referrerSource = null

  // 3. Switch on request’s referrer:
  if (request.referrer === 'client') {
    // Note: node isn't a browser and doesn't implement document/iframes,
    // so we bypass this step and replace it with our own.

    const globalOrigin = getGlobalOrigin()

    if (!globalOrigin || globalOrigin.origin === 'null') {
      return 'no-referrer'
    }

    // note: we need to clone it as it's mutated
    referrerSource = new URL(globalOrigin)
  } else if (request.referrer instanceof URL) {
    // Let referrerSource be request’s referrer.
    referrerSource = request.referrer
  }

  // 4. Let request’s referrerURL be the result of stripping referrerSource for
  //    use as a referrer.
  let referrerURL = stripURLForReferrer(referrerSource)

  // 5. Let referrerOrigin be the result of stripping referrerSource for use as
  //    a referrer, with the origin-only flag set to true.
  const referrerOrigin = stripURLForReferrer(referrerSource, true)

  // 6. If the result of serializing referrerURL is a string whose length is
  //    greater than 4096, set referrerURL to referrerOrigin.
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin
  }

  const areSameOrigin = sameOrigin(request, referrerURL)
  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&
    !isURLPotentiallyTrustworthy(request.url)

  // 8. Execute the switch statements corresponding to the value of policy:
  switch (policy) {
    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)
    case 'unsafe-url': return referrerURL
    case 'same-origin':
      return areSameOrigin ? referrerOrigin : 'no-referrer'
    case 'origin-when-cross-origin':
      return areSameOrigin ? referrerURL : referrerOrigin
    case 'strict-origin-when-cross-origin': {
      const currentURL = requestCurrentURL(request)

      // 1. If the origin of referrerURL and the origin of request’s current
      //    URL are the same, then return referrerURL.
      if (sameOrigin(referrerURL, currentURL)) {
        return referrerURL
      }

      // 2. If referrerURL is a potentially trustworthy URL and request’s
      //    current URL is not a potentially trustworthy URL, then return no
      //    referrer.
      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
        return 'no-referrer'
      }

      // 3. Return referrerOrigin.
      return referrerOrigin
    }
    case 'strict-origin': // eslint-disable-line
      /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * request’s current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
        */
    case 'no-referrer-when-downgrade': // eslint-disable-line
      /**
       * 1. If referrerURL is a potentially trustworthy URL and
       * request’s current URL is not a potentially trustworthy URL,
       * then return no referrer.
       * 2. Return referrerOrigin
      */

    default: // eslint-disable-line
      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin
  }
}

/**
 * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url
 * @param {URL} url
 * @param {boolean|undefined} originOnly
 */
function stripURLForReferrer (url, originOnly) {
  // 1. Assert: url is a URL.
  assert(url instanceof URL)

  url = new URL(url)

  // 2. If url’s scheme is a local scheme, then return no referrer.
  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {
    return 'no-referrer'
  }

  // 3. Set url’s username to the empty string.
  url.username = ''

  // 4. Set url’s password to the empty string.
  url.password = ''

  // 5. Set url’s fragment to null.
  url.hash = ''

  // 6. If the origin-only flag is true, then:
  if (originOnly) {
    // 1. Set url’s path to « the empty string ».
    url.pathname = ''

    // 2. Set url’s query to null.
    url.search = ''
  }

  // 7. Return url.
  return url
}

function isURLPotentiallyTrustworthy (url) {
  if (!(url instanceof URL)) {
    return false
  }

  // If child of about, return true
  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {
    return true
  }

  // If scheme is data, return true
  if (url.protocol === 'data:') return true

  // If file, return true
  if (url.protocol === 'file:') return true

  return isOriginPotentiallyTrustworthy(url.origin)

  function isOriginPotentiallyTrustworthy (origin) {
    // If origin is explicitly null, return false
    if (origin == null || origin === 'null') return false

    const originAsURL = new URL(origin)

    // If secure, return true
    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {
      return true
    }

    // If localhost or variants, return true
    if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) ||
     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||
     (originAsURL.hostname.endsWith('.localhost'))) {
      return true
    }

    // If any other, return false
    return false
  }
}

/**
 * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
 * @param {Uint8Array} bytes
 * @param {string} metadataList
 */
function bytesMatch (bytes, metadataList) {
  // If node is not built with OpenSSL support, we cannot check
  // a request's integrity, so allow it by default (the spec will
  // allow requests if an invalid hash is given, as precedence).
  /* istanbul ignore if: only if node is built with --without-ssl */
  if (crypto === undefined) {
    return true
  }

  // 1. Let parsedMetadata be the result of parsing metadataList.
  const parsedMetadata = parseMetadata(metadataList)

  // 2. If parsedMetadata is no metadata, return true.
  if (parsedMetadata === 'no metadata') {
    return true
  }

  // 3. If parsedMetadata is the empty set, return true.
  if (parsedMetadata.length === 0) {
    return true
  }

  // 4. Let metadata be the result of getting the strongest
  //    metadata from parsedMetadata.
  const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo))
  // get the strongest algorithm
  const strongest = list[0].algo
  // get all entries that use the strongest algorithm; ignore weaker
  const metadata = list.filter((item) => item.algo === strongest)

  // 5. For each item in metadata:
  for (const item of metadata) {
    // 1. Let algorithm be the alg component of item.
    const algorithm = item.algo

    // 2. Let expectedValue be the val component of item.
    let expectedValue = item.hash

    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e
    // "be liberal with padding". This is annoying, and it's not even in the spec.

    if (expectedValue.endsWith('==')) {
      expectedValue = expectedValue.slice(0, -2)
    }

    // 3. Let actualValue be the result of applying algorithm to bytes.
    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')

    if (actualValue.endsWith('==')) {
      actualValue = actualValue.slice(0, -2)
    }

    // 4. If actualValue is a case-sensitive match for expectedValue,
    //    return true.
    if (actualValue === expectedValue) {
      return true
    }

    let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest('base64url')

    if (actualBase64URL.endsWith('==')) {
      actualBase64URL = actualBase64URL.slice(0, -2)
    }

    if (actualBase64URL === expectedValue) {
      return true
    }
  }

  // 6. Return false.
  return false
}

// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options
// https://www.w3.org/TR/CSP2/#source-list-syntax
// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1
const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-(?<hash>[A-Za-z0-9+/]+={0,2}(?=\s|$))( +[!-~]*)?/i

/**
 * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
 * @param {string} metadata
 */
function parseMetadata (metadata) {
  // 1. Let result be the empty set.
  /** @type {{ algo: string, hash: string }[]} */
  const result = []

  // 2. Let empty be equal to true.
  let empty = true

  const supportedHashes = crypto.getHashes()

  // 3. For each token returned by splitting metadata on spaces:
  for (const token of metadata.split(' ')) {
    // 1. Set empty to false.
    empty = false

    // 2. Parse token as a hash-with-options.
    const parsedToken = parseHashWithOptions.exec(token)

    // 3. If token does not parse, continue to the next token.
    if (parsedToken === null || parsedToken.groups === undefined) {
      // Note: Chromium blocks the request at this point, but Firefox
      // gives a warning that an invalid integrity was given. The
      // correct behavior is to ignore these, and subsequently not
      // check the integrity of the resource.
      continue
    }

    // 4. Let algorithm be the hash-algo component of token.
    const algorithm = parsedToken.groups.algo

    // 5. If algorithm is a hash function recognized by the user
    //    agent, add the parsed token to result.
    if (supportedHashes.includes(algorithm.toLowerCase())) {
      result.push(parsedToken.groups)
    }
  }

  // 4. Return no metadata if empty is true, otherwise return result.
  if (empty === true) {
    return 'no metadata'
  }

  return result
}

// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request
function tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {
  // TODO
}

/**
 * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
 * @param {URL} A
 * @param {URL} B
 */
function sameOrigin (A, B) {
  // 1. If A and B are the same opaque origin, then return true.
  if (A.origin === B.origin && A.origin === 'null') {
    return true
  }

  // 2. If A and B are both tuple origins and their schemes,
  //    hosts, and port are identical, then return true.
  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
    return true
  }

  // 3. Return false.
  return false
}

function createDeferredPromise () {
  let res
  let rej
  const promise = new Promise((resolve, reject) => {
    res = resolve
    rej = reject
  })

  return { promise, resolve: res, reject: rej }
}

function isAborted (fetchParams) {
  return fetchParams.controller.state === 'aborted'
}

function isCancelled (fetchParams) {
  return fetchParams.controller.state === 'aborted' ||
    fetchParams.controller.state === 'terminated'
}

const normalizeMethodRecordBase = {
  delete: 'DELETE',
  DELETE: 'DELETE',
  get: 'GET',
  GET: 'GET',
  head: 'HEAD',
  HEAD: 'HEAD',
  options: 'OPTIONS',
  OPTIONS: 'OPTIONS',
  post: 'POST',
  POST: 'POST',
  put: 'PUT',
  PUT: 'PUT'
}

const normalizeMethodRecord = {
  ...normalizeMethodRecordBase,
  patch: 'patch',
  PATCH: 'PATCH'
}

// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
Object.setPrototypeOf(normalizeMethodRecordBase, null)
Object.setPrototypeOf(normalizeMethodRecord, null)

/**
 * @see https://fetch.spec.whatwg.org/#concept-method-normalize
 * @param {string} method
 */
function normalizeMethod (method) {
  return normalizeMethodRecordBase[method.toLowerCase()] ?? method
}

// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string
function serializeJavascriptValueToJSONString (value) {
  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).
  const result = JSON.stringify(value)

  // 2. If result is undefined, then throw a TypeError.
  if (result === undefined) {
    throw new TypeError('Value is not JSON serializable')
  }

  // 3. Assert: result is a string.
  assert(typeof result === 'string')

  // 4. Return result.
  return result
}

// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object
const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))

/**
 * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
 * @param {string} name name of the instance
 * @param {symbol} kInternalIterator
 * @param {string | number} [keyIndex]
 * @param {string | number} [valueIndex]
 */
function createIterator (name, kInternalIterator, keyIndex = 0, valueIndex = 1) {
  class FastIterableIterator {
    /** @type {any} */
    #target
    /** @type {'key' | 'value' | 'key+value'} */
    #kind
    /** @type {number} */
    #index

    /**
     * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object
     * @param {unknown} target
     * @param {'key' | 'value' | 'key+value'} kind
     */
    constructor (target, kind) {
      this.#target = target
      this.#kind = kind
      this.#index = 0
    }

    next () {
      // 1. Let interface be the interface for which the iterator prototype object exists.
      // 2. Let thisValue be the this value.
      // 3. Let object be ? ToObject(thisValue).
      // 4. If object is a platform object, then perform a security
      //    check, passing:
      // 5. If object is not a default iterator object for interface,
      //    then throw a TypeError.
      if (typeof this !== 'object' || this === null || !(#target in this)) {
        throw new TypeError(
          `'next' called on an object that does not implement interface ${name} Iterator.`
        )
      }

      // 6. Let index be object’s index.
      // 7. Let kind be object’s kind.
      // 8. Let values be object’s target's value pairs to iterate over.
      const index = this.#index
      const values = this.#target[kInternalIterator]

      // 9. Let len be the length of values.
      const len = values.length

      // 10. If index is greater than or equal to len, then return
      //     CreateIterResultObject(undefined, true).
      if (index >= len) {
        return {
          value: undefined,
          done: true
        }
      }

      // 11. Let pair be the entry in values at index index.
      const { [keyIndex]: key, [valueIndex]: value } = values[index]

      // 12. Set object’s index to index + 1.
      this.#index = index + 1

      // 13. Return the iterator result for pair and kind.

      // https://webidl.spec.whatwg.org/#iterator-result

      // 1. Let result be a value determined by the value of kind:
      let result
      switch (this.#kind) {
        case 'key':
          // 1. Let idlKey be pair’s key.
          // 2. Let key be the result of converting idlKey to an
          //    ECMAScript value.
          // 3. result is key.
          result = key
          break
        case 'value':
          // 1. Let idlValue be pair’s value.
          // 2. Let value be the result of converting idlValue to
          //    an ECMAScript value.
          // 3. result is value.
          result = value
          break
        case 'key+value':
          // 1. Let idlKey be pair’s key.
          // 2. Let idlValue be pair’s value.
          // 3. Let key be the result of converting idlKey to an
          //    ECMAScript value.
          // 4. Let value be the result of converting idlValue to
          //    an ECMAScript value.
          // 5. Let array be ! ArrayCreate(2).
          // 6. Call ! CreateDataProperty(array, "0", key).
          // 7. Call ! CreateDataProperty(array, "1", value).
          // 8. result is array.
          result = [key, value]
          break
      }

      // 2. Return CreateIterResultObject(result, false).
      return {
        value: result,
        done: false
      }
    }
  }

  // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
  // @ts-ignore
  delete FastIterableIterator.prototype.constructor

  Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype)

  Object.defineProperties(FastIterableIterator.prototype, {
    [Symbol.toStringTag]: {
      writable: false,
      enumerable: false,
      configurable: true,
      value: `${name} Iterator`
    },
    next: { writable: true, enumerable: true, configurable: true }
  })

  /**
   * @param {unknown} target
   * @param {'key' | 'value' | 'key+value'} kind
   * @returns {IterableIterator<any>}
   */
  return function (target, kind) {
    return new FastIterableIterator(target, kind)
  }
}

/**
 * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
 * @param {string} name name of the instance
 * @param {any} object class
 * @param {symbol} kInternalIterator
 * @param {string | number} [keyIndex]
 * @param {string | number} [valueIndex]
 */
function iteratorMixin (name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
  const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex)

  const properties = {
    keys: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function keys () {
        webidl.brandCheck(this, object)
        return makeIterator(this, 'key')
      }
    },
    values: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function values () {
        webidl.brandCheck(this, object)
        return makeIterator(this, 'value')
      }
    },
    entries: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function entries () {
        webidl.brandCheck(this, object)
        return makeIterator(this, 'key+value')
      }
    },
    forEach: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function forEach (callbackfn, thisArg = globalThis) {
        webidl.brandCheck(this, object)
        webidl.argumentLengthCheck(arguments, 1, { header: `${name}.forEach` })
        if (typeof callbackfn !== 'function') {
          throw new TypeError(
            `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`
          )
        }
        for (const { 0: key, 1: value } of makeIterator(this, 'key+value')) {
          callbackfn.call(thisArg, value, key, this)
        }
      }
    }
  }

  return Object.defineProperties(object.prototype, {
    ...properties,
    [Symbol.iterator]: {
      writable: true,
      enumerable: false,
      configurable: true,
      value: properties.entries.value
    }
  })
}

/**
 * @see https://fetch.spec.whatwg.org/#body-fully-read
 */
async function fullyReadBody (body, processBody, processBodyError) {
  // 1. If taskDestination is null, then set taskDestination to
  //    the result of starting a new parallel queue.

  // 2. Let successSteps given a byte sequence bytes be to queue a
  //    fetch task to run processBody given bytes, with taskDestination.
  const successSteps = processBody

  // 3. Let errorSteps be to queue a fetch task to run processBodyError,
  //    with taskDestination.
  const errorSteps = processBodyError

  // 4. Let reader be the result of getting a reader for body’s stream.
  //    If that threw an exception, then run errorSteps with that
  //    exception and return.
  let reader

  try {
    reader = body.stream.getReader()
  } catch (e) {
    errorSteps(e)
    return
  }

  // 5. Read all bytes from reader, given successSteps and errorSteps.
  try {
    const result = await readAllBytes(reader)
    successSteps(result)
  } catch (e) {
    errorSteps(e)
  }
}

function isReadableStreamLike (stream) {
  return stream instanceof ReadableStream || (
    stream[Symbol.toStringTag] === 'ReadableStream' &&
    typeof stream.tee === 'function'
  )
}

/**
 * @param {ReadableStreamController<Uint8Array>} controller
 */
function readableStreamClose (controller) {
  try {
    controller.close()
    controller.byobRequest?.respond(0)
  } catch (err) {
    // TODO: add comment explaining why this error occurs.
    if (!err.message.includes('Controller is already closed') && !err.message.includes('ReadableStream is already closed')) {
      throw err
    }
  }
}

/**
 * @see https://infra.spec.whatwg.org/#isomorphic-encode
 * @param {string} input
 */
function isomorphicEncode (input) {
  // 1. Assert: input contains no code points greater than U+00FF.
  for (let i = 0; i < input.length; i++) {
    assert(input.charCodeAt(i) <= 0xFF)
  }

  // 2. Return a byte sequence whose length is equal to input’s code
  //    point length and whose bytes have the same values as the
  //    values of input’s code points, in the same order
  return input
}

/**
 * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes
 * @see https://streams.spec.whatwg.org/#read-loop
 * @param {ReadableStreamDefaultReader} reader
 */
async function readAllBytes (reader) {
  const bytes = []
  let byteLength = 0

  while (true) {
    const { done, value: chunk } = await reader.read()

    if (done) {
      // 1. Call successSteps with bytes.
      return Buffer.concat(bytes, byteLength)
    }

    // 1. If chunk is not a Uint8Array object, call failureSteps
    //    with a TypeError and abort these steps.
    if (!isUint8Array(chunk)) {
      throw new TypeError('Received non-Uint8Array chunk')
    }

    // 2. Append the bytes represented by chunk to bytes.
    bytes.push(chunk)
    byteLength += chunk.length

    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.
  }
}

/**
 * @see https://fetch.spec.whatwg.org/#is-local
 * @param {URL} url
 */
function urlIsLocal (url) {
  assert('protocol' in url) // ensure it's a url object

  const protocol = url.protocol

  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'
}

/**
 * @param {string|URL} url
 */
function urlHasHttpsScheme (url) {
  if (typeof url === 'string') {
    return url.startsWith('https:')
  }

  return url.protocol === 'https:'
}

/**
 * @see https://fetch.spec.whatwg.org/#http-scheme
 * @param {URL} url
 */
function urlIsHttpHttpsScheme (url) {
  assert('protocol' in url) // ensure it's a url object

  const protocol = url.protocol

  return protocol === 'http:' || protocol === 'https:'
}

/**
 * @see https://fetch.spec.whatwg.org/#simple-range-header-value
 * @param {string} value
 * @param {boolean} allowWhitespace
 */
function simpleRangeHeaderValue (value, allowWhitespace) {
  // 1. Let data be the isomorphic decoding of value.
  // Note: isomorphic decoding takes a sequence of bytes (ie. a Uint8Array) and turns it into a string,
  // nothing more. We obviously don't need to do that if value is a string already.
  const data = value

  // 2. If data does not start with "bytes", then return failure.
  if (!data.startsWith('bytes')) {
    return 'failure'
  }

  // 3. Let position be a position variable for data, initially pointing at the 5th code point of data.
  const position = { position: 5 }

  // 4. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,
  //    from data given position.
  if (allowWhitespace) {
    collectASequenceOfCodePoints(
      (char) => char === '\t' || char === ' ',
      data,
      position
    )
  }

  // 5. If the code point at position within data is not U+003D (=), then return failure.
  if (data.charCodeAt(position.position) !== 0x3D) {
    return 'failure'
  }

  // 6. Advance position by 1.
  position.position++

  // 7. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from
  //    data given position.
  if (allowWhitespace) {
    collectASequenceOfCodePoints(
      (char) => char === '\t' || char === ' ',
      data,
      position
    )
  }

  // 8. Let rangeStart be the result of collecting a sequence of code points that are ASCII digits,
  //    from data given position.
  const rangeStart = collectASequenceOfCodePoints(
    (char) => {
      const code = char.charCodeAt(0)

      return code >= 0x30 && code <= 0x39
    },
    data,
    position
  )

  // 9. Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the
  //    empty string; otherwise null.
  const rangeStartValue = rangeStart.length ? Number(rangeStart) : null

  // 10. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,
  //     from data given position.
  if (allowWhitespace) {
    collectASequenceOfCodePoints(
      (char) => char === '\t' || char === ' ',
      data,
      position
    )
  }

  // 11. If the code point at position within data is not U+002D (-), then return failure.
  if (data.charCodeAt(position.position) !== 0x2D) {
    return 'failure'
  }

  // 12. Advance position by 1.
  position.position++

  // 13. If allowWhitespace is true, collect a sequence of code points that are HTTP tab
  //     or space, from data given position.
  // Note from Khafra: its the same step as in #8 again lol
  if (allowWhitespace) {
    collectASequenceOfCodePoints(
      (char) => char === '\t' || char === ' ',
      data,
      position
    )
  }

  // 14. Let rangeEnd be the result of collecting a sequence of code points that are
  //     ASCII digits, from data given position.
  // Note from Khafra: you wouldn't guess it, but this is also the same step as #8
  const rangeEnd = collectASequenceOfCodePoints(
    (char) => {
      const code = char.charCodeAt(0)

      return code >= 0x30 && code <= 0x39
    },
    data,
    position
  )

  // 15. Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd
  //     is not the empty string; otherwise null.
  // Note from Khafra: THE SAME STEP, AGAIN!!!
  // Note: why interpret as a decimal if we only collect ascii digits?
  const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null

  // 16. If position is not past the end of data, then return failure.
  if (position.position < data.length) {
    return 'failure'
  }

  // 17. If rangeEndValue and rangeStartValue are null, then return failure.
  if (rangeEndValue === null && rangeStartValue === null) {
    return 'failure'
  }

  // 18. If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is
  //     greater than rangeEndValue, then return failure.
  // Note: ... when can they not be numbers?
  if (rangeStartValue > rangeEndValue) {
    return 'failure'
  }

  // 19. Return (rangeStartValue, rangeEndValue).
  return { rangeStartValue, rangeEndValue }
}

/**
 * @see https://fetch.spec.whatwg.org/#build-a-content-range
 * @param {number} rangeStart
 * @param {number} rangeEnd
 * @param {number} fullLength
 */
function buildContentRange (rangeStart, rangeEnd, fullLength) {
  // 1. Let contentRange be `bytes `.
  let contentRange = 'bytes '

  // 2. Append rangeStart, serialized and isomorphic encoded, to contentRange.
  contentRange += isomorphicEncode(`${rangeStart}`)

  // 3. Append 0x2D (-) to contentRange.
  contentRange += '-'

  // 4. Append rangeEnd, serialized and isomorphic encoded to contentRange.
  contentRange += isomorphicEncode(`${rangeEnd}`)

  // 5. Append 0x2F (/) to contentRange.
  contentRange += '/'

  // 6. Append fullLength, serialized and isomorphic encoded to contentRange.
  contentRange += isomorphicEncode(`${fullLength}`)

  // 7. Return contentRange.
  return contentRange
}

// A Stream, which pipes the response to zlib.createInflate() or
// zlib.createInflateRaw() depending on the first byte of the Buffer.
// If the lower byte of the first byte is 0x08, then the stream is
// interpreted as a zlib stream, otherwise it's interpreted as a
// raw deflate stream.
class InflateStream extends Transform {
  _transform (chunk, encoding, callback) {
    if (!this._inflateStream) {
      if (chunk.length === 0) {
        callback()
        return
      }
      this._inflateStream = (chunk[0] & 0x0F) === 0x08
        ? zlib.createInflate()
        : zlib.createInflateRaw()

      this._inflateStream.on('data', this.push.bind(this))
      this._inflateStream.on('end', () => this.push(null))
      this._inflateStream.on('error', (err) => this.destroy(err))
    }

    this._inflateStream.write(chunk, encoding, callback)
  }

  _final (callback) {
    if (this._inflateStream) {
      this._inflateStream.end()
      this._inflateStream = null
    }
    callback()
  }
}

function createInflate () {
  return new InflateStream()
}

/**
 * @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type
 * @param {import('./headers').HeadersList} headers
 */
function extractMimeType (headers) {
  // 1. Let charset be null.
  let charset = null

  // 2. Let essence be null.
  let essence = null

  // 3. Let mimeType be null.
  let mimeType = null

  // 4. Let values be the result of getting, decoding, and splitting `Content-Type` from headers.
  const values = getDecodeSplit('content-type', headers)

  // 5. If values is null, then return failure.
  if (values === null) {
    return 'failure'
  }

  // 6. For each value of values:
  for (const value of values) {
    // 6.1. Let temporaryMimeType be the result of parsing value.
    const temporaryMimeType = parseMIMEType(value)

    // 6.2. If temporaryMimeType is failure or its essence is "*/*", then continue.
    if (temporaryMimeType === 'failure' || temporaryMimeType.essence === '*/*') {
      continue
    }

    // 6.3. Set mimeType to temporaryMimeType.
    mimeType = temporaryMimeType

    // 6.4. If mimeType’s essence is not essence, then:
    if (mimeType.essence !== essence) {
      // 6.4.1. Set charset to null.
      charset = null

      // 6.4.2. If mimeType’s parameters["charset"] exists, then set charset to
      //        mimeType’s parameters["charset"].
      if (mimeType.parameters.has('charset')) {
        charset = mimeType.parameters.get('charset')
      }

      // 6.4.3. Set essence to mimeType’s essence.
      essence = mimeType.essence
    } else if (!mimeType.parameters.has('charset') && charset !== null) {
      // 6.5. Otherwise, if mimeType’s parameters["charset"] does not exist, and
      //      charset is non-null, set mimeType’s parameters["charset"] to charset.
      mimeType.parameters.set('charset', charset)
    }
  }

  // 7. If mimeType is null, then return failure.
  if (mimeType == null) {
    return 'failure'
  }

  // 8. Return mimeType.
  return mimeType
}

/**
 * @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split
 * @param {string|null} value
 */
function gettingDecodingSplitting (value) {
  // 1. Let input be the result of isomorphic decoding value.
  const input = value

  // 2. Let position be a position variable for input, initially pointing at the start of input.
  const position = { position: 0 }

  // 3. Let values be a list of strings, initially empty.
  const values = []

  // 4. Let temporaryValue be the empty string.
  let temporaryValue = ''

  // 5. While position is not past the end of input:
  while (position.position < input.length) {
    // 5.1. Append the result of collecting a sequence of code points that are not U+0022 (")
    //      or U+002C (,) from input, given position, to temporaryValue.
    temporaryValue += collectASequenceOfCodePoints(
      (char) => char !== '"' && char !== ',',
      input,
      position
    )

    // 5.2. If position is not past the end of input, then:
    if (position.position < input.length) {
      // 5.2.1. If the code point at position within input is U+0022 ("), then:
      if (input.charCodeAt(position.position) === 0x22) {
        // 5.2.1.1. Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.
        temporaryValue += collectAnHTTPQuotedString(
          input,
          position
        )

        // 5.2.1.2. If position is not past the end of input, then continue.
        if (position.position < input.length) {
          continue
        }
      } else {
        // 5.2.2. Otherwise:

        // 5.2.2.1. Assert: the code point at position within input is U+002C (,).
        assert(input.charCodeAt(position.position) === 0x2C)

        // 5.2.2.2. Advance position by 1.
        position.position++
      }
    }

    // 5.3. Remove all HTTP tab or space from the start and end of temporaryValue.
    temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 0x9 || char === 0x20)

    // 5.4. Append temporaryValue to values.
    values.push(temporaryValue)

    // 5.6. Set temporaryValue to the empty string.
    temporaryValue = ''
  }

  // 6. Return values.
  return values
}

/**
 * @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split
 * @param {string} name lowercase header name
 * @param {import('./headers').HeadersList} list
 */
function getDecodeSplit (name, list) {
  // 1. Let value be the result of getting name from list.
  const value = list.get(name, true)

  // 2. If value is null, then return null.
  if (value === null) {
    return null
  }

  // 3. Return the result of getting, decoding, and splitting value.
  return gettingDecodingSplitting(value)
}

module.exports = {
  isAborted,
  isCancelled,
  createDeferredPromise,
  ReadableStreamFrom,
  tryUpgradeRequestToAPotentiallyTrustworthyURL,
  clampAndCoarsenConnectionTimingInfo,
  coarsenedSharedCurrentTime,
  determineRequestsReferrer,
  makePolicyContainer,
  clonePolicyContainer,
  appendFetchMetadata,
  appendRequestOriginHeader,
  TAOCheck,
  corsCheck,
  crossOriginResourcePolicyCheck,
  createOpaqueTimingInfo,
  setRequestReferrerPolicyOnRedirect,
  isValidHTTPToken,
  requestBadPort,
  requestCurrentURL,
  responseURL,
  responseLocationURL,
  isBlobLike,
  isURLPotentiallyTrustworthy,
  isValidReasonPhrase,
  sameOrigin,
  normalizeMethod,
  serializeJavascriptValueToJSONString,
  iteratorMixin,
  createIterator,
  isValidHeaderName,
  isValidHeaderValue,
  isErrorLike,
  fullyReadBody,
  bytesMatch,
  isReadableStreamLike,
  readableStreamClose,
  isomorphicEncode,
  urlIsLocal,
  urlHasHttpsScheme,
  urlIsHttpHttpsScheme,
  readAllBytes,
  normalizeMethodRecord,
  simpleRangeHeaderValue,
  buildContentRange,
  parseMetadata,
  createInflate,
  extractMimeType,
  getDecodeSplit
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fetch/webidl.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/webidl.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { types, inspect } = __webpack_require__(/*! node:util */ "node:util")
const { toUSVString } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")

/** @type {import('../../../types/webidl').Webidl} */
const webidl = {}
webidl.converters = {}
webidl.util = {}
webidl.errors = {}

webidl.errors.exception = function (message) {
  return new TypeError(`${message.header}: ${message.message}`)
}

webidl.errors.conversionFailed = function (context) {
  const plural = context.types.length === 1 ? '' : ' one of'
  const message =
    `${context.argument} could not be converted to` +
    `${plural}: ${context.types.join(', ')}.`

  return webidl.errors.exception({
    header: context.prefix,
    message
  })
}

webidl.errors.invalidArgument = function (context) {
  return webidl.errors.exception({
    header: context.prefix,
    message: `"${context.value}" is an invalid ${context.type}.`
  })
}

// https://webidl.spec.whatwg.org/#implements
webidl.brandCheck = function (V, I, opts = undefined) {
  if (opts?.strict !== false) {
    if (!(V instanceof I)) {
      throw new TypeError('Illegal invocation')
    }
  } else {
    if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {
      throw new TypeError('Illegal invocation')
    }
  }
}

webidl.argumentLengthCheck = function ({ length }, min, ctx) {
  if (length < min) {
    throw webidl.errors.exception({
      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +
               `but${length ? ' only' : ''} ${length} found.`,
      ...ctx
    })
  }
}

webidl.illegalConstructor = function () {
  throw webidl.errors.exception({
    header: 'TypeError',
    message: 'Illegal constructor'
  })
}

// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values
webidl.util.Type = function (V) {
  switch (typeof V) {
    case 'undefined': return 'Undefined'
    case 'boolean': return 'Boolean'
    case 'string': return 'String'
    case 'symbol': return 'Symbol'
    case 'number': return 'Number'
    case 'bigint': return 'BigInt'
    case 'function':
    case 'object': {
      if (V === null) {
        return 'Null'
      }

      return 'Object'
    }
  }
}

// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
webidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {
  let upperBound
  let lowerBound

  // 1. If bitLength is 64, then:
  if (bitLength === 64) {
    // 1. Let upperBound be 2^53 − 1.
    upperBound = Math.pow(2, 53) - 1

    // 2. If signedness is "unsigned", then let lowerBound be 0.
    if (signedness === 'unsigned') {
      lowerBound = 0
    } else {
      // 3. Otherwise let lowerBound be −2^53 + 1.
      lowerBound = Math.pow(-2, 53) + 1
    }
  } else if (signedness === 'unsigned') {
    // 2. Otherwise, if signedness is "unsigned", then:

    // 1. Let lowerBound be 0.
    lowerBound = 0

    // 2. Let upperBound be 2^bitLength − 1.
    upperBound = Math.pow(2, bitLength) - 1
  } else {
    // 3. Otherwise:

    // 1. Let lowerBound be -2^bitLength − 1.
    lowerBound = Math.pow(-2, bitLength) - 1

    // 2. Let upperBound be 2^bitLength − 1 − 1.
    upperBound = Math.pow(2, bitLength - 1) - 1
  }

  // 4. Let x be ? ToNumber(V).
  let x = Number(V)

  // 5. If x is −0, then set x to +0.
  if (x === 0) {
    x = 0
  }

  // 6. If the conversion is to an IDL type associated
  //    with the [EnforceRange] extended attribute, then:
  if (opts.enforceRange === true) {
    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.
    if (
      Number.isNaN(x) ||
      x === Number.POSITIVE_INFINITY ||
      x === Number.NEGATIVE_INFINITY
    ) {
      throw webidl.errors.exception({
        header: 'Integer conversion',
        message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
      })
    }

    // 2. Set x to IntegerPart(x).
    x = webidl.util.IntegerPart(x)

    // 3. If x < lowerBound or x > upperBound, then
    //    throw a TypeError.
    if (x < lowerBound || x > upperBound) {
      throw webidl.errors.exception({
        header: 'Integer conversion',
        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
      })
    }

    // 4. Return x.
    return x
  }

  // 7. If x is not NaN and the conversion is to an IDL
  //    type associated with the [Clamp] extended
  //    attribute, then:
  if (!Number.isNaN(x) && opts.clamp === true) {
    // 1. Set x to min(max(x, lowerBound), upperBound).
    x = Math.min(Math.max(x, lowerBound), upperBound)

    // 2. Round x to the nearest integer, choosing the
    //    even integer if it lies halfway between two,
    //    and choosing +0 rather than −0.
    if (Math.floor(x) % 2 === 0) {
      x = Math.floor(x)
    } else {
      x = Math.ceil(x)
    }

    // 3. Return x.
    return x
  }

  // 8. If x is NaN, +0, +∞, or −∞, then return +0.
  if (
    Number.isNaN(x) ||
    (x === 0 && Object.is(0, x)) ||
    x === Number.POSITIVE_INFINITY ||
    x === Number.NEGATIVE_INFINITY
  ) {
    return 0
  }

  // 9. Set x to IntegerPart(x).
  x = webidl.util.IntegerPart(x)

  // 10. Set x to x modulo 2^bitLength.
  x = x % Math.pow(2, bitLength)

  // 11. If signedness is "signed" and x ≥ 2^bitLength − 1,
  //    then return x − 2^bitLength.
  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {
    return x - Math.pow(2, bitLength)
  }

  // 12. Otherwise, return x.
  return x
}

// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart
webidl.util.IntegerPart = function (n) {
  // 1. Let r be floor(abs(n)).
  const r = Math.floor(Math.abs(n))

  // 2. If n < 0, then return -1 × r.
  if (n < 0) {
    return -1 * r
  }

  // 3. Otherwise, return r.
  return r
}

webidl.util.Stringify = function (V) {
  const type = webidl.util.Type(V)

  switch (type) {
    case 'Symbol':
      return `Symbol(${V.description})`
    case 'Object':
      return inspect(V)
    case 'String':
      return `"${V}"`
    default:
      return `${V}`
  }
}

// https://webidl.spec.whatwg.org/#es-sequence
webidl.sequenceConverter = function (converter) {
  return (V, Iterable) => {
    // 1. If Type(V) is not Object, throw a TypeError.
    if (webidl.util.Type(V) !== 'Object') {
      throw webidl.errors.exception({
        header: 'Sequence',
        message: `Value of type ${webidl.util.Type(V)} is not an Object.`
      })
    }

    // 2. Let method be ? GetMethod(V, @@iterator).
    /** @type {Generator} */
    const method = typeof Iterable === 'function' ? Iterable() : V?.[Symbol.iterator]?.()
    const seq = []

    // 3. If method is undefined, throw a TypeError.
    if (
      method === undefined ||
      typeof method.next !== 'function'
    ) {
      throw webidl.errors.exception({
        header: 'Sequence',
        message: 'Object is not an iterator.'
      })
    }

    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable
    while (true) {
      const { done, value } = method.next()

      if (done) {
        break
      }

      seq.push(converter(value))
    }

    return seq
  }
}

// https://webidl.spec.whatwg.org/#es-to-record
webidl.recordConverter = function (keyConverter, valueConverter) {
  return (O) => {
    // 1. If Type(O) is not Object, throw a TypeError.
    if (webidl.util.Type(O) !== 'Object') {
      throw webidl.errors.exception({
        header: 'Record',
        message: `Value of type ${webidl.util.Type(O)} is not an Object.`
      })
    }

    // 2. Let result be a new empty instance of record<K, V>.
    const result = {}

    if (!types.isProxy(O)) {
      // 1. Let desc be ? O.[[GetOwnProperty]](key).
      const keys = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)]

      for (const key of keys) {
        // 1. Let typedKey be key converted to an IDL value of type K.
        const typedKey = keyConverter(key)

        // 2. Let value be ? Get(O, key).
        // 3. Let typedValue be value converted to an IDL value of type V.
        const typedValue = valueConverter(O[key])

        // 4. Set result[typedKey] to typedValue.
        result[typedKey] = typedValue
      }

      // 5. Return result.
      return result
    }

    // 3. Let keys be ? O.[[OwnPropertyKeys]]().
    const keys = Reflect.ownKeys(O)

    // 4. For each key of keys.
    for (const key of keys) {
      // 1. Let desc be ? O.[[GetOwnProperty]](key).
      const desc = Reflect.getOwnPropertyDescriptor(O, key)

      // 2. If desc is not undefined and desc.[[Enumerable]] is true:
      if (desc?.enumerable) {
        // 1. Let typedKey be key converted to an IDL value of type K.
        const typedKey = keyConverter(key)

        // 2. Let value be ? Get(O, key).
        // 3. Let typedValue be value converted to an IDL value of type V.
        const typedValue = valueConverter(O[key])

        // 4. Set result[typedKey] to typedValue.
        result[typedKey] = typedValue
      }
    }

    // 5. Return result.
    return result
  }
}

webidl.interfaceConverter = function (i) {
  return (V, opts = {}) => {
    if (opts.strict !== false && !(V instanceof i)) {
      throw webidl.errors.exception({
        header: i.name,
        message: `Expected ${webidl.util.Stringify(V)} to be an instance of ${i.name}.`
      })
    }

    return V
  }
}

webidl.dictionaryConverter = function (converters) {
  return (dictionary) => {
    const type = webidl.util.Type(dictionary)
    const dict = {}

    if (type === 'Null' || type === 'Undefined') {
      return dict
    } else if (type !== 'Object') {
      throw webidl.errors.exception({
        header: 'Dictionary',
        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
      })
    }

    for (const options of converters) {
      const { key, defaultValue, required, converter } = options

      if (required === true) {
        if (!Object.hasOwn(dictionary, key)) {
          throw webidl.errors.exception({
            header: 'Dictionary',
            message: `Missing required key "${key}".`
          })
        }
      }

      let value = dictionary[key]
      const hasDefault = Object.hasOwn(options, 'defaultValue')

      // Only use defaultValue if value is undefined and
      // a defaultValue options was provided.
      if (hasDefault && value !== null) {
        value = value ?? defaultValue
      }

      // A key can be optional and have no default value.
      // When this happens, do not perform a conversion,
      // and do not assign the key a value.
      if (required || hasDefault || value !== undefined) {
        value = converter(value)

        if (
          options.allowedValues &&
          !options.allowedValues.includes(value)
        ) {
          throw webidl.errors.exception({
            header: 'Dictionary',
            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`
          })
        }

        dict[key] = value
      }
    }

    return dict
  }
}

webidl.nullableConverter = function (converter) {
  return (V) => {
    if (V === null) {
      return V
    }

    return converter(V)
  }
}

// https://webidl.spec.whatwg.org/#es-DOMString
webidl.converters.DOMString = function (V, opts = {}) {
  // 1. If V is null and the conversion is to an IDL type
  //    associated with the [LegacyNullToEmptyString]
  //    extended attribute, then return the DOMString value
  //    that represents the empty string.
  if (V === null && opts.legacyNullToEmptyString) {
    return ''
  }

  // 2. Let x be ? ToString(V).
  if (typeof V === 'symbol') {
    throw new TypeError('Could not convert argument of type symbol to string.')
  }

  // 3. Return the IDL DOMString value that represents the
  //    same sequence of code units as the one the
  //    ECMAScript String value x represents.
  return String(V)
}

// https://webidl.spec.whatwg.org/#es-ByteString
webidl.converters.ByteString = function (V) {
  // 1. Let x be ? ToString(V).
  // Note: DOMString converter perform ? ToString(V)
  const x = webidl.converters.DOMString(V)

  // 2. If the value of any element of x is greater than
  //    255, then throw a TypeError.
  for (let index = 0; index < x.length; index++) {
    if (x.charCodeAt(index) > 255) {
      throw new TypeError(
        'Cannot convert argument to a ByteString because the character at ' +
        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
      )
    }
  }

  // 3. Return an IDL ByteString value whose length is the
  //    length of x, and where the value of each element is
  //    the value of the corresponding element of x.
  return x
}

// https://webidl.spec.whatwg.org/#es-USVString
webidl.converters.USVString = toUSVString

// https://webidl.spec.whatwg.org/#es-boolean
webidl.converters.boolean = function (V) {
  // 1. Let x be the result of computing ToBoolean(V).
  const x = Boolean(V)

  // 2. Return the IDL boolean value that is the one that represents
  //    the same truth value as the ECMAScript Boolean value x.
  return x
}

// https://webidl.spec.whatwg.org/#es-any
webidl.converters.any = function (V) {
  return V
}

// https://webidl.spec.whatwg.org/#es-long-long
webidl.converters['long long'] = function (V) {
  // 1. Let x be ? ConvertToInt(V, 64, "signed").
  const x = webidl.util.ConvertToInt(V, 64, 'signed')

  // 2. Return the IDL long long value that represents
  //    the same numeric value as x.
  return x
}

// https://webidl.spec.whatwg.org/#es-unsigned-long-long
webidl.converters['unsigned long long'] = function (V) {
  // 1. Let x be ? ConvertToInt(V, 64, "unsigned").
  const x = webidl.util.ConvertToInt(V, 64, 'unsigned')

  // 2. Return the IDL unsigned long long value that
  //    represents the same numeric value as x.
  return x
}

// https://webidl.spec.whatwg.org/#es-unsigned-long
webidl.converters['unsigned long'] = function (V) {
  // 1. Let x be ? ConvertToInt(V, 32, "unsigned").
  const x = webidl.util.ConvertToInt(V, 32, 'unsigned')

  // 2. Return the IDL unsigned long value that
  //    represents the same numeric value as x.
  return x
}

// https://webidl.spec.whatwg.org/#es-unsigned-short
webidl.converters['unsigned short'] = function (V, opts) {
  // 1. Let x be ? ConvertToInt(V, 16, "unsigned").
  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts)

  // 2. Return the IDL unsigned short value that represents
  //    the same numeric value as x.
  return x
}

// https://webidl.spec.whatwg.org/#idl-ArrayBuffer
webidl.converters.ArrayBuffer = function (V, opts = {}) {
  // 1. If Type(V) is not Object, or V does not have an
  //    [[ArrayBufferData]] internal slot, then throw a
  //    TypeError.
  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances
  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances
  if (
    webidl.util.Type(V) !== 'Object' ||
    !types.isAnyArrayBuffer(V)
  ) {
    throw webidl.errors.conversionFailed({
      prefix: webidl.util.Stringify(V),
      argument: webidl.util.Stringify(V),
      types: ['ArrayBuffer']
    })
  }

  // 2. If the conversion is not to an IDL type associated
  //    with the [AllowShared] extended attribute, and
  //    IsSharedArrayBuffer(V) is true, then throw a
  //    TypeError.
  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
    throw webidl.errors.exception({
      header: 'ArrayBuffer',
      message: 'SharedArrayBuffer is not allowed.'
    })
  }

  // 3. If the conversion is not to an IDL type associated
  //    with the [AllowResizable] extended attribute, and
  //    IsResizableArrayBuffer(V) is true, then throw a
  //    TypeError.
  if (V.resizable || V.growable) {
    throw webidl.errors.exception({
      header: 'ArrayBuffer',
      message: 'Received a resizable ArrayBuffer.'
    })
  }

  // 4. Return the IDL ArrayBuffer value that is a
  //    reference to the same object as V.
  return V
}

webidl.converters.TypedArray = function (V, T, opts = {}) {
  // 1. Let T be the IDL type V is being converted to.

  // 2. If Type(V) is not Object, or V does not have a
  //    [[TypedArrayName]] internal slot with a value
  //    equal to T’s name, then throw a TypeError.
  if (
    webidl.util.Type(V) !== 'Object' ||
    !types.isTypedArray(V) ||
    V.constructor.name !== T.name
  ) {
    throw webidl.errors.conversionFailed({
      prefix: `${T.name}`,
      argument: webidl.util.Stringify(V),
      types: [T.name]
    })
  }

  // 3. If the conversion is not to an IDL type associated
  //    with the [AllowShared] extended attribute, and
  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is
  //    true, then throw a TypeError.
  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
    throw webidl.errors.exception({
      header: 'ArrayBuffer',
      message: 'SharedArrayBuffer is not allowed.'
    })
  }

  // 4. If the conversion is not to an IDL type associated
  //    with the [AllowResizable] extended attribute, and
  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
  //    true, then throw a TypeError.
  if (V.buffer.resizable || V.buffer.growable) {
    throw webidl.errors.exception({
      header: 'ArrayBuffer',
      message: 'Received a resizable ArrayBuffer.'
    })
  }

  // 5. Return the IDL value of type T that is a reference
  //    to the same object as V.
  return V
}

webidl.converters.DataView = function (V, opts = {}) {
  // 1. If Type(V) is not Object, or V does not have a
  //    [[DataView]] internal slot, then throw a TypeError.
  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {
    throw webidl.errors.exception({
      header: 'DataView',
      message: 'Object is not a DataView.'
    })
  }

  // 2. If the conversion is not to an IDL type associated
  //    with the [AllowShared] extended attribute, and
  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,
  //    then throw a TypeError.
  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
    throw webidl.errors.exception({
      header: 'ArrayBuffer',
      message: 'SharedArrayBuffer is not allowed.'
    })
  }

  // 3. If the conversion is not to an IDL type associated
  //    with the [AllowResizable] extended attribute, and
  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
  //    true, then throw a TypeError.
  if (V.buffer.resizable || V.buffer.growable) {
    throw webidl.errors.exception({
      header: 'ArrayBuffer',
      message: 'Received a resizable ArrayBuffer.'
    })
  }

  // 4. Return the IDL DataView value that is a reference
  //    to the same object as V.
  return V
}

// https://webidl.spec.whatwg.org/#BufferSource
webidl.converters.BufferSource = function (V, opts = {}) {
  if (types.isAnyArrayBuffer(V)) {
    return webidl.converters.ArrayBuffer(V, { ...opts, allowShared: false })
  }

  if (types.isTypedArray(V)) {
    return webidl.converters.TypedArray(V, V.constructor, { ...opts, allowShared: false })
  }

  if (types.isDataView(V)) {
    return webidl.converters.DataView(V, opts, { ...opts, allowShared: false })
  }

  throw new TypeError(`Could not convert ${webidl.util.Stringify(V)} to a BufferSource.`)
}

webidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(
  webidl.converters.ByteString
)

webidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(
  webidl.converters['sequence<ByteString>']
)

webidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(
  webidl.converters.ByteString,
  webidl.converters.ByteString
)

module.exports = {
  webidl
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fileapi/encoding.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/encoding.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * @see https://encoding.spec.whatwg.org/#concept-encoding-get
 * @param {string|undefined} label
 */
function getEncoding (label) {
  if (!label) {
    return 'failure'
  }

  // 1. Remove any leading and trailing ASCII whitespace from label.
  // 2. If label is an ASCII case-insensitive match for any of the
  //    labels listed in the table below, then return the
  //    corresponding encoding; otherwise return failure.
  switch (label.trim().toLowerCase()) {
    case 'unicode-1-1-utf-8':
    case 'unicode11utf8':
    case 'unicode20utf8':
    case 'utf-8':
    case 'utf8':
    case 'x-unicode20utf8':
      return 'UTF-8'
    case '866':
    case 'cp866':
    case 'csibm866':
    case 'ibm866':
      return 'IBM866'
    case 'csisolatin2':
    case 'iso-8859-2':
    case 'iso-ir-101':
    case 'iso8859-2':
    case 'iso88592':
    case 'iso_8859-2':
    case 'iso_8859-2:1987':
    case 'l2':
    case 'latin2':
      return 'ISO-8859-2'
    case 'csisolatin3':
    case 'iso-8859-3':
    case 'iso-ir-109':
    case 'iso8859-3':
    case 'iso88593':
    case 'iso_8859-3':
    case 'iso_8859-3:1988':
    case 'l3':
    case 'latin3':
      return 'ISO-8859-3'
    case 'csisolatin4':
    case 'iso-8859-4':
    case 'iso-ir-110':
    case 'iso8859-4':
    case 'iso88594':
    case 'iso_8859-4':
    case 'iso_8859-4:1988':
    case 'l4':
    case 'latin4':
      return 'ISO-8859-4'
    case 'csisolatincyrillic':
    case 'cyrillic':
    case 'iso-8859-5':
    case 'iso-ir-144':
    case 'iso8859-5':
    case 'iso88595':
    case 'iso_8859-5':
    case 'iso_8859-5:1988':
      return 'ISO-8859-5'
    case 'arabic':
    case 'asmo-708':
    case 'csiso88596e':
    case 'csiso88596i':
    case 'csisolatinarabic':
    case 'ecma-114':
    case 'iso-8859-6':
    case 'iso-8859-6-e':
    case 'iso-8859-6-i':
    case 'iso-ir-127':
    case 'iso8859-6':
    case 'iso88596':
    case 'iso_8859-6':
    case 'iso_8859-6:1987':
      return 'ISO-8859-6'
    case 'csisolatingreek':
    case 'ecma-118':
    case 'elot_928':
    case 'greek':
    case 'greek8':
    case 'iso-8859-7':
    case 'iso-ir-126':
    case 'iso8859-7':
    case 'iso88597':
    case 'iso_8859-7':
    case 'iso_8859-7:1987':
    case 'sun_eu_greek':
      return 'ISO-8859-7'
    case 'csiso88598e':
    case 'csisolatinhebrew':
    case 'hebrew':
    case 'iso-8859-8':
    case 'iso-8859-8-e':
    case 'iso-ir-138':
    case 'iso8859-8':
    case 'iso88598':
    case 'iso_8859-8':
    case 'iso_8859-8:1988':
    case 'visual':
      return 'ISO-8859-8'
    case 'csiso88598i':
    case 'iso-8859-8-i':
    case 'logical':
      return 'ISO-8859-8-I'
    case 'csisolatin6':
    case 'iso-8859-10':
    case 'iso-ir-157':
    case 'iso8859-10':
    case 'iso885910':
    case 'l6':
    case 'latin6':
      return 'ISO-8859-10'
    case 'iso-8859-13':
    case 'iso8859-13':
    case 'iso885913':
      return 'ISO-8859-13'
    case 'iso-8859-14':
    case 'iso8859-14':
    case 'iso885914':
      return 'ISO-8859-14'
    case 'csisolatin9':
    case 'iso-8859-15':
    case 'iso8859-15':
    case 'iso885915':
    case 'iso_8859-15':
    case 'l9':
      return 'ISO-8859-15'
    case 'iso-8859-16':
      return 'ISO-8859-16'
    case 'cskoi8r':
    case 'koi':
    case 'koi8':
    case 'koi8-r':
    case 'koi8_r':
      return 'KOI8-R'
    case 'koi8-ru':
    case 'koi8-u':
      return 'KOI8-U'
    case 'csmacintosh':
    case 'mac':
    case 'macintosh':
    case 'x-mac-roman':
      return 'macintosh'
    case 'iso-8859-11':
    case 'iso8859-11':
    case 'iso885911':
    case 'tis-620':
    case 'windows-874':
      return 'windows-874'
    case 'cp1250':
    case 'windows-1250':
    case 'x-cp1250':
      return 'windows-1250'
    case 'cp1251':
    case 'windows-1251':
    case 'x-cp1251':
      return 'windows-1251'
    case 'ansi_x3.4-1968':
    case 'ascii':
    case 'cp1252':
    case 'cp819':
    case 'csisolatin1':
    case 'ibm819':
    case 'iso-8859-1':
    case 'iso-ir-100':
    case 'iso8859-1':
    case 'iso88591':
    case 'iso_8859-1':
    case 'iso_8859-1:1987':
    case 'l1':
    case 'latin1':
    case 'us-ascii':
    case 'windows-1252':
    case 'x-cp1252':
      return 'windows-1252'
    case 'cp1253':
    case 'windows-1253':
    case 'x-cp1253':
      return 'windows-1253'
    case 'cp1254':
    case 'csisolatin5':
    case 'iso-8859-9':
    case 'iso-ir-148':
    case 'iso8859-9':
    case 'iso88599':
    case 'iso_8859-9':
    case 'iso_8859-9:1989':
    case 'l5':
    case 'latin5':
    case 'windows-1254':
    case 'x-cp1254':
      return 'windows-1254'
    case 'cp1255':
    case 'windows-1255':
    case 'x-cp1255':
      return 'windows-1255'
    case 'cp1256':
    case 'windows-1256':
    case 'x-cp1256':
      return 'windows-1256'
    case 'cp1257':
    case 'windows-1257':
    case 'x-cp1257':
      return 'windows-1257'
    case 'cp1258':
    case 'windows-1258':
    case 'x-cp1258':
      return 'windows-1258'
    case 'x-mac-cyrillic':
    case 'x-mac-ukrainian':
      return 'x-mac-cyrillic'
    case 'chinese':
    case 'csgb2312':
    case 'csiso58gb231280':
    case 'gb2312':
    case 'gb_2312':
    case 'gb_2312-80':
    case 'gbk':
    case 'iso-ir-58':
    case 'x-gbk':
      return 'GBK'
    case 'gb18030':
      return 'gb18030'
    case 'big5':
    case 'big5-hkscs':
    case 'cn-big5':
    case 'csbig5':
    case 'x-x-big5':
      return 'Big5'
    case 'cseucpkdfmtjapanese':
    case 'euc-jp':
    case 'x-euc-jp':
      return 'EUC-JP'
    case 'csiso2022jp':
    case 'iso-2022-jp':
      return 'ISO-2022-JP'
    case 'csshiftjis':
    case 'ms932':
    case 'ms_kanji':
    case 'shift-jis':
    case 'shift_jis':
    case 'sjis':
    case 'windows-31j':
    case 'x-sjis':
      return 'Shift_JIS'
    case 'cseuckr':
    case 'csksc56011987':
    case 'euc-kr':
    case 'iso-ir-149':
    case 'korean':
    case 'ks_c_5601-1987':
    case 'ks_c_5601-1989':
    case 'ksc5601':
    case 'ksc_5601':
    case 'windows-949':
      return 'EUC-KR'
    case 'csiso2022kr':
    case 'hz-gb-2312':
    case 'iso-2022-cn':
    case 'iso-2022-cn-ext':
    case 'iso-2022-kr':
    case 'replacement':
      return 'replacement'
    case 'unicodefffe':
    case 'utf-16be':
      return 'UTF-16BE'
    case 'csunicode':
    case 'iso-10646-ucs-2':
    case 'ucs-2':
    case 'unicode':
    case 'unicodefeff':
    case 'utf-16':
    case 'utf-16le':
      return 'UTF-16LE'
    case 'x-user-defined':
      return 'x-user-defined'
    default: return 'failure'
  }
}

module.exports = {
  getEncoding
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fileapi/filereader.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/filereader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  staticPropertyDescriptors,
  readOperation,
  fireAProgressEvent
} = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/fileapi/util.js")
const {
  kState,
  kError,
  kResult,
  kEvents,
  kAborted
} = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/fileapi/symbols.js")
const { webidl } = __webpack_require__(/*! ../fetch/webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")

class FileReader extends EventTarget {
  constructor () {
    super()

    this[kState] = 'empty'
    this[kResult] = null
    this[kError] = null
    this[kEvents] = {
      loadend: null,
      error: null,
      abort: null,
      load: null,
      progress: null,
      loadstart: null
    }
  }

  /**
   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
   * @param {import('buffer').Blob} blob
   */
  readAsArrayBuffer (blob) {
    webidl.brandCheck(this, FileReader)

    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsArrayBuffer' })

    blob = webidl.converters.Blob(blob, { strict: false })

    // The readAsArrayBuffer(blob) method, when invoked,
    // must initiate a read operation for blob with ArrayBuffer.
    readOperation(this, blob, 'ArrayBuffer')
  }

  /**
   * @see https://w3c.github.io/FileAPI/#readAsBinaryString
   * @param {import('buffer').Blob} blob
   */
  readAsBinaryString (blob) {
    webidl.brandCheck(this, FileReader)

    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsBinaryString' })

    blob = webidl.converters.Blob(blob, { strict: false })

    // The readAsBinaryString(blob) method, when invoked,
    // must initiate a read operation for blob with BinaryString.
    readOperation(this, blob, 'BinaryString')
  }

  /**
   * @see https://w3c.github.io/FileAPI/#readAsDataText
   * @param {import('buffer').Blob} blob
   * @param {string?} encoding
   */
  readAsText (blob, encoding = undefined) {
    webidl.brandCheck(this, FileReader)

    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsText' })

    blob = webidl.converters.Blob(blob, { strict: false })

    if (encoding !== undefined) {
      encoding = webidl.converters.DOMString(encoding)
    }

    // The readAsText(blob, encoding) method, when invoked,
    // must initiate a read operation for blob with Text and encoding.
    readOperation(this, blob, 'Text', encoding)
  }

  /**
   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
   * @param {import('buffer').Blob} blob
   */
  readAsDataURL (blob) {
    webidl.brandCheck(this, FileReader)

    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsDataURL' })

    blob = webidl.converters.Blob(blob, { strict: false })

    // The readAsDataURL(blob) method, when invoked, must
    // initiate a read operation for blob with DataURL.
    readOperation(this, blob, 'DataURL')
  }

  /**
   * @see https://w3c.github.io/FileAPI/#dfn-abort
   */
  abort () {
    // 1. If this's state is "empty" or if this's state is
    //    "done" set this's result to null and terminate
    //    this algorithm.
    if (this[kState] === 'empty' || this[kState] === 'done') {
      this[kResult] = null
      return
    }

    // 2. If this's state is "loading" set this's state to
    //    "done" and set this's result to null.
    if (this[kState] === 'loading') {
      this[kState] = 'done'
      this[kResult] = null
    }

    // 3. If there are any tasks from this on the file reading
    //    task source in an affiliated task queue, then remove
    //    those tasks from that task queue.
    this[kAborted] = true

    // 4. Terminate the algorithm for the read method being processed.
    // TODO

    // 5. Fire a progress event called abort at this.
    fireAProgressEvent('abort', this)

    // 6. If this's state is not "loading", fire a progress
    //    event called loadend at this.
    if (this[kState] !== 'loading') {
      fireAProgressEvent('loadend', this)
    }
  }

  /**
   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
   */
  get readyState () {
    webidl.brandCheck(this, FileReader)

    switch (this[kState]) {
      case 'empty': return this.EMPTY
      case 'loading': return this.LOADING
      case 'done': return this.DONE
    }
  }

  /**
   * @see https://w3c.github.io/FileAPI/#dom-filereader-result
   */
  get result () {
    webidl.brandCheck(this, FileReader)

    // The result attribute’s getter, when invoked, must return
    // this's result.
    return this[kResult]
  }

  /**
   * @see https://w3c.github.io/FileAPI/#dom-filereader-error
   */
  get error () {
    webidl.brandCheck(this, FileReader)

    // The error attribute’s getter, when invoked, must return
    // this's error.
    return this[kError]
  }

  get onloadend () {
    webidl.brandCheck(this, FileReader)

    return this[kEvents].loadend
  }

  set onloadend (fn) {
    webidl.brandCheck(this, FileReader)

    if (this[kEvents].loadend) {
      this.removeEventListener('loadend', this[kEvents].loadend)
    }

    if (typeof fn === 'function') {
      this[kEvents].loadend = fn
      this.addEventListener('loadend', fn)
    } else {
      this[kEvents].loadend = null
    }
  }

  get onerror () {
    webidl.brandCheck(this, FileReader)

    return this[kEvents].error
  }

  set onerror (fn) {
    webidl.brandCheck(this, FileReader)

    if (this[kEvents].error) {
      this.removeEventListener('error', this[kEvents].error)
    }

    if (typeof fn === 'function') {
      this[kEvents].error = fn
      this.addEventListener('error', fn)
    } else {
      this[kEvents].error = null
    }
  }

  get onloadstart () {
    webidl.brandCheck(this, FileReader)

    return this[kEvents].loadstart
  }

  set onloadstart (fn) {
    webidl.brandCheck(this, FileReader)

    if (this[kEvents].loadstart) {
      this.removeEventListener('loadstart', this[kEvents].loadstart)
    }

    if (typeof fn === 'function') {
      this[kEvents].loadstart = fn
      this.addEventListener('loadstart', fn)
    } else {
      this[kEvents].loadstart = null
    }
  }

  get onprogress () {
    webidl.brandCheck(this, FileReader)

    return this[kEvents].progress
  }

  set onprogress (fn) {
    webidl.brandCheck(this, FileReader)

    if (this[kEvents].progress) {
      this.removeEventListener('progress', this[kEvents].progress)
    }

    if (typeof fn === 'function') {
      this[kEvents].progress = fn
      this.addEventListener('progress', fn)
    } else {
      this[kEvents].progress = null
    }
  }

  get onload () {
    webidl.brandCheck(this, FileReader)

    return this[kEvents].load
  }

  set onload (fn) {
    webidl.brandCheck(this, FileReader)

    if (this[kEvents].load) {
      this.removeEventListener('load', this[kEvents].load)
    }

    if (typeof fn === 'function') {
      this[kEvents].load = fn
      this.addEventListener('load', fn)
    } else {
      this[kEvents].load = null
    }
  }

  get onabort () {
    webidl.brandCheck(this, FileReader)

    return this[kEvents].abort
  }

  set onabort (fn) {
    webidl.brandCheck(this, FileReader)

    if (this[kEvents].abort) {
      this.removeEventListener('abort', this[kEvents].abort)
    }

    if (typeof fn === 'function') {
      this[kEvents].abort = fn
      this.addEventListener('abort', fn)
    } else {
      this[kEvents].abort = null
    }
  }
}

// https://w3c.github.io/FileAPI/#dom-filereader-empty
FileReader.EMPTY = FileReader.prototype.EMPTY = 0
// https://w3c.github.io/FileAPI/#dom-filereader-loading
FileReader.LOADING = FileReader.prototype.LOADING = 1
// https://w3c.github.io/FileAPI/#dom-filereader-done
FileReader.DONE = FileReader.prototype.DONE = 2

Object.defineProperties(FileReader.prototype, {
  EMPTY: staticPropertyDescriptors,
  LOADING: staticPropertyDescriptors,
  DONE: staticPropertyDescriptors,
  readAsArrayBuffer: kEnumerableProperty,
  readAsBinaryString: kEnumerableProperty,
  readAsText: kEnumerableProperty,
  readAsDataURL: kEnumerableProperty,
  abort: kEnumerableProperty,
  readyState: kEnumerableProperty,
  result: kEnumerableProperty,
  error: kEnumerableProperty,
  onloadstart: kEnumerableProperty,
  onprogress: kEnumerableProperty,
  onload: kEnumerableProperty,
  onabort: kEnumerableProperty,
  onerror: kEnumerableProperty,
  onloadend: kEnumerableProperty,
  [Symbol.toStringTag]: {
    value: 'FileReader',
    writable: false,
    enumerable: false,
    configurable: true
  }
})

Object.defineProperties(FileReader, {
  EMPTY: staticPropertyDescriptors,
  LOADING: staticPropertyDescriptors,
  DONE: staticPropertyDescriptors
})

module.exports = {
  FileReader
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fileapi/progressevent.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/progressevent.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { webidl } = __webpack_require__(/*! ../fetch/webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")

const kState = Symbol('ProgressEvent state')

/**
 * @see https://xhr.spec.whatwg.org/#progressevent
 */
class ProgressEvent extends Event {
  constructor (type, eventInitDict = {}) {
    type = webidl.converters.DOMString(type)
    eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {})

    super(type, eventInitDict)

    this[kState] = {
      lengthComputable: eventInitDict.lengthComputable,
      loaded: eventInitDict.loaded,
      total: eventInitDict.total
    }
  }

  get lengthComputable () {
    webidl.brandCheck(this, ProgressEvent)

    return this[kState].lengthComputable
  }

  get loaded () {
    webidl.brandCheck(this, ProgressEvent)

    return this[kState].loaded
  }

  get total () {
    webidl.brandCheck(this, ProgressEvent)

    return this[kState].total
  }
}

webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
  {
    key: 'lengthComputable',
    converter: webidl.converters.boolean,
    defaultValue: false
  },
  {
    key: 'loaded',
    converter: webidl.converters['unsigned long long'],
    defaultValue: 0
  },
  {
    key: 'total',
    converter: webidl.converters['unsigned long long'],
    defaultValue: 0
  },
  {
    key: 'bubbles',
    converter: webidl.converters.boolean,
    defaultValue: false
  },
  {
    key: 'cancelable',
    converter: webidl.converters.boolean,
    defaultValue: false
  },
  {
    key: 'composed',
    converter: webidl.converters.boolean,
    defaultValue: false
  }
])

module.exports = {
  ProgressEvent
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fileapi/symbols.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/symbols.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  kState: Symbol('FileReader state'),
  kResult: Symbol('FileReader result'),
  kError: Symbol('FileReader error'),
  kLastProgressEventFired: Symbol('FileReader last progress event fired timestamp'),
  kEvents: Symbol('FileReader events'),
  kAborted: Symbol('FileReader aborted')
}


/***/ }),

/***/ "./node_modules/undici/lib/web/fileapi/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/util.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  kState,
  kError,
  kResult,
  kAborted,
  kLastProgressEventFired
} = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/fileapi/symbols.js")
const { ProgressEvent } = __webpack_require__(/*! ./progressevent */ "./node_modules/undici/lib/web/fileapi/progressevent.js")
const { getEncoding } = __webpack_require__(/*! ./encoding */ "./node_modules/undici/lib/web/fileapi/encoding.js")
const { serializeAMimeType, parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")
const { types } = __webpack_require__(/*! node:util */ "node:util")
const { StringDecoder } = __webpack_require__(/*! string_decoder */ "string_decoder")
const { btoa } = __webpack_require__(/*! node:buffer */ "node:buffer")

/** @type {PropertyDescriptor} */
const staticPropertyDescriptors = {
  enumerable: true,
  writable: false,
  configurable: false
}

/**
 * @see https://w3c.github.io/FileAPI/#readOperation
 * @param {import('./filereader').FileReader} fr
 * @param {import('buffer').Blob} blob
 * @param {string} type
 * @param {string?} encodingName
 */
function readOperation (fr, blob, type, encodingName) {
  // 1. If fr’s state is "loading", throw an InvalidStateError
  //    DOMException.
  if (fr[kState] === 'loading') {
    throw new DOMException('Invalid state', 'InvalidStateError')
  }

  // 2. Set fr’s state to "loading".
  fr[kState] = 'loading'

  // 3. Set fr’s result to null.
  fr[kResult] = null

  // 4. Set fr’s error to null.
  fr[kError] = null

  // 5. Let stream be the result of calling get stream on blob.
  /** @type {import('stream/web').ReadableStream} */
  const stream = blob.stream()

  // 6. Let reader be the result of getting a reader from stream.
  const reader = stream.getReader()

  // 7. Let bytes be an empty byte sequence.
  /** @type {Uint8Array[]} */
  const bytes = []

  // 8. Let chunkPromise be the result of reading a chunk from
  //    stream with reader.
  let chunkPromise = reader.read()

  // 9. Let isFirstChunk be true.
  let isFirstChunk = true

  // 10. In parallel, while true:
  // Note: "In parallel" just means non-blocking
  // Note 2: readOperation itself cannot be async as double
  // reading the body would then reject the promise, instead
  // of throwing an error.
  ;(async () => {
    while (!fr[kAborted]) {
      // 1. Wait for chunkPromise to be fulfilled or rejected.
      try {
        const { done, value } = await chunkPromise

        // 2. If chunkPromise is fulfilled, and isFirstChunk is
        //    true, queue a task to fire a progress event called
        //    loadstart at fr.
        if (isFirstChunk && !fr[kAborted]) {
          queueMicrotask(() => {
            fireAProgressEvent('loadstart', fr)
          })
        }

        // 3. Set isFirstChunk to false.
        isFirstChunk = false

        // 4. If chunkPromise is fulfilled with an object whose
        //    done property is false and whose value property is
        //    a Uint8Array object, run these steps:
        if (!done && types.isUint8Array(value)) {
          // 1. Let bs be the byte sequence represented by the
          //    Uint8Array object.

          // 2. Append bs to bytes.
          bytes.push(value)

          // 3. If roughly 50ms have passed since these steps
          //    were last invoked, queue a task to fire a
          //    progress event called progress at fr.
          if (
            (
              fr[kLastProgressEventFired] === undefined ||
              Date.now() - fr[kLastProgressEventFired] >= 50
            ) &&
            !fr[kAborted]
          ) {
            fr[kLastProgressEventFired] = Date.now()
            queueMicrotask(() => {
              fireAProgressEvent('progress', fr)
            })
          }

          // 4. Set chunkPromise to the result of reading a
          //    chunk from stream with reader.
          chunkPromise = reader.read()
        } else if (done) {
          // 5. Otherwise, if chunkPromise is fulfilled with an
          //    object whose done property is true, queue a task
          //    to run the following steps and abort this algorithm:
          queueMicrotask(() => {
            // 1. Set fr’s state to "done".
            fr[kState] = 'done'

            // 2. Let result be the result of package data given
            //    bytes, type, blob’s type, and encodingName.
            try {
              const result = packageData(bytes, type, blob.type, encodingName)

              // 4. Else:

              if (fr[kAborted]) {
                return
              }

              // 1. Set fr’s result to result.
              fr[kResult] = result

              // 2. Fire a progress event called load at the fr.
              fireAProgressEvent('load', fr)
            } catch (error) {
              // 3. If package data threw an exception error:

              // 1. Set fr’s error to error.
              fr[kError] = error

              // 2. Fire a progress event called error at fr.
              fireAProgressEvent('error', fr)
            }

            // 5. If fr’s state is not "loading", fire a progress
            //    event called loadend at the fr.
            if (fr[kState] !== 'loading') {
              fireAProgressEvent('loadend', fr)
            }
          })

          break
        }
      } catch (error) {
        if (fr[kAborted]) {
          return
        }

        // 6. Otherwise, if chunkPromise is rejected with an
        //    error error, queue a task to run the following
        //    steps and abort this algorithm:
        queueMicrotask(() => {
          // 1. Set fr’s state to "done".
          fr[kState] = 'done'

          // 2. Set fr’s error to error.
          fr[kError] = error

          // 3. Fire a progress event called error at fr.
          fireAProgressEvent('error', fr)

          // 4. If fr’s state is not "loading", fire a progress
          //    event called loadend at fr.
          if (fr[kState] !== 'loading') {
            fireAProgressEvent('loadend', fr)
          }
        })

        break
      }
    }
  })()
}

/**
 * @see https://w3c.github.io/FileAPI/#fire-a-progress-event
 * @see https://dom.spec.whatwg.org/#concept-event-fire
 * @param {string} e The name of the event
 * @param {import('./filereader').FileReader} reader
 */
function fireAProgressEvent (e, reader) {
  // The progress event e does not bubble. e.bubbles must be false
  // The progress event e is NOT cancelable. e.cancelable must be false
  const event = new ProgressEvent(e, {
    bubbles: false,
    cancelable: false
  })

  reader.dispatchEvent(event)
}

/**
 * @see https://w3c.github.io/FileAPI/#blob-package-data
 * @param {Uint8Array[]} bytes
 * @param {string} type
 * @param {string?} mimeType
 * @param {string?} encodingName
 */
function packageData (bytes, type, mimeType, encodingName) {
  // 1. A Blob has an associated package data algorithm, given
  //    bytes, a type, a optional mimeType, and a optional
  //    encodingName, which switches on type and runs the
  //    associated steps:

  switch (type) {
    case 'DataURL': {
      // 1. Return bytes as a DataURL [RFC2397] subject to
      //    the considerations below:
      //  * Use mimeType as part of the Data URL if it is
      //    available in keeping with the Data URL
      //    specification [RFC2397].
      //  * If mimeType is not available return a Data URL
      //    without a media-type. [RFC2397].

      // https://datatracker.ietf.org/doc/html/rfc2397#section-3
      // dataurl    := "data:" [ mediatype ] [ ";base64" ] "," data
      // mediatype  := [ type "/" subtype ] *( ";" parameter )
      // data       := *urlchar
      // parameter  := attribute "=" value
      let dataURL = 'data:'

      const parsed = parseMIMEType(mimeType || 'application/octet-stream')

      if (parsed !== 'failure') {
        dataURL += serializeAMimeType(parsed)
      }

      dataURL += ';base64,'

      const decoder = new StringDecoder('latin1')

      for (const chunk of bytes) {
        dataURL += btoa(decoder.write(chunk))
      }

      dataURL += btoa(decoder.end())

      return dataURL
    }
    case 'Text': {
      // 1. Let encoding be failure
      let encoding = 'failure'

      // 2. If the encodingName is present, set encoding to the
      //    result of getting an encoding from encodingName.
      if (encodingName) {
        encoding = getEncoding(encodingName)
      }

      // 3. If encoding is failure, and mimeType is present:
      if (encoding === 'failure' && mimeType) {
        // 1. Let type be the result of parse a MIME type
        //    given mimeType.
        const type = parseMIMEType(mimeType)

        // 2. If type is not failure, set encoding to the result
        //    of getting an encoding from type’s parameters["charset"].
        if (type !== 'failure') {
          encoding = getEncoding(type.parameters.get('charset'))
        }
      }

      // 4. If encoding is failure, then set encoding to UTF-8.
      if (encoding === 'failure') {
        encoding = 'UTF-8'
      }

      // 5. Decode bytes using fallback encoding encoding, and
      //    return the result.
      return decode(bytes, encoding)
    }
    case 'ArrayBuffer': {
      // Return a new ArrayBuffer whose contents are bytes.
      const sequence = combineByteSequences(bytes)

      return sequence.buffer
    }
    case 'BinaryString': {
      // Return bytes as a binary string, in which every byte
      //  is represented by a code unit of equal value [0..255].
      let binaryString = ''

      const decoder = new StringDecoder('latin1')

      for (const chunk of bytes) {
        binaryString += decoder.write(chunk)
      }

      binaryString += decoder.end()

      return binaryString
    }
  }
}

/**
 * @see https://encoding.spec.whatwg.org/#decode
 * @param {Uint8Array[]} ioQueue
 * @param {string} encoding
 */
function decode (ioQueue, encoding) {
  const bytes = combineByteSequences(ioQueue)

  // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.
  const BOMEncoding = BOMSniffing(bytes)

  let slice = 0

  // 2. If BOMEncoding is non-null:
  if (BOMEncoding !== null) {
    // 1. Set encoding to BOMEncoding.
    encoding = BOMEncoding

    // 2. Read three bytes from ioQueue, if BOMEncoding is
    //    UTF-8; otherwise read two bytes.
    //    (Do nothing with those bytes.)
    slice = BOMEncoding === 'UTF-8' ? 3 : 2
  }

  // 3. Process a queue with an instance of encoding’s
  //    decoder, ioQueue, output, and "replacement".

  // 4. Return output.

  const sliced = bytes.slice(slice)
  return new TextDecoder(encoding).decode(sliced)
}

/**
 * @see https://encoding.spec.whatwg.org/#bom-sniff
 * @param {Uint8Array} ioQueue
 */
function BOMSniffing (ioQueue) {
  // 1. Let BOM be the result of peeking 3 bytes from ioQueue,
  //    converted to a byte sequence.
  const [a, b, c] = ioQueue

  // 2. For each of the rows in the table below, starting with
  //    the first one and going down, if BOM starts with the
  //    bytes given in the first column, then return the
  //    encoding given in the cell in the second column of that
  //    row. Otherwise, return null.
  if (a === 0xEF && b === 0xBB && c === 0xBF) {
    return 'UTF-8'
  } else if (a === 0xFE && b === 0xFF) {
    return 'UTF-16BE'
  } else if (a === 0xFF && b === 0xFE) {
    return 'UTF-16LE'
  }

  return null
}

/**
 * @param {Uint8Array[]} sequences
 */
function combineByteSequences (sequences) {
  const size = sequences.reduce((a, b) => {
    return a + b.byteLength
  }, 0)

  let offset = 0

  return sequences.reduce((a, b) => {
    a.set(b, offset)
    offset += b.byteLength
    return a
  }, new Uint8Array(size))
}

module.exports = {
  staticPropertyDescriptors,
  readOperation,
  fireAProgressEvent
}


/***/ }),

/***/ "./node_modules/undici/lib/web/websocket/connection.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/connection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { uid, states, sentCloseFrameState } = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/web/websocket/constants.js")
const {
  kReadyState,
  kSentClose,
  kByteParser,
  kReceivedClose
} = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/websocket/symbols.js")
const { fireEvent, failWebsocketConnection } = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/websocket/util.js")
const { channels } = __webpack_require__(/*! ../../core/diagnostics */ "./node_modules/undici/lib/core/diagnostics.js")
const { CloseEvent } = __webpack_require__(/*! ./events */ "./node_modules/undici/lib/web/websocket/events.js")
const { makeRequest } = __webpack_require__(/*! ../fetch/request */ "./node_modules/undici/lib/web/fetch/request.js")
const { fetching } = __webpack_require__(/*! ../fetch/index */ "./node_modules/undici/lib/web/fetch/index.js")
const { Headers } = __webpack_require__(/*! ../fetch/headers */ "./node_modules/undici/lib/web/fetch/headers.js")
const { getDecodeSplit } = __webpack_require__(/*! ../fetch/util */ "./node_modules/undici/lib/web/fetch/util.js")
const { kHeadersList } = __webpack_require__(/*! ../../core/symbols */ "./node_modules/undici/lib/core/symbols.js")

/** @type {import('crypto')} */
let crypto
try {
  crypto = __webpack_require__(/*! node:crypto */ "node:crypto")
/* c8 ignore next 3 */
} catch {

}

/**
 * @see https://websockets.spec.whatwg.org/#concept-websocket-establish
 * @param {URL} url
 * @param {string|string[]} protocols
 * @param {import('./websocket').WebSocket} ws
 * @param {(response: any) => void} onEstablish
 * @param {Partial<import('../../types/websocket').WebSocketInit>} options
 */
function establishWebSocketConnection (url, protocols, ws, onEstablish, options) {
  // 1. Let requestURL be a copy of url, with its scheme set to "http", if url’s
  //    scheme is "ws", and to "https" otherwise.
  const requestURL = url

  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'

  // 2. Let request be a new request, whose URL is requestURL, client is client,
  //    service-workers mode is "none", referrer is "no-referrer", mode is
  //    "websocket", credentials mode is "include", cache mode is "no-store" ,
  //    and redirect mode is "error".
  const request = makeRequest({
    urlList: [requestURL],
    serviceWorkers: 'none',
    referrer: 'no-referrer',
    mode: 'websocket',
    credentials: 'include',
    cache: 'no-store',
    redirect: 'error'
  })

  // Note: undici extension, allow setting custom headers.
  if (options.headers) {
    const headersList = new Headers(options.headers)[kHeadersList]

    request.headersList = headersList
  }

  // 3. Append (`Upgrade`, `websocket`) to request’s header list.
  // 4. Append (`Connection`, `Upgrade`) to request’s header list.
  // Note: both of these are handled by undici currently.
  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397

  // 5. Let keyValue be a nonce consisting of a randomly selected
  //    16-byte value that has been forgiving-base64-encoded and
  //    isomorphic encoded.
  const keyValue = crypto.randomBytes(16).toString('base64')

  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s
  //    header list.
  request.headersList.append('sec-websocket-key', keyValue)

  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s
  //    header list.
  request.headersList.append('sec-websocket-version', '13')

  // 8. For each protocol in protocols, combine
  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header
  //    list.
  for (const protocol of protocols) {
    request.headersList.append('sec-websocket-protocol', protocol)
  }

  // 9. Let permessageDeflate be a user-agent defined
  //    "permessage-deflate" extension header value.
  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673
  // TODO: enable once permessage-deflate is supported
  const permessageDeflate = '' // 'permessage-deflate; 15'

  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to
  //     request’s header list.
  // request.headersList.append('sec-websocket-extensions', permessageDeflate)

  // 11. Fetch request with useParallelQueue set to true, and
  //     processResponse given response being these steps:
  const controller = fetching({
    request,
    useParallelQueue: true,
    dispatcher: options.dispatcher,
    processResponse (response) {
      // 1. If response is a network error or its status is not 101,
      //    fail the WebSocket connection.
      if (response.type === 'error' || response.status !== 101) {
        failWebsocketConnection(ws, 'Received network error or non-101 status code.')
        return
      }

      // 2. If protocols is not the empty list and extracting header
      //    list values given `Sec-WebSocket-Protocol` and response’s
      //    header list results in null, failure, or the empty byte
      //    sequence, then fail the WebSocket connection.
      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {
        failWebsocketConnection(ws, 'Server did not respond with sent protocols.')
        return
      }

      // 3. Follow the requirements stated step 2 to step 6, inclusive,
      //    of the last set of steps in section 4.1 of The WebSocket
      //    Protocol to validate response. This either results in fail
      //    the WebSocket connection or the WebSocket connection is
      //    established.

      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|
      //    header field contains a value that is not an ASCII case-
      //    insensitive match for the value "websocket", the client MUST
      //    _Fail the WebSocket Connection_.
      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {
        failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".')
        return
      }

      // 3. If the response lacks a |Connection| header field or the
      //    |Connection| header field doesn't contain a token that is an
      //    ASCII case-insensitive match for the value "Upgrade", the client
      //    MUST _Fail the WebSocket Connection_.
      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {
        failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".')
        return
      }

      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or
      //    the |Sec-WebSocket-Accept| contains a value other than the
      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-
      //    Key| (as a string, not base64-decoded) with the string "258EAFA5-
      //    E914-47DA-95CA-C5AB0DC85B11" but ignoring any leading and
      //    trailing whitespace, the client MUST _Fail the WebSocket
      //    Connection_.
      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')
      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64')
      if (secWSAccept !== digest) {
        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.')
        return
      }

      // 5. If the response includes a |Sec-WebSocket-Extensions| header
      //    field and this header field indicates the use of an extension
      //    that was not present in the client's handshake (the server has
      //    indicated an extension not requested by the client), the client
      //    MUST _Fail the WebSocket Connection_.  (The parsing of this
      //    header field to determine which extensions are requested is
      //    discussed in Section 9.1.)
      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')

      if (secExtension !== null && secExtension !== permessageDeflate) {
        failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.')
        return
      }

      // 6. If the response includes a |Sec-WebSocket-Protocol| header field
      //    and this header field indicates the use of a subprotocol that was
      //    not present in the client's handshake (the server has indicated a
      //    subprotocol not requested by the client), the client MUST _Fail
      //    the WebSocket Connection_.
      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')

      if (secProtocol !== null) {
        const requestProtocols = getDecodeSplit('sec-websocket-protocol', request.headersList)

        // The client can request that the server use a specific subprotocol by
        // including the |Sec-WebSocket-Protocol| field in its handshake.  If it
        // is specified, the server needs to include the same field and one of
        // the selected subprotocol values in its response for the connection to
        // be established.
        if (!requestProtocols.includes(secProtocol)) {
          failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.')
          return
        }
      }

      response.socket.on('data', onSocketData)
      response.socket.on('close', onSocketClose)
      response.socket.on('error', onSocketError)

      if (channels.open.hasSubscribers) {
        channels.open.publish({
          address: response.socket.address(),
          protocol: secProtocol,
          extensions: secExtension
        })
      }

      onEstablish(response)
    }
  })

  return controller
}

/**
 * @param {Buffer} chunk
 */
function onSocketData (chunk) {
  if (!this.ws[kByteParser].write(chunk)) {
    this.pause()
  }
}

/**
 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
 * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
 */
function onSocketClose () {
  const { ws } = this

  // If the TCP connection was closed after the
  // WebSocket closing handshake was completed, the WebSocket connection
  // is said to have been closed _cleanly_.
  const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose]

  let code = 1005
  let reason = ''

  const result = ws[kByteParser].closingInfo

  if (result) {
    code = result.code ?? 1005
    reason = result.reason
  } else if (ws[kSentClose] !== sentCloseFrameState.SENT) {
    // If _The WebSocket
    // Connection is Closed_ and no Close control frame was received by the
    // endpoint (such as could occur if the underlying transport connection
    // is lost), _The WebSocket Connection Close Code_ is considered to be
    // 1006.
    code = 1006
  }

  // 1. Change the ready state to CLOSED (3).
  ws[kReadyState] = states.CLOSED

  // 2. If the user agent was required to fail the WebSocket
  //    connection, or if the WebSocket connection was closed
  //    after being flagged as full, fire an event named error
  //    at the WebSocket object.
  // TODO

  // 3. Fire an event named close at the WebSocket object,
  //    using CloseEvent, with the wasClean attribute
  //    initialized to true if the connection closed cleanly
  //    and false otherwise, the code attribute initialized to
  //    the WebSocket connection close code, and the reason
  //    attribute initialized to the result of applying UTF-8
  //    decode without BOM to the WebSocket connection close
  //    reason.
  // TODO: process.nextTick
  fireEvent('close', ws, CloseEvent, {
    wasClean, code, reason
  })

  if (channels.close.hasSubscribers) {
    channels.close.publish({
      websocket: ws,
      code,
      reason
    })
  }
}

function onSocketError (error) {
  const { ws } = this

  ws[kReadyState] = states.CLOSING

  if (channels.socketError.hasSubscribers) {
    channels.socketError.publish(error)
  }

  this.destroy()
}

module.exports = {
  establishWebSocketConnection
}


/***/ }),

/***/ "./node_modules/undici/lib/web/websocket/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/constants.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


// This is a Globally Unique Identifier unique used
// to validate that the endpoint accepts websocket
// connections.
// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3
const uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'

/** @type {PropertyDescriptor} */
const staticPropertyDescriptors = {
  enumerable: true,
  writable: false,
  configurable: false
}

const states = {
  CONNECTING: 0,
  OPEN: 1,
  CLOSING: 2,
  CLOSED: 3
}

const sentCloseFrameState = {
  NOT_SENT: 0,
  PROCESSING: 1,
  SENT: 2
}

const opcodes = {
  CONTINUATION: 0x0,
  TEXT: 0x1,
  BINARY: 0x2,
  CLOSE: 0x8,
  PING: 0x9,
  PONG: 0xA
}

const maxUnsigned16Bit = 2 ** 16 - 1 // 65535

const parserStates = {
  INFO: 0,
  PAYLOADLENGTH_16: 2,
  PAYLOADLENGTH_64: 3,
  READ_DATA: 4
}

const emptyBuffer = Buffer.allocUnsafe(0)

module.exports = {
  uid,
  sentCloseFrameState,
  staticPropertyDescriptors,
  states,
  opcodes,
  maxUnsigned16Bit,
  parserStates,
  emptyBuffer
}


/***/ }),

/***/ "./node_modules/undici/lib/web/websocket/events.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/events.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { webidl } = __webpack_require__(/*! ../fetch/webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const { MessagePort } = __webpack_require__(/*! node:worker_threads */ "node:worker_threads")

/**
 * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
 */
class MessageEvent extends Event {
  #eventInit

  constructor (type, eventInitDict = {}) {
    webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent constructor' })

    type = webidl.converters.DOMString(type)
    eventInitDict = webidl.converters.MessageEventInit(eventInitDict)

    super(type, eventInitDict)

    this.#eventInit = eventInitDict
  }

  get data () {
    webidl.brandCheck(this, MessageEvent)

    return this.#eventInit.data
  }

  get origin () {
    webidl.brandCheck(this, MessageEvent)

    return this.#eventInit.origin
  }

  get lastEventId () {
    webidl.brandCheck(this, MessageEvent)

    return this.#eventInit.lastEventId
  }

  get source () {
    webidl.brandCheck(this, MessageEvent)

    return this.#eventInit.source
  }

  get ports () {
    webidl.brandCheck(this, MessageEvent)

    if (!Object.isFrozen(this.#eventInit.ports)) {
      Object.freeze(this.#eventInit.ports)
    }

    return this.#eventInit.ports
  }

  initMessageEvent (
    type,
    bubbles = false,
    cancelable = false,
    data = null,
    origin = '',
    lastEventId = '',
    source = null,
    ports = []
  ) {
    webidl.brandCheck(this, MessageEvent)

    webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent.initMessageEvent' })

    return new MessageEvent(type, {
      bubbles, cancelable, data, origin, lastEventId, source, ports
    })
  }
}

/**
 * @see https://websockets.spec.whatwg.org/#the-closeevent-interface
 */
class CloseEvent extends Event {
  #eventInit

  constructor (type, eventInitDict = {}) {
    webidl.argumentLengthCheck(arguments, 1, { header: 'CloseEvent constructor' })

    type = webidl.converters.DOMString(type)
    eventInitDict = webidl.converters.CloseEventInit(eventInitDict)

    super(type, eventInitDict)

    this.#eventInit = eventInitDict
  }

  get wasClean () {
    webidl.brandCheck(this, CloseEvent)

    return this.#eventInit.wasClean
  }

  get code () {
    webidl.brandCheck(this, CloseEvent)

    return this.#eventInit.code
  }

  get reason () {
    webidl.brandCheck(this, CloseEvent)

    return this.#eventInit.reason
  }
}

// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface
class ErrorEvent extends Event {
  #eventInit

  constructor (type, eventInitDict) {
    webidl.argumentLengthCheck(arguments, 1, { header: 'ErrorEvent constructor' })

    super(type, eventInitDict)

    type = webidl.converters.DOMString(type)
    eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {})

    this.#eventInit = eventInitDict
  }

  get message () {
    webidl.brandCheck(this, ErrorEvent)

    return this.#eventInit.message
  }

  get filename () {
    webidl.brandCheck(this, ErrorEvent)

    return this.#eventInit.filename
  }

  get lineno () {
    webidl.brandCheck(this, ErrorEvent)

    return this.#eventInit.lineno
  }

  get colno () {
    webidl.brandCheck(this, ErrorEvent)

    return this.#eventInit.colno
  }

  get error () {
    webidl.brandCheck(this, ErrorEvent)

    return this.#eventInit.error
  }
}

Object.defineProperties(MessageEvent.prototype, {
  [Symbol.toStringTag]: {
    value: 'MessageEvent',
    configurable: true
  },
  data: kEnumerableProperty,
  origin: kEnumerableProperty,
  lastEventId: kEnumerableProperty,
  source: kEnumerableProperty,
  ports: kEnumerableProperty,
  initMessageEvent: kEnumerableProperty
})

Object.defineProperties(CloseEvent.prototype, {
  [Symbol.toStringTag]: {
    value: 'CloseEvent',
    configurable: true
  },
  reason: kEnumerableProperty,
  code: kEnumerableProperty,
  wasClean: kEnumerableProperty
})

Object.defineProperties(ErrorEvent.prototype, {
  [Symbol.toStringTag]: {
    value: 'ErrorEvent',
    configurable: true
  },
  message: kEnumerableProperty,
  filename: kEnumerableProperty,
  lineno: kEnumerableProperty,
  colno: kEnumerableProperty,
  error: kEnumerableProperty
})

webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort)

webidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(
  webidl.converters.MessagePort
)

const eventInit = [
  {
    key: 'bubbles',
    converter: webidl.converters.boolean,
    defaultValue: false
  },
  {
    key: 'cancelable',
    converter: webidl.converters.boolean,
    defaultValue: false
  },
  {
    key: 'composed',
    converter: webidl.converters.boolean,
    defaultValue: false
  }
]

webidl.converters.MessageEventInit = webidl.dictionaryConverter([
  ...eventInit,
  {
    key: 'data',
    converter: webidl.converters.any,
    defaultValue: null
  },
  {
    key: 'origin',
    converter: webidl.converters.USVString,
    defaultValue: ''
  },
  {
    key: 'lastEventId',
    converter: webidl.converters.DOMString,
    defaultValue: ''
  },
  {
    key: 'source',
    // Node doesn't implement WindowProxy or ServiceWorker, so the only
    // valid value for source is a MessagePort.
    converter: webidl.nullableConverter(webidl.converters.MessagePort),
    defaultValue: null
  },
  {
    key: 'ports',
    converter: webidl.converters['sequence<MessagePort>'],
    get defaultValue () {
      return []
    }
  }
])

webidl.converters.CloseEventInit = webidl.dictionaryConverter([
  ...eventInit,
  {
    key: 'wasClean',
    converter: webidl.converters.boolean,
    defaultValue: false
  },
  {
    key: 'code',
    converter: webidl.converters['unsigned short'],
    defaultValue: 0
  },
  {
    key: 'reason',
    converter: webidl.converters.USVString,
    defaultValue: ''
  }
])

webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
  ...eventInit,
  {
    key: 'message',
    converter: webidl.converters.DOMString,
    defaultValue: ''
  },
  {
    key: 'filename',
    converter: webidl.converters.USVString,
    defaultValue: ''
  },
  {
    key: 'lineno',
    converter: webidl.converters['unsigned long'],
    defaultValue: 0
  },
  {
    key: 'colno',
    converter: webidl.converters['unsigned long'],
    defaultValue: 0
  },
  {
    key: 'error',
    converter: webidl.converters.any
  }
])

module.exports = {
  MessageEvent,
  CloseEvent,
  ErrorEvent
}


/***/ }),

/***/ "./node_modules/undici/lib/web/websocket/frame.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/frame.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const { maxUnsigned16Bit } = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/web/websocket/constants.js")

/** @type {import('crypto')} */
let crypto
try {
  crypto = __webpack_require__(/*! node:crypto */ "node:crypto")
/* c8 ignore next 3 */
} catch {

}

class WebsocketFrameSend {
  /**
   * @param {Buffer|undefined} data
   */
  constructor (data) {
    this.frameData = data
    this.maskKey = crypto.randomBytes(4)
  }

  createFrame (opcode) {
    const bodyLength = this.frameData?.byteLength ?? 0

    /** @type {number} */
    let payloadLength = bodyLength // 0-125
    let offset = 6

    if (bodyLength > maxUnsigned16Bit) {
      offset += 8 // payload length is next 8 bytes
      payloadLength = 127
    } else if (bodyLength > 125) {
      offset += 2 // payload length is next 2 bytes
      payloadLength = 126
    }

    const buffer = Buffer.allocUnsafe(bodyLength + offset)

    // Clear first 2 bytes, everything else is overwritten
    buffer[0] = buffer[1] = 0
    buffer[0] |= 0x80 // FIN
    buffer[0] = (buffer[0] & 0xF0) + opcode // opcode

    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
    buffer[offset - 4] = this.maskKey[0]
    buffer[offset - 3] = this.maskKey[1]
    buffer[offset - 2] = this.maskKey[2]
    buffer[offset - 1] = this.maskKey[3]

    buffer[1] = payloadLength

    if (payloadLength === 126) {
      buffer.writeUInt16BE(bodyLength, 2)
    } else if (payloadLength === 127) {
      // Clear extended payload length
      buffer[2] = buffer[3] = 0
      buffer.writeUIntBE(bodyLength, 4, 6)
    }

    buffer[1] |= 0x80 // MASK

    // mask body
    for (let i = 0; i < bodyLength; i++) {
      buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4]
    }

    return buffer
  }
}

module.exports = {
  WebsocketFrameSend
}


/***/ }),

/***/ "./node_modules/undici/lib/web/websocket/receiver.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/receiver.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const { Writable } = __webpack_require__(/*! node:stream */ "node:stream")
const { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/web/websocket/constants.js")
const { kReadyState, kSentClose, kResponse, kReceivedClose } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/websocket/symbols.js")
const { channels } = __webpack_require__(/*! ../../core/diagnostics */ "./node_modules/undici/lib/core/diagnostics.js")
const { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/websocket/util.js")
const { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ "./node_modules/undici/lib/web/websocket/frame.js")

// This code was influenced by ws released under the MIT license.
// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>
// Copyright (c) 2013 Arnout Kazemier and contributors
// Copyright (c) 2016 Luigi Pinca and contributors

const textDecoder = new TextDecoder('utf-8', { fatal: true })

class ByteParser extends Writable {
  #buffers = []
  #byteOffset = 0

  #state = parserStates.INFO

  #info = {}
  #fragments = []

  constructor (ws) {
    super()

    this.ws = ws
  }

  /**
   * @param {Buffer} chunk
   * @param {() => void} callback
   */
  _write (chunk, _, callback) {
    this.#buffers.push(chunk)
    this.#byteOffset += chunk.length

    this.run(callback)
  }

  /**
   * Runs whenever a new chunk is received.
   * Callback is called whenever there are no more chunks buffering,
   * or not enough bytes are buffered to parse.
   */
  run (callback) {
    while (true) {
      if (this.#state === parserStates.INFO) {
        // If there aren't enough bytes to parse the payload length, etc.
        if (this.#byteOffset < 2) {
          return callback()
        }

        const buffer = this.consume(2)

        this.#info.fin = (buffer[0] & 0x80) !== 0
        this.#info.opcode = buffer[0] & 0x0F

        // If we receive a fragmented message, we use the type of the first
        // frame to parse the full message as binary/text, when it's terminated
        this.#info.originalOpcode ??= this.#info.opcode

        this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION

        if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
          // Only text and binary frames can be fragmented
          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.')
          return
        }

        const payloadLength = buffer[1] & 0x7F

        if (payloadLength <= 125) {
          this.#info.payloadLength = payloadLength
          this.#state = parserStates.READ_DATA
        } else if (payloadLength === 126) {
          this.#state = parserStates.PAYLOADLENGTH_16
        } else if (payloadLength === 127) {
          this.#state = parserStates.PAYLOADLENGTH_64
        }

        if (this.#info.fragmented && payloadLength > 125) {
          // A fragmented frame can't be fragmented itself
          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.')
          return
        } else if (
          (this.#info.opcode === opcodes.PING ||
            this.#info.opcode === opcodes.PONG ||
            this.#info.opcode === opcodes.CLOSE) &&
          payloadLength > 125
        ) {
          // Control frames can have a payload length of 125 bytes MAX
          failWebsocketConnection(this.ws, 'Payload length for control frame exceeded 125 bytes.')
          return
        } else if (this.#info.opcode === opcodes.CLOSE) {
          if (payloadLength === 1) {
            failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.')
            return
          }

          const body = this.consume(payloadLength)

          this.#info.closeInfo = this.parseCloseBody(body)

          if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {
            // If an endpoint receives a Close frame and did not previously send a
            // Close frame, the endpoint MUST send a Close frame in response.  (When
            // sending a Close frame in response, the endpoint typically echos the
            // status code it received.)
            let body = emptyBuffer
            if (this.#info.closeInfo.code) {
              body = Buffer.allocUnsafe(2)
              body.writeUInt16BE(this.#info.closeInfo.code, 0)
            }
            const closeFrame = new WebsocketFrameSend(body)

            this.ws[kResponse].socket.write(
              closeFrame.createFrame(opcodes.CLOSE),
              (err) => {
                if (!err) {
                  this.ws[kSentClose] = sentCloseFrameState.SENT
                }
              }
            )
          }

          // Upon either sending or receiving a Close control frame, it is said
          // that _The WebSocket Closing Handshake is Started_ and that the
          // WebSocket connection is in the CLOSING state.
          this.ws[kReadyState] = states.CLOSING
          this.ws[kReceivedClose] = true

          this.end()

          return
        } else if (this.#info.opcode === opcodes.PING) {
          // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in
          // response, unless it already received a Close frame.
          // A Pong frame sent in response to a Ping frame must have identical
          // "Application data"

          const body = this.consume(payloadLength)

          if (!this.ws[kReceivedClose]) {
            const frame = new WebsocketFrameSend(body)

            this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG))

            if (channels.ping.hasSubscribers) {
              channels.ping.publish({
                payload: body
              })
            }
          }

          this.#state = parserStates.INFO

          if (this.#byteOffset > 0) {
            continue
          } else {
            callback()
            return
          }
        } else if (this.#info.opcode === opcodes.PONG) {
          // A Pong frame MAY be sent unsolicited.  This serves as a
          // unidirectional heartbeat.  A response to an unsolicited Pong frame is
          // not expected.

          const body = this.consume(payloadLength)

          if (channels.pong.hasSubscribers) {
            channels.pong.publish({
              payload: body
            })
          }

          if (this.#byteOffset > 0) {
            continue
          } else {
            callback()
            return
          }
        }
      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
        if (this.#byteOffset < 2) {
          return callback()
        }

        const buffer = this.consume(2)

        this.#info.payloadLength = buffer.readUInt16BE(0)
        this.#state = parserStates.READ_DATA
      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
        if (this.#byteOffset < 8) {
          return callback()
        }

        const buffer = this.consume(8)
        const upper = buffer.readUInt32BE(0)

        // 2^31 is the maxinimum bytes an arraybuffer can contain
        // on 32-bit systems. Although, on 64-bit systems, this is
        // 2^53-1 bytes.
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length
        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275
        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e
        if (upper > 2 ** 31 - 1) {
          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.')
          return
        }

        const lower = buffer.readUInt32BE(4)

        this.#info.payloadLength = (upper << 8) + lower
        this.#state = parserStates.READ_DATA
      } else if (this.#state === parserStates.READ_DATA) {
        if (this.#byteOffset < this.#info.payloadLength) {
          // If there is still more data in this chunk that needs to be read
          return callback()
        } else if (this.#byteOffset >= this.#info.payloadLength) {
          // If the server sent multiple frames in a single chunk

          const body = this.consume(this.#info.payloadLength)

          this.#fragments.push(body)

          // If the frame is unfragmented, or a fragmented frame was terminated,
          // a message was received
          if (!this.#info.fragmented || (this.#info.fin && this.#info.opcode === opcodes.CONTINUATION)) {
            const fullMessage = Buffer.concat(this.#fragments)

            websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage)

            this.#info = {}
            this.#fragments.length = 0
          }

          this.#state = parserStates.INFO
        }
      }

      if (this.#byteOffset === 0) {
        callback()
        break
      }
    }
  }

  /**
   * Take n bytes from the buffered Buffers
   * @param {number} n
   * @returns {Buffer|null}
   */
  consume (n) {
    if (n > this.#byteOffset) {
      return null
    } else if (n === 0) {
      return emptyBuffer
    }

    if (this.#buffers[0].length === n) {
      this.#byteOffset -= this.#buffers[0].length
      return this.#buffers.shift()
    }

    const buffer = Buffer.allocUnsafe(n)
    let offset = 0

    while (offset !== n) {
      const next = this.#buffers[0]
      const { length } = next

      if (length + offset === n) {
        buffer.set(this.#buffers.shift(), offset)
        break
      } else if (length + offset > n) {
        buffer.set(next.subarray(0, n - offset), offset)
        this.#buffers[0] = next.subarray(n - offset)
        break
      } else {
        buffer.set(this.#buffers.shift(), offset)
        offset += next.length
      }
    }

    this.#byteOffset -= n

    return buffer
  }

  parseCloseBody (data) {
    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5
    /** @type {number|undefined} */
    let code

    if (data.length >= 2) {
      // _The WebSocket Connection Close Code_ is
      // defined as the status code (Section 7.4) contained in the first Close
      // control frame received by the application
      code = data.readUInt16BE(0)
    }

    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6
    /** @type {Buffer} */
    let reason = data.subarray(2)

    // Remove BOM
    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {
      reason = reason.subarray(3)
    }

    if (code !== undefined && !isValidStatusCode(code)) {
      return null
    }

    try {
      reason = textDecoder.decode(reason)
    } catch {
      return null
    }

    return { code, reason }
  }

  get closingInfo () {
    return this.#info.closeInfo
  }
}

module.exports = {
  ByteParser
}


/***/ }),

/***/ "./node_modules/undici/lib/web/websocket/symbols.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/symbols.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  kWebSocketURL: Symbol('url'),
  kReadyState: Symbol('ready state'),
  kController: Symbol('controller'),
  kResponse: Symbol('response'),
  kBinaryType: Symbol('binary type'),
  kSentClose: Symbol('sent close'),
  kReceivedClose: Symbol('received close'),
  kByteParser: Symbol('byte parser')
}


/***/ }),

/***/ "./node_modules/undici/lib/web/websocket/util.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/util.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/websocket/symbols.js")
const { states, opcodes } = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/web/websocket/constants.js")
const { MessageEvent, ErrorEvent } = __webpack_require__(/*! ./events */ "./node_modules/undici/lib/web/websocket/events.js")

/* globals Blob */

/**
 * @param {import('./websocket').WebSocket} ws
 * @returns {boolean}
 */
function isConnecting (ws) {
  // If the WebSocket connection is not yet established, and the connection
  // is not yet closed, then the WebSocket connection is in the CONNECTING state.
  return ws[kReadyState] === states.CONNECTING
}

/**
 * @param {import('./websocket').WebSocket} ws
 * @returns {boolean}
 */
function isEstablished (ws) {
  // If the server's response is validated as provided for above, it is
  // said that _The WebSocket Connection is Established_ and that the
  // WebSocket Connection is in the OPEN state.
  return ws[kReadyState] === states.OPEN
}

/**
 * @param {import('./websocket').WebSocket} ws
 * @returns {boolean}
 */
function isClosing (ws) {
  // Upon either sending or receiving a Close control frame, it is said
  // that _The WebSocket Closing Handshake is Started_ and that the
  // WebSocket connection is in the CLOSING state.
  return ws[kReadyState] === states.CLOSING
}

/**
 * @param {import('./websocket').WebSocket} ws
 * @returns {boolean}
 */
function isClosed (ws) {
  return ws[kReadyState] === states.CLOSED
}

/**
 * @see https://dom.spec.whatwg.org/#concept-event-fire
 * @param {string} e
 * @param {EventTarget} target
 * @param {EventInit | undefined} eventInitDict
 */
function fireEvent (e, target, eventConstructor = Event, eventInitDict = {}) {
  // 1. If eventConstructor is not given, then let eventConstructor be Event.

  // 2. Let event be the result of creating an event given eventConstructor,
  //    in the relevant realm of target.
  // 3. Initialize event’s type attribute to e.
  const event = new eventConstructor(e, eventInitDict) // eslint-disable-line new-cap

  // 4. Initialize any other IDL attributes of event as described in the
  //    invocation of this algorithm.

  // 5. Return the result of dispatching event at target, with legacy target
  //    override flag set if set.
  target.dispatchEvent(event)
}

const textDecoder = new TextDecoder('utf-8', { fatal: true })

/**
 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
 * @param {import('./websocket').WebSocket} ws
 * @param {number} type Opcode
 * @param {Buffer} data application data
 */
function websocketMessageReceived (ws, type, data) {
  // 1. If ready state is not OPEN (1), then return.
  if (ws[kReadyState] !== states.OPEN) {
    return
  }

  // 2. Let dataForEvent be determined by switching on type and binary type:
  let dataForEvent

  if (type === opcodes.TEXT) {
    // -> type indicates that the data is Text
    //      a new DOMString containing data
    try {
      dataForEvent = textDecoder.decode(data)
    } catch {
      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.')
      return
    }
  } else if (type === opcodes.BINARY) {
    if (ws[kBinaryType] === 'blob') {
      // -> type indicates that the data is Binary and binary type is "blob"
      //      a new Blob object, created in the relevant Realm of the WebSocket
      //      object, that represents data as its raw data
      dataForEvent = new Blob([data])
    } else {
      // -> type indicates that the data is Binary and binary type is "arraybuffer"
      //      a new ArrayBuffer object, created in the relevant Realm of the
      //      WebSocket object, whose contents are data
      dataForEvent = new Uint8Array(data).buffer
    }
  }

  // 3. Fire an event named message at the WebSocket object, using MessageEvent,
  //    with the origin attribute initialized to the serialization of the WebSocket
  //    object’s url's origin, and the data attribute initialized to dataForEvent.
  fireEvent('message', ws, MessageEvent, {
    origin: ws[kWebSocketURL].origin,
    data: dataForEvent
  })
}

/**
 * @see https://datatracker.ietf.org/doc/html/rfc6455
 * @see https://datatracker.ietf.org/doc/html/rfc2616
 * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407
 * @param {string} protocol
 */
function isValidSubprotocol (protocol) {
  // If present, this value indicates one
  // or more comma-separated subprotocol the client wishes to speak,
  // ordered by preference.  The elements that comprise this value
  // MUST be non-empty strings with characters in the range U+0021 to
  // U+007E not including separator characters as defined in
  // [RFC2616] and MUST all be unique strings.
  if (protocol.length === 0) {
    return false
  }

  for (let i = 0; i < protocol.length; ++i) {
    const code = protocol.charCodeAt(i)

    if (
      code < 0x21 || // CTL, contains SP (0x20) and HT (0x09)
      code > 0x7E ||
      code === 0x22 || // "
      code === 0x28 || // (
      code === 0x29 || // )
      code === 0x2C || // ,
      code === 0x2F || // /
      code === 0x3A || // :
      code === 0x3B || // ;
      code === 0x3C || // <
      code === 0x3D || // =
      code === 0x3E || // >
      code === 0x3F || // ?
      code === 0x40 || // @
      code === 0x5B || // [
      code === 0x5C || // \
      code === 0x5D || // ]
      code === 0x7B || // {
      code === 0x7D // }
    ) {
      return false
    }
  }

  return true
}

/**
 * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4
 * @param {number} code
 */
function isValidStatusCode (code) {
  if (code >= 1000 && code < 1015) {
    return (
      code !== 1004 && // reserved
      code !== 1005 && // "MUST NOT be set as a status code"
      code !== 1006 // "MUST NOT be set as a status code"
    )
  }

  return code >= 3000 && code <= 4999
}

/**
 * @param {import('./websocket').WebSocket} ws
 * @param {string|undefined} reason
 */
function failWebsocketConnection (ws, reason) {
  const { [kController]: controller, [kResponse]: response } = ws

  controller.abort()

  if (response?.socket && !response.socket.destroyed) {
    response.socket.destroy()
  }

  if (reason) {
    // TODO: process.nextTick
    fireEvent('error', ws, ErrorEvent, {
      error: new Error(reason)
    })
  }
}

module.exports = {
  isConnecting,
  isEstablished,
  isClosing,
  isClosed,
  fireEvent,
  isValidSubprotocol,
  isValidStatusCode,
  failWebsocketConnection,
  websocketMessageReceived
}


/***/ }),

/***/ "./node_modules/undici/lib/web/websocket/websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/websocket.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const { webidl } = __webpack_require__(/*! ../fetch/webidl */ "./node_modules/undici/lib/web/fetch/webidl.js")
const { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ "./node_modules/undici/lib/web/fetch/data-url.js")
const { getGlobalOrigin } = __webpack_require__(/*! ../fetch/global */ "./node_modules/undici/lib/web/fetch/global.js")
const { staticPropertyDescriptors, states, sentCloseFrameState, opcodes, emptyBuffer } = __webpack_require__(/*! ./constants */ "./node_modules/undici/lib/web/websocket/constants.js")
const {
  kWebSocketURL,
  kReadyState,
  kController,
  kBinaryType,
  kResponse,
  kSentClose,
  kByteParser
} = __webpack_require__(/*! ./symbols */ "./node_modules/undici/lib/web/websocket/symbols.js")
const {
  isConnecting,
  isEstablished,
  isClosed,
  isClosing,
  isValidSubprotocol,
  failWebsocketConnection,
  fireEvent
} = __webpack_require__(/*! ./util */ "./node_modules/undici/lib/web/websocket/util.js")
const { establishWebSocketConnection } = __webpack_require__(/*! ./connection */ "./node_modules/undici/lib/web/websocket/connection.js")
const { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ "./node_modules/undici/lib/web/websocket/frame.js")
const { ByteParser } = __webpack_require__(/*! ./receiver */ "./node_modules/undici/lib/web/websocket/receiver.js")
const { kEnumerableProperty, isBlobLike } = __webpack_require__(/*! ../../core/util */ "./node_modules/undici/lib/core/util.js")
const { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ "./node_modules/undici/lib/global.js")
const { types } = __webpack_require__(/*! node:util */ "node:util")

let experimentalWarned = false

// https://websockets.spec.whatwg.org/#interface-definition
class WebSocket extends EventTarget {
  #events = {
    open: null,
    error: null,
    close: null,
    message: null
  }

  #bufferedAmount = 0
  #protocol = ''
  #extensions = ''

  /**
   * @param {string} url
   * @param {string|string[]} protocols
   */
  constructor (url, protocols = []) {
    super()

    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket constructor' })

    if (!experimentalWarned) {
      experimentalWarned = true
      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {
        code: 'UNDICI-WS'
      })
    }

    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols)

    url = webidl.converters.USVString(url)
    protocols = options.protocols

    // 1. Let baseURL be this's relevant settings object's API base URL.
    const baseURL = getGlobalOrigin()

    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.
    let urlRecord

    try {
      urlRecord = new URL(url, baseURL)
    } catch (e) {
      // 3. If urlRecord is failure, then throw a "SyntaxError" DOMException.
      throw new DOMException(e, 'SyntaxError')
    }

    // 4. If urlRecord’s scheme is "http", then set urlRecord’s scheme to "ws".
    if (urlRecord.protocol === 'http:') {
      urlRecord.protocol = 'ws:'
    } else if (urlRecord.protocol === 'https:') {
      // 5. Otherwise, if urlRecord’s scheme is "https", set urlRecord’s scheme to "wss".
      urlRecord.protocol = 'wss:'
    }

    // 6. If urlRecord’s scheme is not "ws" or "wss", then throw a "SyntaxError" DOMException.
    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {
      throw new DOMException(
        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
        'SyntaxError'
      )
    }

    // 7. If urlRecord’s fragment is non-null, then throw a "SyntaxError"
    //    DOMException.
    if (urlRecord.hash || urlRecord.href.endsWith('#')) {
      throw new DOMException('Got fragment', 'SyntaxError')
    }

    // 8. If protocols is a string, set protocols to a sequence consisting
    //    of just that string.
    if (typeof protocols === 'string') {
      protocols = [protocols]
    }

    // 9. If any of the values in protocols occur more than once or otherwise
    //    fail to match the requirements for elements that comprise the value
    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket
    //    protocol, then throw a "SyntaxError" DOMException.
    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {
      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')
    }

    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {
      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')
    }

    // 10. Set this's url to urlRecord.
    this[kWebSocketURL] = new URL(urlRecord.href)

    // 11. Let client be this's relevant settings object.

    // 12. Run this step in parallel:

    //    1. Establish a WebSocket connection given urlRecord, protocols,
    //       and client.
    this[kController] = establishWebSocketConnection(
      urlRecord,
      protocols,
      this,
      (response) => this.#onConnectionEstablished(response),
      options
    )

    // Each WebSocket object has an associated ready state, which is a
    // number representing the state of the connection. Initially it must
    // be CONNECTING (0).
    this[kReadyState] = WebSocket.CONNECTING

    this[kSentClose] = sentCloseFrameState.NOT_SENT

    // The extensions attribute must initially return the empty string.

    // The protocol attribute must initially return the empty string.

    // Each WebSocket object has an associated binary type, which is a
    // BinaryType. Initially it must be "blob".
    this[kBinaryType] = 'blob'
  }

  /**
   * @see https://websockets.spec.whatwg.org/#dom-websocket-close
   * @param {number|undefined} code
   * @param {string|undefined} reason
   */
  close (code = undefined, reason = undefined) {
    webidl.brandCheck(this, WebSocket)

    if (code !== undefined) {
      code = webidl.converters['unsigned short'](code, { clamp: true })
    }

    if (reason !== undefined) {
      reason = webidl.converters.USVString(reason)
    }

    // 1. If code is present, but is neither an integer equal to 1000 nor an
    //    integer in the range 3000 to 4999, inclusive, throw an
    //    "InvalidAccessError" DOMException.
    if (code !== undefined) {
      if (code !== 1000 && (code < 3000 || code > 4999)) {
        throw new DOMException('invalid code', 'InvalidAccessError')
      }
    }

    let reasonByteLength = 0

    // 2. If reason is present, then run these substeps:
    if (reason !== undefined) {
      // 1. Let reasonBytes be the result of encoding reason.
      // 2. If reasonBytes is longer than 123 bytes, then throw a
      //    "SyntaxError" DOMException.
      reasonByteLength = Buffer.byteLength(reason)

      if (reasonByteLength > 123) {
        throw new DOMException(
          `Reason must be less than 123 bytes; received ${reasonByteLength}`,
          'SyntaxError'
        )
      }
    }

    // 3. Run the first matching steps from the following list:
    if (isClosing(this) || isClosed(this)) {
      // If this's ready state is CLOSING (2) or CLOSED (3)
      // Do nothing.
    } else if (!isEstablished(this)) {
      // If the WebSocket connection is not yet established
      // Fail the WebSocket connection and set this's ready state
      // to CLOSING (2).
      failWebsocketConnection(this, 'Connection was closed before it was established.')
      this[kReadyState] = WebSocket.CLOSING
    } else if (this[kSentClose] === sentCloseFrameState.NOT_SENT) {
      // If the WebSocket closing handshake has not yet been started
      // Start the WebSocket closing handshake and set this's ready
      // state to CLOSING (2).
      // - If neither code nor reason is present, the WebSocket Close
      //   message must not have a body.
      // - If code is present, then the status code to use in the
      //   WebSocket Close message must be the integer given by code.
      // - If reason is also present, then reasonBytes must be
      //   provided in the Close message after the status code.

      this[kSentClose] = sentCloseFrameState.PROCESSING

      const frame = new WebsocketFrameSend()

      // If neither code nor reason is present, the WebSocket Close
      // message must not have a body.

      // If code is present, then the status code to use in the
      // WebSocket Close message must be the integer given by code.
      if (code !== undefined && reason === undefined) {
        frame.frameData = Buffer.allocUnsafe(2)
        frame.frameData.writeUInt16BE(code, 0)
      } else if (code !== undefined && reason !== undefined) {
        // If reason is also present, then reasonBytes must be
        // provided in the Close message after the status code.
        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength)
        frame.frameData.writeUInt16BE(code, 0)
        // the body MAY contain UTF-8-encoded data with value /reason/
        frame.frameData.write(reason, 2, 'utf-8')
      } else {
        frame.frameData = emptyBuffer
      }

      /** @type {import('stream').Duplex} */
      const socket = this[kResponse].socket

      socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
        if (!err) {
          this[kSentClose] = sentCloseFrameState.SENT
        }
      })

      // Upon either sending or receiving a Close control frame, it is said
      // that _The WebSocket Closing Handshake is Started_ and that the
      // WebSocket connection is in the CLOSING state.
      this[kReadyState] = states.CLOSING
    } else {
      // Otherwise
      // Set this's ready state to CLOSING (2).
      this[kReadyState] = WebSocket.CLOSING
    }
  }

  /**
   * @see https://websockets.spec.whatwg.org/#dom-websocket-send
   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
   */
  send (data) {
    webidl.brandCheck(this, WebSocket)

    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket.send' })

    data = webidl.converters.WebSocketSendData(data)

    // 1. If this's ready state is CONNECTING, then throw an
    //    "InvalidStateError" DOMException.
    if (isConnecting(this)) {
      throw new DOMException('Sent before connected.', 'InvalidStateError')
    }

    // 2. Run the appropriate set of steps from the following list:
    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1
    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2

    if (!isEstablished(this) || isClosing(this)) {
      return
    }

    /** @type {import('stream').Duplex} */
    const socket = this[kResponse].socket

    // If data is a string
    if (typeof data === 'string') {
      // If the WebSocket connection is established and the WebSocket
      // closing handshake has not yet started, then the user agent
      // must send a WebSocket Message comprised of the data argument
      // using a text frame opcode; if the data cannot be sent, e.g.
      // because it would need to be buffered but the buffer is full,
      // the user agent must flag the WebSocket as full and then close
      // the WebSocket connection. Any invocation of this method with a
      // string argument that does not throw an exception must increase
      // the bufferedAmount attribute by the number of bytes needed to
      // express the argument as UTF-8.

      const value = Buffer.from(data)
      const frame = new WebsocketFrameSend(value)
      const buffer = frame.createFrame(opcodes.TEXT)

      this.#bufferedAmount += value.byteLength
      socket.write(buffer, () => {
        this.#bufferedAmount -= value.byteLength
      })
    } else if (types.isArrayBuffer(data)) {
      // If the WebSocket connection is established, and the WebSocket
      // closing handshake has not yet started, then the user agent must
      // send a WebSocket Message comprised of data using a binary frame
      // opcode; if the data cannot be sent, e.g. because it would need
      // to be buffered but the buffer is full, the user agent must flag
      // the WebSocket as full and then close the WebSocket connection.
      // The data to be sent is the data stored in the buffer described
      // by the ArrayBuffer object. Any invocation of this method with an
      // ArrayBuffer argument that does not throw an exception must
      // increase the bufferedAmount attribute by the length of the
      // ArrayBuffer in bytes.

      const value = Buffer.from(data)
      const frame = new WebsocketFrameSend(value)
      const buffer = frame.createFrame(opcodes.BINARY)

      this.#bufferedAmount += value.byteLength
      socket.write(buffer, () => {
        this.#bufferedAmount -= value.byteLength
      })
    } else if (ArrayBuffer.isView(data)) {
      // If the WebSocket connection is established, and the WebSocket
      // closing handshake has not yet started, then the user agent must
      // send a WebSocket Message comprised of data using a binary frame
      // opcode; if the data cannot be sent, e.g. because it would need to
      // be buffered but the buffer is full, the user agent must flag the
      // WebSocket as full and then close the WebSocket connection. The
      // data to be sent is the data stored in the section of the buffer
      // described by the ArrayBuffer object that data references. Any
      // invocation of this method with this kind of argument that does
      // not throw an exception must increase the bufferedAmount attribute
      // by the length of data’s buffer in bytes.

      const ab = Buffer.from(data, data.byteOffset, data.byteLength)

      const frame = new WebsocketFrameSend(ab)
      const buffer = frame.createFrame(opcodes.BINARY)

      this.#bufferedAmount += ab.byteLength
      socket.write(buffer, () => {
        this.#bufferedAmount -= ab.byteLength
      })
    } else if (isBlobLike(data)) {
      // If the WebSocket connection is established, and the WebSocket
      // closing handshake has not yet started, then the user agent must
      // send a WebSocket Message comprised of data using a binary frame
      // opcode; if the data cannot be sent, e.g. because it would need to
      // be buffered but the buffer is full, the user agent must flag the
      // WebSocket as full and then close the WebSocket connection. The data
      // to be sent is the raw data represented by the Blob object. Any
      // invocation of this method with a Blob argument that does not throw
      // an exception must increase the bufferedAmount attribute by the size
      // of the Blob object’s raw data, in bytes.

      const frame = new WebsocketFrameSend()

      data.arrayBuffer().then((ab) => {
        const value = Buffer.from(ab)
        frame.frameData = value
        const buffer = frame.createFrame(opcodes.BINARY)

        this.#bufferedAmount += value.byteLength
        socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength
        })
      })
    }
  }

  get readyState () {
    webidl.brandCheck(this, WebSocket)

    // The readyState getter steps are to return this's ready state.
    return this[kReadyState]
  }

  get bufferedAmount () {
    webidl.brandCheck(this, WebSocket)

    return this.#bufferedAmount
  }

  get url () {
    webidl.brandCheck(this, WebSocket)

    // The url getter steps are to return this's url, serialized.
    return URLSerializer(this[kWebSocketURL])
  }

  get extensions () {
    webidl.brandCheck(this, WebSocket)

    return this.#extensions
  }

  get protocol () {
    webidl.brandCheck(this, WebSocket)

    return this.#protocol
  }

  get onopen () {
    webidl.brandCheck(this, WebSocket)

    return this.#events.open
  }

  set onopen (fn) {
    webidl.brandCheck(this, WebSocket)

    if (this.#events.open) {
      this.removeEventListener('open', this.#events.open)
    }

    if (typeof fn === 'function') {
      this.#events.open = fn
      this.addEventListener('open', fn)
    } else {
      this.#events.open = null
    }
  }

  get onerror () {
    webidl.brandCheck(this, WebSocket)

    return this.#events.error
  }

  set onerror (fn) {
    webidl.brandCheck(this, WebSocket)

    if (this.#events.error) {
      this.removeEventListener('error', this.#events.error)
    }

    if (typeof fn === 'function') {
      this.#events.error = fn
      this.addEventListener('error', fn)
    } else {
      this.#events.error = null
    }
  }

  get onclose () {
    webidl.brandCheck(this, WebSocket)

    return this.#events.close
  }

  set onclose (fn) {
    webidl.brandCheck(this, WebSocket)

    if (this.#events.close) {
      this.removeEventListener('close', this.#events.close)
    }

    if (typeof fn === 'function') {
      this.#events.close = fn
      this.addEventListener('close', fn)
    } else {
      this.#events.close = null
    }
  }

  get onmessage () {
    webidl.brandCheck(this, WebSocket)

    return this.#events.message
  }

  set onmessage (fn) {
    webidl.brandCheck(this, WebSocket)

    if (this.#events.message) {
      this.removeEventListener('message', this.#events.message)
    }

    if (typeof fn === 'function') {
      this.#events.message = fn
      this.addEventListener('message', fn)
    } else {
      this.#events.message = null
    }
  }

  get binaryType () {
    webidl.brandCheck(this, WebSocket)

    return this[kBinaryType]
  }

  set binaryType (type) {
    webidl.brandCheck(this, WebSocket)

    if (type !== 'blob' && type !== 'arraybuffer') {
      this[kBinaryType] = 'blob'
    } else {
      this[kBinaryType] = type
    }
  }

  /**
   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
   */
  #onConnectionEstablished (response) {
    // processResponse is called when the "response’s header list has been received and initialized."
    // once this happens, the connection is open
    this[kResponse] = response

    const parser = new ByteParser(this)
    parser.on('drain', function onParserDrain () {
      this.ws[kResponse].socket.resume()
    })

    response.socket.ws = this
    this[kByteParser] = parser

    // 1. Change the ready state to OPEN (1).
    this[kReadyState] = states.OPEN

    // 2. Change the extensions attribute’s value to the extensions in use, if
    //    it is not the null value.
    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1
    const extensions = response.headersList.get('sec-websocket-extensions')

    if (extensions !== null) {
      this.#extensions = extensions
    }

    // 3. Change the protocol attribute’s value to the subprotocol in use, if
    //    it is not the null value.
    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9
    const protocol = response.headersList.get('sec-websocket-protocol')

    if (protocol !== null) {
      this.#protocol = protocol
    }

    // 4. Fire an event named open at the WebSocket object.
    fireEvent('open', this)
  }
}

// https://websockets.spec.whatwg.org/#dom-websocket-connecting
WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING
// https://websockets.spec.whatwg.org/#dom-websocket-open
WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN
// https://websockets.spec.whatwg.org/#dom-websocket-closing
WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING
// https://websockets.spec.whatwg.org/#dom-websocket-closed
WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED

Object.defineProperties(WebSocket.prototype, {
  CONNECTING: staticPropertyDescriptors,
  OPEN: staticPropertyDescriptors,
  CLOSING: staticPropertyDescriptors,
  CLOSED: staticPropertyDescriptors,
  url: kEnumerableProperty,
  readyState: kEnumerableProperty,
  bufferedAmount: kEnumerableProperty,
  onopen: kEnumerableProperty,
  onerror: kEnumerableProperty,
  onclose: kEnumerableProperty,
  close: kEnumerableProperty,
  onmessage: kEnumerableProperty,
  binaryType: kEnumerableProperty,
  send: kEnumerableProperty,
  extensions: kEnumerableProperty,
  protocol: kEnumerableProperty,
  [Symbol.toStringTag]: {
    value: 'WebSocket',
    writable: false,
    enumerable: false,
    configurable: true
  }
})

Object.defineProperties(WebSocket, {
  CONNECTING: staticPropertyDescriptors,
  OPEN: staticPropertyDescriptors,
  CLOSING: staticPropertyDescriptors,
  CLOSED: staticPropertyDescriptors
})

webidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(
  webidl.converters.DOMString
)

webidl.converters['DOMString or sequence<DOMString>'] = function (V) {
  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {
    return webidl.converters['sequence<DOMString>'](V)
  }

  return webidl.converters.DOMString(V)
}

// This implements the propsal made in https://github.com/whatwg/websockets/issues/42
webidl.converters.WebSocketInit = webidl.dictionaryConverter([
  {
    key: 'protocols',
    converter: webidl.converters['DOMString or sequence<DOMString>'],
    get defaultValue () {
      return []
    }
  },
  {
    key: 'dispatcher',
    converter: (V) => V,
    get defaultValue () {
      return getGlobalDispatcher()
    }
  },
  {
    key: 'headers',
    converter: webidl.nullableConverter(webidl.converters.HeadersInit)
  }
])

webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {
  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {
    return webidl.converters.WebSocketInit(V)
  }

  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }
}

webidl.converters.WebSocketSendData = function (V) {
  if (webidl.util.Type(V) === 'Object') {
    if (isBlobLike(V)) {
      return webidl.converters.Blob(V, { strict: false })
    }

    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
      return webidl.converters.BufferSource(V)
    }
  }

  return webidl.converters.USVString(V)
}

module.exports = {
  WebSocket
}


/***/ }),

/***/ "./node_modules/universal-user-agent/dist-node/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/universal-user-agent/dist-node/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }

  if (typeof process === "object" && "version" in process) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }

  return "<environment undetectable>";
}

exports.getUserAgent = getUserAgent;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/browser.js":
/*!************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/browser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/browser/main */ "./node_modules/vscode-jsonrpc/lib/browser/main.js");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/browser/main.js":
/*!*********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/browser/main.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.BrowserMessageWriter = exports.BrowserMessageReader = void 0;
const ril_1 = __webpack_require__(/*! ./ril */ "./node_modules/vscode-jsonrpc/lib/browser/ril.js");
// Install the browser runtime abstract.
ril_1.default.install();
const api_1 = __webpack_require__(/*! ../common/api */ "./node_modules/vscode-jsonrpc/lib/common/api.js");
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-jsonrpc/lib/common/api.js"), exports);
class BrowserMessageReader extends api_1.AbstractMessageReader {
    constructor(context) {
        super();
        this._onData = new api_1.Emitter();
        this._messageListener = (event) => {
            this._onData.fire(event.data);
        };
        context.addEventListener('error', (event) => this.fireError(event));
        context.onmessage = this._messageListener;
    }
    listen(callback) {
        return this._onData.event(callback);
    }
}
exports.BrowserMessageReader = BrowserMessageReader;
class BrowserMessageWriter extends api_1.AbstractMessageWriter {
    constructor(context) {
        super();
        this.context = context;
        this.errorCount = 0;
        context.addEventListener('error', (event) => this.fireError(event));
    }
    write(msg) {
        try {
            this.context.postMessage(msg);
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.BrowserMessageWriter = BrowserMessageWriter;
function createMessageConnection(reader, writer, logger, options) {
    if (logger === undefined) {
        logger = api_1.NullLogger;
    }
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/browser/ril.js":
/*!********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/browser/ril.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ral_1 = __webpack_require__(/*! ../common/ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const disposable_1 = __webpack_require__(/*! ../common/disposable */ "./node_modules/vscode-jsonrpc/lib/common/disposable.js");
const events_1 = __webpack_require__(/*! ../common/events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
const messageBuffer_1 = __webpack_require__(/*! ../common/messageBuffer */ "./node_modules/vscode-jsonrpc/lib/common/messageBuffer.js");
class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
        this.asciiDecoder = new TextDecoder('ascii');
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, _encoding) {
        return (new TextEncoder()).encode(value);
    }
    toString(value, encoding) {
        if (encoding === 'ascii') {
            return this.asciiDecoder.decode(value);
        }
        else {
            return (new TextDecoder(encoding)).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer;
        }
        else {
            return buffer.slice(0, length);
        }
    }
    allocNative(length) {
        return new Uint8Array(length);
    }
}
MessageBuffer.emptyBuffer = new Uint8Array(0);
class ReadableStreamWrapper {
    constructor(socket) {
        this.socket = socket;
        this._onData = new events_1.Emitter();
        this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
                this._onData.fire(new Uint8Array(buffer));
            }, () => {
                (0, ral_1.default)().console.error(`Converting blob to array buffer failed.`);
            });
        };
        this.socket.addEventListener('message', this._messageListener);
    }
    onClose(listener) {
        this.socket.addEventListener('close', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('close', listener));
    }
    onError(listener) {
        this.socket.addEventListener('error', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('error', listener));
    }
    onEnd(listener) {
        this.socket.addEventListener('end', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('end', listener));
    }
    onData(listener) {
        return this._onData.event(listener);
    }
}
class WritableStreamWrapper {
    constructor(socket) {
        this.socket = socket;
    }
    onClose(listener) {
        this.socket.addEventListener('close', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('close', listener));
    }
    onError(listener) {
        this.socket.addEventListener('error', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('error', listener));
    }
    onEnd(listener) {
        this.socket.addEventListener('end', listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener('end', listener));
    }
    write(data, encoding) {
        if (typeof data === 'string') {
            if (encoding !== undefined && encoding !== 'utf-8') {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
        }
        else {
            this.socket.send(data);
        }
        return Promise.resolve();
    }
    end() {
        this.socket.close();
    }
}
const _textEncoder = new TextEncoder();
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                if (options.charset !== 'utf-8') {
                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                }
                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                if (!(buffer instanceof Uint8Array)) {
                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                }
                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (socket) => new ReadableStreamWrapper(socket),
        asWritableStream: (socket) => new WritableStreamWrapper(socket)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        },
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        ral_1.default.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;
//# sourceMappingURL=ril.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/api.js":
/*!*******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/api.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceFormat = exports.TraceValues = exports.Trace = exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-jsonrpc/lib/common/messages.js");
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return messages_1.Message; } }));
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "./node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
Object.defineProperty(exports, "LinkedMap", ({ enumerable: true, get: function () { return linkedMap_1.LinkedMap; } }));
Object.defineProperty(exports, "LRUCache", ({ enumerable: true, get: function () { return linkedMap_1.LRUCache; } }));
Object.defineProperty(exports, "Touch", ({ enumerable: true, get: function () { return linkedMap_1.Touch; } }));
const disposable_1 = __webpack_require__(/*! ./disposable */ "./node_modules/vscode-jsonrpc/lib/common/disposable.js");
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "./node_modules/vscode-jsonrpc/lib/common/messageReader.js");
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "./node_modules/vscode-jsonrpc/lib/common/messageWriter.js");
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const connection_1 = __webpack_require__(/*! ./connection */ "./node_modules/vscode-jsonrpc/lib/common/connection.js");
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressToken", ({ enumerable: true, get: function () { return connection_1.ProgressToken; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceValues", ({ enumerable: true, get: function () { return connection_1.TraceValues; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
exports.RAL = ral_1.default;
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js":
/*!****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/cancellation.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { handle.dispose(); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;
//# sourceMappingURL=cancellation.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/connection.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/connection.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-jsonrpc/lib/common/messages.js");
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "./node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressToken;
(function (ProgressToken) {
    function is(value) {
        return typeof value === 'string' || typeof value === 'number';
    }
    ProgressToken.is = is;
})(ProgressToken = exports.ProgressToken || (exports.ProgressToken = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Compact"] = 2] = "Compact";
    Trace[Trace["Verbose"] = 3] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceValues;
(function (TraceValues) {
    /**
     * Turn tracing off.
     */
    TraceValues.Off = 'off';
    /**
     * Trace messages only.
     */
    TraceValues.Messages = 'messages';
    /**
     * Compact message tracing.
     */
    TraceValues.Compact = 'compact';
    /**
     * Verbose message tracing.
     */
    TraceValues.Verbose = 'verbose';
})(TraceValues = exports.TraceValues || (exports.TraceValues = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'compact':
                return Trace.Compact;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Compact:
                return 'compact';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        if (!Is.string(value)) {
            return TraceFormat.Text;
        }
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.createCancellationTokenSource);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = new Map();
    let starNotificationHandler = undefined;
    const notificationHandlers = new Map();
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = new Map();
    let knownCanceledRequests = new Set();
    let requestTokens = new Map();
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            if (messages_1.Message.isRequest(message)) {
                handleRequest(message);
            }
            else if (messages_1.Message.isNotification(message)) {
                handleNotification(message);
            }
            else if (messages_1.Message.isResponse(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                const cancelId = message.params.id;
                const key = createRequestQueueKey(cancelId);
                const toCancel = messageQueue.get(key);
                if (messages_1.Message.isRequest(toCancel)) {
                    const strategy = options?.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        requestTokens.delete(cancelId);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                        return;
                    }
                }
                const cancellationToken = requestTokens.get(cancelId);
                // The request is already running. Cancel the token
                if (cancellationToken !== undefined) {
                    cancellationToken.cancel();
                    traceReceivedNotification(message);
                    return;
                }
                else {
                    // Remember the cancel but still queue the message to
                    // clean up state in process message.
                    knownCanceledRequests.add(cancelId);
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now()); //
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
                requestTokens.set(tokenKey, cancellationSource);
            }
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    requestTokens.delete(tokenKey);
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        requestTokens.delete(tokenKey);
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        requestTokens.delete(tokenKey);
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    requestTokens.delete(tokenKey);
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== undefined) {
                responsePromises.delete(key);
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
        }
        else {
            const element = notificationHandlers.get(message.method);
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        // There are JSON-RPC libraries that send progress message as positional params although
                        // specified as named. So convert them if this is the case.
                        const params = message.params;
                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                            notificationHandler({ token: params[0], value: params[1] });
                        }
                        else {
                            if (type !== undefined) {
                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                }
                                if (type.numberOfParams !== message.params.length) {
                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                }
                            }
                            notificationHandler(...params);
                        }
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function stringifyTrace(params) {
        if (params === undefined || params === null) {
            return undefined;
        }
        switch (trace) {
            case Trace.Verbose:
                return JSON.stringify(params, null, 4);
            case Trace.Compact:
                return JSON.stringify(params);
            default:
                return undefined;
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Received parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch(() => logger.error(`Sending notification failed.`));
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers.set(type, { type: undefined, handler });
                }
                else {
                    method = type.method;
                    notificationHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        notificationHandlers.delete(method);
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                    if (p === undefined) {
                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                        return Promise.resolve();
                    }
                    else {
                        return p.catch(() => {
                            logger.log(`Sending cancellation messages for id ${id} failed`);
                        });
                    }
                });
            }
            const result = new Promise((resolve, reject) => {
                const requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage).catch(() => logger.error(`Sending request failed.`));
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises.set(id, responsePromise);
                }
            });
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers.set(type, { handler: handler, type: undefined });
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        requestHandlers.delete(method);
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        hasPendingResponse: () => {
            return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
            for (const promise of responsePromises.values()) {
                promise.reject(error);
            }
            responsePromises = new Map();
            requestTokens = new Map();
            knownCanceledRequests = new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            (0, ral_1.default)().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/disposable.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/disposable.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
//# sourceMappingURL=disposable.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/events.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/events.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                (0, ral_1.default)().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/is.js":
/*!******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/is.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/linkedMap.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/linkedMap.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this[_a] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        return this._head?.value;
    }
    get last() {
        return this._tail?.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;
//# sourceMappingURL=linkedMap.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messageBuffer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messageBuffer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders() {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;
//# sourceMappingURL=messageBuffer.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messageReader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messageReader.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options ?? 'utf-8';
        }
        else {
            charset = options.charset ?? 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                const contentLength = headers.get('Content-Length');
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === undefined) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== undefined) {
                p = this.options.contentDecoder.decode(body);
            }
            else {
                p = Promise.resolve(body);
            }
            p.then((value) => {
                this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                    this.callback(msg);
                }, (error) => {
                    this.fireError(error);
                });
            }, (error) => {
                this.fireError(error);
            });
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
//# sourceMappingURL=messageReader.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messageWriter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messageWriter.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const semaphore_1 = __webpack_require__(/*! ./semaphore */ "./node_modules/vscode-jsonrpc/lib/common/semaphore.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        if (options === undefined || typeof options === 'string') {
            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        }
        else {
            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
//# sourceMappingURL=messageWriter.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messages.js":
/*!************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messages.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = -32099;
    /**
     * An error occurred when write a message to the transport layer.
     */
    ErrorCodes.MessageWriteError = -32099;
    /**
     * An error occurred when reading a message from the transport layer.
     */
    ErrorCodes.MessageReadError = -32098;
    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */
    ErrorCodes.PendingResponseRejected = -32097;
    /**
     * The connection is inactive and a use of it failed.
     */
    ErrorCodes.ConnectionInactive = -32096;
    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = -32000;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        const result = {
            code: this.code,
            message: this.message
        };
        if (this.data !== undefined) {
            result.data = this.data;
        }
        return result;
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
var Message;
(function (Message) {
    /**
     * Tests if the given message is a request message
     */
    function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    Message.isRequest = isRequest;
    /**
     * Tests if the given message is a notification message
     */
    function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
    }
    Message.isNotification = isNotification;
    /**
     * Tests if the given message is a response message
     */
    function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    Message.isResponse = isResponse;
})(Message = exports.Message || (exports.Message = {}));
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/ral.js":
/*!*******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/ral.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;
//# sourceMappingURL=ral.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/semaphore.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/semaphore.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;
//# sourceMappingURL=semaphore.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/node/main.js":
/*!******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/node/main.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(/*! ./ril */ "./node_modules/vscode-jsonrpc/lib/node/ril.js");
// Install the node runtime abstract.
ril_1.default.install();
const api_1 = __webpack_require__(/*! ../common/api */ "./node_modules/vscode-jsonrpc/lib/common/api.js");
const path = __webpack_require__(/*! path */ "path");
const os = __webpack_require__(/*! os */ "os");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const net_1 = __webpack_require__(/*! net */ "net");
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-jsonrpc/lib/common/api.js"), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readble, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readble), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = (0, crypto_1.randomBytes)(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length >= limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/node/ril.js":
/*!*****************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/node/ril.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ral_1 = __webpack_require__(/*! ../common/ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const util_1 = __webpack_require__(/*! util */ "util");
const disposable_1 = __webpack_require__(/*! ../common/disposable */ "./node_modules/vscode-jsonrpc/lib/common/disposable.js");
const messageBuffer_1 = __webpack_require__(/*! ../common/messageBuffer */ "./node_modules/vscode-jsonrpc/lib/common/messageBuffer.js");
class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return disposable_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setImmediate(callback, ...args);
            return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        ral_1.default.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;
//# sourceMappingURL=ril.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/node.js":
/*!*********************************************!*\
  !*** ./node_modules/vscode-jsonrpc/node.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "./node_modules/vscode-jsonrpc/lib/node/main.js");

/***/ }),

/***/ "./node_modules/vscode-languageclient/browser.js":
/*!*******************************************************!*\
  !*** ./node_modules/vscode-languageclient/browser.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/browser/main */ "./node_modules/vscode-languageclient/lib/browser/main.js");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/browser/main.js":
/*!****************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/browser/main.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LanguageClient = void 0;
const api_1 = __webpack_require__(/*! ../common/api */ "./node_modules/vscode-languageclient/lib/common/api.js");
const browser_1 = __webpack_require__(/*! vscode-languageserver-protocol/browser */ "./node_modules/vscode-languageserver-protocol/browser.js");
__exportStar(__webpack_require__(/*! vscode-languageserver-protocol/browser */ "./node_modules/vscode-languageserver-protocol/browser.js"), exports);
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-languageclient/lib/common/api.js"), exports);
class LanguageClient extends api_1.BaseLanguageClient {
    constructor(id, name, clientOptions, worker) {
        super(id, name, clientOptions);
        this.worker = worker;
    }
    createMessageTransports(_encoding) {
        const reader = new browser_1.BrowserMessageReader(this.worker);
        const writer = new browser_1.BrowserMessageWriter(this.worker);
        return Promise.resolve({ reader, writer });
    }
    getLocale() {
        // ToDo: need to find a way to let the locale
        // travel to the worker extension host.
        return 'en';
    }
}
exports.LanguageClient = LanguageClient;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/api.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/api.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticPullMode = exports.vsdiag = void 0;
__exportStar(__webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js"), exports);
__exportStar(__webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js"), exports);
var diagnostic_1 = __webpack_require__(/*! ./diagnostic */ "./node_modules/vscode-languageclient/lib/common/diagnostic.js");
Object.defineProperty(exports, "vsdiag", ({ enumerable: true, get: function () { return diagnostic_1.vsdiag; } }));
Object.defineProperty(exports, "DiagnosticPullMode", ({ enumerable: true, get: function () { return diagnostic_1.DiagnosticPullMode; } }));
__exportStar(__webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js"), exports);
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/callHierarchy.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/callHierarchy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class CallHierarchyProvider {
    constructor(client) {
        this.client = client;
        this.middleware = client.middleware;
    }
    prepareCallHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareCallHierarchy = (document, position, token) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asCallHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, token, error, null);
            });
        };
        return middleware.prepareCallHierarchy
            ? middleware.prepareCallHierarchy(document, position, token, prepareCallHierarchy)
            : prepareCallHierarchy(document, position, token);
    }
    provideCallHierarchyIncomingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyIncomingCalls = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asCallHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asCallHierarchyIncomingCalls(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, token, error, null);
            });
        };
        return middleware.provideCallHierarchyIncomingCalls
            ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls)
            : provideCallHierarchyIncomingCalls(item, token);
    }
    provideCallHierarchyOutgoingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyOutgoingCalls = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asCallHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, token, error, null);
            });
        };
        return middleware.provideCallHierarchyOutgoingCalls
            ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls)
            : provideCallHierarchyOutgoingCalls(item, token);
    }
}
class CallHierarchyFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
    }
    fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'callHierarchy');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const client = this._client;
        const provider = new CallHierarchyProvider(client);
        return [vscode_1.languages.registerCallHierarchyProvider(this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
    }
}
exports.CallHierarchyFeature = CallHierarchyFeature;
//# sourceMappingURL=callHierarchy.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProposedFeatures = exports.BaseLanguageClient = exports.MessageTransports = exports.SuspendMode = exports.State = exports.CloseAction = exports.ErrorAction = exports.RevealOutputChannelOn = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const c2p = __webpack_require__(/*! ./codeConverter */ "./node_modules/vscode-languageclient/lib/common/codeConverter.js");
const p2c = __webpack_require__(/*! ./protocolConverter */ "./node_modules/vscode-languageclient/lib/common/protocolConverter.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
const async_1 = __webpack_require__(/*! ./utils/async */ "./node_modules/vscode-languageclient/lib/common/utils/async.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const progressPart_1 = __webpack_require__(/*! ./progressPart */ "./node_modules/vscode-languageclient/lib/common/progressPart.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const diagnostic_1 = __webpack_require__(/*! ./diagnostic */ "./node_modules/vscode-languageclient/lib/common/diagnostic.js");
const notebook_1 = __webpack_require__(/*! ./notebook */ "./node_modules/vscode-languageclient/lib/common/notebook.js");
const configuration_1 = __webpack_require__(/*! ./configuration */ "./node_modules/vscode-languageclient/lib/common/configuration.js");
const textSynchronization_1 = __webpack_require__(/*! ./textSynchronization */ "./node_modules/vscode-languageclient/lib/common/textSynchronization.js");
const completion_1 = __webpack_require__(/*! ./completion */ "./node_modules/vscode-languageclient/lib/common/completion.js");
const hover_1 = __webpack_require__(/*! ./hover */ "./node_modules/vscode-languageclient/lib/common/hover.js");
const definition_1 = __webpack_require__(/*! ./definition */ "./node_modules/vscode-languageclient/lib/common/definition.js");
const signatureHelp_1 = __webpack_require__(/*! ./signatureHelp */ "./node_modules/vscode-languageclient/lib/common/signatureHelp.js");
const documentHighlight_1 = __webpack_require__(/*! ./documentHighlight */ "./node_modules/vscode-languageclient/lib/common/documentHighlight.js");
const documentSymbol_1 = __webpack_require__(/*! ./documentSymbol */ "./node_modules/vscode-languageclient/lib/common/documentSymbol.js");
const workspaceSymbol_1 = __webpack_require__(/*! ./workspaceSymbol */ "./node_modules/vscode-languageclient/lib/common/workspaceSymbol.js");
const reference_1 = __webpack_require__(/*! ./reference */ "./node_modules/vscode-languageclient/lib/common/reference.js");
const codeAction_1 = __webpack_require__(/*! ./codeAction */ "./node_modules/vscode-languageclient/lib/common/codeAction.js");
const codeLens_1 = __webpack_require__(/*! ./codeLens */ "./node_modules/vscode-languageclient/lib/common/codeLens.js");
const formatting_1 = __webpack_require__(/*! ./formatting */ "./node_modules/vscode-languageclient/lib/common/formatting.js");
const rename_1 = __webpack_require__(/*! ./rename */ "./node_modules/vscode-languageclient/lib/common/rename.js");
const documentLink_1 = __webpack_require__(/*! ./documentLink */ "./node_modules/vscode-languageclient/lib/common/documentLink.js");
const executeCommand_1 = __webpack_require__(/*! ./executeCommand */ "./node_modules/vscode-languageclient/lib/common/executeCommand.js");
const fileSystemWatcher_1 = __webpack_require__(/*! ./fileSystemWatcher */ "./node_modules/vscode-languageclient/lib/common/fileSystemWatcher.js");
const colorProvider_1 = __webpack_require__(/*! ./colorProvider */ "./node_modules/vscode-languageclient/lib/common/colorProvider.js");
const implementation_1 = __webpack_require__(/*! ./implementation */ "./node_modules/vscode-languageclient/lib/common/implementation.js");
const typeDefinition_1 = __webpack_require__(/*! ./typeDefinition */ "./node_modules/vscode-languageclient/lib/common/typeDefinition.js");
const workspaceFolder_1 = __webpack_require__(/*! ./workspaceFolder */ "./node_modules/vscode-languageclient/lib/common/workspaceFolder.js");
const foldingRange_1 = __webpack_require__(/*! ./foldingRange */ "./node_modules/vscode-languageclient/lib/common/foldingRange.js");
const declaration_1 = __webpack_require__(/*! ./declaration */ "./node_modules/vscode-languageclient/lib/common/declaration.js");
const selectionRange_1 = __webpack_require__(/*! ./selectionRange */ "./node_modules/vscode-languageclient/lib/common/selectionRange.js");
const progress_1 = __webpack_require__(/*! ./progress */ "./node_modules/vscode-languageclient/lib/common/progress.js");
const callHierarchy_1 = __webpack_require__(/*! ./callHierarchy */ "./node_modules/vscode-languageclient/lib/common/callHierarchy.js");
const semanticTokens_1 = __webpack_require__(/*! ./semanticTokens */ "./node_modules/vscode-languageclient/lib/common/semanticTokens.js");
const fileOperations_1 = __webpack_require__(/*! ./fileOperations */ "./node_modules/vscode-languageclient/lib/common/fileOperations.js");
const linkedEditingRange_1 = __webpack_require__(/*! ./linkedEditingRange */ "./node_modules/vscode-languageclient/lib/common/linkedEditingRange.js");
const typeHierarchy_1 = __webpack_require__(/*! ./typeHierarchy */ "./node_modules/vscode-languageclient/lib/common/typeHierarchy.js");
const inlineValue_1 = __webpack_require__(/*! ./inlineValue */ "./node_modules/vscode-languageclient/lib/common/inlineValue.js");
const inlayHint_1 = __webpack_require__(/*! ./inlayHint */ "./node_modules/vscode-languageclient/lib/common/inlayHint.js");
/**
 * Controls when the output channel is revealed.
 */
var RevealOutputChannelOn;
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
/**
 * An action to be performed when the connection is producing errors.
 */
var ErrorAction;
(function (ErrorAction) {
    /**
     * Continue running the server.
     */
    ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
    /**
     * Shutdown the server.
     */
    ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));
/**
 * An action to be performed when the connection to a server got closed.
 */
var CloseAction;
(function (CloseAction) {
    /**
     * Don't restart the server. The connection stays closed.
     */
    CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
    /**
     * Restart the server.
     */
    CloseAction[CloseAction["Restart"] = 2] = "Restart";
})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));
/**
 * Signals in which state the language client is in.
 */
var State;
(function (State) {
    /**
     * The client is stopped or got never started.
     */
    State[State["Stopped"] = 1] = "Stopped";
    /**
     * The client is starting but not ready yet.
     */
    State[State["Starting"] = 3] = "Starting";
    /**
     * The client is running and ready.
     */
    State[State["Running"] = 2] = "Running";
})(State = exports.State || (exports.State = {}));
var SuspendMode;
(function (SuspendMode) {
    /**
     * Don't allow suspend mode.
     */
    SuspendMode["off"] = "off";
    /**
     * Support suspend mode even if not all
     * registered providers have a corresponding
     * activation listener.
     */
    SuspendMode["on"] = "on";
})(SuspendMode = exports.SuspendMode || (exports.SuspendMode = {}));
class DefaultErrorHandler {
    constructor(client, maxRestartCount) {
        this.client = client;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
    }
    error(_error, _message, count) {
        if (count && count <= 3) {
            return { action: ErrorAction.Continue };
        }
        return { action: ErrorAction.Shutdown };
    }
    closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length <= this.maxRestartCount) {
            return { action: CloseAction.Restart };
        }
        else {
            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1000) {
                return { action: CloseAction.DoNotRestart, message: `The ${this.client.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted. See the output for more information.` };
            }
            else {
                this.restarts.shift();
                return { action: CloseAction.Restart };
            }
        }
    }
}
var ClientState;
(function (ClientState) {
    ClientState["Initial"] = "initial";
    ClientState["Starting"] = "starting";
    ClientState["StartFailed"] = "startFailed";
    ClientState["Running"] = "running";
    ClientState["Stopping"] = "stopping";
    ClientState["Stopped"] = "stopped";
})(ClientState || (ClientState = {}));
var MessageTransports;
(function (MessageTransports) {
    function is(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
    }
    MessageTransports.is = is;
})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));
class BaseLanguageClient {
    constructor(id, name, clientOptions) {
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._diagnosticQueue = new Map();
        this._diagnosticQueueState = { state: 'idle' };
        this._features = [];
        this._dynamicFeatures = new Map();
        this.workspaceEditLock = new async_1.Semaphore(1);
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        const markdown = { isTrusted: false, supportHtml: false };
        if (clientOptions.markdown !== undefined) {
            markdown.isTrusted = clientOptions.markdown.isTrusted === true;
            markdown.supportHtml = clientOptions.markdown.supportHtml === true;
        }
        // const defaultInterval = (clientOptions as TestOptions).$testMode ? 50 : 60000;
        this._clientOptions = {
            documentSelector: clientOptions.documentSelector ?? [],
            synchronize: clientOptions.synchronize ?? {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: clientOptions.outputChannelName ?? this._name,
            revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? RevealOutputChannelOn.Error,
            stdioEncoding: clientOptions.stdioEncoding ?? 'utf8',
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            progressOnInitialization: !!clientOptions.progressOnInitialization,
            errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler(clientOptions.connectionOptions?.maxRestartCount),
            middleware: clientOptions.middleware ?? {},
            uriConverters: clientOptions.uriConverters,
            workspaceFolder: clientOptions.workspaceFolder,
            connectionOptions: clientOptions.connectionOptions,
            markdown,
            // suspend: {
            // 	mode: clientOptions.suspend?.mode ?? SuspendMode.off,
            // 	callback: clientOptions.suspend?.callback ?? (() => Promise.resolve(true)),
            // 	interval: clientOptions.suspend?.interval ? Math.max(clientOptions.suspend.interval, defaultInterval) : defaultInterval
            // },
            diagnosticPullOptions: clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false },
            notebookDocumentOptions: clientOptions.notebookDocumentOptions ?? {}
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this._state = ClientState.Initial;
        this._ignoredRegistrations = new Set();
        this._listeners = [];
        this._notificationHandlers = new Map();
        this._pendingNotificationHandlers = new Map();
        this._notificationDisposables = new Map();
        this._requestHandlers = new Map();
        this._pendingRequestHandlers = new Map();
        this._requestDisposables = new Map();
        this._progressHandlers = new Map();
        this._pendingProgressHandlers = new Map();
        this._progressDisposables = new Map();
        this._connection = undefined;
        // this._idleStart = undefined;
        this._initializeResult = undefined;
        if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
            this._disposeOutputChannel = false;
        }
        else {
            this._outputChannel = undefined;
            this._disposeOutputChannel = true;
        }
        this._traceOutputChannel = clientOptions.traceOutputChannel;
        this._diagnostics = undefined;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onStop = undefined;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
        this._tracer = {
            log: (messageOrDataObject, data) => {
                if (Is.string(messageOrDataObject)) {
                    this.logTrace(messageOrDataObject, data);
                }
                else {
                    this.logObjectTrace(messageOrDataObject);
                }
            },
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : undefined);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : undefined, this._clientOptions.markdown.isTrusted, this._clientOptions.markdown.supportHtml);
        this._syncedDocuments = new Map();
        this.registerBuiltinFeatures();
    }
    get name() {
        return this._name;
    }
    get middleware() {
        return this._clientOptions.middleware ?? Object.create(null);
    }
    get clientOptions() {
        return this._clientOptions;
    }
    get protocol2CodeConverter() {
        return this._p2c;
    }
    get code2ProtocolConverter() {
        return this._c2p;
    }
    get onTelemetry() {
        return this._telemetryEmitter.event;
    }
    get onDidChangeState() {
        return this._stateChangeEmitter.event;
    }
    get outputChannel() {
        if (!this._outputChannel) {
            this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
    }
    get traceOutputChannel() {
        if (this._traceOutputChannel) {
            return this._traceOutputChannel;
        }
        return this.outputChannel;
    }
    get diagnostics() {
        return this._diagnostics;
    }
    get state() {
        return this.getPublicState();
    }
    get $state() {
        return this._state;
    }
    set $state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
        }
    }
    getPublicState() {
        switch (this.$state) {
            case ClientState.Starting:
                return State.Starting;
            case ClientState.Running:
                return State.Running;
            default:
                return State.Stopped;
        }
    }
    get initializeResult() {
        return this._initializeResult;
    }
    async sendRequest(type, ...params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        try {
            // Ensure we have a connection before we force the document sync.
            const connection = await this.$start();
            await this.forceDocumentSync();
            return connection.sendRequest(type, ...params);
        }
        catch (error) {
            this.error(`Sending request ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onRequest(type, handler) {
        const method = typeof type === 'string' ? type : type.method;
        this._requestHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== undefined) {
            this._requestDisposables.set(method, connection.onRequest(type, handler));
            disposable = {
                dispose: () => {
                    const disposable = this._requestDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._requestDisposables.delete(method);
                    }
                }
            };
        }
        else {
            this._pendingRequestHandlers.set(method, handler);
            disposable = {
                dispose: () => {
                    this._pendingRequestHandlers.delete(method);
                    const disposable = this._requestDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._requestDisposables.delete(method);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._requestHandlers.delete(method);
                disposable.dispose();
            }
        };
    }
    async sendNotification(type, params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        try {
            // Ensure we have a connection before we force the document sync.
            const connection = await this.$start();
            await this.forceDocumentSync();
            return connection.sendNotification(type, params);
        }
        catch (error) {
            this.error(`Sending notification ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onNotification(type, handler) {
        const method = typeof type === 'string' ? type : type.method;
        this._notificationHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== undefined) {
            this._notificationDisposables.set(method, connection.onNotification(type, handler));
            disposable = {
                dispose: () => {
                    const disposable = this._notificationDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._notificationDisposables.delete(method);
                    }
                }
            };
        }
        else {
            this._pendingNotificationHandlers.set(method, handler);
            disposable = {
                dispose: () => {
                    this._pendingNotificationHandlers.delete(method);
                    const disposable = this._notificationDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._notificationDisposables.delete(method);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._notificationHandlers.delete(method);
                disposable.dispose();
            }
        };
    }
    async sendProgress(type, token, value) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        try {
            // Ensure we have a connection before we force the document sync.
            const connection = await this.$start();
            return connection.sendProgress(type, token, value);
        }
        catch (error) {
            this.error(`Sending progress for token ${token} failed.`, error);
            throw error;
        }
    }
    onProgress(type, token, handler) {
        this._progressHandlers.set(token, { type, handler });
        const connection = this.activeConnection();
        let disposable;
        const handleWorkDoneProgress = this._clientOptions.middleware?.handleWorkDoneProgress;
        const realHandler = vscode_languageserver_protocol_1.WorkDoneProgress.is(type) && handleWorkDoneProgress !== undefined
            ? (params) => {
                handleWorkDoneProgress(token, params, () => handler(params));
            }
            : handler;
        if (connection !== undefined) {
            this._progressDisposables.set(token, connection.onProgress(type, token, realHandler));
            disposable = {
                dispose: () => {
                    const disposable = this._progressDisposables.get(token);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._progressDisposables.delete(token);
                    }
                }
            };
        }
        else {
            this._pendingProgressHandlers.set(token, { type, handler });
            disposable = {
                dispose: () => {
                    this._pendingProgressHandlers.delete(token);
                    const disposable = this._progressDisposables.get(token);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._progressDisposables.delete(token);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._progressHandlers.delete(token);
                disposable.dispose();
            }
        };
    }
    createDefaultErrorHandler(maxRestartCount) {
        if (maxRestartCount !== undefined && maxRestartCount < 0) {
            throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
        }
        return new DefaultErrorHandler(this, maxRestartCount ?? 4);
    }
    async setTrace(value) {
        this._trace = value;
        const connection = this.activeConnection();
        if (connection !== undefined) {
            await connection.trace(this._trace, this._tracer, {
                sendNotification: false,
                traceFormat: this._traceFormat
            });
        }
    }
    data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
            const responseError = data;
            return `  Message: ${responseError.message}\n  Code: ${responseError.code} ${responseError.data ? '\n' + responseError.data.toString() : ''}`;
        }
        if (data instanceof Error) {
            if (Is.string(data.stack)) {
                return data.stack;
            }
            return data.message;
        }
        if (Is.string(data)) {
            return data;
        }
        return data.toString();
    }
    info(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Info  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Info, message);
        }
    }
    warn(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Warn  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Warning, message);
        }
    }
    error(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Error - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification === 'force' || (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error)) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Error, message);
        }
    }
    showNotificationMessage(type, message) {
        message = message ?? 'A request has failed. See the output for more information.';
        const messageFunc = type === vscode_languageserver_protocol_1.MessageType.Error
            ? vscode_1.window.showErrorMessage
            : type === vscode_languageserver_protocol_1.MessageType.Warning
                ? vscode_1.window.showWarningMessage
                : vscode_1.window.showInformationMessage;
        void messageFunc(message, 'Go to output').then((selection) => {
            if (selection !== undefined) {
                this.outputChannel.show(true);
            }
        });
    }
    logTrace(message, data) {
        this.traceOutputChannel.appendLine(`[Trace - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.traceOutputChannel.appendLine(this.data2String(data));
        }
    }
    logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
            this.traceOutputChannel.append(`[LSP   - ${(new Date().toLocaleTimeString())}] `);
        }
        else {
            this.traceOutputChannel.append(`[Trace - ${(new Date().toLocaleTimeString())}] `);
        }
        if (data) {
            this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
        }
    }
    needsStart() {
        return this.$state === ClientState.Initial || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped;
    }
    needsStop() {
        return this.$state === ClientState.Starting || this.$state === ClientState.Running;
    }
    activeConnection() {
        return this.$state === ClientState.Running && this._connection !== undefined ? this._connection : undefined;
    }
    isRunning() {
        return this.$state === ClientState.Running;
    }
    async start() {
        if (this._disposed === 'disposing' || this._disposed === 'disposed') {
            throw new Error(`Client got disposed and can't be restarted.`);
        }
        if (this.$state === ClientState.Stopping) {
            throw new Error(`Client is currently stopping. Can only restart a full stopped client`);
        }
        // We are already running or are in the process of getting up
        // to speed.
        if (this._onStart !== undefined) {
            return this._onStart;
        }
        const [promise, resolve, reject] = this.createOnStartPromise();
        this._onStart = promise;
        // If we restart then the diagnostics collection is reused.
        if (this._diagnostics === undefined) {
            this._diagnostics = this._clientOptions.diagnosticCollectionName
                ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName)
                : vscode_1.languages.createDiagnosticCollection();
        }
        // When we start make all buffer handlers pending so that they
        // get added.
        for (const [method, handler] of this._notificationHandlers) {
            if (!this._pendingNotificationHandlers.has(method)) {
                this._pendingNotificationHandlers.set(method, handler);
            }
        }
        for (const [method, handler] of this._requestHandlers) {
            if (!this._pendingRequestHandlers.has(method)) {
                this._pendingRequestHandlers.set(method, handler);
            }
        }
        for (const [token, data] of this._progressHandlers) {
            if (!this._pendingProgressHandlers.has(token)) {
                this._pendingProgressHandlers.set(token, data);
            }
        }
        this.$state = ClientState.Starting;
        try {
            const connection = await this.createConnection();
            connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, (message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        this.error(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        this.warn(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        this.info(message.message, undefined, false);
                        break;
                    default:
                        this.outputChannel.appendLine(message.message);
                }
            });
            connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, (message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        void vscode_1.window.showErrorMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        void vscode_1.window.showWarningMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        void vscode_1.window.showInformationMessage(message.message);
                        break;
                    default:
                        void vscode_1.window.showInformationMessage(message.message);
                }
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
                let messageFunc;
                switch (params.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        messageFunc = vscode_1.window.showErrorMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        messageFunc = vscode_1.window.showWarningMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        messageFunc = vscode_1.window.showInformationMessage;
                        break;
                    default:
                        messageFunc = vscode_1.window.showInformationMessage;
                }
                let actions = params.actions || [];
                return messageFunc(params.message, ...actions);
            });
            connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, (data) => {
                this._telemetryEmitter.fire(data);
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
                const showDocument = async (params) => {
                    const uri = this.protocol2CodeConverter.asUri(params.uri);
                    try {
                        if (params.external === true) {
                            const success = await vscode_1.env.openExternal(uri);
                            return { success };
                        }
                        else {
                            const options = {};
                            if (params.selection !== undefined) {
                                options.selection = this.protocol2CodeConverter.asRange(params.selection);
                            }
                            if (params.takeFocus === undefined || params.takeFocus === false) {
                                options.preserveFocus = true;
                            }
                            else if (params.takeFocus === true) {
                                options.preserveFocus = false;
                            }
                            await vscode_1.window.showTextDocument(uri, options);
                            return { success: true };
                        }
                    }
                    catch (error) {
                        return { success: false };
                    }
                };
                const middleware = this._clientOptions.middleware.window?.showDocument;
                if (middleware !== undefined) {
                    return middleware(params, showDocument);
                }
                else {
                    return showDocument(params);
                }
            });
            connection.listen();
            await this.initialize(connection);
            resolve();
        }
        catch (error) {
            this.$state = ClientState.StartFailed;
            this.error(`${this._name} client: couldn't create connection to server.`, error, 'force');
            reject(error);
        }
        return this._onStart;
    }
    createOnStartPromise() {
        let resolve;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
            resolve = _resolve;
            reject = _reject;
        });
        return [promise, resolve, reject];
    }
    async initialize(connection) {
        this.refreshTrace(connection, false);
        const initOption = this._clientOptions.initializationOptions;
        // If the client is locked to a workspace folder use it. In this case the workspace folder
        // feature is not registered and we need to initialize the value here.
        const [rootPath, workspaceFolders] = this._clientOptions.workspaceFolder !== undefined
            ? [this._clientOptions.workspaceFolder.uri.fsPath, [{ uri: this._c2p.asUri(this._clientOptions.workspaceFolder.uri), name: this._clientOptions.workspaceFolder.name }]]
            : [this._clientGetRootPath(), null];
        const initParams = {
            processId: null,
            clientInfo: {
                name: vscode_1.env.appName,
                version: vscode_1.version
            },
            locale: this.getLocale(),
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is.func(initOption) ? initOption() : initOption,
            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
            workspaceFolders: workspaceFolders
        };
        this.fillInitializeParams(initParams);
        if (this._clientOptions.progressOnInitialization) {
            const token = UUID.generateUuid();
            const part = new progressPart_1.ProgressPart(connection, token);
            initParams.workDoneToken = token;
            try {
                const result = await this.doInitialize(connection, initParams);
                part.done();
                return result;
            }
            catch (error) {
                part.cancel();
                throw error;
            }
        }
        else {
            return this.doInitialize(connection, initParams);
        }
    }
    async doInitialize(connection, initParams) {
        try {
            const result = await connection.initialize(initParams);
            if (result.capabilities.positionEncoding !== undefined && result.capabilities.positionEncoding !== vscode_languageserver_protocol_1.PositionEncodingKind.UTF16) {
                throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
            }
            this._initializeResult = result;
            this.$state = ClientState.Running;
            let textDocumentSyncOptions = undefined;
            if (Is.number(result.capabilities.textDocumentSync)) {
                if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                    textDocumentSyncOptions = {
                        openClose: false,
                        change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                        save: undefined
                    };
                }
                else {
                    textDocumentSyncOptions = {
                        openClose: true,
                        change: result.capabilities.textDocumentSync,
                        save: {
                            includeText: false
                        }
                    };
                }
            }
            else if (result.capabilities.textDocumentSync !== undefined && result.capabilities.textDocumentSync !== null) {
                textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
            connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params => this.handleDiagnostics(params));
            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));
            // Add pending notification, request and progress handlers.
            for (const [method, handler] of this._pendingNotificationHandlers) {
                this._notificationDisposables.set(method, connection.onNotification(method, handler));
            }
            this._pendingNotificationHandlers.clear();
            for (const [method, handler] of this._pendingRequestHandlers) {
                this._requestDisposables.set(method, connection.onRequest(method, handler));
            }
            this._pendingRequestHandlers.clear();
            for (const [token, data] of this._pendingProgressHandlers) {
                this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
            }
            this._pendingProgressHandlers.clear();
            // if (this._clientOptions.suspend.mode !== SuspendMode.off) {
            // 	this._idleInterval =  RAL().timer.setInterval(() => this.checkSuspend(), this._clientOptions.suspend.interval);
            // }
            await connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            return result;
        }
        catch (error) {
            if (this._clientOptions.initializationFailedHandler) {
                if (this._clientOptions.initializationFailedHandler(error)) {
                    void this.initialize(connection);
                }
                else {
                    void this.stop();
                }
            }
            else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
                void vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: 'retry' }).then(item => {
                    if (item && item.id === 'retry') {
                        void this.initialize(connection);
                    }
                    else {
                        void this.stop();
                    }
                });
            }
            else {
                if (error && error.message) {
                    void vscode_1.window.showErrorMessage(error.message);
                }
                this.error('Server initialization failed.', error);
                void this.stop();
            }
            throw error;
        }
    }
    _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    stop(timeout = 2000) {
        // Wait 2 seconds on stop
        return this.shutdown('stop', timeout);
    }
    dispose(timeout = 2000) {
        try {
            this._disposed = 'disposing';
            return this.stop(timeout);
        }
        finally {
            this._disposed = 'disposed';
        }
    }
    async shutdown(mode, timeout) {
        // If the client is stopped or in its initial state return.
        if (this.$state === ClientState.Stopped || this.$state === ClientState.Initial) {
            return;
        }
        // If we are stopping the client and have a stop promise return it.
        if (this.$state === ClientState.Stopping) {
            if (this._onStop !== undefined) {
                return this._onStop;
            }
            else {
                throw new Error(`Client is stopping but no stop promise available.`);
            }
        }
        const connection = this.activeConnection();
        // We can't stop a client that is not running (e.g. has no connection). Especially not
        // on that us starting since it can't be correctly synchronized.
        if (connection === undefined || this.$state !== ClientState.Running) {
            throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
        }
        this._initializeResult = undefined;
        this.$state = ClientState.Stopping;
        this.cleanUp(mode);
        const tp = new Promise(c => { (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(c, timeout); });
        const shutdown = (async (connection) => {
            await connection.shutdown();
            await connection.exit();
            return connection;
        })(connection);
        return this._onStop = Promise.race([tp, shutdown]).then((connection) => {
            // The connection won the race with the timeout.
            if (connection !== undefined) {
                connection.end();
                connection.dispose();
            }
            else {
                this.error(`Stopping server timed out`, undefined, false);
                throw new Error(`Stopping the server timed out`);
            }
        }, (error) => {
            this.error(`Stopping server failed`, error, false);
            throw error;
        }).finally(() => {
            this.$state = ClientState.Stopped;
            mode === 'stop' && this.cleanUpChannel();
            this._onStart = undefined;
            this._onStop = undefined;
            this._connection = undefined;
            this._ignoredRegistrations.clear();
        });
    }
    cleanUp(mode) {
        // purge outstanding file events.
        this._fileEvents = [];
        this._fileEventDelayer.cancel();
        const disposables = this._listeners.splice(0, this._listeners.length);
        for (const disposable of disposables) {
            disposable.dispose();
        }
        if (this._syncedDocuments) {
            this._syncedDocuments.clear();
        }
        // Dispose features in reverse order;
        for (const feature of Array.from(this._features.entries()).map(entry => entry[1]).reverse()) {
            feature.dispose();
        }
        if (mode === 'stop' && this._diagnostics !== undefined) {
            this._diagnostics.dispose();
            this._diagnostics = undefined;
        }
        if (this._idleInterval !== undefined) {
            this._idleInterval.dispose();
            this._idleInterval = undefined;
        }
        // this._idleStart = undefined;
    }
    cleanUpChannel() {
        if (this._outputChannel !== undefined && this._disposeOutputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = undefined;
        }
    }
    notifyFileEvent(event) {
        const client = this;
        async function didChangeWatchedFile(event) {
            client._fileEvents.push(event);
            return client._fileEventDelayer.trigger(async () => {
                const connection = await client.$start();
                await client.forceDocumentSync();
                const result = connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, { changes: client._fileEvents });
                client._fileEvents = [];
                return result;
            });
        }
        const workSpaceMiddleware = this.clientOptions.middleware?.workspace;
        (workSpaceMiddleware?.didChangeWatchedFile ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event)).catch((error) => {
            client.error(`Notify file events failed.`, error);
        });
    }
    async forceDocumentSync() {
        if (this._didChangeTextDocumentFeature === undefined) {
            this._didChangeTextDocumentFeature = this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method);
        }
        return this._didChangeTextDocumentFeature.forceDelivery();
    }
    handleDiagnostics(params) {
        if (!this._diagnostics) {
            return;
        }
        const key = params.uri;
        if (this._diagnosticQueueState.state === 'busy' && this._diagnosticQueueState.document === key) {
            // Cancel the active run;
            this._diagnosticQueueState.tokenSource.cancel();
        }
        this._diagnosticQueue.set(params.uri, params.diagnostics);
        this.triggerDiagnosticQueue();
    }
    triggerDiagnosticQueue() {
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => { this.workDiagnosticQueue(); });
    }
    workDiagnosticQueue() {
        if (this._diagnosticQueueState.state === 'busy') {
            return;
        }
        const next = this._diagnosticQueue.entries().next();
        if (next.done === true) {
            // Nothing in the queue
            return;
        }
        const [document, diagnostics] = next.value;
        this._diagnosticQueue.delete(document);
        const tokenSource = new vscode_1.CancellationTokenSource();
        this._diagnosticQueueState = { state: 'busy', document: document, tokenSource };
        this._p2c.asDiagnostics(diagnostics, tokenSource.token).then((converted) => {
            if (!tokenSource.token.isCancellationRequested) {
                const uri = this._p2c.asUri(document);
                const middleware = this.clientOptions.middleware;
                if (middleware.handleDiagnostics) {
                    middleware.handleDiagnostics(uri, converted, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics));
                }
                else {
                    this.setDiagnostics(uri, converted);
                }
            }
        }).finally(() => {
            this._diagnosticQueueState = { state: 'idle' };
            this.triggerDiagnosticQueue();
        });
    }
    setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
            return;
        }
        this._diagnostics.set(uri, diagnostics);
    }
    async $start() {
        if (this.$state === ClientState.StartFailed) {
            throw new Error(`Previous start failed. Can't restart server.`);
        }
        await this.start();
        const connection = this.activeConnection();
        if (connection === undefined) {
            throw new Error(`Starting server failed`);
        }
        return connection;
    }
    async createConnection() {
        let errorHandler = (error, message, count) => {
            this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
            this.handleConnectionClosed();
        };
        const transports = await this.createMessageTransports(this._clientOptions.stdioEncoding || 'utf8');
        this._connection = createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        return this._connection;
    }
    handleConnectionClosed() {
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.$state === ClientState.Stopped) {
            return;
        }
        try {
            if (this._connection !== undefined) {
                this._connection.dispose();
            }
        }
        catch (error) {
            // Disposing a connection could fail if error cases.
        }
        let handlerResult = { action: CloseAction.DoNotRestart };
        if (this.$state !== ClientState.Stopping) {
            try {
                handlerResult = this._clientOptions.errorHandler.closed();
            }
            catch (error) {
                // Ignore errors coming from the error handler.
            }
        }
        this._connection = undefined;
        if (handlerResult.action === CloseAction.DoNotRestart) {
            this.error(handlerResult.message ?? 'Connection to server got closed. Server will not be restarted.', undefined, 'force');
            this.cleanUp('stop');
            if (this.$state === ClientState.Starting) {
                this.$state = ClientState.StartFailed;
            }
            else {
                this.$state = ClientState.Stopped;
            }
            this._onStop = Promise.resolve();
            this._onStart = undefined;
        }
        else if (handlerResult.action === CloseAction.Restart) {
            this.info(handlerResult.message ?? 'Connection to server got closed. Server will restart.');
            this.cleanUp('restart');
            this.$state = ClientState.Initial;
            this._onStop = Promise.resolve();
            this._onStart = undefined;
            this.start().catch((error) => this.error(`Restarting server failed`, error, 'force'));
        }
    }
    handleConnectionError(error, message, count) {
        const handlerResult = this._clientOptions.errorHandler.error(error, message, count);
        if (handlerResult.action === ErrorAction.Shutdown) {
            this.error(handlerResult.message ?? `Client ${this._name}: connection to server is erroring. Shutting down server.`, undefined, 'force');
            this.stop().catch((error) => {
                this.error(`Stopping server failed`, error, false);
            });
        }
    }
    hookConfigurationChanged(connection) {
        this._listeners.push(vscode_1.workspace.onDidChangeConfiguration(() => {
            this.refreshTrace(connection, true);
        }));
    }
    refreshTrace(connection, sendNotification = false) {
        const config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
            const traceConfig = config.get('trace.server', 'off');
            if (typeof traceConfig === 'string') {
                trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
            }
            else {
                trace = vscode_languageserver_protocol_1.Trace.fromString(config.get('trace.server.verbosity', 'off'));
                traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get('trace.server.format', 'text'));
            }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
            sendNotification,
            traceFormat: this._traceFormat
        }).catch((error) => { this.error(`Updating trace failed with error`, error, false); });
    }
    hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
            return;
        }
        let watchers;
        if (Is.array(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
    }
    registerFeatures(features) {
        for (let feature of features) {
            this.registerFeature(feature);
        }
    }
    registerFeature(feature) {
        this._features.push(feature);
        if (features_1.DynamicFeature.is(feature)) {
            const registrationType = feature.registrationType;
            this._dynamicFeatures.set(registrationType.method, feature);
        }
    }
    getFeature(request) {
        return this._dynamicFeatures.get(request);
    }
    hasDedicatedTextSynchronizationFeature(textDocument) {
        const feature = this.getFeature(vscode_languageserver_protocol_1.NotebookDocumentSyncRegistrationType.method);
        if (feature === undefined || !(feature instanceof notebook_1.NotebookDocumentSyncFeature)) {
            return false;
        }
        return feature.handles(textDocument);
    }
    registerBuiltinFeatures() {
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new textSynchronization_1.DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new textSynchronization_1.DidChangeTextDocumentFeature(this));
        this.registerFeature(new textSynchronization_1.WillSaveFeature(this));
        this.registerFeature(new textSynchronization_1.WillSaveWaitUntilFeature(this));
        this.registerFeature(new textSynchronization_1.DidSaveTextDocumentFeature(this));
        this.registerFeature(new textSynchronization_1.DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new fileSystemWatcher_1.FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new completion_1.CompletionItemFeature(this));
        this.registerFeature(new hover_1.HoverFeature(this));
        this.registerFeature(new signatureHelp_1.SignatureHelpFeature(this));
        this.registerFeature(new definition_1.DefinitionFeature(this));
        this.registerFeature(new reference_1.ReferencesFeature(this));
        this.registerFeature(new documentHighlight_1.DocumentHighlightFeature(this));
        this.registerFeature(new documentSymbol_1.DocumentSymbolFeature(this));
        this.registerFeature(new workspaceSymbol_1.WorkspaceSymbolFeature(this));
        this.registerFeature(new codeAction_1.CodeActionFeature(this));
        this.registerFeature(new codeLens_1.CodeLensFeature(this));
        this.registerFeature(new formatting_1.DocumentFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentRangeFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new rename_1.RenameFeature(this));
        this.registerFeature(new documentLink_1.DocumentLinkFeature(this));
        this.registerFeature(new executeCommand_1.ExecuteCommandFeature(this));
        this.registerFeature(new configuration_1.SyncConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        // We only register the workspace folder feature if the client is not locked
        // to a specific workspace folder.
        if (this.clientOptions.workspaceFolder === undefined) {
            this.registerFeature(new workspaceFolder_1.WorkspaceFoldersFeature(this));
        }
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
        this.registerFeature(new progress_1.ProgressFeature(this));
        this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
        this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
        this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this));
        this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this));
        this.registerFeature(new typeHierarchy_1.TypeHierarchyFeature(this));
        this.registerFeature(new inlineValue_1.InlineValueFeature(this));
        this.registerFeature(new inlayHint_1.InlayHintsFeature(this));
        this.registerFeature(new diagnostic_1.DiagnosticFeature(this));
        this.registerFeature(new notebook_1.NotebookDocumentSyncFeature(this));
    }
    registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
    }
    fillInitializeParams(params) {
        for (let feature of this._features) {
            if (Is.func(feature.fillInitializeParams)) {
                feature.fillInitializeParams(params);
            }
        }
    }
    computeClientCapabilities() {
        const result = {};
        (0, features_1.ensure)(result, 'workspace').applyEdit = true;
        const workspaceEdit = (0, features_1.ensure)((0, features_1.ensure)(result, 'workspace'), 'workspaceEdit');
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
            groupsOnLabel: true
        };
        const diagnostics = (0, features_1.ensure)((0, features_1.ensure)(result, 'textDocument'), 'publishDiagnostics');
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = (0, features_1.ensure)(result, 'window');
        const showMessage = (0, features_1.ensure)(windowCapabilities, 'showMessage');
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = (0, features_1.ensure)(windowCapabilities, 'showDocument');
        showDocument.support = true;
        const generalCapabilities = (0, features_1.ensure)(result, 'general');
        generalCapabilities.staleRequestSupport = {
            cancel: true,
            retryOnContentModified: Array.from(BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        generalCapabilities.regularExpressions = { engine: 'ECMAScript', version: 'ES2020' };
        generalCapabilities.markdown = {
            parser: 'marked',
            version: '1.1.0',
        };
        generalCapabilities.positionEncodings = ['utf-16'];
        if (this._clientOptions.markdown.supportHtml) {
            generalCapabilities.markdown.allowedTags = ['ul', 'li', 'p', 'code', 'blockquote', 'ol', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'em', 'pre', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'div', 'del', 'a', 'strong', 'br', 'img', 'span'];
        }
        for (let feature of this._features) {
            feature.fillClientCapabilities(result);
        }
        return result;
    }
    initializeFeatures(_connection) {
        const documentSelector = this._clientOptions.documentSelector;
        for (const feature of this._features) {
            if (Is.func(feature.preInitialize)) {
                feature.preInitialize(this._capabilities, documentSelector);
            }
        }
        for (const feature of this._features) {
            feature.initialize(this._capabilities, documentSelector);
        }
    }
    async handleRegistrationRequest(params) {
        // We will not receive a registration call before a client is running
        // from a server. However if we stop or shutdown we might which might
        // try to restart the server. So ignore registrations if we are not running
        if (!this.isRunning()) {
            for (const registration of params.registrations) {
                this._ignoredRegistrations.add(registration.id);
            }
            return;
        }
        for (const registration of params.registrations) {
            const feature = this._dynamicFeatures.get(registration.method);
            if (feature === undefined) {
                return Promise.reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
            }
            const options = registration.registerOptions ?? {};
            options.documentSelector = options.documentSelector ?? this._clientOptions.documentSelector;
            const data = {
                id: registration.id,
                registerOptions: options
            };
            try {
                feature.register(data);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
    }
    async handleUnregistrationRequest(params) {
        for (let unregistration of params.unregisterations) {
            if (this._ignoredRegistrations.has(unregistration.id)) {
                continue;
            }
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (!feature) {
                return Promise.reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
            }
            feature.unregister(unregistration.id);
        }
    }
    async handleApplyWorkspaceEdit(params) {
        const workspaceEdit = params.edit;
        // Make sure we convert workspace edits one after the other. Otherwise
        // we might execute a workspace edit received first after we received another
        // one since the conversion might race.
        const converted = await this.workspaceEditLock.lock(() => {
            return this._p2c.asWorkspaceEdit(workspaceEdit);
        });
        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
        // However doing it here adds some safety since the server can lag more behind then an extension.
        const openTextDocuments = new Map();
        vscode_1.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
                if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    const textDocument = openTextDocuments.get(change.textDocument.uri);
                    if (textDocument && textDocument.version !== change.textDocument.version) {
                        versionMismatch = true;
                        break;
                    }
                }
            }
        }
        if (versionMismatch) {
            return Promise.resolve({ applied: false });
        }
        return Is.asPromise(vscode_1.workspace.applyEdit(converted).then((value) => { return { applied: value }; }));
    }
    handleFailedRequest(type, token, error, defaultValue, showNotification = true) {
        // If we get a request cancel or a content modified don't log anything.
        if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
            // The connection got disposed while we were waiting for a response.
            // Simply return the default value. Is the best we can do.
            if (error.code === vscode_languageserver_protocol_1.ErrorCodes.PendingResponseRejected || error.code === vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive) {
                return defaultValue;
            }
            if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ServerCancelled) {
                if (token !== undefined && token.isCancellationRequested) {
                    return defaultValue;
                }
                else {
                    if (error.data !== undefined) {
                        throw new features_1.LSPCancellationError(error.data);
                    }
                    else {
                        throw new vscode_1.CancellationError();
                    }
                }
            }
            else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
                if (BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method)) {
                    throw new vscode_1.CancellationError();
                }
                else {
                    return defaultValue;
                }
            }
        }
        this.error(`Request ${type.method} failed.`, error, showNotification);
        throw error;
    }
}
exports.BaseLanguageClient = BaseLanguageClient;
BaseLanguageClient.RequestsToCancelOnContentModified = new Set([
    vscode_languageserver_protocol_1.SemanticTokensRequest.method,
    vscode_languageserver_protocol_1.SemanticTokensRangeRequest.method,
    vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.method
]);
class ConsoleLogger {
    error(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.error(message);
    }
    warn(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.warn(message);
    }
    info(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.info(message);
    }
    log(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.log(message);
    }
}
function createConnection(input, output, errorHandler, closeHandler, options) {
    let _lastUsed = -1;
    const logger = new ConsoleLogger();
    const connection = (0, vscode_languageserver_protocol_1.createProtocolConnection)(input, output, logger, options);
    connection.onError((data) => { errorHandler(data[0], data[1], data[2]); });
    connection.onClose(closeHandler);
    const result = {
        get lastUsed() {
            return _lastUsed;
        },
        resetLastUsed: () => {
            _lastUsed = -1;
        },
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => {
            _lastUsed = Date.now();
            return connection.sendRequest(type, ...params);
        },
        onRequest: (type, handler) => connection.onRequest(type, handler),
        hasPendingResponse: () => connection.hasPendingResponse(),
        sendNotification: (type, params) => {
            _lastUsed = Date.now();
            return connection.sendNotification(type, params);
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
            const defaultTraceOptions = {
                sendNotification: false,
                traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
            };
            if (sendNotificationOrTraceOptions === undefined) {
                return connection.trace(value, tracer, defaultTraceOptions);
            }
            else if (Is.boolean(sendNotificationOrTraceOptions)) {
                return connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
            else {
                return connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
        },
        initialize: (params) => {
            _lastUsed = Date.now();
            return connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params);
        },
        shutdown: () => {
            _lastUsed = Date.now();
            return connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, undefined);
        },
        exit: () => {
            _lastUsed = Date.now();
            return connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type);
        },
        end: () => connection.end(),
        dispose: () => connection.dispose()
    };
    return result;
}
// Exporting proposed protocol.
var ProposedFeatures;
(function (ProposedFeatures) {
    function createAll(_client) {
        let result = [];
        return result;
    }
    ProposedFeatures.createAll = createAll;
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
//# sourceMappingURL=client.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/codeAction.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/codeAction.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeActionFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class CodeActionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const cap = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'codeAction');
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        // We can only resolve the edit property.
        cap.resolveSupport = {
            properties: ['edit']
        };
        cap.codeActionLiteralSupport = {
            codeActionKind: {
                valueSet: [
                    vscode_languageserver_protocol_1.CodeActionKind.Empty,
                    vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
                    vscode_languageserver_protocol_1.CodeActionKind.Refactor,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
                    vscode_languageserver_protocol_1.CodeActionKind.Source,
                    vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
                ]
            }
        };
        cap.honorsChangeAnnotations = false;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideCodeActions: (document, range, context, token) => {
                const client = this._client;
                const _provideCodeActions = async (document, range, context, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        context: await client.code2ProtocolConverter.asCodeActionContext(context, token)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token).then((values) => {
                        if (token.isCancellationRequested || values === null || values === undefined) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asCodeActionResult(values, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideCodeActions
                    ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions)
                    : _provideCodeActions(document, range, context, token);
            },
            resolveCodeAction: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.middleware;
                    const resolveCodeAction = async (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, await client.code2ProtocolConverter.asCodeAction(item, token), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return item;
                            }
                            return client.protocol2CodeConverter.asCodeAction(result, token);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, token, error, item);
                        });
                    };
                    return middleware.resolveCodeAction
                        ? middleware.resolveCodeAction(item, token, resolveCodeAction)
                        : resolveCodeAction(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCodeActionsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, (options.codeActionKinds
                ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) }
                : undefined)), provider];
    }
}
exports.CodeActionFeature = CodeActionFeature;
//# sourceMappingURL=codeAction.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/codeConverter.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/codeConverter.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(/*! vscode */ "vscode");
const proto = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
const async = __webpack_require__(/*! ./utils/async */ "./node_modules/vscode-languageclient/lib/common/utils/async.js");
const protocolCompletionItem_1 = __webpack_require__(/*! ./protocolCompletionItem */ "./node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js");
const protocolCodeLens_1 = __webpack_require__(/*! ./protocolCodeLens */ "./node_modules/vscode-languageclient/lib/common/protocolCodeLens.js");
const protocolDocumentLink_1 = __webpack_require__(/*! ./protocolDocumentLink */ "./node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js");
const protocolCodeAction_1 = __webpack_require__(/*! ./protocolCodeAction */ "./node_modules/vscode-languageclient/lib/common/protocolCodeAction.js");
const protocolDiagnostic_1 = __webpack_require__(/*! ./protocolDiagnostic */ "./node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js");
const protocolCallHierarchyItem_1 = __webpack_require__(/*! ./protocolCallHierarchyItem */ "./node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js");
const protocolTypeHierarchyItem_1 = __webpack_require__(/*! ./protocolTypeHierarchyItem */ "./node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js");
const protocolWorkspaceSymbol_1 = __webpack_require__(/*! ./protocolWorkspaceSymbol */ "./node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js");
const protocolInlayHint_1 = __webpack_require__(/*! ./protocolInlayHint */ "./node_modules/vscode-languageclient/lib/common/protocolInlayHint.js");
var InsertReplaceRange;
(function (InsertReplaceRange) {
    function is(value) {
        const candidate = value;
        return candidate && !!candidate.inserting && !!candidate.replacing;
    }
    InsertReplaceRange.is = is;
})(InsertReplaceRange || (InsertReplaceRange = {}));
function createConverter(uriConverter) {
    const nullConverter = (value) => value.toString();
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri)
        };
    }
    function asTextDocumentItem(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            languageId: textDocument.languageId,
            version: textDocument.version,
            text: textDocument.getText()
        };
    }
    function asVersionedTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            version: textDocument.version
        };
    }
    function asOpenTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentItem(textDocument)
        };
    }
    function isTextDocumentChangeEvent(value) {
        let candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
    }
    function isTextDocument(value) {
        let candidate = value;
        return !!candidate.uri && !!candidate.version;
    }
    function asChangeTextDocumentParams(arg) {
        if (isTextDocument(arg)) {
            let result = {
                textDocument: {
                    uri: _uriConverter(arg.uri),
                    version: arg.version
                },
                contentChanges: [{ text: arg.getText() }]
            };
            return result;
        }
        else if (isTextDocumentChangeEvent(arg)) {
            let document = arg.document;
            let result = {
                textDocument: {
                    uri: _uriConverter(document.uri),
                    version: document.version
                },
                contentChanges: arg.contentChanges.map((change) => {
                    let range = change.range;
                    return {
                        range: {
                            start: { line: range.start.line, character: range.start.character },
                            end: { line: range.end.line, character: range.end.character }
                        },
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            };
            return result;
        }
        else {
            throw Error('Unsupported text document change parameter');
        }
    }
    function asCloseTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
            result.text = textDocument.getText();
        }
        return result;
    }
    function asTextDocumentSaveReason(reason) {
        switch (reason) {
            case code.TextDocumentSaveReason.Manual:
                return proto.TextDocumentSaveReason.Manual;
            case code.TextDocumentSaveReason.AfterDelay:
                return proto.TextDocumentSaveReason.AfterDelay;
            case code.TextDocumentSaveReason.FocusOut:
                return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
    }
    function asWillSaveTextDocumentParams(event) {
        return {
            textDocument: asTextDocumentIdentifier(event.document),
            reason: asTextDocumentSaveReason(event.reason)
        };
    }
    function asDidCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asDidRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asDidDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asWillDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asTextDocumentPositionParams(textDocument, position) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position)
        };
    }
    function asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.CompletionTriggerKind.TriggerCharacter:
                return proto.CompletionTriggerKind.TriggerCharacter;
            case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
                return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
                return proto.CompletionTriggerKind.Invoked;
        }
    }
    function asCompletionParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                triggerKind: asCompletionTriggerKind(context.triggerKind),
                triggerCharacter: context.triggerCharacter
            }
        };
    }
    function asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.SignatureHelpTriggerKind.Invoke:
                return proto.SignatureHelpTriggerKind.Invoked;
            case code.SignatureHelpTriggerKind.TriggerCharacter:
                return proto.SignatureHelpTriggerKind.TriggerCharacter;
            case code.SignatureHelpTriggerKind.ContentChange:
                return proto.SignatureHelpTriggerKind.ContentChange;
        }
    }
    function asParameterInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label
        };
    }
    function asParameterInformations(values) {
        return values.map(asParameterInformation);
    }
    function asSignatureInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label,
            parameters: asParameterInformations(value.parameters)
        };
    }
    function asSignatureInformations(values) {
        return values.map(asSignatureInformation);
    }
    function asSignatureHelp(value) {
        if (value === undefined) {
            return value;
        }
        return {
            signatures: asSignatureInformations(value.signatures),
            activeSignature: value.activeSignature,
            activeParameter: value.activeParameter
        };
    }
    function asSignatureHelpParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                isRetrigger: context.isRetrigger,
                triggerCharacter: context.triggerCharacter,
                triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
                activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
            }
        };
    }
    function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
    }
    function asPosition(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { line: value.line > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.line, character: value.character > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.character };
    }
    function asPositions(value, token) {
        return async.map(value, asPosition, token);
    }
    function asRange(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
    }
    function asLocation(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return proto.Location.create(asUri(value.uri), asRange(value.range));
    }
    function asDiagnosticSeverity(value) {
        switch (value) {
            case code.DiagnosticSeverity.Error:
                return proto.DiagnosticSeverity.Error;
            case code.DiagnosticSeverity.Warning:
                return proto.DiagnosticSeverity.Warning;
            case code.DiagnosticSeverity.Information:
                return proto.DiagnosticSeverity.Information;
            case code.DiagnosticSeverity.Hint:
                return proto.DiagnosticSeverity.Hint;
        }
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case code.DiagnosticTag.Unnecessary:
                return proto.DiagnosticTag.Unnecessary;
            case code.DiagnosticTag.Deprecated:
                return proto.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asRelatedInformation(item) {
        return {
            message: item.message,
            location: asLocation(item.location)
        };
    }
    function asRelatedInformations(items) {
        return items.map(asRelatedInformation);
    }
    function asDiagnosticCode(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        if (Is.number(value) || Is.string(value)) {
            return value;
        }
        return { value: value.value, target: asUri(value.target) };
    }
    function asDiagnostic(item) {
        const result = proto.Diagnostic.create(asRange(item.range), item.message);
        const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : undefined;
        if (protocolDiagnostic !== undefined && protocolDiagnostic.data !== undefined) {
            result.data = protocolDiagnostic.data;
        }
        const code = asDiagnosticCode(item.code);
        if (protocolDiagnostic_1.DiagnosticCode.is(code)) {
            if (protocolDiagnostic !== undefined && protocolDiagnostic.hasDiagnosticCode) {
                result.code = code;
            }
            else {
                result.code = code.value;
                result.codeDescription = { href: code.target };
            }
        }
        else {
            result.code = code;
        }
        if (Is.number(item.severity)) {
            result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Array.isArray(item.tags)) {
            result.tags = asDiagnosticTags(item.tags);
        }
        if (item.relatedInformation) {
            result.relatedInformation = asRelatedInformations(item.relatedInformation);
        }
        if (item.source) {
            result.source = item.source;
        }
        return result;
    }
    function asDiagnostics(items, token) {
        if (items === undefined || items === null) {
            return items;
        }
        return async.map(items, asDiagnostic, token);
    }
    function asDocumentation(format, documentation) {
        switch (format) {
            case '$string':
                return documentation;
            case proto.MarkupKind.PlainText:
                return { kind: format, value: documentation };
            case proto.MarkupKind.Markdown:
                return { kind: format, value: documentation.value };
            default:
                return `Unsupported Markup content received. Kind is: ${format}`;
        }
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case code.CompletionItemTag.Deprecated:
                return proto.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined) {
            return tags;
        }
        const result = [];
        for (let tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItemKind(value, original) {
        if (original !== undefined) {
            return original;
        }
        return value + 1;
    }
    function asCompletionItem(item, labelDetailsSupport = false) {
        let label;
        let labelDetails;
        if (Is.string(item.label)) {
            label = item.label;
        }
        else {
            label = item.label.label;
            if (labelDetailsSupport && (item.label.detail !== undefined || item.label.description !== undefined)) {
                labelDetails = { detail: item.label.detail, description: item.label.description };
            }
        }
        let result = { label: label };
        if (labelDetails !== undefined) {
            result.labelDetails = labelDetails;
        }
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : undefined;
        if (item.detail) {
            result.detail = item.detail;
        }
        // We only send items back we created. So this can't be something else than
        // a string right now.
        if (item.documentation) {
            if (!protocolItem || protocolItem.documentationFormat === '$string') {
                result.documentation = item.documentation;
            }
            else {
                result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
            }
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
            result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        const tags = asCompletionItemTags(item.tags);
        if (protocolItem) {
            if (protocolItem.data !== undefined) {
                result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
                if (protocolItem.deprecated === true && tags !== undefined && tags.length > 0) {
                    const index = tags.indexOf(code.CompletionItemTag.Deprecated);
                    if (index !== -1) {
                        tags.splice(index, 1);
                    }
                }
                result.deprecated = protocolItem.deprecated;
            }
            if (protocolItem.insertTextMode !== undefined) {
                result.insertTextMode = protocolItem.insertTextMode;
            }
        }
        if (tags !== undefined && tags.length > 0) {
            result.tags = tags;
        }
        if (result.insertTextMode === undefined && item.keepWhitespace === true) {
            result.insertTextMode = proto.InsertTextMode.adjustIndentation;
        }
        return result;
    }
    function fillPrimaryInsertText(target, source) {
        let format = proto.InsertTextFormat.PlainText;
        let text = undefined;
        let range = undefined;
        if (source.textEdit) {
            text = source.textEdit.newText;
            range = source.textEdit.range;
        }
        else if (source.insertText instanceof code.SnippetString) {
            format = proto.InsertTextFormat.Snippet;
            text = source.insertText.value;
        }
        else {
            text = source.insertText;
        }
        if (source.range) {
            range = source.range;
        }
        target.insertTextFormat = format;
        if (source.fromEdit && text !== undefined && range !== undefined) {
            target.textEdit = asCompletionTextEdit(text, range);
        }
        else {
            target.insertText = text;
        }
    }
    function asCompletionTextEdit(newText, range) {
        if (InsertReplaceRange.is(range)) {
            return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
        }
        else {
            return { newText, range: asRange(range) };
        }
    }
    function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
    }
    function asTextEdits(edits) {
        if (edits === undefined || edits === null) {
            return edits;
        }
        return edits.map(asTextEdit);
    }
    function asSymbolKind(item) {
        if (item <= code.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return (item + 1);
        }
        return proto.SymbolKind.Property;
    }
    function asSymbolTag(item) {
        return item;
    }
    function asSymbolTags(items) {
        return items.map(asSymbolTag);
    }
    function asReferenceParams(textDocument, position, options) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: { includeDeclaration: options.includeDeclaration }
        };
    }
    async function asCodeAction(item, token) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== undefined) {
            result.data = item.data;
        }
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = await asDiagnostics(item.diagnostics, token);
        }
        if (item.edit !== undefined) {
            throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    async function asCodeActionContext(context, token) {
        if (context === undefined || context === null) {
            return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
            only = [context.only.value];
        }
        return proto.CodeActionContext.create(await asDiagnostics(context.diagnostics, token), only, asCodeActionTriggerKind(context.triggerKind));
    }
    function asCodeActionTriggerKind(kind) {
        switch (kind) {
            case code.CodeActionTriggerKind.Invoke:
                return proto.CodeActionTriggerKind.Invoked;
            case code.CodeActionTriggerKind.Automatic:
                return proto.CodeActionTriggerKind.Automatic;
            default:
                return undefined;
        }
    }
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        return item.value;
    }
    function asInlineValueContext(context) {
        if (context === undefined || context === null) {
            return context;
        }
        return proto.InlineValueContext.create(context.frameId, asRange(context.stoppedLocation));
    }
    function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
            if (item.data) {
                result.data = item.data;
            }
        }
        return result;
    }
    function asFormattingOptions(options, fileOptions) {
        const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
        if (fileOptions.trimTrailingWhitespace) {
            result.trimTrailingWhitespace = true;
        }
        if (fileOptions.trimFinalNewlines) {
            result.trimFinalNewlines = true;
        }
        if (fileOptions.insertFinalNewline) {
            result.insertFinalNewline = true;
        }
        return result;
    }
    function asDocumentSymbolParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCodeLensParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange(item.range));
        if (item.target) {
            result.target = asUri(item.target);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = item.tooltip;
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : undefined;
        if (protocolItem && protocolItem.data) {
            result.data = protocolItem.data;
        }
        return result;
    }
    function asDocumentLinkParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCallHierarchyItem(value) {
        const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange)
        };
        if (value.detail !== undefined && value.detail.length > 0) {
            result.detail = value.detail;
        }
        if (value.tags !== undefined) {
            result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolCallHierarchyItem_1.default && value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    function asTypeHierarchyItem(value) {
        const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange),
        };
        if (value.detail !== undefined && value.detail.length > 0) {
            result.detail = value.detail;
        }
        if (value.tags !== undefined) {
            result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolTypeHierarchyItem_1.default && value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    function asWorkspaceSymbol(item) {
        const result = item instanceof protocolWorkspaceSymbol_1.default
            ? { name: item.name, kind: asSymbolKind(item.kind), location: item.hasRange ? asLocation(item.location) : { uri: _uriConverter(item.location.uri) }, data: item.data }
            : { name: item.name, kind: asSymbolKind(item.kind), location: asLocation(item.location) };
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        if (item.containerName !== '') {
            result.containerName = item.containerName;
        }
        return result;
    }
    function asInlayHint(item) {
        const label = typeof item.label === 'string'
            ? item.label
            : item.label.map(asInlayHintLabelPart);
        const result = proto.InlayHint.create(asPosition(item.position), label);
        if (item.kind !== undefined) {
            result.kind = item.kind;
        }
        if (item.textEdits !== undefined) {
            result.textEdits = asTextEdits(item.textEdits);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = asTooltip(item.tooltip);
        }
        if (item.paddingLeft !== undefined) {
            result.paddingLeft = item.paddingLeft;
        }
        if (item.paddingRight !== undefined) {
            result.paddingRight = item.paddingRight;
        }
        if (item instanceof protocolInlayHint_1.default && item.data !== undefined) {
            result.data = item.data;
        }
        return result;
    }
    function asInlayHintLabelPart(item) {
        const result = proto.InlayHintLabelPart.create(item.value);
        if (item.location !== undefined) {
            result.location = asLocation(item.location);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = asTooltip(item.tooltip);
        }
        return result;
    }
    function asTooltip(value) {
        if (typeof value === 'string') {
            return value;
        }
        const result = {
            kind: proto.MarkupKind.Markdown,
            value: value.value
        };
        return result;
    }
    return {
        asUri,
        asTextDocumentIdentifier,
        asTextDocumentItem,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asDidCreateFilesParams,
        asDidRenameFilesParams,
        asDidDeleteFilesParams,
        asWillCreateFilesParams,
        asWillRenameFilesParams,
        asWillDeleteFilesParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asSignatureHelpParams,
        asWorkerPosition,
        asRange,
        asPosition,
        asPositions,
        asLocation,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asDiagnostic,
        asDiagnostics,
        asCompletionItem,
        asTextEdit,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asReferenceParams,
        asCodeAction,
        asCodeActionContext,
        asInlineValueContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams,
        asCallHierarchyItem,
        asTypeHierarchyItem,
        asInlayHint,
        asWorkspaceSymbol
    };
}
exports.createConverter = createConverter;
//# sourceMappingURL=codeConverter.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/codeLens.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/codeLens.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeLensFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class CodeLensFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'codeLens').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'codeLens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeCodeLensEmitter.fire();
            }
        });
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeCodeLenses: eventEmitter.event,
            provideCodeLenses: (document, token) => {
                const client = this._client;
                const provideCodeLenses = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asCodeLenses(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideCodeLenses
                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)
                    : provideCodeLenses(document, token);
            },
            resolveCodeLens: (options.resolveProvider)
                ? (codeLens, token) => {
                    const client = this._client;
                    const resolveCodeLens = (codeLens, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return codeLens;
                            }
                            return client.protocol2CodeConverter.asCodeLens(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, token, error, codeLens);
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.resolveCodeLens
                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)
                        : resolveCodeLens(codeLens, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCodeLensProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), { provider, onDidChangeCodeLensEmitter: eventEmitter }];
    }
}
exports.CodeLensFeature = CodeLensFeature;
//# sourceMappingURL=codeLens.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/colorProvider.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/colorProvider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorProviderFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class ColorProviderFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'colorProvider').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideColorPresentations: (color, context, token) => {
                const client = this._client;
                const provideColorPresentations = (color, context, token) => {
                    const requestParams = {
                        color,
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context.document),
                        range: client.code2ProtocolConverter.asRange(context.range)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return this._client.protocol2CodeConverter.asColorPresentations(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideColorPresentations
                    ? middleware.provideColorPresentations(color, context, token, provideColorPresentations)
                    : provideColorPresentations(color, context, token);
            },
            provideDocumentColors: (document, token) => {
                const client = this._client;
                const provideDocumentColors = (document, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return this._client.protocol2CodeConverter.asColorInformations(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentColors
                    ? middleware.provideDocumentColors(document, token, provideDocumentColors)
                    : provideDocumentColors(document, token);
            }
        };
        return [vscode_1.languages.registerColorProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.ColorProviderFeature = ColorProviderFeature;
//# sourceMappingURL=colorProvider.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/completion.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/completion.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompletionItemFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const SupportedCompletionItemKinds = [
    vscode_languageserver_protocol_1.CompletionItemKind.Text,
    vscode_languageserver_protocol_1.CompletionItemKind.Method,
    vscode_languageserver_protocol_1.CompletionItemKind.Function,
    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
    vscode_languageserver_protocol_1.CompletionItemKind.Field,
    vscode_languageserver_protocol_1.CompletionItemKind.Variable,
    vscode_languageserver_protocol_1.CompletionItemKind.Class,
    vscode_languageserver_protocol_1.CompletionItemKind.Interface,
    vscode_languageserver_protocol_1.CompletionItemKind.Module,
    vscode_languageserver_protocol_1.CompletionItemKind.Property,
    vscode_languageserver_protocol_1.CompletionItemKind.Unit,
    vscode_languageserver_protocol_1.CompletionItemKind.Value,
    vscode_languageserver_protocol_1.CompletionItemKind.Enum,
    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
    vscode_languageserver_protocol_1.CompletionItemKind.Color,
    vscode_languageserver_protocol_1.CompletionItemKind.File,
    vscode_languageserver_protocol_1.CompletionItemKind.Reference,
    vscode_languageserver_protocol_1.CompletionItemKind.Folder,
    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
    vscode_languageserver_protocol_1.CompletionItemKind.Constant,
    vscode_languageserver_protocol_1.CompletionItemKind.Struct,
    vscode_languageserver_protocol_1.CompletionItemKind.Event,
    vscode_languageserver_protocol_1.CompletionItemKind.Operator,
    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
];
class CompletionItemFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
        this.labelDetailsSupport = new Map();
    }
    fillClientCapabilities(capabilities) {
        let completion = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'completion');
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
            snippetSupport: true,
            commitCharactersSupport: true,
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            deprecatedSupport: true,
            preselectSupport: true,
            tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
            insertReplaceSupport: true,
            resolveSupport: {
                properties: ['documentation', 'detail', 'additionalTextEdits']
            },
            insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] },
            labelDetailsSupport: true
        };
        completion.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
        completion.completionList = {
            itemDefaults: [
                'commitCharacters', 'editRange', 'insertTextFormat', 'insertTextMode'
            ]
        };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options, id) {
        this.labelDetailsSupport.set(id, !!options.completionItem?.labelDetailsSupport);
        const triggerCharacters = options.triggerCharacters ?? [];
        const defaultCommitCharacters = options.allCommitCharacters;
        const selector = options.documentSelector;
        const provider = {
            provideCompletionItems: (document, position, token, context) => {
                const client = this._client;
                const middleware = this._client.middleware;
                const provideCompletionItems = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document, position, context), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asCompletionResult(result, defaultCommitCharacters, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, token, error, null);
                    });
                };
                return middleware.provideCompletionItem
                    ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)
                    : provideCompletionItems(document, position, context, token);
            },
            resolveCompletionItem: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.middleware;
                    const resolveCompletionItem = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item, !!this.labelDetailsSupport.get(id)), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asCompletionItem(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, token, error, item);
                        });
                    };
                    return middleware.resolveCompletionItem
                        ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)
                        : resolveCompletionItem(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCompletionItemProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, ...triggerCharacters), provider];
    }
}
exports.CompletionItemFeature = CompletionItemFeature;
//# sourceMappingURL=completion.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/configuration.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/configuration.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyncConfigurationFeature = exports.toJSONObject = exports.ConfigurationFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
/**
 * Configuration pull model. From server to client.
 */
class ConfigurationFeature {
    constructor(client) {
        this._client = client;
    }
    getState() {
        return { kind: 'static' };
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
    }
    initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
            let configuration = (params) => {
                let result = [];
                for (let item of params.items) {
                    let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : undefined;
                    result.push(this.getConfiguration(resource, item.section !== null ? item.section : undefined));
                }
                return result;
            };
            let middleware = client.middleware.workspace;
            return middleware && middleware.configuration
                ? middleware.configuration(params, token, configuration)
                : configuration(params, token);
        });
    }
    getConfiguration(resource, section) {
        let result = null;
        if (section) {
            let index = section.lastIndexOf('.');
            if (index === -1) {
                result = toJSONObject(vscode_1.workspace.getConfiguration(undefined, resource).get(section));
            }
            else {
                let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
                if (config) {
                    result = toJSONObject(config.get(section.substr(index + 1)));
                }
            }
        }
        else {
            let config = vscode_1.workspace.getConfiguration(undefined, resource);
            result = {};
            for (let key of Object.keys(config)) {
                if (config.has(key)) {
                    result[key] = toJSONObject(config.get(key));
                }
            }
        }
        if (result === undefined) {
            result = null;
        }
        return result;
    }
    dispose() {
    }
}
exports.ConfigurationFeature = ConfigurationFeature;
function toJSONObject(obj) {
    if (obj) {
        if (Array.isArray(obj)) {
            return obj.map(toJSONObject);
        }
        else if (typeof obj === 'object') {
            const res = Object.create(null);
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    res[key] = toJSONObject(obj[key]);
                }
            }
            return res;
        }
    }
    return obj;
}
exports.toJSONObject = toJSONObject;
class SyncConfigurationFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._listeners.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;
    }
    initialize() {
        let section = this._client.clientOptions.synchronize?.configurationSection;
        if (section !== undefined) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: {
                    section: section
                }
            });
        }
    }
    register(data) {
        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
            this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== undefined) {
            this.onDidChangeConfiguration(data.registerOptions.section, undefined);
        }
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
            this._listeners.delete(id);
            disposable.dispose();
        }
    }
    dispose() {
        for (const disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    onDidChangeConfiguration(configurationSection, event) {
        let sections;
        if (Is.string(configurationSection)) {
            sections = [configurationSection];
        }
        else {
            sections = configurationSection;
        }
        if (sections !== undefined && event !== undefined) {
            let affected = sections.some((section) => event.affectsConfiguration(section));
            if (!affected) {
                return;
            }
        }
        const didChangeConfiguration = async (sections) => {
            if (sections === undefined) {
                return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
            }
            else {
                return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections) });
            }
        };
        let middleware = this._client.middleware.workspace?.didChangeConfiguration;
        (middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections)).catch((error) => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type.method} failed`, error);
        });
    }
    extractSettingsInformation(keys) {
        function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
                let obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        let resource = this._client.clientOptions.workspaceFolder
            ? this._client.clientOptions.workspaceFolder.uri
            : undefined;
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf('.');
            let config = null;
            if (index >= 0) {
                config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
            }
            else {
                config = vscode_1.workspace.getConfiguration(undefined, resource).get(key);
            }
            if (config) {
                let path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = toJSONObject(config);
            }
        }
        return result;
    }
}
exports.SyncConfigurationFeature = SyncConfigurationFeature;
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/declaration.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/declaration.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class DeclarationFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const declarationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'declaration');
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDeclaration: (document, position, token) => {
                const client = this._client;
                const provideDeclaration = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDeclarationResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDeclaration
                    ? middleware.provideDeclaration(document, position, token, provideDeclaration)
                    : provideDeclaration(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerDeclarationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.DeclarationFeature = DeclarationFeature;
//# sourceMappingURL=declaration.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/definition.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/definition.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefinitionFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
class DefinitionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let definitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'definition');
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDefinition: (document, position, token) => {
                const client = this._client;
                const provideDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDefinitionResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDefinition
                    ? middleware.provideDefinition(document, position, token, provideDefinition)
                    : provideDefinition(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.DefinitionFeature = DefinitionFeature;
//# sourceMappingURL=definition.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/diagnostic.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/diagnostic.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticFeature = exports.DiagnosticPullMode = exports.vsdiag = void 0;
const minimatch = __webpack_require__(/*! minimatch */ "./node_modules/minimatch/minimatch.js");
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const uuid_1 = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var vsdiag;
(function (vsdiag) {
    let DocumentDiagnosticReportKind;
    (function (DocumentDiagnosticReportKind) {
        DocumentDiagnosticReportKind["full"] = "full";
        DocumentDiagnosticReportKind["unChanged"] = "unChanged";
    })(DocumentDiagnosticReportKind = vsdiag.DocumentDiagnosticReportKind || (vsdiag.DocumentDiagnosticReportKind = {}));
})(vsdiag = exports.vsdiag || (exports.vsdiag = {}));
var DiagnosticPullMode;
(function (DiagnosticPullMode) {
    DiagnosticPullMode["onType"] = "onType";
    DiagnosticPullMode["onSave"] = "onSave";
})(DiagnosticPullMode = exports.DiagnosticPullMode || (exports.DiagnosticPullMode = {}));
var RequestStateKind;
(function (RequestStateKind) {
    RequestStateKind["active"] = "open";
    RequestStateKind["reschedule"] = "reschedule";
    RequestStateKind["outDated"] = "drop";
})(RequestStateKind || (RequestStateKind = {}));
/**
 * Manages the open tabs. We don't directly use the tab API since for
 * diagnostics we need to de-dupe tabs that show the same resources since
 * we pull on the model not the UI.
 */
class Tabs {
    constructor() {
        this.open = new Set();
        this._onOpen = new vscode_1.EventEmitter();
        this._onClose = new vscode_1.EventEmitter();
        Tabs.fillTabResources(this.open);
        const openTabsHandler = (event) => {
            if (event.closed.length === 0 && event.opened.length === 0) {
                return;
            }
            const oldTabs = this.open;
            const currentTabs = new Set();
            Tabs.fillTabResources(currentTabs);
            const closed = new Set();
            const opened = new Set(currentTabs);
            for (const tab of oldTabs.values()) {
                if (currentTabs.has(tab)) {
                    opened.delete(tab);
                }
                else {
                    closed.add(tab);
                }
            }
            this.open = currentTabs;
            if (closed.size > 0) {
                const toFire = new Set();
                for (const item of closed) {
                    toFire.add(vscode_1.Uri.parse(item));
                }
                this._onClose.fire(toFire);
            }
            if (opened.size > 0) {
                const toFire = new Set();
                for (const item of opened) {
                    toFire.add(vscode_1.Uri.parse(item));
                }
                this._onOpen.fire(toFire);
            }
        };
        if (vscode_1.window.tabGroups.onDidChangeTabs !== undefined) {
            this.disposable = vscode_1.window.tabGroups.onDidChangeTabs(openTabsHandler);
        }
        else {
            this.disposable = { dispose: () => { } };
        }
    }
    get onClose() {
        return this._onClose.event;
    }
    get onOpen() {
        return this._onOpen.event;
    }
    dispose() {
        this.disposable.dispose();
    }
    isActive(document) {
        return document instanceof vscode_1.Uri
            ? vscode_1.window.activeTextEditor?.document.uri === document
            : vscode_1.window.activeTextEditor?.document === document;
    }
    isVisible(document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        return this.open.has(uri.toString());
    }
    getTabResources() {
        const result = new Set();
        Tabs.fillTabResources(new Set(), result);
        return result;
    }
    static fillTabResources(strings, uris) {
        const seen = strings ?? new Set();
        for (const group of vscode_1.window.tabGroups.all) {
            for (const tab of group.tabs) {
                const input = tab.input;
                let uri;
                if (input instanceof vscode_1.TabInputText) {
                    uri = input.uri;
                }
                else if (input instanceof vscode_1.TabInputTextDiff) {
                    uri = input.modified;
                }
                if (uri !== undefined && !seen.has(uri.toString())) {
                    seen.add(uri.toString());
                    uris !== undefined && uris.add(uri);
                }
            }
        }
    }
}
var PullState;
(function (PullState) {
    PullState[PullState["document"] = 1] = "document";
    PullState[PullState["workspace"] = 2] = "workspace";
})(PullState || (PullState = {}));
class DocumentPullStateTracker {
    constructor() {
        this.documentPullStates = new Map();
        this.workspacePullStates = new Map();
    }
    track(kind, document, arg1) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version] = document instanceof vscode_1.Uri
            ? [document.toString(), document, arg1]
            : [document.uri.toString(), document.uri, document.version];
        let state = states.get(key);
        if (state === undefined) {
            state = { document: uri, pulledVersion: version, resultId: undefined };
            states.set(key, state);
        }
        return state;
    }
    update(kind, document, arg1, arg2) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version, resultId] = document instanceof vscode_1.Uri
            ? [document.toString(), document, arg1, arg2]
            : [document.uri.toString(), document.uri, document.version, arg1];
        let state = states.get(key);
        if (state === undefined) {
            state = { document: uri, pulledVersion: version, resultId };
            states.set(key, state);
        }
        else {
            state.pulledVersion = version;
            state.resultId = resultId;
        }
    }
    unTrack(kind, document) {
        const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        states.delete(key);
    }
    tracks(kind, document) {
        const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
    }
    getResultId(kind, document) {
        const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.get(key)?.resultId;
    }
    getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
            if (this.documentPullStates.has(uri)) {
                value = this.documentPullStates.get(uri);
            }
            if (value.resultId !== undefined) {
                result.push({ uri, value: value.resultId });
            }
        }
        return result;
    }
}
class DiagnosticRequestor {
    constructor(client, tabs, options) {
        this.client = client;
        this.tabs = tabs;
        this.options = options;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();
        this.provider = this.createProvider();
        this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);
        this.openRequests = new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
    }
    knows(kind, document) {
        return this.documentStates.tracks(kind, document);
    }
    forget(kind, document) {
        this.documentStates.unTrack(kind, document);
    }
    pull(document, cb) {
        if (this.isDisposed) {
            return;
        }
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        this.pullAsync(document).then(() => {
            if (cb) {
                cb();
            }
        }, (error) => {
            this.client.error(`Document pull failed for text document ${uri.toString()}`, error, false);
        });
    }
    async pullAsync(document, version) {
        if (this.isDisposed) {
            return;
        }
        const isUri = document instanceof vscode_1.Uri;
        const uri = isUri ? document : document.uri;
        const key = uri.toString();
        version = isUri ? version : document.version;
        const currentRequestState = this.openRequests.get(key);
        const documentState = isUri
            ? this.documentStates.track(PullState.document, document, version)
            : this.documentStates.track(PullState.document, document);
        if (currentRequestState === undefined) {
            const tokenSource = new vscode_1.CancellationTokenSource();
            this.openRequests.set(key, { state: RequestStateKind.active, document: document, version: version, tokenSource });
            let report;
            let afterState;
            try {
                report = await this.provider.provideDiagnostics(document, documentState.resultId, tokenSource.token) ?? { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
            }
            catch (error) {
                if (error instanceof features_1.LSPCancellationError && vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
                    afterState = { state: RequestStateKind.outDated, document };
                }
                if (afterState === undefined && error instanceof vscode_1.CancellationError) {
                    afterState = { state: RequestStateKind.reschedule, document };
                }
                else {
                    throw error;
                }
            }
            afterState = afterState ?? this.openRequests.get(key);
            if (afterState === undefined) {
                // This shouldn't happen. Log it
                this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);
                this.diagnostics.delete(uri);
                return;
            }
            this.openRequests.delete(key);
            if (!this.tabs.isVisible(document)) {
                this.documentStates.unTrack(PullState.document, document);
                return;
            }
            if (afterState.state === RequestStateKind.outDated) {
                return;
            }
            // report is only undefined if the request has thrown.
            if (report !== undefined) {
                if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                    this.diagnostics.set(uri, report.items);
                }
                documentState.pulledVersion = version;
                documentState.resultId = report.resultId;
            }
            if (afterState.state === RequestStateKind.reschedule) {
                this.pull(document);
            }
        }
        else {
            if (currentRequestState.state === RequestStateKind.active) {
                // Cancel the current request and reschedule a new one when the old one returned.
                currentRequestState.tokenSource.cancel();
                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            }
            else if (currentRequestState.state === RequestStateKind.outDated) {
                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            }
        }
    }
    forgetDocument(document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        const key = uri.toString();
        const request = this.openRequests.get(key);
        if (this.options.workspaceDiagnostics) {
            // If we run workspace diagnostic pull a last time for the diagnostics
            // and the rely on getting them from the workspace result.
            if (request !== undefined) {
                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: document });
            }
            else {
                this.pull(document, () => {
                    this.forget(PullState.document, document);
                });
            }
        }
        else {
            // We have normal pull or inter file dependencies. In this case we
            // clear the diagnostics (to have the same start as after startup).
            // We also cancel outstanding requests.
            if (request !== undefined) {
                if (request.state === RequestStateKind.active) {
                    request.tokenSource.cancel();
                }
                this.openRequests.set(key, { state: RequestStateKind.outDated, document: document });
            }
            this.diagnostics.delete(uri);
            this.forget(PullState.document, document);
        }
    }
    pullWorkspace() {
        if (this.isDisposed) {
            return;
        }
        this.pullWorkspaceAsync().then(() => {
            this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
                this.pullWorkspace();
            }, 2000);
        }, (error) => {
            if (!(error instanceof features_1.LSPCancellationError) && !vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data)) {
                this.client.error(`Workspace diagnostic pull failed.`, error, false);
                this.workspaceErrorCounter++;
            }
            if (this.workspaceErrorCounter <= 5) {
                this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
                    this.pullWorkspace();
                }, 2000);
            }
        });
    }
    async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics || this.isDisposed) {
            return;
        }
        if (this.workspaceCancellation !== undefined) {
            this.workspaceCancellation.cancel();
            this.workspaceCancellation = undefined;
        }
        this.workspaceCancellation = new vscode_1.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds().map((item) => {
            return {
                uri: this.client.protocol2CodeConverter.asUri(item.uri),
                value: item.value
            };
        });
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
            if (!chunk || this.isDisposed) {
                return;
            }
            for (const item of chunk.items) {
                if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                    // Favour document pull result over workspace results. So skip if it is tracked
                    // as a document result.
                    if (!this.documentStates.tracks(PullState.document, item.uri)) {
                        this.diagnostics.set(item.uri, item.items);
                    }
                }
                this.documentStates.update(PullState.workspace, item.uri, item.version ?? undefined, item.resultId);
            }
        });
    }
    createProvider() {
        const result = {
            onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
            provideDiagnostics: (document, previousResultId, token) => {
                const provideDiagnostics = (document, previousResultId, token) => {
                    const params = {
                        identifier: this.options.identifier,
                        textDocument: { uri: this.client.code2ProtocolConverter.asUri(document instanceof vscode_1.Uri ? document : document.uri) },
                        previousResultId: previousResultId
                    };
                    if (this.isDisposed === true || !this.client.isRunning()) {
                        return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                    }
                    return this.client.sendRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, params, token).then(async (result) => {
                        if (result === undefined || result === null || this.isDisposed || token.isCancellationRequested) {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                        }
                        if (result.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.full, resultId: result.resultId, items: await this.client.protocol2CodeConverter.asDiagnostics(result.items, token) };
                        }
                        else {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.unChanged, resultId: result.resultId };
                        }
                    }, (error) => {
                        return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] });
                    });
                };
                const middleware = this.client.middleware;
                return middleware.provideDiagnostics
                    ? middleware.provideDiagnostics(document, previousResultId, token, provideDiagnostics)
                    : provideDiagnostics(document, previousResultId, token);
            }
        };
        if (this.options.workspaceDiagnostics) {
            result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
                const convertReport = async (report) => {
                    if (report.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                        return {
                            kind: vsdiag.DocumentDiagnosticReportKind.full,
                            uri: this.client.protocol2CodeConverter.asUri(report.uri),
                            resultId: report.resultId,
                            version: report.version,
                            items: await this.client.protocol2CodeConverter.asDiagnostics(report.items, token)
                        };
                    }
                    else {
                        return {
                            kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
                            uri: this.client.protocol2CodeConverter.asUri(report.uri),
                            resultId: report.resultId,
                            version: report.version
                        };
                    }
                };
                const convertPreviousResultIds = (resultIds) => {
                    const converted = [];
                    for (const item of resultIds) {
                        converted.push({ uri: this.client.code2ProtocolConverter.asUri(item.uri), value: item.value });
                    }
                    return converted;
                };
                const provideDiagnostics = (resultIds, token) => {
                    const partialResultToken = (0, uuid_1.generateUuid)();
                    const disposable = this.client.onProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, async (partialResult) => {
                        if (partialResult === undefined || partialResult === null) {
                            resultReporter(null);
                            return;
                        }
                        const converted = {
                            items: []
                        };
                        for (const item of partialResult.items) {
                            try {
                                converted.items.push(await convertReport(item));
                            }
                            catch (error) {
                                this.client.error(`Converting workspace diagnostics failed.`, error);
                            }
                        }
                        resultReporter(converted);
                    });
                    const params = {
                        identifier: this.options.identifier,
                        previousResultIds: convertPreviousResultIds(resultIds),
                        partialResultToken: partialResultToken
                    };
                    if (this.isDisposed === true || !this.client.isRunning()) {
                        return { items: [] };
                    }
                    return this.client.sendRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, params, token).then(async (result) => {
                        if (token.isCancellationRequested) {
                            return { items: [] };
                        }
                        const converted = {
                            items: []
                        };
                        for (const item of result.items) {
                            converted.items.push(await convertReport(item));
                        }
                        disposable.dispose();
                        resultReporter(converted);
                        return { items: [] };
                    }, (error) => {
                        disposable.dispose();
                        return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, { items: [] });
                    });
                };
                const middleware = this.client.middleware;
                return middleware.provideWorkspaceDiagnostics
                    ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics)
                    : provideDiagnostics(resultIds, token, resultReporter);
            };
        }
        return result;
    }
    dispose() {
        this.isDisposed = true;
        // Cancel and clear workspace pull if present.
        this.workspaceCancellation?.cancel();
        this.workspaceTimeout?.dispose();
        // Cancel all request and mark open requests as outdated.
        for (const [key, request] of this.openRequests) {
            if (request.state === RequestStateKind.active) {
                request.tokenSource.cancel();
            }
            this.openRequests.set(key, { state: RequestStateKind.outDated, document: request.document });
        }
        // cleanup old diagnostics
        this.diagnostics.dispose();
    }
}
class BackgroundScheduler {
    constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new vscode_languageserver_protocol_1.LinkedMap();
        this.isDisposed = false;
    }
    add(document) {
        if (this.isDisposed === true) {
            return;
        }
        const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
        if (this.documents.has(key)) {
            return;
        }
        this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);
        this.trigger();
    }
    remove(document) {
        const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
        if (this.documents.has(key)) {
            this.documents.delete(key);
            // Do a last pull
            this.diagnosticRequestor.pull(document);
        }
        // No more documents. Stop background activity.
        if (this.documents.size === 0) {
            this.stop();
        }
        else if (document === this.endDocument) {
            // Make sure we have a correct last document. It could have
            this.endDocument = this.documents.last;
        }
    }
    trigger() {
        if (this.isDisposed === true) {
            return;
        }
        // We have a round running. So simply make sure we run up to the
        // last document
        if (this.intervalHandle !== undefined) {
            this.endDocument = this.documents.last;
            return;
        }
        this.endDocument = this.documents.last;
        this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {
            const document = this.documents.first;
            if (document !== undefined) {
                const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
                this.diagnosticRequestor.pull(document);
                this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);
                if (document === this.endDocument) {
                    this.stop();
                }
            }
        }, 200);
    }
    dispose() {
        this.isDisposed = true;
        this.stop();
        this.documents.clear();
    }
    stop() {
        this.intervalHandle?.dispose();
        this.intervalHandle = undefined;
        this.endDocument = undefined;
    }
}
class DiagnosticFeatureProviderImpl {
    constructor(client, tabs, options) {
        const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false };
        const documentSelector = client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        const disposables = [];
        const matchResource = (resource) => {
            const selector = options.documentSelector;
            if (diagnosticPullOptions.match !== undefined) {
                return diagnosticPullOptions.match(selector, resource);
            }
            for (const filter of selector) {
                if (!vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
                    continue;
                }
                // The filter is a language id. We can't determine if it matches
                // so we return false.
                if (typeof filter === 'string') {
                    return false;
                }
                if (filter.language !== undefined && filter.language !== '*') {
                    return false;
                }
                if (filter.scheme !== undefined && filter.scheme !== '*' && filter.scheme !== resource.scheme) {
                    return false;
                }
                if (filter.pattern !== undefined) {
                    const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
                    if (!matcher.makeRe()) {
                        return false;
                    }
                    if (!matcher.match(resource.fsPath)) {
                        return false;
                    }
                }
            }
            return true;
        };
        const matches = (document) => {
            return document instanceof vscode_1.Uri
                ? matchResource(document)
                : vscode_1.languages.match(documentSelector, document) > 0 && tabs.isVisible(document);
        };
        const isActiveDocument = (document) => {
            return document instanceof vscode_1.Uri
                ? this.activeTextDocument?.uri.toString() === document.toString()
                : this.activeTextDocument === document;
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client, tabs, options);
        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (document) => {
            if (!matches(document) || !options.interFileDependencies || isActiveDocument(document)) {
                return;
            }
            this.backgroundScheduler.add(document);
        };
        this.activeTextDocument = vscode_1.window.activeTextEditor?.document;
        vscode_1.window.onDidChangeActiveTextEditor((editor) => {
            const oldActive = this.activeTextDocument;
            this.activeTextDocument = editor?.document;
            if (oldActive !== undefined) {
                addToBackgroundIfNeeded(oldActive);
            }
            if (this.activeTextDocument !== undefined) {
                this.backgroundScheduler.remove(this.activeTextDocument);
            }
        });
        // For pull model diagnostics we pull for documents visible in the UI.
        // From an eventing point of view we still rely on open document events
        // and filter the documents that are not visible in the UI instead of
        // listening to Tab events. Major reason is event timing since we need
        // to ensure that the pull is send after the document open has reached
        // the server.
        // We always pull on open.
        const openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            if (matches(textDocument)) {
                this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });
            }
        }));
        // Pull all diagnostics for documents that are already open
        const pulledTextDocuments = new Set();
        for (const textDocument of vscode_1.workspace.textDocuments) {
            if (matches(textDocument)) {
                this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });
                pulledTextDocuments.add(textDocument.uri.toString());
            }
        }
        // Pull all tabs if not already pulled as text document
        if (diagnosticPullOptions.onTabs === true) {
            for (const resource of tabs.getTabResources()) {
                if (!pulledTextDocuments.has(resource.toString()) && matches(resource)) {
                    this.diagnosticRequestor.pull(resource, () => { addToBackgroundIfNeeded(resource); });
                }
            }
        }
        tabs.onOpen((opened) => {
            for (const document of opened) {
                if (matches(document) && !this.diagnosticRequestor.knows(PullState.document, document)) {
                    this.diagnosticRequestor.pull(document, () => { addToBackgroundIfNeeded(document); });
                }
            }
        });
        if (diagnosticPullOptions.onChange === true) {
            const changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
            disposables.push(changeFeature.onNotificationSent(async (event) => {
                const textDocument = event.original.document;
                if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument) && event.original.contentChanges.length > 0) {
                    this.diagnosticRequestor.pull(textDocument, () => { this.backgroundScheduler.trigger(); });
                }
            }));
        }
        if (diagnosticPullOptions.onSave === true) {
            const saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
            disposables.push(saveFeature.onNotificationSent((event) => {
                const textDocument = event.original;
                if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
                    this.diagnosticRequestor.pull(event.original, () => { this.backgroundScheduler.trigger(); });
                }
            }));
        }
        // When the document closes clear things up
        const closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent((event) => {
            this.cleanUpDocument(event.original);
        }));
        // Same when a tabs closes.
        tabs.onClose((closed) => {
            for (const document of closed) {
                this.cleanUpDocument(document);
            }
        });
        // We received a did change from the server.
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
            for (const textDocument of vscode_1.workspace.textDocuments) {
                if (matches(textDocument)) {
                    this.diagnosticRequestor.pull(textDocument);
                }
            }
        });
        // da348dc5-c30a-4515-9d98-31ff3be38d14 is the test UUID to test the middle ware. So don't auto trigger pulls.
        if (options.workspaceDiagnostics === true && options.identifier !== 'da348dc5-c30a-4515-9d98-31ff3be38d14') {
            this.diagnosticRequestor.pullWorkspace();
        }
        this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);
    }
    get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
    }
    get diagnostics() {
        return this.diagnosticRequestor.provider;
    }
    cleanUpDocument(document) {
        if (this.diagnosticRequestor.knows(PullState.document, document)) {
            this.diagnosticRequestor.forgetDocument(document);
            this.backgroundScheduler.remove(document);
        }
    }
}
class DiagnosticFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, 'textDocument'), 'diagnostic');
        capability.dynamicRegistration = true;
        // We first need to decide how a UI will look with related documents.
        // An easy implementation would be to only show related diagnostics for
        // the active editor.
        capability.relatedDocumentSupport = false;
        ensure(ensure(capabilities, 'workspace'), 'diagnostics').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeDiagnosticsEmitter.fire();
            }
        });
        let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    dispose() {
        if (this.tabs !== undefined) {
            this.tabs.dispose();
            this.tabs = undefined;
        }
        super.dispose();
    }
    registerLanguageProvider(options) {
        if (this.tabs === undefined) {
            this.tabs = new Tabs();
        }
        const provider = new DiagnosticFeatureProviderImpl(this._client, this.tabs, options);
        return [provider.disposable, provider];
    }
}
exports.DiagnosticFeature = DiagnosticFeature;
//# sourceMappingURL=diagnostic.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/documentHighlight.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/documentHighlight.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentHighlightFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
class DocumentHighlightFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'documentHighlight').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentHighlights: (document, position, token) => {
                const client = this._client;
                const _provideDocumentHighlights = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDocumentHighlights(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentHighlights
                    ? middleware.provideDocumentHighlights(document, position, token, _provideDocumentHighlights)
                    : _provideDocumentHighlights(document, position, token);
            }
        };
        return [vscode_1.languages.registerDocumentHighlightProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentHighlightFeature = DocumentHighlightFeature;
//# sourceMappingURL=documentHighlight.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/documentLink.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/documentLink.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentLinkFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
class DocumentLinkFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'documentLink');
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentLinks: (document, token) => {
                const client = this._client;
                const provideDocumentLinks = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDocumentLinks(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentLinks
                    ? middleware.provideDocumentLinks(document, token, provideDocumentLinks)
                    : provideDocumentLinks(document, token);
            },
            resolveDocumentLink: options.resolveProvider
                ? (link, token) => {
                    const client = this._client;
                    let resolveDocumentLink = (link, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return link;
                            }
                            return client.protocol2CodeConverter.asDocumentLink(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, token, error, link);
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.resolveDocumentLink
                        ? middleware.resolveDocumentLink(link, token, resolveDocumentLink)
                        : resolveDocumentLink(link, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerDocumentLinkProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentLinkFeature = DocumentLinkFeature;
//# sourceMappingURL=documentLink.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/documentSymbol.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/documentSymbol.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentSymbolFeature = exports.SupportedSymbolTags = exports.SupportedSymbolKinds = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
exports.SupportedSymbolKinds = [
    vscode_languageserver_protocol_1.SymbolKind.File,
    vscode_languageserver_protocol_1.SymbolKind.Module,
    vscode_languageserver_protocol_1.SymbolKind.Namespace,
    vscode_languageserver_protocol_1.SymbolKind.Package,
    vscode_languageserver_protocol_1.SymbolKind.Class,
    vscode_languageserver_protocol_1.SymbolKind.Method,
    vscode_languageserver_protocol_1.SymbolKind.Property,
    vscode_languageserver_protocol_1.SymbolKind.Field,
    vscode_languageserver_protocol_1.SymbolKind.Constructor,
    vscode_languageserver_protocol_1.SymbolKind.Enum,
    vscode_languageserver_protocol_1.SymbolKind.Interface,
    vscode_languageserver_protocol_1.SymbolKind.Function,
    vscode_languageserver_protocol_1.SymbolKind.Variable,
    vscode_languageserver_protocol_1.SymbolKind.Constant,
    vscode_languageserver_protocol_1.SymbolKind.String,
    vscode_languageserver_protocol_1.SymbolKind.Number,
    vscode_languageserver_protocol_1.SymbolKind.Boolean,
    vscode_languageserver_protocol_1.SymbolKind.Array,
    vscode_languageserver_protocol_1.SymbolKind.Object,
    vscode_languageserver_protocol_1.SymbolKind.Key,
    vscode_languageserver_protocol_1.SymbolKind.Null,
    vscode_languageserver_protocol_1.SymbolKind.EnumMember,
    vscode_languageserver_protocol_1.SymbolKind.Struct,
    vscode_languageserver_protocol_1.SymbolKind.Event,
    vscode_languageserver_protocol_1.SymbolKind.Operator,
    vscode_languageserver_protocol_1.SymbolKind.TypeParameter
];
exports.SupportedSymbolTags = [
    vscode_languageserver_protocol_1.SymbolTag.Deprecated
];
class DocumentSymbolFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'documentSymbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: exports.SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
            valueSet: exports.SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentSymbols: (document, token) => {
                const client = this._client;
                const _provideDocumentSymbols = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document), token).then(async (data) => {
                        if (token.isCancellationRequested || data === undefined || data === null) {
                            return null;
                        }
                        if (data.length === 0) {
                            return [];
                        }
                        else {
                            const first = data[0];
                            if (vscode_languageserver_protocol_1.DocumentSymbol.is(first)) {
                                return await client.protocol2CodeConverter.asDocumentSymbols(data, token);
                            }
                            else {
                                return await client.protocol2CodeConverter.asSymbolInformations(data, token);
                            }
                        }
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentSymbols
                    ? middleware.provideDocumentSymbols(document, token, _provideDocumentSymbols)
                    : _provideDocumentSymbols(document, token);
            }
        };
        const metaData = options.label !== undefined ? { label: options.label } : undefined;
        return [vscode_1.languages.registerDocumentSymbolProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, metaData), provider];
    }
}
exports.DocumentSymbolFeature = DocumentSymbolFeature;
//# sourceMappingURL=documentSymbol.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/executeCommand.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/executeCommand.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecuteCommandFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class ExecuteCommandFeature {
    constructor(client) {
        this._client = client;
        this._commands = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._commands.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;
    }
    initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
    }
    register(data) {
        const client = this._client;
        const middleware = client.middleware;
        const executeCommand = (command, args) => {
            let params = {
                command,
                arguments: args
            };
            return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(undefined, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, undefined, error, undefined);
            });
        };
        if (data.registerOptions.commands) {
            const disposables = [];
            for (const command of data.registerOptions.commands) {
                disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
                    return middleware.executeCommand
                        ? middleware.executeCommand(command, args, executeCommand)
                        : executeCommand(command, args);
                }));
            }
            this._commands.set(data.id, disposables);
        }
    }
    unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
            disposables.forEach(disposable => disposable.dispose());
        }
    }
    dispose() {
        this._commands.forEach((value) => {
            value.forEach(disposable => disposable.dispose());
        });
        this._commands.clear();
    }
}
exports.ExecuteCommandFeature = ExecuteCommandFeature;
//# sourceMappingURL=executeCommand.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/features.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/features.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFeature = exports.TextDocumentLanguageFeature = exports.TextDocumentEventFeature = exports.DynamicDocumentFeature = exports.DynamicFeature = exports.StaticFeature = exports.ensure = exports.LSPCancellationError = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
class LSPCancellationError extends vscode_1.CancellationError {
    constructor(data) {
        super();
        this.data = data;
    }
}
exports.LSPCancellationError = LSPCancellationError;
function ensure(target, key) {
    if (target[key] === undefined) {
        target[key] = {};
    }
    return target[key];
}
exports.ensure = ensure;
var StaticFeature;
(function (StaticFeature) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null &&
            Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.dispose) &&
            (candidate.fillInitializeParams === undefined || Is.func(candidate.fillInitializeParams));
    }
    StaticFeature.is = is;
})(StaticFeature = exports.StaticFeature || (exports.StaticFeature = {}));
var DynamicFeature;
(function (DynamicFeature) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null &&
            Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.dispose) &&
            (candidate.fillInitializeParams === undefined || Is.func(candidate.fillInitializeParams)) && Is.func(candidate.register) &&
            Is.func(candidate.unregister) && candidate.registrationType !== undefined;
    }
    DynamicFeature.is = is;
})(DynamicFeature = exports.DynamicFeature || (exports.DynamicFeature = {}));
/**
 * An abstract dynamic feature implementation that operates on documents (e.g. text
 * documents or notebooks).
 */
class DynamicDocumentFeature {
    constructor(client) {
        this._client = client;
    }
    /**
     * Returns the state the feature is in.
     */
    getState() {
        const selectors = this.getDocumentSelectors();
        let count = 0;
        for (const selector of selectors) {
            count++;
            for (const document of vscode_1.workspace.textDocuments) {
                if (vscode_1.languages.match(selector, document) > 0) {
                    return { kind: 'document', id: this.registrationType.method, registrations: true, matches: true };
                }
            }
        }
        const registrations = count > 0;
        return { kind: 'document', id: this.registrationType.method, registrations, matches: false };
    }
}
exports.DynamicDocumentFeature = DynamicDocumentFeature;
/**
 * An abstract base class to implement features that react to events
 * emitted from text documents.
 */
class TextDocumentEventFeature extends DynamicDocumentFeature {
    constructor(client, event, type, middleware, createParams, textDocument, selectorFilter) {
        super(client);
        this._event = event;
        this._type = type;
        this._middleware = middleware;
        this._createParams = createParams;
        this._textDocument = textDocument;
        this._selectorFilter = selectorFilter;
        this._selectors = new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
    }
    static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
            if (vscode_1.languages.match(selector, textDocument) > 0) {
                return true;
            }
        }
        return false;
    }
    getStateInfo() {
        return [this._selectors.values(), false];
    }
    getDocumentSelectors() {
        return this._selectors.values();
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._event((data) => {
                this.callback(data).catch((error) => {
                    this._client.error(`Sending document notification ${this._type.method} failed.`, error);
                });
            });
        }
        this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
    }
    async callback(data) {
        const doSend = async (data) => {
            const params = this._createParams(data);
            await this._client.sendNotification(this._type, params).catch();
            this.notificationSent(data, this._type, params);
        };
        if (this.matches(data)) {
            const middleware = this._middleware();
            return middleware ? middleware(data, (data) => doSend(data)) : doSend(data);
        }
    }
    matches(data) {
        if (this._client.hasDedicatedTextSynchronizationFeature(this._textDocument(data))) {
            return false;
        }
        return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
    }
    get onNotificationSent() {
        return this._onNotificationSent.event;
    }
    notificationSent(data, type, params) {
        this._onNotificationSent.fire({ original: data, type, params });
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getProvider(document) {
        for (const selector of this._selectors.values()) {
            if (vscode_1.languages.match(selector, document) > 0) {
                return {
                    send: (data) => {
                        return this.callback(data);
                    }
                };
            }
        }
        return undefined;
    }
}
exports.TextDocumentEventFeature = TextDocumentEventFeature;
/**
 * A abstract feature implementation that registers language providers
 * for text documents using a given document selector.
 */
class TextDocumentLanguageFeature extends DynamicDocumentFeature {
    constructor(client, registrationType) {
        super(client);
        this._registrationType = registrationType;
        this._registrations = new Map();
    }
    *getDocumentSelectors() {
        for (const registration of this._registrations.values()) {
            const selector = registration.data.registerOptions.documentSelector;
            if (selector === null) {
                continue;
            }
            yield this._client.protocol2CodeConverter.asDocumentSelector(selector);
        }
    }
    get registrationType() {
        return this._registrationType;
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((value) => {
            value.disposable.dispose();
        });
        this._registrations.clear();
    }
    getRegistration(documentSelector, capability) {
        if (!capability) {
            return [undefined, undefined];
        }
        else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
            const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
            const selector = capability.documentSelector || documentSelector;
            if (selector) {
                return [id, Object.assign({}, capability, { documentSelector: selector })];
            }
        }
        else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
            if (!documentSelector) {
                return [undefined, undefined];
            }
            let options = (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
            return [UUID.generateUuid(), options];
        }
        return [undefined, undefined];
    }
    getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
            return undefined;
        }
        return (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
    }
    getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
            let selector = registration.data.registerOptions.documentSelector;
            if (selector !== null && vscode_1.languages.match(this._client.protocol2CodeConverter.asDocumentSelector(selector), textDocument) > 0) {
                return registration.provider;
            }
        }
        return undefined;
    }
    getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
            result.push(item.provider);
        }
        return result;
    }
}
exports.TextDocumentLanguageFeature = TextDocumentLanguageFeature;
class WorkspaceFeature {
    constructor(client, registrationType) {
        this._client = client;
        this._registrationType = registrationType;
        this._registrations = new Map();
    }
    getState() {
        const registrations = this._registrations.size > 0;
        return { kind: 'workspace', id: this._registrationType.method, registrations };
    }
    get registrationType() {
        return this._registrationType;
    }
    register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((registration) => {
            registration.disposable.dispose();
        });
        this._registrations.clear();
    }
    getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
            result.push(registration.provider);
        }
        return result;
    }
}
exports.WorkspaceFeature = WorkspaceFeature;
//# sourceMappingURL=features.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/fileOperations.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/fileOperations.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesFeature = exports.WillRenameFilesFeature = exports.WillCreateFilesFeature = exports.DidDeleteFilesFeature = exports.DidRenameFilesFeature = exports.DidCreateFilesFeature = void 0;
const code = __webpack_require__(/*! vscode */ "vscode");
const minimatch = __webpack_require__(/*! minimatch */ "./node_modules/minimatch/minimatch.js");
const proto = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
function access(target, key) {
    return target[key];
}
function assign(target, key, value) {
    target[key] = value;
}
class FileOperationFeature {
    constructor(client, event, registrationType, clientCapability, serverCapability) {
        this._client = client;
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
        this._filters = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this._registrationType.method, registrations: this._filters.size > 0 };
    }
    filterSize() {
        return this._filters.size;
    }
    get registrationType() {
        return this._registrationType;
    }
    fillClientCapabilities(capabilities) {
        const value = ensure(ensure(capabilities, 'workspace'), 'fileOperations');
        // this happens n times but it is the same value so we tolerate this.
        assign(value, 'dynamicRegistration', true);
        assign(value, this._clientCapability, true);
    }
    initialize(capabilities) {
        const options = capabilities.workspace?.fileOperations;
        const capability = options !== undefined ? access(options, this._serverCapability) : undefined;
        if (capability?.filters !== undefined) {
            try {
                this.register({
                    id: UUID.generateUuid(),
                    registerOptions: { filters: capability.filters }
                });
            }
            catch (e) {
                this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
            }
        }
    }
    register(data) {
        if (!this._listener) {
            this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter) => {
            const matcher = new minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));
            if (!matcher.makeRe()) {
                throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
            }
            return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
    }
    unregister(id) {
        this._filters.delete(id);
        if (this._filters.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._filters.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getFileType(uri) {
        return FileOperationFeature.getFileType(uri);
    }
    async filter(event, prop) {
        // (Asynchronously) map each file onto a boolean of whether it matches
        // any of the globs.
        const fileMatches = await Promise.all(event.files.map(async (item) => {
            const uri = prop(item);
            // Use fsPath to make this consistent with file system watchers but help
            // minimatch to use '/' instead of `\\` if present.
            const path = uri.fsPath.replace(/\\/g, '/');
            for (const filters of this._filters.values()) {
                for (const filter of filters) {
                    if (filter.scheme !== undefined && filter.scheme !== uri.scheme) {
                        continue;
                    }
                    if (filter.matcher.match(path)) {
                        // The pattern matches. If kind is undefined then everything is ok
                        if (filter.kind === undefined) {
                            return true;
                        }
                        const fileType = await this.getFileType(uri);
                        // If we can't determine the file type than we treat it as a match.
                        // Dropping it would be another alternative.
                        if (fileType === undefined) {
                            this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                            return true;
                        }
                        if ((fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file) || (fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder)) {
                            return true;
                        }
                    }
                    else if (filter.kind === proto.FileOperationPatternKind.folder) {
                        const fileType = await FileOperationFeature.getFileType(uri);
                        if (fileType === code.FileType.Directory && filter.matcher.match(`${path}/`)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }));
        // Filter the files to those that matched.
        const files = event.files.filter((_, index) => fileMatches[index]);
        return { ...event, files };
    }
    static async getFileType(uri) {
        try {
            return (await code.workspace.fs.stat(uri)).type;
        }
        catch (e) {
            return undefined;
        }
    }
    static asMinimatchOptions(options) {
        if (options === undefined) {
            return undefined;
        }
        if (options.ignoreCase === true) {
            return { nocase: true };
        }
        return undefined;
    }
}
class NotificationFileOperationFeature extends FileOperationFeature {
    constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = async (event) => {
                return this._client.sendNotification(this._notificationType, this._createParams(event));
            };
            return this.doSend(filteredEvent, next);
        }
    }
}
class CachingNotificationFileOperationFeature extends NotificationFileOperationFeature {
    constructor() {
        super(...arguments);
        this._fsPathFileTypes = new Map();
    }
    async getFileType(uri) {
        const fsPath = uri.fsPath;
        if (this._fsPathFileTypes.has(fsPath)) {
            return this._fsPathFileTypes.get(fsPath);
        }
        const type = await FileOperationFeature.getFileType(uri);
        if (type) {
            this._fsPathFileTypes.set(fsPath, type);
        }
        return type;
    }
    async cacheFileTypes(event, prop) {
        // Calling filter will force the matching logic to run. For any item
        // that requires a getFileType lookup, the overriden getFileType will
        // be called that will cache the result so that when onDidRename fires,
        // it can still be checked even though the item no longer exists on disk
        // in its original location.
        await this.filter(event, prop);
    }
    clearFileTypeCache() {
        this._fsPathFileTypes.clear();
    }
    unregister(id) {
        super.unregister(id);
        if (this.filterSize() === 0 && this._willListener) {
            this._willListener.dispose();
            this._willListener = undefined;
        }
    }
    dispose() {
        super.dispose();
        if (this._willListener) {
            this._willListener.dispose();
            this._willListener = undefined;
        }
    }
}
class DidCreateFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, 'didCreate', 'didCreate', (i) => i, client.code2ProtocolConverter.asDidCreateFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.didCreateFiles
            ? middleware.didCreateFiles(event, next)
            : next(event);
    }
}
exports.DidCreateFilesFeature = DidCreateFilesFeature;
class DidRenameFilesFeature extends CachingNotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, 'didRename', 'didRename', (i) => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);
    }
    register(data) {
        if (!this._willListener) {
            this._willListener = code.workspace.onWillRenameFiles(this.willRename, this);
        }
        super.register(data);
    }
    willRename(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i.oldUri));
    }
    doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.middleware.workspace;
        return middleware?.didRenameFiles
            ? middleware.didRenameFiles(event, next)
            : next(event);
    }
}
exports.DidRenameFilesFeature = DidRenameFilesFeature;
class DidDeleteFilesFeature extends CachingNotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, 'didDelete', 'didDelete', (i) => i, client.code2ProtocolConverter.asDidDeleteFilesParams);
    }
    register(data) {
        if (!this._willListener) {
            this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this);
        }
        super.register(data);
    }
    willDelete(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i));
    }
    doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.middleware.workspace;
        return middleware?.didDeleteFiles
            ? middleware.didDeleteFiles(event, next)
            : next(event);
    }
}
exports.DidDeleteFilesFeature = DidDeleteFilesFeature;
class RequestFileOperationFeature extends FileOperationFeature {
    constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
    }
    async waitUntil(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = (event) => {
                return this._client.sendRequest(this._requestType, this._createParams(event), event.token)
                    .then(this._client.protocol2CodeConverter.asWorkspaceEdit);
            };
            return this.doSend(filteredEvent, next);
        }
        else {
            return undefined;
        }
    }
}
class WillCreateFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, 'willCreate', 'willCreate', (i) => i, client.code2ProtocolConverter.asWillCreateFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willCreateFiles
            ? middleware.willCreateFiles(event, next)
            : next(event);
    }
}
exports.WillCreateFilesFeature = WillCreateFilesFeature;
class WillRenameFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, 'willRename', 'willRename', (i) => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willRenameFiles
            ? middleware.willRenameFiles(event, next)
            : next(event);
    }
}
exports.WillRenameFilesFeature = WillRenameFilesFeature;
class WillDeleteFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, 'willDelete', 'willDelete', (i) => i, client.code2ProtocolConverter.asWillDeleteFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willDeleteFiles
            ? middleware.willDeleteFiles(event, next)
            : next(event);
    }
}
exports.WillDeleteFilesFeature = WillDeleteFilesFeature;
//# sourceMappingURL=fileOperations.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/fileSystemWatcher.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/fileSystemWatcher.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystemWatcherFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class FileSystemWatcherFeature {
    constructor(client, notifyFileEvent) {
        this._client = client;
        this._notifyFileEvent = notifyFileEvent;
        this._watchers = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._watchers.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeWatchedFiles').relativePatternSupport = true;
    }
    initialize(_capabilities, _documentSelector) {
    }
    register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
            return;
        }
        const disposables = [];
        for (const watcher of data.registerOptions.watchers) {
            const globPattern = this._client.protocol2CodeConverter.asGlobPattern(watcher.globPattern);
            if (globPattern === undefined) {
                continue;
            }
            let watchCreate = true, watchChange = true, watchDelete = true;
            if (watcher.kind !== undefined && watcher.kind !== null) {
                watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
                watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
                watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
            }
            const fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(globPattern, !watchCreate, !watchChange, !watchDelete);
            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
            disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
    }
    registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
            this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
    }
    hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
            fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Created
            }), null, listeners);
        }
        if (watchChange) {
            fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Changed
            }), null, listeners);
        }
        if (watchDelete) {
            fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Deleted
            }), null, listeners);
        }
    }
    unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        }
    }
    dispose() {
        this._watchers.forEach((disposables) => {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        });
        this._watchers.clear();
    }
}
exports.FileSystemWatcherFeature = FileSystemWatcherFeature;
//# sourceMappingURL=fileSystemWatcher.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/foldingRange.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/foldingRange.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class FoldingRangeFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'foldingRange');
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5000;
        capability.lineFoldingOnly = true;
        capability.foldingRangeKind = { valueSet: [vscode_languageserver_protocol_1.FoldingRangeKind.Comment, vscode_languageserver_protocol_1.FoldingRangeKind.Imports, vscode_languageserver_protocol_1.FoldingRangeKind.Region] };
        capability.foldingRange = { collapsedText: false };
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideFoldingRanges: (document, context, token) => {
                const client = this._client;
                const provideFoldingRanges = (document, _, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asFoldingRanges(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideFoldingRanges
                    ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges)
                    : provideFoldingRanges(document, context, token);
            }
        };
        return [vscode_1.languages.registerFoldingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.FoldingRangeFeature = FoldingRangeFeature;
//# sourceMappingURL=foldingRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/formatting.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/formatting.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentOnTypeFormattingFeature = exports.DocumentRangeFormattingFeature = exports.DocumentFormattingFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
var FileFormattingOptions;
(function (FileFormattingOptions) {
    function fromConfiguration(document) {
        const filesConfig = vscode_1.workspace.getConfiguration('files', document);
        return {
            trimTrailingWhitespace: filesConfig.get('trimTrailingWhitespace'),
            trimFinalNewlines: filesConfig.get('trimFinalNewlines'),
            insertFinalNewline: filesConfig.get('insertFinalNewline'),
        };
    }
    FileFormattingOptions.fromConfiguration = fromConfiguration;
})(FileFormattingOptions || (FileFormattingOptions = {}));
class DocumentFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'formatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentFormattingEdits: (document, options, token) => {
                const client = this._client;
                const provideDocumentFormattingEdits = (document, options, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asTextEdits(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentFormattingEdits
                    ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits)
                    : provideDocumentFormattingEdits(document, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentFormattingFeature = DocumentFormattingFeature;
class DocumentRangeFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'rangeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentRangeFormattingEdits: (document, range, options, token) => {
                const client = this._client;
                const provideDocumentRangeFormattingEdits = (document, range, options, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asTextEdits(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentRangeFormattingEdits
                    ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits)
                    : provideDocumentRangeFormattingEdits(document, range, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentRangeFormattingFeature = DocumentRangeFormattingFeature;
class DocumentOnTypeFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'onTypeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideOnTypeFormattingEdits: (document, position, ch, options, token) => {
                const client = this._client;
                const provideOnTypeFormattingEdits = (document, position, ch, options, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        ch: ch,
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asTextEdits(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideOnTypeFormattingEdits
                    ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits)
                    : provideOnTypeFormattingEdits(document, position, ch, options, token);
            }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        return [vscode_1.languages.registerOnTypeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
    }
}
exports.DocumentOnTypeFormattingFeature = DocumentOnTypeFormattingFeature;
//# sourceMappingURL=formatting.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/hover.js":
/*!****************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/hover.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HoverFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
class HoverFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const hoverCapability = ((0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'hover'));
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideHover: (document, position, token) => {
                const client = this._client;
                const provideHover = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asHover(result);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideHover
                    ? middleware.provideHover(document, position, token, provideHover)
                    : provideHover(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerHoverProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.HoverFeature = HoverFeature;
//# sourceMappingURL=hover.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/implementation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/implementation.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class ImplementationFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let implementationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'implementation');
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideImplementation: (document, position, token) => {
                const client = this._client;
                const provideImplementation = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDefinitionResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideImplementation
                    ? middleware.provideImplementation(document, position, token, provideImplementation)
                    : provideImplementation(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerImplementationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.ImplementationFeature = ImplementationFeature;
//# sourceMappingURL=implementation.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/inlayHint.js":
/*!********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/inlayHint.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlayHintsFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class InlayHintsFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlayHintRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const inlayHint = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'inlayHint');
        inlayHint.dynamicRegistration = true;
        inlayHint.resolveSupport = {
            properties: ['tooltip', 'textEdits', 'label.tooltip', 'label.location', 'label.command']
        };
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'inlayHint').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeInlayHints.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.inlayHintProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeInlayHints: eventEmitter.event,
            provideInlayHints: (document, viewPort, token) => {
                const client = this._client;
                const provideInlayHints = async (document, viewPort, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(viewPort)
                    };
                    try {
                        const values = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, requestParams, token);
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asInlayHints(values, token);
                    }
                    catch (error) {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, token, error, null);
                    }
                };
                const middleware = client.middleware;
                return middleware.provideInlayHints
                    ? middleware.provideInlayHints(document, viewPort, token, provideInlayHints)
                    : provideInlayHints(document, viewPort, token);
            }
        };
        provider.resolveInlayHint = options.resolveProvider === true
            ? (hint, token) => {
                const client = this._client;
                const resolveInlayHint = async (item, token) => {
                    try {
                        const value = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, client.code2ProtocolConverter.asInlayHint(item), token);
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        const result = client.protocol2CodeConverter.asInlayHint(value, token);
                        return token.isCancellationRequested ? null : result;
                    }
                    catch (error) {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, token, error, null);
                    }
                };
                const middleware = client.middleware;
                return middleware.resolveInlayHint
                    ? middleware.resolveInlayHint(hint, token, resolveInlayHint)
                    : resolveInlayHint(hint, token);
            }
            : undefined;
        return [this.registerProvider(selector, provider), { provider: provider, onDidChangeInlayHints: eventEmitter }];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerInlayHintsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.InlayHintsFeature = InlayHintsFeature;
//# sourceMappingURL=inlayHint.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/inlineValue.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/inlineValue.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineValueFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class InlineValueFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlineValueRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'inlineValue').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'inlineValue').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeInlineValues.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.inlineValueProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeInlineValues: eventEmitter.event,
            provideInlineValues: (document, viewPort, context, token) => {
                const client = this._client;
                const provideInlineValues = (document, viewPort, context, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(viewPort),
                        context: client.code2ProtocolConverter.asInlineValueContext(context)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, requestParams, token).then((values) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asInlineValues(values, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideInlineValues
                    ? middleware.provideInlineValues(document, viewPort, context, token, provideInlineValues)
                    : provideInlineValues(document, viewPort, context, token);
            }
        };
        return [this.registerProvider(selector, provider), { provider: provider, onDidChangeInlineValues: eventEmitter }];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerInlineValuesProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.InlineValueFeature = InlineValueFeature;
//# sourceMappingURL=inlineValue.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/linkedEditingRange.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/linkedEditingRange.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingFeature = void 0;
const code = __webpack_require__(/*! vscode */ "vscode");
const proto = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class LinkedEditingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, proto.LinkedEditingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const linkedEditingSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'linkedEditingRange');
        linkedEditingSupport.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideLinkedEditingRanges: (document, position, token) => {
                const client = this._client;
                const provideLinkedEditing = (document, position, token) => {
                    return client.sendRequest(proto.LinkedEditingRangeRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asLinkedEditingRanges(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(proto.LinkedEditingRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideLinkedEditingRange
                    ? middleware.provideLinkedEditingRange(document, position, token, provideLinkedEditing)
                    : provideLinkedEditing(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return code.languages.registerLinkedEditingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.LinkedEditingFeature = LinkedEditingFeature;
//# sourceMappingURL=linkedEditingRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/notebook.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/notebook.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookDocumentSyncFeature = void 0;
const vscode = __webpack_require__(/*! vscode */ "vscode");
const minimatch = __webpack_require__(/*! minimatch */ "./node_modules/minimatch/minimatch.js");
const proto = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var Converter;
(function (Converter) {
    let c2p;
    (function (c2p) {
        function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {
            return {
                version: notebookDocument.version,
                uri: base.asUri(notebookDocument.uri)
            };
        }
        c2p.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;
        function asNotebookDocument(notebookDocument, cells, base) {
            const result = proto.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));
            if (Object.keys(notebookDocument.metadata).length > 0) {
                result.metadata = asMetadata(notebookDocument.metadata);
            }
            return result;
        }
        c2p.asNotebookDocument = asNotebookDocument;
        function asNotebookCells(cells, base) {
            return cells.map(cell => asNotebookCell(cell, base));
        }
        c2p.asNotebookCells = asNotebookCells;
        function asMetadata(metadata) {
            const seen = new Set();
            return deepCopy(seen, metadata);
        }
        c2p.asMetadata = asMetadata;
        function asNotebookCell(cell, base) {
            const result = proto.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));
            if (Object.keys(cell.metadata).length > 0) {
                result.metadata = asMetadata(cell.metadata);
            }
            if (cell.executionSummary !== undefined && (Is.number(cell.executionSummary.executionOrder) && Is.boolean(cell.executionSummary.success))) {
                result.executionSummary = {
                    executionOrder: cell.executionSummary.executionOrder,
                    success: cell.executionSummary.success
                };
            }
            return result;
        }
        c2p.asNotebookCell = asNotebookCell;
        function asNotebookCellKind(kind) {
            switch (kind) {
                case vscode.NotebookCellKind.Markup:
                    return proto.NotebookCellKind.Markup;
                case vscode.NotebookCellKind.Code:
                    return proto.NotebookCellKind.Code;
            }
        }
        function deepCopy(seen, value) {
            if (seen.has(value)) {
                throw new Error(`Can't deep copy cyclic structures.`);
            }
            if (Array.isArray(value)) {
                const result = [];
                for (const elem of value) {
                    if (elem !== null && typeof elem === 'object' || Array.isArray(elem)) {
                        result.push(deepCopy(seen, elem));
                    }
                    else {
                        if (elem instanceof RegExp) {
                            throw new Error(`Can't transfer regular expressions to the server`);
                        }
                        result.push(elem);
                    }
                }
                return result;
            }
            else {
                const props = Object.keys(value);
                const result = Object.create(null);
                for (const prop of props) {
                    const elem = value[prop];
                    if (elem !== null && typeof elem === 'object' || Array.isArray(elem)) {
                        result[prop] = deepCopy(seen, elem);
                    }
                    else {
                        if (elem instanceof RegExp) {
                            throw new Error(`Can't transfer regular expressions to the server`);
                        }
                        result[prop] = elem;
                    }
                }
                return result;
            }
        }
        function asTextContentChange(event, base) {
            const params = base.asChangeTextDocumentParams(event);
            return { document: params.textDocument, changes: params.contentChanges };
        }
        c2p.asTextContentChange = asTextContentChange;
        function asNotebookDocumentChangeEvent(event, base) {
            const result = Object.create(null);
            if (event.metadata) {
                result.metadata = Converter.c2p.asMetadata(event.metadata);
            }
            if (event.cells !== undefined) {
                const cells = Object.create(null);
                const changedCells = event.cells;
                if (changedCells.structure) {
                    cells.structure = {
                        array: {
                            start: changedCells.structure.array.start,
                            deleteCount: changedCells.structure.array.deleteCount,
                            cells: changedCells.structure.array.cells !== undefined ? changedCells.structure.array.cells.map(cell => Converter.c2p.asNotebookCell(cell, base)) : undefined
                        },
                        didOpen: changedCells.structure.didOpen !== undefined
                            ? changedCells.structure.didOpen.map(cell => base.asOpenTextDocumentParams(cell.document).textDocument)
                            : undefined,
                        didClose: changedCells.structure.didClose !== undefined
                            ? changedCells.structure.didClose.map(cell => base.asCloseTextDocumentParams(cell.document).textDocument)
                            : undefined
                    };
                }
                if (changedCells.data !== undefined) {
                    cells.data = changedCells.data.map(cell => Converter.c2p.asNotebookCell(cell, base));
                }
                if (changedCells.textContent !== undefined) {
                    cells.textContent = changedCells.textContent.map(event => Converter.c2p.asTextContentChange(event, base));
                }
                if (Object.keys(cells).length > 0) {
                    result.cells = cells;
                }
            }
            return result;
        }
        c2p.asNotebookDocumentChangeEvent = asNotebookDocumentChangeEvent;
    })(c2p = Converter.c2p || (Converter.c2p = {}));
})(Converter || (Converter = {}));
var $NotebookCell;
(function ($NotebookCell) {
    function computeDiff(originalCells, modifiedCells, compareMetadata) {
        const originalLength = originalCells.length;
        const modifiedLength = modifiedCells.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && equals(originalCells[startIndex], modifiedCells[startIndex], compareMetadata)) {
            startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= 0 && modifiedEndIndex >= 0 && equals(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata)) {
                originalEndIndex--;
                modifiedEndIndex--;
            }
            const deleteCount = (originalEndIndex + 1) - startIndex;
            const newCells = startIndex === modifiedEndIndex + 1 ? undefined : modifiedCells.slice(startIndex, modifiedEndIndex + 1);
            return newCells !== undefined ? { start: startIndex, deleteCount, cells: newCells } : { start: startIndex, deleteCount };
        }
        else if (startIndex < modifiedLength) {
            return { start: startIndex, deleteCount: 0, cells: modifiedCells.slice(startIndex) };
        }
        else if (startIndex < originalLength) {
            return { start: startIndex, deleteCount: originalLength - startIndex };
        }
        else {
            // The two arrays are the same.
            return undefined;
        }
    }
    $NotebookCell.computeDiff = computeDiff;
    /**
     * We only sync kind, document, execution and metadata to the server. So we only need to compare those.
     */
    function equals(one, other, compareMetaData = true) {
        if (one.kind !== other.kind || one.document.uri.toString() !== other.document.uri.toString() || one.document.languageId !== other.document.languageId ||
            !equalsExecution(one.executionSummary, other.executionSummary)) {
            return false;
        }
        return !compareMetaData || (compareMetaData && equalsMetadata(one.metadata, other.metadata));
    }
    function equalsExecution(one, other) {
        if (one === other) {
            return true;
        }
        if (one === undefined || other === undefined) {
            return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success && equalsTiming(one.timing, other.timing);
    }
    function equalsTiming(one, other) {
        if (one === other) {
            return true;
        }
        if (one === undefined || other === undefined) {
            return false;
        }
        return one.startTime === other.startTime && one.endTime === other.endTime;
    }
    function equalsMetadata(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
            return false;
        }
        if (oneArray && otherArray) {
            if (one.length !== other.length) {
                return false;
            }
            for (let i = 0; i < one.length; i++) {
                if (!equalsMetadata(one[i], other[i])) {
                    return false;
                }
            }
        }
        if (isObjectLiteral(one) && isObjectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
                return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
                return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
                const prop = oneKeys[i];
                if (!equalsMetadata(one[prop], other[prop])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    function isObjectLiteral(value) {
        return value !== null && typeof value === 'object';
    }
    $NotebookCell.isObjectLiteral = isObjectLiteral;
})($NotebookCell || ($NotebookCell = {}));
var $NotebookDocumentFilter;
(function ($NotebookDocumentFilter) {
    function matchNotebook(filter, notebookDocument) {
        if (typeof filter === 'string') {
            return filter === '*' || notebookDocument.notebookType === filter;
        }
        if (filter.notebookType !== undefined && filter.notebookType !== '*' && notebookDocument.notebookType !== filter.notebookType) {
            return false;
        }
        const uri = notebookDocument.uri;
        if (filter.scheme !== undefined && filter.scheme !== '*' && uri.scheme !== filter.scheme) {
            return false;
        }
        if (filter.pattern !== undefined) {
            const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
            if (!matcher.makeRe()) {
                return false;
            }
            if (!matcher.match(uri.fsPath)) {
                return false;
            }
        }
        return true;
    }
    $NotebookDocumentFilter.matchNotebook = matchNotebook;
})($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));
var $NotebookDocumentSyncOptions;
(function ($NotebookDocumentSyncOptions) {
    function asDocumentSelector(options) {
        const selector = options.notebookSelector;
        const result = [];
        for (const element of selector) {
            const notebookType = (typeof element.notebook === 'string' ? element.notebook : element.notebook?.notebookType) ?? '*';
            const scheme = (typeof element.notebook === 'string') ? undefined : element.notebook?.scheme;
            const pattern = (typeof element.notebook === 'string') ? undefined : element.notebook?.pattern;
            if (element.cells !== undefined) {
                for (const cell of element.cells) {
                    result.push(asDocumentFilter(notebookType, scheme, pattern, cell.language));
                }
            }
            else {
                result.push(asDocumentFilter(notebookType, scheme, pattern, undefined));
            }
        }
        return result;
    }
    $NotebookDocumentSyncOptions.asDocumentSelector = asDocumentSelector;
    function asDocumentFilter(notebookType, scheme, pattern, language) {
        return scheme === undefined && pattern === undefined
            ? { notebook: notebookType, language }
            : { notebook: { notebookType, scheme, pattern }, language };
    }
})($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));
var SyncInfo;
(function (SyncInfo) {
    function create(cells) {
        return {
            cells,
            uris: new Set(cells.map(cell => cell.document.uri.toString()))
        };
    }
    SyncInfo.create = create;
})(SyncInfo || (SyncInfo = {}));
class NotebookDocumentSyncFeatureProvider {
    constructor(client, options) {
        this.client = client;
        this.options = options;
        this.notebookSyncInfo = new Map();
        this.notebookDidOpen = new Set();
        this.disposables = [];
        this.selector = client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
        // open
        vscode.workspace.onDidOpenNotebookDocument((notebookDocument) => {
            this.notebookDidOpen.add(notebookDocument.uri.toString());
            this.didOpen(notebookDocument);
        }, undefined, this.disposables);
        for (const notebookDocument of vscode.workspace.notebookDocuments) {
            this.notebookDidOpen.add(notebookDocument.uri.toString());
            this.didOpen(notebookDocument);
        }
        // Notebook document changed.
        vscode.workspace.onDidChangeNotebookDocument(event => this.didChangeNotebookDocument(event), undefined, this.disposables);
        //save
        if (this.options.save === true) {
            vscode.workspace.onDidSaveNotebookDocument(notebookDocument => this.didSave(notebookDocument), undefined, this.disposables);
        }
        // close
        vscode.workspace.onDidCloseNotebookDocument((notebookDocument) => {
            this.didClose(notebookDocument);
            this.notebookDidOpen.delete(notebookDocument.uri.toString());
        }, undefined, this.disposables);
    }
    getState() {
        for (const notebook of vscode.workspace.notebookDocuments) {
            const matchingCells = this.getMatchingCells(notebook);
            if (matchingCells !== undefined) {
                return { kind: 'document', id: '$internal', registrations: true, matches: true };
            }
        }
        return { kind: 'document', id: '$internal', registrations: true, matches: false };
    }
    get mode() {
        return 'notebook';
    }
    handles(textDocument) {
        return vscode.languages.match(this.selector, textDocument) > 0;
    }
    didOpenNotebookCellTextDocument(notebookDocument, cell) {
        if (vscode.languages.match(this.selector, cell.document) === 0) {
            return;
        }
        if (!this.notebookDidOpen.has(notebookDocument.uri.toString())) {
            // We have never received an open notification for the notebook document.
            // VS Code guarantees that we first get cell document open and then
            // notebook open. So simply wait for the notebook open.
            return;
        }
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        // In VS Code we receive a notebook open before a cell document open.
        // The document and the cell is synced.
        const cellMatches = this.cellMatches(notebookDocument, cell);
        if (syncInfo !== undefined) {
            const cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());
            if ((cellMatches && cellIsSynced) || (!cellMatches && !cellIsSynced)) {
                // The cell doesn't match and was not synced or it matches and is synced.
                // In both cases nothing to do.
                //
                // Note that if the language mode of a document changes we remove the
                // cell and add it back to update the language mode on the server side.
                return;
            }
            if (cellMatches) {
                // don't use cells from above since there might be more matching cells in the notebook
                // Since we had a matching cell above we will have matching cells now.
                const matchingCells = this.getMatchingCells(notebookDocument);
                if (matchingCells !== undefined) {
                    const event = this.asNotebookDocumentChangeEvent(notebookDocument, undefined, syncInfo, matchingCells);
                    if (event !== undefined) {
                        this.doSendChange(event, matchingCells).catch(() => { });
                    }
                }
            }
        }
        else {
            // No sync info. But we have a open event for the notebook document
            // itself. If the cell matches then we need to send an open with
            // exactly that cell.
            if (cellMatches) {
                this.doSendOpen(notebookDocument, [cell]).catch(() => { });
            }
        }
    }
    didChangeNotebookCellTextDocument(notebookDocument, event) {
        // No match with the selector
        if (vscode.languages.match(this.selector, event.document) === 0) {
            return;
        }
        this.doSendChange({
            notebook: notebookDocument,
            cells: { textContent: [event] }
        }, undefined).catch(() => { });
    }
    didCloseNotebookCellTextDocument(notebookDocument, cell) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === undefined) {
            // The notebook document got never synced. So it doesn't matter if a cell
            // document closes.
            return;
        }
        const cellUri = cell.document.uri;
        const index = syncInfo.cells.findIndex((item) => item.document.uri.toString() === cellUri.toString());
        if (index === -1) {
            // The cell never got synced or it got deleted and we now received the document
            // close event.
            return;
        }
        if (index === 0 && syncInfo.cells.length === 1) {
            // The last cell. Close the notebook document in the server.
            this.doSendClose(notebookDocument, syncInfo.cells).catch(() => { });
        }
        else {
            const newCells = syncInfo.cells.slice();
            const deleted = newCells.splice(index, 1);
            this.doSendChange({
                notebook: notebookDocument,
                cells: {
                    structure: {
                        array: { start: index, deleteCount: 1 },
                        didClose: deleted
                    }
                }
            }, newCells).catch(() => { });
        }
    }
    dispose() {
        for (const disposable of this.disposables) {
            disposable.dispose();
        }
    }
    didOpen(notebookDocument, matchingCells = this.getMatchingCells(notebookDocument), syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo !== undefined) {
            if (matchingCells !== undefined) {
                const event = this.asNotebookDocumentChangeEvent(notebookDocument, undefined, syncInfo, matchingCells);
                if (event !== undefined) {
                    this.doSendChange(event, matchingCells).catch(() => { });
                }
            }
            else {
                this.doSendClose(notebookDocument, []).catch(() => { });
            }
        }
        else {
            // Check if we need to sync the notebook document.
            if (matchingCells === undefined) {
                return;
            }
            this.doSendOpen(notebookDocument, matchingCells).catch(() => { });
        }
    }
    didChangeNotebookDocument(event) {
        const notebookDocument = event.notebook;
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === undefined) {
            // We have no changes to the cells. Since the notebook wasn't synced
            // it will not be synced now.
            if (event.contentChanges.length === 0) {
                return;
            }
            // Check if we have new matching cells.
            const cells = this.getMatchingCells(notebookDocument);
            // No matching cells and the notebook never synced. So still no need
            // to sync it.
            if (cells === undefined) {
                return;
            }
            // Open the notebook document and ignore the rest of the changes
            // this the notebooks will be synced with the correct settings.
            this.didOpen(notebookDocument, cells, syncInfo);
        }
        else {
            // The notebook is synced. First check if we have no matching
            // cells anymore and if so close the notebook
            const cells = this.getMatchingCells(notebookDocument);
            if (cells === undefined) {
                this.didClose(notebookDocument, syncInfo);
                return;
            }
            const newEvent = this.asNotebookDocumentChangeEvent(event.notebook, event, syncInfo, cells);
            if (newEvent !== undefined) {
                this.doSendChange(newEvent, cells).catch(() => { });
            }
        }
    }
    didSave(notebookDocument) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === undefined) {
            return;
        }
        this.doSendSave(notebookDocument).catch(() => { });
    }
    didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo === undefined) {
            return;
        }
        const syncedCells = notebookDocument.getCells().filter(cell => syncInfo.uris.has(cell.document.uri.toString()));
        this.doSendClose(notebookDocument, syncedCells).catch(() => { });
    }
    async sendDidOpenNotebookDocument(notebookDocument) {
        const cells = this.getMatchingCells(notebookDocument);
        if (cells === undefined) {
            return;
        }
        return this.doSendOpen(notebookDocument, cells);
    }
    async doSendOpen(notebookDocument, cells) {
        const send = async (notebookDocument, cells) => {
            const nb = Converter.c2p.asNotebookDocument(notebookDocument, cells, this.client.code2ProtocolConverter);
            const cellDocuments = cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));
            try {
                await this.client.sendNotification(proto.DidOpenNotebookDocumentNotification.type, {
                    notebookDocument: nb,
                    cellTextDocuments: cellDocuments
                });
            }
            catch (error) {
                this.client.error('Sending DidOpenNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(cells));
        return middleware?.didOpen !== undefined ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);
    }
    async sendDidChangeNotebookDocument(event) {
        return this.doSendChange(event, undefined);
    }
    async doSendChange(event, cells = this.getMatchingCells(event.notebook)) {
        const send = async (event) => {
            try {
                await this.client.sendNotification(proto.DidChangeNotebookDocumentNotification.type, {
                    notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(event.notebook, this.client.code2ProtocolConverter),
                    change: Converter.c2p.asNotebookDocumentChangeEvent(event, this.client.code2ProtocolConverter)
                });
            }
            catch (error) {
                this.client.error('Sending DidChangeNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        if (event.cells?.structure !== undefined) {
            this.notebookSyncInfo.set(event.notebook.uri.toString(), SyncInfo.create(cells ?? []));
        }
        return middleware?.didChange !== undefined ? middleware?.didChange(event, send) : send(event);
    }
    async sendDidSaveNotebookDocument(notebookDocument) {
        return this.doSendSave(notebookDocument);
    }
    async doSendSave(notebookDocument) {
        const send = async (notebookDocument) => {
            try {
                await this.client.sendNotification(proto.DidSaveNotebookDocumentNotification.type, {
                    notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri) }
                });
            }
            catch (error) {
                this.client.error('Sending DidSaveNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        return middleware?.didSave !== undefined ? middleware.didSave(notebookDocument, send) : send(notebookDocument);
    }
    async sendDidCloseNotebookDocument(notebookDocument) {
        return this.doSendClose(notebookDocument, this.getMatchingCells(notebookDocument) ?? []);
    }
    async doSendClose(notebookDocument, cells) {
        const send = async (notebookDocument, cells) => {
            try {
                await this.client.sendNotification(proto.DidCloseNotebookDocumentNotification.type, {
                    notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri) },
                    cellTextDocuments: cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))
                });
            }
            catch (error) {
                this.client.error('Sending DidCloseNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        this.notebookSyncInfo.delete(notebookDocument.uri.toString());
        return middleware?.didClose !== undefined ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);
    }
    asNotebookDocumentChangeEvent(notebook, event, syncInfo, matchingCells) {
        if (event !== undefined && event.notebook !== notebook) {
            throw new Error('Notebook must be identical');
        }
        const result = {
            notebook: notebook
        };
        if (event?.metadata !== undefined) {
            result.metadata = Converter.c2p.asMetadata(event.metadata);
        }
        let matchingCellsSet;
        if (event?.cellChanges !== undefined && event.cellChanges.length > 0) {
            const data = [];
            // Only consider the new matching cells.
            matchingCellsSet = new Set(matchingCells.map(cell => cell.document.uri.toString()));
            for (const cellChange of event.cellChanges) {
                if (matchingCellsSet.has(cellChange.cell.document.uri.toString()) && (cellChange.executionSummary !== undefined || cellChange.metadata !== undefined)) {
                    data.push(cellChange.cell);
                }
            }
            if (data.length > 0) {
                result.cells = result.cells ?? {};
                result.cells.data = data;
            }
        }
        if (((event?.contentChanges !== undefined && event.contentChanges.length > 0) || event === undefined) && syncInfo !== undefined && matchingCells !== undefined) {
            // We still have matching cells. Check if the cell changes
            // affect the notebook on the server side.
            const oldCells = syncInfo.cells;
            const newCells = matchingCells;
            // meta data changes are reported using on the cell itself. So we can ignore comparing
            // it which has a positive effect on performance.
            const diff = $NotebookCell.computeDiff(oldCells, newCells, false);
            let addedCells;
            let removedCells;
            if (diff !== undefined) {
                addedCells = diff.cells === undefined
                    ? new Map()
                    : new Map(diff.cells.map(cell => [cell.document.uri.toString(), cell]));
                removedCells = diff.deleteCount === 0
                    ? new Map()
                    : new Map(oldCells.slice(diff.start, diff.start + diff.deleteCount).map(cell => [cell.document.uri.toString(), cell]));
                // Remove the onces that got deleted and inserted again.
                for (const key of Array.from(removedCells.keys())) {
                    if (addedCells.has(key)) {
                        removedCells.delete(key);
                        addedCells.delete(key);
                    }
                }
                result.cells = result.cells ?? {};
                const didOpen = [];
                const didClose = [];
                if (addedCells.size > 0 || removedCells.size > 0) {
                    for (const cell of addedCells.values()) {
                        didOpen.push(cell);
                    }
                    for (const cell of removedCells.values()) {
                        didClose.push(cell);
                    }
                }
                result.cells.structure = {
                    array: diff,
                    didOpen,
                    didClose
                };
            }
        }
        // The notebook is a property as well.
        return Object.keys(result).length > 1 ? result : undefined;
    }
    getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {
        if (this.options.notebookSelector === undefined) {
            return undefined;
        }
        for (const item of this.options.notebookSelector) {
            if (item.notebook === undefined || $NotebookDocumentFilter.matchNotebook(item.notebook, notebookDocument)) {
                const filtered = this.filterCells(notebookDocument, cells, item.cells);
                return filtered.length === 0 ? undefined : filtered;
            }
        }
        return undefined;
    }
    cellMatches(notebookDocument, cell) {
        const cells = this.getMatchingCells(notebookDocument, [cell]);
        return cells !== undefined && cells[0] === cell;
    }
    filterCells(notebookDocument, cells, cellSelector) {
        const filtered = cellSelector !== undefined ? cells.filter((cell) => {
            const cellLanguage = cell.document.languageId;
            return cellSelector.some((filter => (filter.language === '*' || cellLanguage === filter.language)));
        }) : cells;
        return typeof this.client.clientOptions.notebookDocumentOptions?.filterCells === 'function'
            ? this.client.clientOptions.notebookDocumentOptions.filterCells(notebookDocument, filtered)
            : filtered;
    }
}
class NotebookDocumentSyncFeature {
    constructor(client) {
        this.client = client;
        this.registrations = new Map();
        this.registrationType = proto.NotebookDocumentSyncRegistrationType.type;
        // We don't receive an event for cells where the document changes its language mode
        // Since we allow servers to filter on the language mode we fire such an event ourselves.
        vscode.workspace.onDidOpenTextDocument((textDocument) => {
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
                return;
            }
            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === undefined || notebookCell === undefined) {
                return;
            }
            for (const provider of this.registrations.values()) {
                if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                    provider.didOpenNotebookCellTextDocument(notebookDocument, notebookCell);
                }
            }
        });
        vscode.workspace.onDidChangeTextDocument((event) => {
            if (event.contentChanges.length === 0) {
                return;
            }
            const textDocument = event.document;
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
                return;
            }
            const [notebookDocument,] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === undefined) {
                return;
            }
            for (const provider of this.registrations.values()) {
                if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                    provider.didChangeNotebookCellTextDocument(notebookDocument, event);
                }
            }
        });
        vscode.workspace.onDidCloseTextDocument((textDocument) => {
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
                return;
            }
            // There are two cases when we receive a close for a text document
            // 1: the cell got removed. This is handled in `onDidChangeNotebookCells`
            // 2: the language mode of a cell changed. This keeps the URI stable so
            //    we will still find the cell and the notebook document.
            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === undefined || notebookCell === undefined) {
                return;
            }
            for (const provider of this.registrations.values()) {
                if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                    provider.didCloseNotebookCellTextDocument(notebookDocument, notebookCell);
                }
            }
        });
    }
    getState() {
        if (this.registrations.size === 0) {
            return { kind: 'document', id: this.registrationType.method, registrations: false, matches: false };
        }
        for (const provider of this.registrations.values()) {
            const state = provider.getState();
            if (state.kind === 'document' && state.registrations === true && state.matches === true) {
                return { kind: 'document', id: this.registrationType.method, registrations: true, matches: true };
            }
        }
        return { kind: 'document', id: this.registrationType.method, registrations: true, matches: false };
    }
    fillClientCapabilities(capabilities) {
        const synchronization = ensure(ensure(capabilities, 'notebookDocument'), 'synchronization');
        synchronization.dynamicRegistration = true;
        synchronization.executionSummarySupport = true;
    }
    preInitialize(capabilities) {
        const options = capabilities.notebookDocumentSync;
        if (options === undefined) {
            return;
        }
        this.dedicatedChannel = this.client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
    }
    initialize(capabilities) {
        const options = capabilities.notebookDocumentSync;
        if (options === undefined) {
            return;
        }
        const id = options.id ?? UUID.generateUuid();
        this.register({ id, registerOptions: options });
    }
    register(data) {
        const provider = new NotebookDocumentSyncFeatureProvider(this.client, data.registerOptions);
        this.registrations.set(data.id, provider);
    }
    unregister(id) {
        const provider = this.registrations.get(id);
        provider && provider.dispose();
    }
    dispose() {
        for (const provider of this.registrations.values()) {
            provider.dispose();
        }
        this.registrations.clear();
    }
    handles(textDocument) {
        if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
            return false;
        }
        if (this.dedicatedChannel !== undefined && vscode.languages.match(this.dedicatedChannel, textDocument) > 0) {
            return true;
        }
        for (const provider of this.registrations.values()) {
            if (provider.handles(textDocument)) {
                return true;
            }
        }
        return false;
    }
    getProvider(notebookCell) {
        for (const provider of this.registrations.values()) {
            if (provider.handles(notebookCell.document)) {
                return provider;
            }
        }
        return undefined;
    }
    findNotebookDocumentAndCell(textDocument) {
        const uri = textDocument.uri.toString();
        for (const notebookDocument of vscode.workspace.notebookDocuments) {
            for (const cell of notebookDocument.getCells()) {
                if (cell.document.uri.toString() === uri) {
                    return [notebookDocument, cell];
                }
            }
        }
        return [undefined, undefined];
    }
}
exports.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;
NotebookDocumentSyncFeature.CellScheme = 'vscode-notebook-cell';
//# sourceMappingURL=notebook.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/progress.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/progress.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const progressPart_1 = __webpack_require__(/*! ./progressPart */ "./node_modules/vscode-languageclient/lib/common/progressPart.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = Object.create(null);
    }
    return target[key];
}
class ProgressFeature {
    constructor(_client) {
        this._client = _client;
        this.activeParts = new Set();
    }
    getState() {
        return { kind: 'window', id: vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.method, registrations: this.activeParts.size > 0 };
    }
    fillClientCapabilities(capabilities) {
        ensure(capabilities, 'window').workDoneProgress = true;
    }
    initialize() {
        const client = this._client;
        const deleteHandler = (part) => {
            this.activeParts.delete(part);
        };
        const createHandler = (params) => {
            this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
    }
    dispose() {
        for (const part of this.activeParts) {
            part.done();
        }
        this.activeParts.clear();
    }
}
exports.ProgressFeature = ProgressFeature;
//# sourceMappingURL=progress.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/progressPart.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/progressPart.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressPart = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
class ProgressPart {
    constructor(_client, _token, done) {
        this._client = _client;
        this._token = _token;
        this._reported = 0;
        this._infinite = false;
        this._lspProgressDisposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
            switch (value.kind) {
                case 'begin':
                    this.begin(value);
                    break;
                case 'report':
                    this.report(value);
                    break;
                case 'end':
                    this.done();
                    done && done(this);
                    break;
            }
        });
    }
    begin(params) {
        this._infinite = params.percentage === undefined;
        // the progress as already been marked as done / canceled. Ignore begin call
        if (this._lspProgressDisposable === undefined) {
            return;
        }
        // Since we don't use commands this will be a silent window progress with a hidden notification.
        void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
            // the progress as already been marked as done / canceled. Ignore begin call
            if (this._lspProgressDisposable === undefined) {
                return;
            }
            this._progress = progress;
            this._cancellationToken = cancellationToken;
            this._tokenDisposable = this._cancellationToken.onCancellationRequested(() => {
                this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
            });
            this.report(params);
            return new Promise((resolve, reject) => {
                this._resolve = resolve;
                this._reject = reject;
            });
        });
    }
    report(params) {
        if (this._infinite && Is.string(params.message)) {
            this._progress !== undefined && this._progress.report({ message: params.message });
        }
        else if (Is.number(params.percentage)) {
            const percentage = Math.max(0, Math.min(params.percentage, 100));
            const delta = Math.max(0, percentage - this._reported);
            this._reported += delta;
            this._progress !== undefined && this._progress.report({ message: params.message, increment: delta });
        }
    }
    cancel() {
        this.cleanup();
        if (this._reject !== undefined) {
            this._reject();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
    done() {
        this.cleanup();
        if (this._resolve !== undefined) {
            this._resolve();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
    cleanup() {
        if (this._lspProgressDisposable !== undefined) {
            this._lspProgressDisposable.dispose();
            this._lspProgressDisposable = undefined;
        }
        if (this._tokenDisposable !== undefined) {
            this._tokenDisposable.dispose();
            this._tokenDisposable = undefined;
        }
        this._progress = undefined;
        this._cancellationToken = undefined;
    }
}
exports.ProgressPart = ProgressPart;
//# sourceMappingURL=progressPart.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(/*! vscode */ "vscode");
class ProtocolCallHierarchyItem extends code.CallHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = ProtocolCallHierarchyItem;
//# sourceMappingURL=protocolCallHierarchyItem.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolCodeAction.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolCodeAction.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode = __webpack_require__(/*! vscode */ "vscode");
class ProtocolCodeAction extends vscode.CodeAction {
    constructor(title, data) {
        super(title);
        this.data = data;
    }
}
exports["default"] = ProtocolCodeAction;
//# sourceMappingURL=protocolCodeAction.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolCodeLens.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolCodeLens.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(/*! vscode */ "vscode");
class ProtocolCodeLens extends code.CodeLens {
    constructor(range) {
        super(range);
    }
}
exports["default"] = ProtocolCodeLens;
//# sourceMappingURL=protocolCodeLens.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(/*! vscode */ "vscode");
class ProtocolCompletionItem extends code.CompletionItem {
    constructor(label) {
        super(label);
    }
}
exports["default"] = ProtocolCompletionItem;
//# sourceMappingURL=protocolCompletionItem.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolConverter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolConverter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(/*! vscode */ "vscode");
const ls = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
const async = __webpack_require__(/*! ./utils/async */ "./node_modules/vscode-languageclient/lib/common/utils/async.js");
const protocolCompletionItem_1 = __webpack_require__(/*! ./protocolCompletionItem */ "./node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js");
const protocolCodeLens_1 = __webpack_require__(/*! ./protocolCodeLens */ "./node_modules/vscode-languageclient/lib/common/protocolCodeLens.js");
const protocolDocumentLink_1 = __webpack_require__(/*! ./protocolDocumentLink */ "./node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js");
const protocolCodeAction_1 = __webpack_require__(/*! ./protocolCodeAction */ "./node_modules/vscode-languageclient/lib/common/protocolCodeAction.js");
const protocolDiagnostic_1 = __webpack_require__(/*! ./protocolDiagnostic */ "./node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js");
const protocolCallHierarchyItem_1 = __webpack_require__(/*! ./protocolCallHierarchyItem */ "./node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js");
const protocolTypeHierarchyItem_1 = __webpack_require__(/*! ./protocolTypeHierarchyItem */ "./node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js");
const protocolWorkspaceSymbol_1 = __webpack_require__(/*! ./protocolWorkspaceSymbol */ "./node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js");
const protocolInlayHint_1 = __webpack_require__(/*! ./protocolInlayHint */ "./node_modules/vscode-languageclient/lib/common/protocolInlayHint.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
var CodeBlock;
(function (CodeBlock) {
    function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.language) && Is.string(candidate.value);
    }
    CodeBlock.is = is;
})(CodeBlock || (CodeBlock = {}));
function createConverter(uriConverter, trustMarkdown, supportHtml) {
    const nullConverter = (value) => code.Uri.parse(value);
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asDocumentSelector(selector) {
        const result = [];
        for (const filter of selector) {
            if (typeof filter === 'string') {
                result.push(filter);
            }
            else if (vscode_languageserver_protocol_1.NotebookCellTextDocumentFilter.is(filter)) {
                // We first need to check for the notebook cell filter since a TextDocumentFilter would
                // match both (e.g. the notebook is optional).
                if (typeof filter.notebook === 'string') {
                    result.push({ notebookType: filter.notebook, language: filter.language });
                }
                else {
                    const notebookType = filter.notebook.notebookType ?? '*';
                    result.push({ notebookType: notebookType, scheme: filter.notebook.scheme, pattern: filter.notebook.pattern, language: filter.language });
                }
            }
            else if (vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
                result.push({ language: filter.language, scheme: filter.scheme, pattern: filter.pattern });
            }
        }
        return result;
    }
    async function asDiagnostics(diagnostics, token) {
        return async.map(diagnostics, asDiagnostic, token);
    }
    function asDiagnosticsSync(diagnostics) {
        const result = new Array(diagnostics.length);
        for (let i = 0; i < diagnostics.length; i++) {
            result[i] = asDiagnostic(diagnostics[i]);
        }
        return result;
    }
    function asDiagnostic(diagnostic) {
        let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
        if (diagnostic.code !== undefined) {
            if (typeof diagnostic.code === 'string' || typeof diagnostic.code === 'number') {
                if (ls.CodeDescription.is(diagnostic.codeDescription)) {
                    result.code = {
                        value: diagnostic.code,
                        target: asUri(diagnostic.codeDescription.href)
                    };
                }
                else {
                    result.code = diagnostic.code;
                }
            }
            else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
                // This is for backwards compatibility of a proposed API.
                // We should remove this at some point.
                result.hasDiagnosticCode = true;
                const diagnosticCode = diagnostic.code;
                result.code = {
                    value: diagnosticCode.value,
                    target: asUri(diagnosticCode.target)
                };
            }
        }
        if (diagnostic.source) {
            result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
            result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        if (Array.isArray(diagnostic.tags)) {
            result.tags = asDiagnosticTags(diagnostic.tags);
        }
        return result;
    }
    function asRelatedInformation(relatedInformation) {
        const result = new Array(relatedInformation.length);
        for (let i = 0; i < relatedInformation.length; i++) {
            const info = relatedInformation[i];
            result[i] = new code.DiagnosticRelatedInformation(asLocation(info.location), info.message);
        }
        return result;
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case ls.DiagnosticTag.Unnecessary:
                return code.DiagnosticTag.Unnecessary;
            case ls.DiagnosticTag.Deprecated:
                return code.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asPosition(value) {
        return value ? new code.Position(value.line, value.character) : undefined;
    }
    function asRange(value) {
        return value ? new code.Range(value.start.line, value.start.character, value.end.line, value.end.character) : undefined;
    }
    async function asRanges(items, token) {
        return async.map(items, (range) => {
            return new code.Range(range.start.line, range.start.character, range.end.line, range.end.character);
        }, token);
    }
    function asDiagnosticSeverity(value) {
        if (value === undefined || value === null) {
            return code.DiagnosticSeverity.Error;
        }
        switch (value) {
            case ls.DiagnosticSeverity.Error:
                return code.DiagnosticSeverity.Error;
            case ls.DiagnosticSeverity.Warning:
                return code.DiagnosticSeverity.Warning;
            case ls.DiagnosticSeverity.Information:
                return code.DiagnosticSeverity.Information;
            case ls.DiagnosticSeverity.Hint:
                return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
    }
    function asHoverContent(value) {
        if (Is.string(value)) {
            return asMarkdownString(value);
        }
        else if (CodeBlock.is(value)) {
            let result = asMarkdownString();
            return result.appendCodeblock(value.value, value.language);
        }
        else if (Array.isArray(value)) {
            let result = [];
            for (let element of value) {
                let item = asMarkdownString();
                if (CodeBlock.is(element)) {
                    item.appendCodeblock(element.value, element.language);
                }
                else {
                    item.appendMarkdown(element);
                }
                result.push(item);
            }
            return result;
        }
        else {
            return asMarkdownString(value);
        }
    }
    function asDocumentation(value) {
        if (Is.string(value)) {
            return value;
        }
        else {
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return asMarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    return value.value;
                default:
                    return `Unsupported Markup content received. Kind is: ${value.kind}`;
            }
        }
    }
    function asMarkdownString(value) {
        let result;
        if (value === undefined || typeof value === 'string') {
            result = new code.MarkdownString(value);
        }
        else {
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    result = new code.MarkdownString(value.value);
                    break;
                case ls.MarkupKind.PlainText:
                    result = new code.MarkdownString();
                    result.appendText(value.value);
                    break;
                default:
                    result = new code.MarkdownString();
                    result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
                    break;
            }
        }
        result.isTrusted = trustMarkdown;
        result.supportHtml = supportHtml;
        return result;
    }
    function asHover(hover) {
        if (!hover) {
            return undefined;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
    }
    async function asCompletionResult(value, allCommitCharacters, token) {
        if (!value) {
            return undefined;
        }
        if (Array.isArray(value)) {
            return async.map(value, (item) => asCompletionItem(item, allCommitCharacters), token);
        }
        const list = value;
        const { defaultRange, commitCharacters } = getCompletionItemDefaults(list, allCommitCharacters);
        const converted = await async.map(list.items, (item) => {
            return asCompletionItem(item, commitCharacters, defaultRange, list.itemDefaults?.insertTextMode, list.itemDefaults?.insertTextFormat, list.itemDefaults?.data);
        }, token);
        return new code.CompletionList(converted, list.isIncomplete);
    }
    function getCompletionItemDefaults(list, allCommitCharacters) {
        const rangeDefaults = list.itemDefaults?.editRange;
        const commitCharacters = list.itemDefaults?.commitCharacters ?? allCommitCharacters;
        return ls.Range.is(rangeDefaults)
            ? { defaultRange: asRange(rangeDefaults), commitCharacters }
            : rangeDefaults !== undefined
                ? { defaultRange: { inserting: asRange(rangeDefaults.insert), replacing: asRange(rangeDefaults.replace) }, commitCharacters }
                : { defaultRange: undefined, commitCharacters };
    }
    function asCompletionItemKind(value) {
        // Protocol item kind is 1 based, codes item kind is zero based.
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
            return [value - 1, undefined];
        }
        return [code.CompletionItemKind.Text, value];
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case ls.CompletionItemTag.Deprecated:
                return code.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined || tags === null) {
            return [];
        }
        const result = [];
        for (const tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItem(item, defaultCommitCharacters, defaultRange, defaultInsertTextMode, defaultInsertTextFormat, defaultData) {
        const tags = asCompletionItemTags(item.tags);
        const label = asCompletionItemLabel(item);
        const result = new protocolCompletionItem_1.default(label);
        if (item.detail) {
            result.detail = item.detail;
        }
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
            result.documentationFormat = Is.string(item.documentation) ? '$string' : item.documentation.kind;
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        const insertText = asCompletionInsertText(item, defaultRange, defaultInsertTextFormat);
        if (insertText) {
            result.insertText = insertText.text;
            result.range = insertText.range;
            result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
            let [itemKind, original] = asCompletionItemKind(item.kind);
            result.kind = itemKind;
            if (original) {
                result.originalItemKind = original;
            }
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEditsSync(item.additionalTextEdits);
        }
        const commitCharacters = item.commitCharacters !== undefined
            ? Is.stringArray(item.commitCharacters) ? item.commitCharacters : undefined
            : defaultCommitCharacters;
        if (commitCharacters) {
            result.commitCharacters = commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
            if (item.deprecated === true) {
                tags.push(code.CompletionItemTag.Deprecated);
            }
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        const data = item.data ?? defaultData;
        if (data !== undefined) {
            result.data = data;
        }
        if (tags.length > 0) {
            result.tags = tags;
        }
        const insertTextMode = item.insertTextMode ?? defaultInsertTextMode;
        if (insertTextMode !== undefined) {
            result.insertTextMode = insertTextMode;
            if (insertTextMode === ls.InsertTextMode.asIs) {
                result.keepWhitespace = true;
            }
        }
        return result;
    }
    function asCompletionItemLabel(item) {
        if (ls.CompletionItemLabelDetails.is(item.labelDetails)) {
            return {
                label: item.label,
                detail: item.labelDetails.detail,
                description: item.labelDetails.description
            };
        }
        else {
            return item.label;
        }
    }
    function asCompletionInsertText(item, defaultRange, defaultInsertTextFormat) {
        const insertTextFormat = item.insertTextFormat ?? defaultInsertTextFormat;
        if (item.textEdit !== undefined || defaultRange !== undefined) {
            const [range, newText] = item.textEdit !== undefined
                ? getCompletionRangeAndText(item.textEdit)
                : [defaultRange, item.textEditText ?? item.label];
            if (insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(newText), range: range, fromEdit: true };
            }
            else {
                return { text: newText, range: range, fromEdit: true };
            }
        }
        else if (item.insertText) {
            if (insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.insertText), fromEdit: false };
            }
            else {
                return { text: item.insertText, fromEdit: false };
            }
        }
        else {
            return undefined;
        }
    }
    function getCompletionRangeAndText(value) {
        if (ls.InsertReplaceEdit.is(value)) {
            return [{ inserting: asRange(value.insert), replacing: asRange(value.replace) }, value.newText];
        }
        else {
            return [asRange(value.range), value.newText];
        }
    }
    function asTextEdit(edit) {
        if (!edit) {
            return undefined;
        }
        return new code.TextEdit(asRange(edit.range), edit.newText);
    }
    async function asTextEdits(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asTextEdit, token);
    }
    function asTextEditsSync(items) {
        if (!items) {
            return undefined;
        }
        const result = new Array(items.length);
        for (let i = 0; i < items.length; i++) {
            result[i] = asTextEdit(items[i]);
        }
        return result;
    }
    async function asSignatureHelp(item, token) {
        if (!item) {
            return undefined;
        }
        let result = new code.SignatureHelp();
        if (Is.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
        }
        else {
            // activeSignature was optional in the past
            result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
        }
        else {
            // activeParameter was optional in the past
            result.activeParameter = 0;
        }
        if (item.signatures) {
            result.signatures = await asSignatureInformations(item.signatures, token);
        }
        return result;
    }
    async function asSignatureInformations(items, token) {
        return async.mapAsync(items, asSignatureInformation, token);
    }
    async function asSignatureInformation(item, token) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation !== undefined) {
            result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters !== undefined) {
            result.parameters = await asParameterInformations(item.parameters, token);
        }
        if (item.activeParameter !== undefined) {
            result.activeParameter = item.activeParameter;
        }
        {
            return result;
        }
    }
    function asParameterInformations(items, token) {
        return async.map(items, asParameterInformation, token);
    }
    function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
        }
        return result;
    }
    function asLocation(item) {
        return item ? new code.Location(_uriConverter(item.uri), asRange(item.range)) : undefined;
    }
    async function asDeclarationResult(item, token) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item, token);
    }
    async function asDefinitionResult(item, token) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item, token);
    }
    function asLocationLink(item) {
        if (!item) {
            return undefined;
        }
        let result = {
            targetUri: _uriConverter(item.targetUri),
            targetRange: asRange(item.targetRange),
            originSelectionRange: asRange(item.originSelectionRange),
            targetSelectionRange: asRange(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
            throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
    }
    async function asLocationResult(item, token) {
        if (!item) {
            return undefined;
        }
        if (Is.array(item)) {
            if (item.length === 0) {
                return [];
            }
            else if (ls.LocationLink.is(item[0])) {
                const links = item;
                return async.map(links, asLocationLink, token);
            }
            else {
                const locations = item;
                return async.map(locations, asLocation, token);
            }
        }
        else if (ls.LocationLink.is(item)) {
            return [asLocationLink(item)];
        }
        else {
            return asLocation(item);
        }
    }
    async function asReferences(values, token) {
        if (!values) {
            return undefined;
        }
        return async.map(values, asLocation, token);
    }
    async function asDocumentHighlights(values, token) {
        if (!values) {
            return undefined;
        }
        return async.map(values, asDocumentHighlight, token);
    }
    function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange(item.range));
        if (Is.number(item.kind)) {
            result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
    }
    function asDocumentHighlightKind(item) {
        switch (item) {
            case ls.DocumentHighlightKind.Text:
                return code.DocumentHighlightKind.Text;
            case ls.DocumentHighlightKind.Read:
                return code.DocumentHighlightKind.Read;
            case ls.DocumentHighlightKind.Write:
                return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
    }
    async function asSymbolInformations(values, token) {
        if (!values) {
            return undefined;
        }
        return async.map(values, asSymbolInformation, token);
    }
    function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return item - 1;
        }
        return code.SymbolKind.Property;
    }
    function asSymbolTag(value) {
        switch (value) {
            case ls.SymbolTag.Deprecated:
                return code.SymbolTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asSymbolTags(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        const result = [];
        for (const item of items) {
            const converted = asSymbolTag(item);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length === 0 ? undefined : result;
    }
    function asSymbolInformation(item) {
        const data = item.data;
        const location = item.location;
        const result = location.range === undefined || data !== undefined
            ? new protocolWorkspaceSymbol_1.default(item.name, asSymbolKind(item.kind), item.containerName ?? '', location.range === undefined ? _uriConverter(location.uri) : new code.Location(_uriConverter(item.location.uri), asRange(location.range)), data)
            : new code.SymbolInformation(item.name, asSymbolKind(item.kind), item.containerName ?? '', new code.Location(_uriConverter(item.location.uri), asRange(location.range)));
        fillTags(result, item);
        return result;
    }
    async function asDocumentSymbols(values, token) {
        if (values === undefined || values === null) {
            return undefined;
        }
        return async.map(values, asDocumentSymbol, token);
    }
    function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || '', asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
        fillTags(result, value);
        if (value.children !== undefined && value.children.length > 0) {
            let children = [];
            for (let child of value.children) {
                children.push(asDocumentSymbol(child));
            }
            result.children = children;
        }
        return result;
    }
    function fillTags(result, value) {
        result.tags = asSymbolTags(value.tags);
        if (value.deprecated) {
            if (!result.tags) {
                result.tags = [code.SymbolTag.Deprecated];
            }
            else {
                if (!result.tags.includes(code.SymbolTag.Deprecated)) {
                    result.tags = result.tags.concat(code.SymbolTag.Deprecated);
                }
            }
        }
    }
    function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    async function asCommands(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asCommand, token);
    }
    const kindMapping = new Map();
    kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
    kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
    kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
    kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
    kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
    kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
    kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
    kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = kindMapping.get(item);
        if (result) {
            return result;
        }
        let parts = item.split('.');
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
            result = result.append(part);
        }
        return result;
    }
    function asCodeActionKinds(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        return items.map(kind => asCodeActionKind(kind));
    }
    async function asCodeAction(item, token) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = new protocolCodeAction_1.default(item.title, item.data);
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = asDiagnosticsSync(item.diagnostics);
        }
        if (item.edit !== undefined) {
            result.edit = await asWorkspaceEdit(item.edit, token);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    function asCodeActionResult(items, token) {
        return async.mapAsync(items, async (item) => {
            if (ls.Command.is(item)) {
                return asCommand(item);
            }
            else {
                return asCodeAction(item, token);
            }
        }, token);
    }
    function asCodeLens(item) {
        if (!item) {
            return undefined;
        }
        let result = new protocolCodeLens_1.default(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.data !== undefined && item.data !== null) {
            result.data = item.data;
        }
        return result;
    }
    async function asCodeLenses(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asCodeLens, token);
    }
    async function asWorkspaceEdit(item, token) {
        if (!item) {
            return undefined;
        }
        const sharedMetadata = new Map();
        if (item.changeAnnotations !== undefined) {
            const changeAnnotations = item.changeAnnotations;
            await async.forEach(Object.keys(changeAnnotations), (key) => {
                const metaData = asWorkspaceEditEntryMetadata(changeAnnotations[key]);
                sharedMetadata.set(key, metaData);
            }, token);
        }
        const asMetadata = (annotation) => {
            if (annotation === undefined) {
                return undefined;
            }
            else {
                return sharedMetadata.get(annotation);
            }
        };
        const result = new code.WorkspaceEdit();
        if (item.documentChanges) {
            const documentChanges = item.documentChanges;
            await async.forEach(documentChanges, (change) => {
                if (ls.CreateFile.is(change)) {
                    result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.RenameFile.is(change)) {
                    result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.DeleteFile.is(change)) {
                    result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.TextDocumentEdit.is(change)) {
                    const uri = _uriConverter(change.textDocument.uri);
                    for (const edit of change.edits) {
                        if (ls.AnnotatedTextEdit.is(edit)) {
                            result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
                        }
                        else {
                            result.replace(uri, asRange(edit.range), edit.newText);
                        }
                    }
                }
                else {
                    throw new Error(`Unknown workspace edit change received:\n${JSON.stringify(change, undefined, 4)}`);
                }
            }, token);
        }
        else if (item.changes) {
            const changes = item.changes;
            await async.forEach(Object.keys(changes), (key) => {
                result.set(_uriConverter(key), asTextEditsSync(changes[key]));
            }, token);
        }
        return result;
    }
    function asWorkspaceEditEntryMetadata(annotation) {
        if (annotation === undefined) {
            return undefined;
        }
        return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
    }
    function asDocumentLink(item) {
        let range = asRange(item.range);
        let target = item.target ? asUri(item.target) : undefined;
        // target must be optional in DocumentLink
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.tooltip !== undefined) {
            link.tooltip = item.tooltip;
        }
        if (item.data !== undefined && item.data !== null) {
            link.data = item.data;
        }
        return link;
    }
    async function asDocumentLinks(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asDocumentLink, token);
    }
    function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
    }
    function asColorInformation(ci) {
        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
    }
    async function asColorInformations(colorInformation, token) {
        if (!colorInformation) {
            return undefined;
        }
        return async.map(colorInformation, asColorInformation, token);
    }
    function asColorPresentation(cp) {
        let presentation = new code.ColorPresentation(cp.label);
        presentation.additionalTextEdits = asTextEditsSync(cp.additionalTextEdits);
        if (cp.textEdit) {
            presentation.textEdit = asTextEdit(cp.textEdit);
        }
        return presentation;
    }
    async function asColorPresentations(colorPresentations, token) {
        if (!colorPresentations) {
            return undefined;
        }
        return async.map(colorPresentations, asColorPresentation, token);
    }
    function asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case ls.FoldingRangeKind.Comment:
                    return code.FoldingRangeKind.Comment;
                case ls.FoldingRangeKind.Imports:
                    return code.FoldingRangeKind.Imports;
                case ls.FoldingRangeKind.Region:
                    return code.FoldingRangeKind.Region;
            }
        }
        return undefined;
    }
    function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
    }
    async function asFoldingRanges(foldingRanges, token) {
        if (!foldingRanges) {
            return undefined;
        }
        return async.map(foldingRanges, asFoldingRange, token);
    }
    function asSelectionRange(selectionRange) {
        return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : undefined);
    }
    async function asSelectionRanges(selectionRanges, token) {
        if (!Array.isArray(selectionRanges)) {
            return [];
        }
        return async.map(selectionRanges, asSelectionRange, token);
    }
    function asInlineValue(inlineValue) {
        if (ls.InlineValueText.is(inlineValue)) {
            return new code.InlineValueText(asRange(inlineValue.range), inlineValue.text);
        }
        else if (ls.InlineValueVariableLookup.is(inlineValue)) {
            return new code.InlineValueVariableLookup(asRange(inlineValue.range), inlineValue.variableName, inlineValue.caseSensitiveLookup);
        }
        else {
            return new code.InlineValueEvaluatableExpression(asRange(inlineValue.range), inlineValue.expression);
        }
    }
    async function asInlineValues(inlineValues, token) {
        if (!Array.isArray(inlineValues)) {
            return [];
        }
        return async.map(inlineValues, asInlineValue, token);
    }
    async function asInlayHint(value, token) {
        const label = typeof value.label === 'string'
            ? value.label
            : await async.map(value.label, asInlayHintLabelPart, token);
        const result = new protocolInlayHint_1.default(asPosition(value.position), label);
        if (value.kind !== undefined) {
            result.kind = value.kind;
        }
        if (value.textEdits !== undefined) {
            result.textEdits = await asTextEdits(value.textEdits, token);
        }
        if (value.tooltip !== undefined) {
            result.tooltip = asTooltip(value.tooltip);
        }
        if (value.paddingLeft !== undefined) {
            result.paddingLeft = value.paddingLeft;
        }
        if (value.paddingRight !== undefined) {
            result.paddingRight = value.paddingRight;
        }
        if (value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    function asInlayHintLabelPart(part) {
        const result = new code.InlayHintLabelPart(part.value);
        if (part.location !== undefined) {
            result.location = asLocation(part.location);
        }
        if (part.tooltip !== undefined) {
            result.tooltip = asTooltip(part.tooltip);
        }
        if (part.command !== undefined) {
            result.command = asCommand(part.command);
        }
        return result;
    }
    function asTooltip(value) {
        if (typeof value === 'string') {
            return value;
        }
        return asMarkdownString(value);
    }
    async function asInlayHints(values, token) {
        if (!Array.isArray(values)) {
            return undefined;
        }
        return async.mapAsync(values, asInlayHint, token);
    }
    function asCallHierarchyItem(item) {
        if (item === null) {
            return undefined;
        }
        const result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || '', asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        return result;
    }
    async function asCallHierarchyItems(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.map(items, asCallHierarchyItem, token);
    }
    async function asCallHierarchyIncomingCall(item, token) {
        return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), await asRanges(item.fromRanges, token));
    }
    async function asCallHierarchyIncomingCalls(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.mapAsync(items, asCallHierarchyIncomingCall, token);
    }
    async function asCallHierarchyOutgoingCall(item, token) {
        return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), await asRanges(item.fromRanges, token));
    }
    async function asCallHierarchyOutgoingCalls(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.mapAsync(items, asCallHierarchyOutgoingCall, token);
    }
    async function asSemanticTokens(value, _token) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
    }
    function asSemanticTokensEdit(value) {
        return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== undefined ? new Uint32Array(value.data) : undefined);
    }
    async function asSemanticTokensEdits(value, _token) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
    }
    function asSemanticTokensLegend(value) {
        return value;
    }
    async function asLinkedEditingRanges(value, token) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new code.LinkedEditingRanges(await asRanges(value.ranges, token), asRegularExpression(value.wordPattern));
    }
    function asRegularExpression(value) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new RegExp(value);
    }
    function asTypeHierarchyItem(item) {
        if (item === null) {
            return undefined;
        }
        let result = new protocolTypeHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || '', asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        return result;
    }
    async function asTypeHierarchyItems(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.map(items, asTypeHierarchyItem, token);
    }
    function asGlobPattern(pattern) {
        if (Is.string(pattern)) {
            return pattern;
        }
        if (ls.RelativePattern.is(pattern)) {
            if (ls.URI.is(pattern.baseUri)) {
                return new code.RelativePattern(asUri(pattern.baseUri), pattern.pattern);
            }
            else if (ls.WorkspaceFolder.is(pattern.baseUri)) {
                const workspaceFolder = code.workspace.getWorkspaceFolder(asUri(pattern.baseUri.uri));
                return workspaceFolder !== undefined ? new code.RelativePattern(workspaceFolder, pattern.pattern) : undefined;
            }
        }
        return undefined;
    }
    return {
        asUri,
        asDocumentSelector,
        asDiagnostics,
        asDiagnostic,
        asRange,
        asRanges,
        asPosition,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeActionResult,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations,
        asSelectionRange,
        asSelectionRanges,
        asInlineValue,
        asInlineValues,
        asInlayHint,
        asInlayHints,
        asSemanticTokensLegend,
        asSemanticTokens,
        asSemanticTokensEdit,
        asSemanticTokensEdits,
        asCallHierarchyItem,
        asCallHierarchyItems,
        asCallHierarchyIncomingCall,
        asCallHierarchyIncomingCalls,
        asCallHierarchyOutgoingCall,
        asCallHierarchyOutgoingCalls,
        asLinkedEditingRanges: asLinkedEditingRanges,
        asTypeHierarchyItem,
        asTypeHierarchyItems,
        asGlobPattern
    };
}
exports.createConverter = createConverter;
//# sourceMappingURL=protocolConverter.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolDiagnostic = exports.DiagnosticCode = void 0;
const vscode = __webpack_require__(/*! vscode */ "vscode");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
var DiagnosticCode;
(function (DiagnosticCode) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && (Is.number(candidate.value) || Is.string(candidate.value)) && Is.string(candidate.target);
    }
    DiagnosticCode.is = is;
})(DiagnosticCode = exports.DiagnosticCode || (exports.DiagnosticCode = {}));
class ProtocolDiagnostic extends vscode.Diagnostic {
    constructor(range, message, severity, data) {
        super(range, message, severity);
        this.data = data;
        this.hasDiagnosticCode = false;
    }
}
exports.ProtocolDiagnostic = ProtocolDiagnostic;
//# sourceMappingURL=protocolDiagnostic.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(/*! vscode */ "vscode");
class ProtocolDocumentLink extends code.DocumentLink {
    constructor(range, target) {
        super(range, target);
    }
}
exports["default"] = ProtocolDocumentLink;
//# sourceMappingURL=protocolDocumentLink.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolInlayHint.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolInlayHint.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(/*! vscode */ "vscode");
class ProtocolInlayHint extends code.InlayHint {
    constructor(position, label, kind) {
        super(position, label, kind);
    }
}
exports["default"] = ProtocolInlayHint;
//# sourceMappingURL=protocolInlayHint.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(/*! vscode */ "vscode");
class ProtocolTypeHierarchyItem extends code.TypeHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = ProtocolTypeHierarchyItem;
//# sourceMappingURL=protocolTypeHierarchyItem.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(/*! vscode */ "vscode");
class WorkspaceSymbol extends code.SymbolInformation {
    constructor(name, kind, containerName, locationOrUri, data) {
        const hasRange = !(locationOrUri instanceof code.Uri);
        super(name, kind, containerName, hasRange ? locationOrUri : new code.Location(locationOrUri, new code.Range(0, 0, 0, 0)));
        this.hasRange = hasRange;
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = WorkspaceSymbol;
//# sourceMappingURL=protocolWorkspaceSymbol.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/reference.js":
/*!********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/reference.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReferencesFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
class ReferencesFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'references').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideReferences: (document, position, options, token) => {
                const client = this._client;
                const _providerReferences = (document, position, options, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document, position, options), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asReferences(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideReferences
                    ? middleware.provideReferences(document, position, options, token, _providerReferences)
                    : _providerReferences(document, position, options, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerReferenceProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.ReferencesFeature = ReferencesFeature;
//# sourceMappingURL=reference.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/rename.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/rename.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class RenameFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let rename = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'rename');
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
        rename.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
        rename.honorsChangeAnnotations = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
            return;
        }
        if (Is.boolean(capabilities.renameProvider)) {
            options.prepareProvider = false;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideRenameEdits: (document, position, newName, token) => {
                const client = this._client;
                const provideRenameEdits = (document, position, newName, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        newName: newName
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asWorkspaceEdit(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, token, error, null, false);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideRenameEdits
                    ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits)
                    : provideRenameEdits(document, position, newName, token);
            },
            prepareRename: options.prepareProvider
                ? (document, position, token) => {
                    const client = this._client;
                    const prepareRename = (document, position, token) => {
                        let params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            position: client.code2ProtocolConverter.asPosition(position),
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            if (vscode_languageserver_protocol_1.Range.is(result)) {
                                return client.protocol2CodeConverter.asRange(result);
                            }
                            else if (this.isDefaultBehavior(result)) {
                                return result.defaultBehavior === true
                                    ? null
                                    : Promise.reject(new Error(`The element can't be renamed.`));
                            }
                            else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                                return {
                                    range: client.protocol2CodeConverter.asRange(result.range),
                                    placeholder: result.placeholder
                                };
                            }
                            // To cancel the rename vscode API expects a rejected promise.
                            return Promise.reject(new Error(`The element can't be renamed.`));
                        }, (error) => {
                            if (typeof error.message === 'string') {
                                throw new Error(error.message);
                            }
                            else {
                                throw new Error(`The element can't be renamed.`);
                            }
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.prepareRename
                        ? middleware.prepareRename(document, position, token, prepareRename)
                        : prepareRename(document, position, token);
                }
                : undefined
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerRenameProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
    isDefaultBehavior(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.defaultBehavior);
    }
}
exports.RenameFeature = RenameFeature;
//# sourceMappingURL=rename.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/selectionRange.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/selectionRange.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class SelectionRangeFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'selectionRange');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideSelectionRanges: (document, positions, token) => {
                const client = this._client;
                const provideSelectionRanges = async (document, positions, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        positions: await client.code2ProtocolConverter.asPositions(positions, token)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token).then((ranges) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asSelectionRanges(ranges, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideSelectionRanges
                    ? middleware.provideSelectionRanges(document, positions, token, provideSelectionRanges)
                    : provideSelectionRanges(document, positions, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerSelectionRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.SelectionRangeFeature = SelectionRangeFeature;
//# sourceMappingURL=selectionRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/semanticTokens.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/semanticTokens.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensFeature = void 0;
const vscode = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
class SemanticTokensFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'semanticTokens');
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
            vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
            vscode_languageserver_protocol_1.SemanticTokenTypes.type,
            vscode_languageserver_protocol_1.SemanticTokenTypes.class,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
            vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
            vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
            vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
            vscode_languageserver_protocol_1.SemanticTokenTypes.property,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
            vscode_languageserver_protocol_1.SemanticTokenTypes.event,
            vscode_languageserver_protocol_1.SemanticTokenTypes.function,
            vscode_languageserver_protocol_1.SemanticTokenTypes.method,
            vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
            vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
            vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
            vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
            vscode_languageserver_protocol_1.SemanticTokenTypes.string,
            vscode_languageserver_protocol_1.SemanticTokenTypes.number,
            vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
            vscode_languageserver_protocol_1.SemanticTokenTypes.operator,
            vscode_languageserver_protocol_1.SemanticTokenTypes.decorator
        ];
        capability.tokenModifiers = [
            vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
        capability.requests = {
            range: true,
            full: {
                delta: true
            }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        capability.serverCancelSupport = true;
        capability.augmentsSyntaxTokens = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'semanticTokens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeSemanticTokensEmitter.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const fullProvider = Is.boolean(options.full) ? options.full : options.full !== undefined;
        const hasEditProvider = options.full !== undefined && typeof options.full !== 'boolean' && options.full.delta === true;
        const eventEmitter = new vscode.EventEmitter();
        const documentProvider = fullProvider
            ? {
                onDidChangeSemanticTokens: eventEmitter.event,
                provideDocumentSemanticTokens: (document, token) => {
                    const client = this._client;
                    const middleware = client.middleware;
                    const provideDocumentSemanticTokens = (document, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asSemanticTokens(result, token);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, token, error, null);
                        });
                    };
                    return middleware.provideDocumentSemanticTokens
                        ? middleware.provideDocumentSemanticTokens(document, token, provideDocumentSemanticTokens)
                        : provideDocumentSemanticTokens(document, token);
                },
                provideDocumentSemanticTokensEdits: hasEditProvider
                    ? (document, previousResultId, token) => {
                        const client = this._client;
                        const middleware = client.middleware;
                        const provideDocumentSemanticTokensEdits = (document, previousResultId, token) => {
                            const params = {
                                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                                previousResultId
                            };
                            return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token).then(async (result) => {
                                if (token.isCancellationRequested) {
                                    return null;
                                }
                                if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                                    return await client.protocol2CodeConverter.asSemanticTokens(result, token);
                                }
                                else {
                                    return await client.protocol2CodeConverter.asSemanticTokensEdits(result, token);
                                }
                            }, (error) => {
                                return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, token, error, null);
                            });
                        };
                        return middleware.provideDocumentSemanticTokensEdits
                            ? middleware.provideDocumentSemanticTokensEdits(document, previousResultId, token, provideDocumentSemanticTokensEdits)
                            : provideDocumentSemanticTokensEdits(document, previousResultId, token);
                    }
                    : undefined
            }
            : undefined;
        const hasRangeProvider = options.range === true;
        const rangeProvider = hasRangeProvider
            ? {
                provideDocumentRangeSemanticTokens: (document, range, token) => {
                    const client = this._client;
                    const middleware = client.middleware;
                    const provideDocumentRangeSemanticTokens = (document, range, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            range: client.code2ProtocolConverter.asRange(range)
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asSemanticTokens(result, token);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, token, error, null);
                        });
                    };
                    return middleware.provideDocumentRangeSemanticTokens
                        ? middleware.provideDocumentRangeSemanticTokens(document, range, token, provideDocumentRangeSemanticTokens)
                        : provideDocumentRangeSemanticTokens(document, range, token);
                }
            }
            : undefined;
        const disposables = [];
        const client = this._client;
        const legend = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
        const documentSelector = client.protocol2CodeConverter.asDocumentSelector(selector);
        if (documentProvider !== undefined) {
            disposables.push(vscode.languages.registerDocumentSemanticTokensProvider(documentSelector, documentProvider, legend));
        }
        if (rangeProvider !== undefined) {
            disposables.push(vscode.languages.registerDocumentRangeSemanticTokensProvider(documentSelector, rangeProvider, legend));
        }
        return [new vscode.Disposable(() => disposables.forEach(item => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
    }
}
exports.SemanticTokensFeature = SemanticTokensFeature;
//# sourceMappingURL=semanticTokens.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/signatureHelp.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/signatureHelp.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignatureHelpFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
class SignatureHelpFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let config = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'signatureHelp');
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
        config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
        config.signatureInformation.activeParameterSupport = true;
        config.contextSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideSignatureHelp: (document, position, token, context) => {
                const client = this._client;
                const providerSignatureHelp = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document, position, context), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asSignatureHelp(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideSignatureHelp
                    ? middleware.provideSignatureHelp(document, position, context, token, providerSignatureHelp)
                    : providerSignatureHelp(document, position, context, token);
            }
        };
        return [this.registerProvider(options, provider), provider];
    }
    registerProvider(options, provider) {
        const selector = this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        if (options.retriggerCharacters === undefined) {
            const triggerCharacters = options.triggerCharacters || [];
            return vscode_1.languages.registerSignatureHelpProvider(selector, provider, ...triggerCharacters);
        }
        else {
            const metaData = {
                triggerCharacters: options.triggerCharacters || [],
                retriggerCharacters: options.retriggerCharacters || []
            };
            return vscode_1.languages.registerSignatureHelpProvider(selector, provider, metaData);
        }
    }
}
exports.SignatureHelpFeature = SignatureHelpFeature;
//# sourceMappingURL=signatureHelp.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/textSynchronization.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/textSynchronization.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidSaveTextDocumentFeature = exports.WillSaveWaitUntilFeature = exports.WillSaveFeature = exports.DidChangeTextDocumentFeature = exports.DidCloseTextDocumentFeature = exports.DidOpenTextDocumentFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const async_1 = __webpack_require__(/*! ./utils/async */ "./node_modules/vscode-languageclient/lib/common/utils/async.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
class DidOpenTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client, syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, () => client.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = syncedDocuments;
    }
    get openDocuments() {
        return this._syncedDocuments.values();
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
    }
    register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) {
            return;
        }
        const documentSelector = this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector);
        vscode_1.workspace.textDocuments.forEach((textDocument) => {
            const uri = textDocument.uri.toString();
            if (this._syncedDocuments.has(uri)) {
                return;
            }
            if (vscode_1.languages.match(documentSelector, textDocument) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
                const middleware = this._client.middleware;
                const didOpen = (textDocument) => {
                    return this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                (middleware.didOpen ? middleware.didOpen(textDocument, didOpen) : didOpen(textDocument)).catch((error) => {
                    this._client.error(`Sending document notification ${this._type.method} failed`, error);
                });
                this._syncedDocuments.set(uri, textDocument);
            }
        });
    }
    notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
    }
}
exports.DidOpenTextDocumentFeature = DidOpenTextDocumentFeature;
class DidCloseTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client, syncedDocuments) {
        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, () => client.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = syncedDocuments;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.delete(textDocument.uri.toString());
    }
    unregister(id) {
        const selector = this._selectors.get(id);
        // The super call removed the selector from the map
        // of selectors.
        super.unregister(id);
        const selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
            if (vscode_1.languages.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument) && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
                let middleware = this._client.middleware;
                let didClose = (textDocument) => {
                    return this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                this._syncedDocuments.delete(textDocument.uri.toString());
                (middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument)).catch((error) => {
                    this._client.error(`Sending document notification ${this._type.method} failed`, error);
                });
            }
        });
    }
}
exports.DidCloseTextDocumentFeature = DidCloseTextDocumentFeature;
class DidChangeTextDocumentFeature extends features_1.DynamicDocumentFeature {
    constructor(client) {
        super(client);
        this._forcingDelivery = false;
        this._changeData = new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== undefined && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
            syncKind: data.registerOptions.syncKind,
            documentSelector: this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector),
        });
    }
    *getDocumentSelectors() {
        for (const data of this._changeData.values()) {
            yield data.documentSelector;
        }
    }
    async callback(event) {
        // Text document changes are send for dirty changes as well. We don't
        // have dirty / un-dirty events in the LSP so we ignore content changes
        // with length zero.
        if (event.contentChanges.length === 0) {
            return;
        }
        const promises = [];
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, event.document) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
                const middleware = this._client.middleware;
                if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
                    const didChange = async (event) => {
                        const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event);
                        await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                        this.notificationSent(event, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                    };
                    promises.push(middleware.didChange ? middleware.didChange(event, event => didChange(event)) : didChange(event));
                }
                else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                    const didChange = async (event) => {
                        const doSend = async (event) => {
                            const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document);
                            await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                            this.notificationSent(event, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                        };
                        if (this._changeDelayer) {
                            if (this._changeDelayer.uri !== event.document.uri.toString()) {
                                // Use this force delivery to track boolean state. Otherwise we might call two times.
                                await this.forceDelivery();
                                this._changeDelayer.uri = event.document.uri.toString();
                            }
                            // Usually we return the promise that signals that the data has been
                            // handed of to the network. With delayed change notification we can't
                            // do that since it would make the sendNotification call wait until the
                            // change delayer resolves and would therefore defeat the purpose. We
                            // instead return the change delayer and ensure via forceDocumentSync
                            // that before sending other notification / request the document sync
                            // has actually happened.
                            return this._changeDelayer.delayer.trigger(() => doSend(event));
                        }
                        else {
                            this._changeDelayer = {
                                uri: event.document.uri.toString(),
                                delayer: new async_1.Delayer(200)
                            };
                            // See comment above.
                            return this._changeDelayer.delayer.trigger(() => doSend(event), -1);
                        }
                    };
                    promises.push(middleware.didChange ? middleware.didChange(event, event => didChange(event)) : didChange(event));
                }
            }
        }
        return Promise.all(promises).then(undefined, (error) => {
            this._client.error(`Sending document notification ${vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method} failed`, error);
            throw error;
        });
    }
    get onNotificationSent() {
        return this._onNotificationSent.event;
    }
    notificationSent(changeEvent, type, params) {
        this._onNotificationSent.fire({ original: changeEvent, type, params });
    }
    unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        if (this._changeDelayer !== undefined) {
            this._changeDelayer.delayer.cancel();
        }
        this._changeDelayer = undefined;
        this._forcingDelivery = false;
        this._changeData.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    async forceDelivery() {
        if (this._forcingDelivery || !this._changeDelayer) {
            return;
        }
        try {
            this._forcingDelivery = true;
            return this._changeDelayer.delayer.forceDelivery();
        }
        finally {
            this._forcingDelivery = false;
        }
    }
    getProvider(document) {
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, document) > 0) {
                return {
                    send: (event) => {
                        return this.callback(event);
                    }
                };
            }
        }
        return undefined;
    }
}
exports.DidChangeTextDocumentFeature = DidChangeTextDocumentFeature;
class WillSaveFeature extends features_1.TextDocumentEventFeature {
    constructor(client) {
        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, () => client.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (event) => event.document, (selectors, willSaveEvent) => features_1.TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document));
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization');
        value.willSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
}
exports.WillSaveFeature = WillSaveFeature;
class WillSaveWaitUntilFeature extends features_1.DynamicDocumentFeature {
    constructor(client) {
        super(client);
        this._selectors = new Map();
    }
    getDocumentSelectors() {
        return this._selectors.values();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
    }
    fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization');
        value.willSaveWaitUntil = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
    }
    callback(event) {
        if (features_1.TextDocumentEventFeature.textDocumentFilter(this._selectors.values(), event.document) && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
            let middleware = this._client.middleware;
            let willSaveWaitUntil = (event) => {
                return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event)).then(async (edits) => {
                    let vEdits = await this._client.protocol2CodeConverter.asTextEdits(edits);
                    return vEdits === undefined ? [] : vEdits;
                });
            };
            event.waitUntil(middleware.willSaveWaitUntil
                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)
                : willSaveWaitUntil(event));
        }
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
}
exports.WillSaveWaitUntilFeature = WillSaveWaitUntilFeature;
class DidSaveTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client) {
        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, () => client.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._includeText = false;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').didSave = true;
    }
    initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
            const saveOptions = typeof textDocumentSyncOptions.save === 'boolean'
                ? { includeText: false }
                : { includeText: !!textDocumentSyncOptions.save.includeText };
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, saveOptions)
            });
        }
    }
    register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
    }
}
exports.DidSaveTextDocumentFeature = DidSaveTextDocumentFeature;
//# sourceMappingURL=textSynchronization.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/typeDefinition.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/typeDefinition.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class TypeDefinitionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'typeDefinition').dynamicRegistration = true;
        let typeDefinitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'typeDefinition');
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideTypeDefinition: (document, position, token) => {
                const client = this._client;
                const provideTypeDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDefinitionResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideTypeDefinition
                    ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition)
                    : provideTypeDefinition(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerTypeDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.TypeDefinitionFeature = TypeDefinitionFeature;
//# sourceMappingURL=typeDefinition.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/typeHierarchy.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/typeHierarchy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
class TypeHierarchyProvider {
    constructor(client) {
        this.client = client;
        this.middleware = client.middleware;
    }
    prepareTypeHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareTypeHierarchy = (document, position, token) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asTypeHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, token, error, null);
            });
        };
        return middleware.prepareTypeHierarchy
            ? middleware.prepareTypeHierarchy(document, position, token, prepareTypeHierarchy)
            : prepareTypeHierarchy(document, position, token);
    }
    provideTypeHierarchySupertypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySupertypes = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asTypeHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asTypeHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, token, error, null);
            });
        };
        return middleware.provideTypeHierarchySupertypes
            ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes)
            : provideTypeHierarchySupertypes(item, token);
    }
    provideTypeHierarchySubtypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySubtypes = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asTypeHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asTypeHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, token, error, null);
            });
        };
        return middleware.provideTypeHierarchySubtypes
            ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes)
            : provideTypeHierarchySubtypes(item, token);
    }
}
class TypeHierarchyFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'typeHierarchy');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.typeHierarchyProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const client = this._client;
        const provider = new TypeHierarchyProvider(client);
        return [vscode_1.languages.registerTypeHierarchyProvider(client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
    }
}
exports.TypeHierarchyFeature = TypeHierarchyFeature;
//# sourceMappingURL=typeHierarchy.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/utils/async.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/utils/async.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forEach = exports.mapAsync = exports.map = exports.clearTestMode = exports.setTestMode = exports.Semaphore = exports.Delayer = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
class Delayer {
    constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = undefined;
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
    }
    trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
            this.cancelTimeout();
        }
        if (!this.completionPromise) {
            this.completionPromise = new Promise((resolve) => {
                this.onSuccess = resolve;
            }).then(() => {
                this.completionPromise = undefined;
                this.onSuccess = undefined;
                var result = this.task();
                this.task = undefined;
                return result;
            });
        }
        if (delay >= 0 || this.timeout === void 0) {
            this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
                this.timeout = undefined;
                this.onSuccess(undefined);
            }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
    }
    forceDelivery() {
        if (!this.completionPromise) {
            return undefined;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
        return result;
    }
    isTriggered() {
        return this.timeout !== undefined;
    }
    cancel() {
        this.cancelTimeout();
        this.completionPromise = undefined;
    }
    cancelTimeout() {
        if (this.timeout !== undefined) {
            this.timeout.dispose();
            this.timeout = undefined;
        }
    }
}
exports.Delayer = Delayer;
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;
let $test = false;
function setTestMode() {
    $test = true;
}
exports.setTestMode = setTestMode;
function clearTestMode() {
    $test = false;
}
exports.clearTestMode = clearTestMode;
const defaultYieldTimeout = 15 /*ms*/;
class Timer {
    constructor(yieldAfter = defaultYieldTimeout) {
        this.yieldAfter = $test === true ? Math.max(yieldAfter, 2) : Math.max(yieldAfter, defaultYieldTimeout);
        this.startTime = Date.now();
        this.counter = 0;
        this.total = 0;
        // start with a counter interval of 1.
        this.counterInterval = 1;
    }
    start() {
        this.counter = 0;
        this.total = 0;
        this.counterInterval = 1;
        this.startTime = Date.now();
    }
    shouldYield() {
        if (++this.counter >= this.counterInterval) {
            const timeTaken = Date.now() - this.startTime;
            const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
            this.total += this.counter;
            this.counter = 0;
            if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
                // Yield also if time left <= 1 since we compute the counter
                // for max < 2 ms.
                // Start with interval 1 again. We could do some calculation
                // with using 80% of the last counter however other things (GC)
                // affect the timing heavily since we have small timings (1 - 15ms).
                this.counterInterval = 1;
                this.total = 0;
                return true;
            }
            else {
                // Only increase the counter until we have spent <= 2 ms. Increasing
                // the counter further is very fragile since timing is influenced
                // by other things and can increase the counter too much. This will result
                // that we yield in average after [14 - 16]ms.
                switch (timeTaken) {
                    case 0:
                    case 1:
                        this.counterInterval = this.total * 2;
                        break;
                }
            }
        }
        return false;
    }
}
async function map(items, func, token, options) {
    if (items.length === 0) {
        return [];
    }
    const result = new Array(items.length);
    const timer = new Timer(options?.yieldAfter);
    function convertBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
            result[i] = func(items[i]);
            if (timer.shouldYield()) {
                options?.yieldCallback && options.yieldCallback();
                return i + 1;
            }
        }
        return -1;
    }
    // Convert the first batch sync on the same frame.
    let index = convertBatch(0);
    while (index !== -1) {
        if (token !== undefined && token.isCancellationRequested) {
            break;
        }
        index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
                resolve(convertBatch(index));
            });
        });
    }
    return result;
}
exports.map = map;
async function mapAsync(items, func, token, options) {
    if (items.length === 0) {
        return [];
    }
    const result = new Array(items.length);
    const timer = new Timer(options?.yieldAfter);
    async function convertBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
            result[i] = await func(items[i], token);
            if (timer.shouldYield()) {
                options?.yieldCallback && options.yieldCallback();
                return i + 1;
            }
        }
        return -1;
    }
    let index = await convertBatch(0);
    while (index !== -1) {
        if (token !== undefined && token.isCancellationRequested) {
            break;
        }
        index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
                resolve(convertBatch(index));
            });
        });
    }
    return result;
}
exports.mapAsync = mapAsync;
async function forEach(items, func, token, options) {
    if (items.length === 0) {
        return;
    }
    const timer = new Timer(options?.yieldAfter);
    function runBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
            func(items[i]);
            if (timer.shouldYield()) {
                options?.yieldCallback && options.yieldCallback();
                return i + 1;
            }
        }
        return -1;
    }
    // Convert the first batch sync on the same frame.
    let index = runBatch(0);
    while (index !== -1) {
        if (token !== undefined && token.isCancellationRequested) {
            break;
        }
        index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
                resolve(runBatch(index));
            });
        });
    }
}
exports.forEach = forEach;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/utils/is.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/utils/is.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asPromise = exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;
function asPromise(value) {
    if (value instanceof Promise) {
        return value;
    }
    else if (thenable(value)) {
        return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
        });
    }
    else {
        return Promise.resolve(value);
    }
}
exports.asPromise = asPromise;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/utils/uuid.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/workspaceFolder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/workspaceFolder.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFoldersFeature = exports.arrayDiff = void 0;
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
function access(target, key) {
    if (target === void 0) {
        return undefined;
    }
    return target[key];
}
function arrayDiff(left, right) {
    return left.filter(element => right.indexOf(element) < 0);
}
exports.arrayDiff = arrayDiff;
class WorkspaceFoldersFeature {
    constructor(client) {
        this._client = client;
        this._listeners = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._listeners.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
    }
    fillInitializeParams(params) {
        const folders = vscode_1.workspace.workspaceFolders;
        this.initializeWithFolders(folders);
        if (folders === void 0) {
            params.workspaceFolders = null;
        }
        else {
            params.workspaceFolders = folders.map(folder => this.asProtocol(folder));
        }
    }
    initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
    }
    initialize(capabilities) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
            const workspaceFolders = () => {
                const folders = vscode_1.workspace.workspaceFolders;
                if (folders === undefined) {
                    return null;
                }
                const result = folders.map((folder) => {
                    return this.asProtocol(folder);
                });
                return result;
            };
            const middleware = client.middleware.workspace;
            return middleware && middleware.workspaceFolders
                ? middleware.workspaceFolders(token, workspaceFolders)
                : workspaceFolders(token);
        });
        const value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');
        let id;
        if (typeof value === 'string') {
            id = value;
        }
        else if (value === true) {
            id = UUID.generateUuid();
        }
        if (id) {
            this.register({ id: id, registerOptions: undefined });
        }
    }
    sendInitialEvent(currentWorkspaceFolders) {
        let promise;
        if (this._initialFolders && currentWorkspaceFolders) {
            const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
            const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
            if (added.length > 0 || removed.length > 0) {
                promise = this.doSendEvent(added, removed);
            }
        }
        else if (this._initialFolders) {
            promise = this.doSendEvent([], this._initialFolders);
        }
        else if (currentWorkspaceFolders) {
            promise = this.doSendEvent(currentWorkspaceFolders, []);
        }
        if (promise !== undefined) {
            promise.catch((error) => {
                this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
        }
    }
    doSendEvent(addedFolders, removedFolders) {
        let params = {
            event: {
                added: addedFolders.map(folder => this.asProtocol(folder)),
                removed: removedFolders.map(folder => this.asProtocol(folder))
            }
        };
        return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
    }
    register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
            let didChangeWorkspaceFolders = (event) => {
                return this.doSendEvent(event.added, event.removed);
            };
            let middleware = client.middleware.workspace;
            const promise = middleware && middleware.didChangeWorkspaceFolders
                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)
                : didChangeWorkspaceFolders(event);
            promise.catch((error) => {
                this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
        });
        this._listeners.set(id, disposable);
        this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
            return;
        }
        this._listeners.delete(id);
        disposable.dispose();
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
            return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
    }
}
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
//# sourceMappingURL=workspaceFolder.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/workspaceSymbol.js":
/*!**************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/workspaceSymbol.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceSymbolFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const features_1 = __webpack_require__(/*! ./features */ "./node_modules/vscode-languageclient/lib/common/features.js");
const documentSymbol_1 = __webpack_require__(/*! ./documentSymbol */ "./node_modules/vscode-languageclient/lib/common/documentSymbol.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
class WorkspaceSymbolFeature extends features_1.WorkspaceFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'symbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: documentSymbol_1.SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
            valueSet: documentSymbol_1.SupportedSymbolTags
        };
        symbolCapabilities.resolveSupport = { properties: ['location.range'] };
    }
    initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideWorkspaceSymbols: (query, token) => {
                const client = this._client;
                const provideWorkspaceSymbols = (query, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query }, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asSymbolInformations(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideWorkspaceSymbols
                    ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols)
                    : provideWorkspaceSymbols(query, token);
            },
            resolveWorkspaceSymbol: options.resolveProvider === true
                ? (item, token) => {
                    const client = this._client;
                    const resolveWorkspaceSymbol = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, client.code2ProtocolConverter.asWorkspaceSymbol(item), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asSymbolInformation(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, token, error, null);
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.resolveWorkspaceSymbol
                        ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol)
                        : resolveWorkspaceSymbol(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
    }
}
exports.WorkspaceSymbolFeature = WorkspaceSymbolFeature;
//# sourceMappingURL=workspaceSymbol.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/node/main.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/node/main.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingMonitor = exports.LanguageClient = exports.TransportKind = void 0;
const cp = __webpack_require__(/*! child_process */ "child_process");
const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const Is = __webpack_require__(/*! ../common/utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
const client_1 = __webpack_require__(/*! ../common/client */ "./node_modules/vscode-languageclient/lib/common/client.js");
const processes_1 = __webpack_require__(/*! ./processes */ "./node_modules/vscode-languageclient/lib/node/processes.js");
const node_1 = __webpack_require__(/*! vscode-languageserver-protocol/node */ "./node_modules/vscode-languageserver-protocol/node.js");
// Import SemVer functions individually to avoid circular dependencies in SemVer
const semverParse = __webpack_require__(/*! semver/functions/parse */ "./node_modules/vscode-languageclient/node_modules/semver/functions/parse.js");
const semverSatisfies = __webpack_require__(/*! semver/functions/satisfies */ "./node_modules/vscode-languageclient/node_modules/semver/functions/satisfies.js");
__exportStar(__webpack_require__(/*! vscode-languageserver-protocol/node */ "./node_modules/vscode-languageserver-protocol/node.js"), exports);
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-languageclient/lib/common/api.js"), exports);
const REQUIRED_VSCODE_VERSION = '^1.67.0'; // do not change format, updated by `updateVSCode` script
var TransportKind;
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
    TransportKind[TransportKind["pipe"] = 2] = "pipe";
    TransportKind[TransportKind["socket"] = 3] = "socket";
})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));
var Transport;
(function (Transport) {
    function isSocket(value) {
        const candidate = value;
        return candidate && candidate.kind === TransportKind.socket && Is.number(candidate.port);
    }
    Transport.isSocket = isSocket;
})(Transport || (Transport = {}));
var Executable;
(function (Executable) {
    function is(value) {
        return Is.string(value.command);
    }
    Executable.is = is;
})(Executable || (Executable = {}));
var NodeModule;
(function (NodeModule) {
    function is(value) {
        return Is.string(value.module);
    }
    NodeModule.is = is;
})(NodeModule || (NodeModule = {}));
var StreamInfo;
(function (StreamInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== undefined && candidate.reader !== undefined;
    }
    StreamInfo.is = is;
})(StreamInfo || (StreamInfo = {}));
var ChildProcessInfo;
(function (ChildProcessInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.process !== undefined && typeof candidate.detached === 'boolean';
    }
    ChildProcessInfo.is = is;
})(ChildProcessInfo || (ChildProcessInfo = {}));
class LanguageClient extends client_1.BaseLanguageClient {
    constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is.string(arg2)) {
            id = arg1;
            name = arg2;
            serverOptions = arg3;
            clientOptions = arg4;
            forceDebug = !!arg5;
        }
        else {
            id = arg1.toLowerCase();
            name = arg1;
            serverOptions = arg2;
            clientOptions = arg3;
            forceDebug = arg4;
        }
        if (forceDebug === undefined) {
            forceDebug = false;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        this._isInDebugMode = forceDebug;
        try {
            this.checkVersion();
        }
        catch (error) {
            if (Is.string(error.message)) {
                this.outputChannel.appendLine(error.message);
            }
            throw error;
        }
    }
    checkVersion() {
        const codeVersion = semverParse(vscode_1.version);
        if (!codeVersion) {
            throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);
        }
        // Remove the insider pre-release since we stay API compatible.
        if (codeVersion.prerelease && codeVersion.prerelease.length > 0) {
            codeVersion.prerelease = [];
        }
        if (!semverSatisfies(codeVersion, REQUIRED_VSCODE_VERSION)) {
            throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);
        }
    }
    get isInDebugMode() {
        return this._isInDebugMode;
    }
    async restart() {
        await this.stop();
        // We are in debug mode. Wait a little before we restart
        // so that the debug port can be freed. We can safely ignore
        // the disposable returned from start since it will call
        // stop on the same client instance.
        if (this.isInDebugMode) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
            await this.start();
        }
        else {
            await this.start();
        }
    }
    stop(timeout = 2000) {
        return super.stop(timeout).finally(() => {
            if (this._serverProcess) {
                const toCheck = this._serverProcess;
                this._serverProcess = undefined;
                if (this._isDetached === undefined || !this._isDetached) {
                    this.checkProcessDied(toCheck);
                }
                this._isDetached = undefined;
            }
        });
    }
    checkProcessDied(childProcess) {
        if (!childProcess || childProcess.pid === undefined) {
            return;
        }
        setTimeout(() => {
            // Test if the process is still alive. Throws an exception if not
            try {
                if (childProcess.pid !== undefined) {
                    process.kill(childProcess.pid, 0);
                    (0, processes_1.terminate)(childProcess);
                }
            }
            catch (error) {
                // All is fine.
            }
        }, 2000);
    }
    handleConnectionClosed() {
        this._serverProcess = undefined;
        super.handleConnectionClosed();
    }
    fillInitializeParams(params) {
        super.fillInitializeParams(params);
        if (params.processId === null) {
            params.processId = process.pid;
        }
    }
    createMessageTransports(encoding) {
        function getEnvironment(env, fork) {
            if (!env && !fork) {
                return undefined;
            }
            const result = Object.create(null);
            Object.keys(process.env).forEach(key => result[key] = process.env[key]);
            if (fork) {
                result['ELECTRON_RUN_AS_NODE'] = '1';
                result['ELECTRON_NO_ASAR'] = '1';
            }
            if (env) {
                Object.keys(env).forEach(key => result[key] = env[key]);
            }
            return result;
        }
        const debugStartWith = ['--debug=', '--debug-brk=', '--inspect=', '--inspect-brk='];
        const debugEquals = ['--debug', '--debug-brk', '--inspect', '--inspect-brk'];
        function startedInDebugMode() {
            let args = process.execArgv;
            if (args) {
                return args.some((arg) => {
                    return debugStartWith.some(value => arg.startsWith(value)) ||
                        debugEquals.some(value => arg === value);
                });
            }
            return false;
        }
        function assertStdio(process) {
            if (process.stdin === null || process.stdout === null || process.stderr === null) {
                throw new Error('Process created without stdio streams');
            }
        }
        const server = this._serverOptions;
        // We got a function.
        if (Is.func(server)) {
            return server().then((result) => {
                if (client_1.MessageTransports.is(result)) {
                    this._isDetached = !!result.detached;
                    return result;
                }
                else if (StreamInfo.is(result)) {
                    this._isDetached = !!result.detached;
                    return { reader: new node_1.StreamMessageReader(result.reader), writer: new node_1.StreamMessageWriter(result.writer) };
                }
                else {
                    let cp;
                    if (ChildProcessInfo.is(result)) {
                        cp = result.process;
                        this._isDetached = result.detached;
                    }
                    else {
                        cp = result;
                        this._isDetached = false;
                    }
                    cp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    return { reader: new node_1.StreamMessageReader(cp.stdout), writer: new node_1.StreamMessageWriter(cp.stdin) };
                }
            });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
            if (this._forceDebug || startedInDebugMode()) {
                json = runDebug.debug;
                this._isInDebugMode = true;
            }
            else {
                json = runDebug.run;
                this._isInDebugMode = false;
            }
        }
        else {
            json = server;
        }
        return this._getServerWorkingDir(json.options).then(serverWorkingDir => {
            if (NodeModule.is(json) && json.module) {
                let node = json;
                let transport = node.transport || TransportKind.stdio;
                if (node.runtime) {
                    const args = [];
                    const options = node.options ?? Object.create(null);
                    if (options.execArgv) {
                        options.execArgv.forEach(element => args.push(element));
                    }
                    args.push(node.module);
                    if (node.args) {
                        node.args.forEach(element => args.push(element));
                    }
                    const execOptions = Object.create(null);
                    execOptions.cwd = serverWorkingDir;
                    execOptions.env = getEnvironment(options.env, false);
                    const runtime = this._getRuntimePath(node.runtime, serverWorkingDir);
                    let pipeName = undefined;
                    if (transport === TransportKind.ipc) {
                        // exec options not correctly typed in lib
                        execOptions.stdio = [null, null, null, 'ipc'];
                        args.push('--node-ipc');
                    }
                    else if (transport === TransportKind.stdio) {
                        args.push('--stdio');
                    }
                    else if (transport === TransportKind.pipe) {
                        pipeName = (0, node_1.generateRandomPipeName)();
                        args.push(`--pipe=${pipeName}`);
                    }
                    else if (Transport.isSocket(transport)) {
                        args.push(`--socket=${transport.port}`);
                    }
                    args.push(`--clientProcessId=${process.pid.toString()}`);
                    if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                        const serverProcess = cp.spawn(runtime, args, execOptions);
                        if (!serverProcess || !serverProcess.pid) {
                            return handleChildProcessStartError(serverProcess, `Launching server using runtime ${runtime} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        if (transport === TransportKind.ipc) {
                            serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return Promise.resolve({ reader: new node_1.IPCMessageReader(serverProcess), writer: new node_1.IPCMessageWriter(serverProcess) });
                        }
                        else {
                            return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
                        }
                    }
                    else if (transport === TransportKind.pipe) {
                        return (0, node_1.createClientPipeTransport)(pipeName).then((transport) => {
                            const process = cp.spawn(runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return handleChildProcessStartError(process, `Launching server using runtime ${runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                    else if (Transport.isSocket(transport)) {
                        return (0, node_1.createClientSocketTransport)(transport.port).then((transport) => {
                            const process = cp.spawn(runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return handleChildProcessStartError(process, `Launching server using runtime ${runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                }
                else {
                    let pipeName = undefined;
                    return new Promise((resolve, reject) => {
                        const args = (node.args && node.args.slice()) ?? [];
                        if (transport === TransportKind.ipc) {
                            args.push('--node-ipc');
                        }
                        else if (transport === TransportKind.stdio) {
                            args.push('--stdio');
                        }
                        else if (transport === TransportKind.pipe) {
                            pipeName = (0, node_1.generateRandomPipeName)();
                            args.push(`--pipe=${pipeName}`);
                        }
                        else if (Transport.isSocket(transport)) {
                            args.push(`--socket=${transport.port}`);
                        }
                        args.push(`--clientProcessId=${process.pid.toString()}`);
                        const options = node.options ?? Object.create(null);
                        options.env = getEnvironment(options.env, true);
                        options.execArgv = options.execArgv || [];
                        options.cwd = serverWorkingDir;
                        options.silent = true;
                        if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                            const sp = cp.fork(node.module, args || [], options);
                            assertStdio(sp);
                            this._serverProcess = sp;
                            sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            if (transport === TransportKind.ipc) {
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                resolve({ reader: new node_1.IPCMessageReader(this._serverProcess), writer: new node_1.IPCMessageWriter(this._serverProcess) });
                            }
                            else {
                                resolve({ reader: new node_1.StreamMessageReader(sp.stdout), writer: new node_1.StreamMessageWriter(sp.stdin) });
                            }
                        }
                        else if (transport === TransportKind.pipe) {
                            (0, node_1.createClientPipeTransport)(pipeName).then((transport) => {
                                const sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                }, reject);
                            }, reject);
                        }
                        else if (Transport.isSocket(transport)) {
                            (0, node_1.createClientSocketTransport)(transport.port).then((transport) => {
                                const sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                }, reject);
                            }, reject);
                        }
                    });
                }
            }
            else if (Executable.is(json) && json.command) {
                const command = json;
                const args = json.args !== undefined ? json.args.slice(0) : [];
                let pipeName = undefined;
                const transport = json.transport;
                if (transport === TransportKind.stdio) {
                    args.push('--stdio');
                }
                else if (transport === TransportKind.pipe) {
                    pipeName = (0, node_1.generateRandomPipeName)();
                    args.push(`--pipe=${pipeName}`);
                }
                else if (Transport.isSocket(transport)) {
                    args.push(`--socket=${transport.port}`);
                }
                else if (transport === TransportKind.ipc) {
                    throw new Error(`Transport kind ipc is not support for command executable`);
                }
                const options = Object.assign({}, command.options);
                options.cwd = options.cwd || serverWorkingDir;
                if (transport === undefined || transport === TransportKind.stdio) {
                    const serverProcess = cp.spawn(command.command, args, options);
                    if (!serverProcess || !serverProcess.pid) {
                        return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                    }
                    serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    this._serverProcess = serverProcess;
                    this._isDetached = !!options.detached;
                    return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
                }
                else if (transport === TransportKind.pipe) {
                    return (0, node_1.createClientPipeTransport)(pipeName).then((transport) => {
                        const serverProcess = cp.spawn(command.command, args, options);
                        if (!serverProcess || !serverProcess.pid) {
                            return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        this._isDetached = !!options.detached;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        return transport.onConnected().then((protocol) => {
                            return { reader: protocol[0], writer: protocol[1] };
                        });
                    });
                }
                else if (Transport.isSocket(transport)) {
                    return (0, node_1.createClientSocketTransport)(transport.port).then((transport) => {
                        const serverProcess = cp.spawn(command.command, args, options);
                        if (!serverProcess || !serverProcess.pid) {
                            return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        this._isDetached = !!options.detached;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        return transport.onConnected().then((protocol) => {
                            return { reader: protocol[0], writer: protocol[1] };
                        });
                    });
                }
            }
            return Promise.reject(new Error(`Unsupported server configuration ` + JSON.stringify(server, null, 4)));
        });
    }
    _getRuntimePath(runtime, serverWorkingDirectory) {
        if (path.isAbsolute(runtime)) {
            return runtime;
        }
        const mainRootPath = this._mainGetRootPath();
        if (mainRootPath !== undefined) {
            const result = path.join(mainRootPath, runtime);
            if (fs.existsSync(result)) {
                return result;
            }
        }
        if (serverWorkingDirectory !== undefined) {
            const result = path.join(serverWorkingDirectory, runtime);
            if (fs.existsSync(result)) {
                return result;
            }
        }
        return runtime;
    }
    _mainGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (!cwd) {
            cwd = this.clientOptions.workspaceFolder
                ? this.clientOptions.workspaceFolder.uri.fsPath
                : this._mainGetRootPath();
        }
        if (cwd) {
            // make sure the folder exists otherwise creating the process will fail
            return new Promise(s => {
                fs.lstat(cwd, (err, stats) => {
                    s(!err && stats.isDirectory() ? cwd : undefined);
                });
            });
        }
        return Promise.resolve(undefined);
    }
    getLocale() {
        const envValue = process.env['VSCODE_NLS_CONFIG'];
        if (envValue === undefined) {
            return 'en';
        }
        let config = undefined;
        try {
            config = JSON.parse(envValue);
        }
        catch (err) {
        }
        if (config === undefined || typeof config.locale !== 'string') {
            return 'en';
        }
        return config.locale;
    }
}
exports.LanguageClient = LanguageClient;
class SettingMonitor {
    constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    start() {
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(() => {
            if (this._client.needsStop()) {
                void this._client.stop();
            }
        });
    }
    onDidChangeConfiguration() {
        let index = this._setting.indexOf('.');
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        let enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start().catch((error) => this._client.error('Start failed after configuration change', error, 'force'));
        }
        else if (!enabled && this._client.needsStop()) {
            void this._client.stop().catch((error) => this._client.error('Stop failed after configuration change', error, 'force'));
        }
    }
}
exports.SettingMonitor = SettingMonitor;
function handleChildProcessStartError(process, message) {
    if (process === null) {
        return Promise.reject(message);
    }
    return new Promise((_, reject) => {
        process.on('error', (err) => {
            reject(`${message} ${err}`);
        });
        // the error event should always be run immediately,
        // but race on it just in case
        setImmediate(() => reject(message));
    });
}
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/node/processes.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/node/processes.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.terminate = void 0;
const cp = __webpack_require__(/*! child_process */ "child_process");
const path_1 = __webpack_require__(/*! path */ "path");
const isWindows = (process.platform === 'win32');
const isMacintosh = (process.platform === 'darwin');
const isLinux = (process.platform === 'linux');
function terminate(process, cwd) {
    if (isWindows) {
        try {
            // This we run in Atom execFileSync is available.
            // Ignore stderr since this is otherwise piped to parent.stderr
            // which might be already closed.
            let options = {
                stdio: ['pipe', 'pipe', 'ignore']
            };
            if (cwd) {
                options.cwd = cwd;
            }
            cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    else if (isLinux || isMacintosh) {
        try {
            var cmd = (0, path_1.join)(__dirname, 'terminateProcess.sh');
            var result = cp.spawnSync(cmd, [process.pid.toString()]);
            return result.error ? false : true;
        }
        catch (err) {
            return false;
        }
    }
    else {
        process.kill('SIGKILL');
        return true;
    }
}
exports.terminate = terminate;
//# sourceMappingURL=processes.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/node.js":
/*!****************************************************!*\
  !*** ./node_modules/vscode-languageclient/node.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "./node_modules/vscode-languageclient/lib/node/main.js");

/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/classes/comparator.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/classes/comparator.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    comp = comp.trim().split(/\s+/).join(' ')
    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    options = parseOptions(options)

    // Special cases where nothing can possibly be lower
    if (options.includePrerelease &&
      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
      return false
    }
    if (!options.includePrerelease &&
      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
      return false
    }

    // Same direction increasing (> or >=)
    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
      return true
    }
    // Same direction decreasing (< or <=)
    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
      return true
    }
    // same SemVer and both sides are inclusive (<= or >=)
    if (
      (this.semver.version === comp.semver.version) &&
      this.operator.includes('=') && comp.operator.includes('=')) {
      return true
    }
    // opposite directions less than
    if (cmp(this.semver, '<', comp.semver, options) &&
      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
      return true
    }
    // opposite directions greater than
    if (cmp(this.semver, '>', comp.semver, options) &&
      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
      return true
    }
    return false
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/vscode-languageclient/node_modules/semver/internal/parse-options.js")
const { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/vscode-languageclient/node_modules/semver/internal/re.js")
const cmp = __webpack_require__(/*! ../functions/cmp */ "./node_modules/vscode-languageclient/node_modules/semver/functions/cmp.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/vscode-languageclient/node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/vscode-languageclient/node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ./range */ "./node_modules/vscode-languageclient/node_modules/semver/classes/range.js")


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/classes/range.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/classes/range.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First reduce all whitespace as much as possible so we do not have to rely
    // on potentially slow regexes like \s*. This is then stored and used for
    // future error messages as well.
    this.raw = range
      .trim()
      .split(/\s+/)
      .join(' ')

    // First, split on ||
    this.set = this.raw
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => comps.join(' ').trim())
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts =
      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
      (this.options.loose && FLAG_LOOSE)
    const memoKey = memoOpts + ':' + range
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)

    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)
    debug('tilde trim', range)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)
    debug('caret trim', range)

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}

module.exports = Range

const LRU = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js")
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/vscode-languageclient/node_modules/semver/internal/parse-options.js")
const Comparator = __webpack_require__(/*! ./comparator */ "./node_modules/vscode-languageclient/node_modules/semver/classes/comparator.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/vscode-languageclient/node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/vscode-languageclient/node_modules/semver/classes/semver.js")
const {
  safeRe: re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = __webpack_require__(/*! ../internal/re */ "./node_modules/vscode-languageclient/node_modules/semver/internal/re.js")
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__(/*! ../internal/constants */ "./node_modules/vscode-languageclient/node_modules/semver/internal/constants.js")

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceTilde(c, options))
    .join(' ')
}

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceCaret(c, options))
    .join(' ')
}

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp
    .split(/\s+/)
    .map((c) => replaceXRange(c, options))
    .join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp
    .trim()
    .replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp
    .trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return `${from} ${to}`.trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/classes/semver.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/classes/semver.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/vscode-languageclient/node_modules/semver/internal/debug.js")
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ "./node_modules/vscode-languageclient/node_modules/semver/internal/constants.js")
const { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/vscode-languageclient/node_modules/semver/internal/re.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/vscode-languageclient/node_modules/semver/internal/parse-options.js")
const { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ "./node_modules/vscode-languageclient/node_modules/semver/internal/identifiers.js")
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier, identifierBase)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier, identifierBase)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier, identifierBase)
        this.inc('pre', identifier, identifierBase)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase)
        }
        this.inc('pre', identifier, identifierBase)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0

        if (!identifier && identifierBase === false) {
          throw new Error('invalid increment argument: identifier is empty')
        }

        if (this.prerelease.length === 0) {
          this.prerelease = [base]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base]
          if (identifierBase === false) {
            prerelease = [identifier]
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease
            }
          } else {
            this.prerelease = prerelease
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.raw = this.format()
    if (this.build.length) {
      this.raw += `+${this.build.join('.')}`
    }
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/functions/cmp.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/functions/cmp.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(/*! ./eq */ "./node_modules/vscode-languageclient/node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./neq */ "./node_modules/vscode-languageclient/node_modules/semver/functions/neq.js")
const gt = __webpack_require__(/*! ./gt */ "./node_modules/vscode-languageclient/node_modules/semver/functions/gt.js")
const gte = __webpack_require__(/*! ./gte */ "./node_modules/vscode-languageclient/node_modules/semver/functions/gte.js")
const lt = __webpack_require__(/*! ./lt */ "./node_modules/vscode-languageclient/node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ./lte */ "./node_modules/vscode-languageclient/node_modules/semver/functions/lte.js")

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/functions/compare.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/functions/compare.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/vscode-languageclient/node_modules/semver/classes/semver.js")
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/functions/eq.js":
/*!********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/functions/eq.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/vscode-languageclient/node_modules/semver/functions/compare.js")
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/functions/gt.js":
/*!********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/functions/gt.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/vscode-languageclient/node_modules/semver/functions/compare.js")
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/functions/gte.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/functions/gte.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/vscode-languageclient/node_modules/semver/functions/compare.js")
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/functions/lt.js":
/*!********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/functions/lt.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/vscode-languageclient/node_modules/semver/functions/compare.js")
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/functions/lte.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/functions/lte.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/vscode-languageclient/node_modules/semver/functions/compare.js")
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/functions/neq.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/functions/neq.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/vscode-languageclient/node_modules/semver/functions/compare.js")
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/functions/parse.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/functions/parse.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/vscode-languageclient/node_modules/semver/classes/semver.js")
const parse = (version, options, throwErrors = false) => {
  if (version instanceof SemVer) {
    return version
  }
  try {
    return new SemVer(version, options)
  } catch (er) {
    if (!throwErrors) {
      return null
    }
    throw er
  }
}

module.exports = parse


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/functions/satisfies.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/functions/satisfies.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/vscode-languageclient/node_modules/semver/classes/range.js")
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/internal/constants.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/internal/constants.js ***!
  \**************************************************************************************/
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
]

module.exports = {
  MAX_LENGTH,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
}


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/internal/debug.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/internal/debug.js ***!
  \**********************************************************************************/
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/internal/identifiers.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/internal/identifiers.js ***!
  \****************************************************************************************/
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/internal/parse-options.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/internal/parse-options.js ***!
  \******************************************************************************************/
/***/ ((module) => {

// parse out just the options we care about
const looseOption = Object.freeze({ loose: true })
const emptyOpts = Object.freeze({ })
const parseOptions = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
}
module.exports = parseOptions


/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/internal/re.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/internal/re.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

const {
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_LENGTH,
} = __webpack_require__(/*! ./constants */ "./node_modules/vscode-languageclient/node_modules/semver/internal/constants.js")
const debug = __webpack_require__(/*! ./debug */ "./node_modules/vscode-languageclient/node_modules/semver/internal/debug.js")
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const safeRe = exports.safeRe = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const LETTERDASHNUMBER = '[a-zA-Z0-9-]'

// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
  ['\\s', 1],
  ['\\d', MAX_LENGTH],
  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
]

const makeSafeRegex = (value) => {
  for (const [token, max] of safeRegexReplacements) {
    value = value
      .split(`${token}*`).join(`${token}{0,${max}}`)
      .split(`${token}+`).join(`${token}{1,${max}}`)
  }
  return value
}

const createToken = (name, value, isGlobal) => {
  const safe = makeSafeRegex(value)
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '\\d+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCEPLAIN', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)
createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`)
createToken('COERCEFULL', src[t.COERCEPLAIN] +
              `(?:${src[t.PRERELEASE]})?` +
              `(?:${src[t.BUILD]})?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)
createToken('COERCERTLFULL', src[t.COERCEFULL], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')


/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/browser.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/browser/main */ "./node_modules/vscode-languageserver-protocol/lib/browser/main.js");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/browser/main.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/browser/main.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const browser_1 = __webpack_require__(/*! vscode-jsonrpc/browser */ "./node_modules/vscode-jsonrpc/browser.js");
__exportStar(__webpack_require__(/*! vscode-jsonrpc/browser */ "./node_modules/vscode-jsonrpc/browser.js"), exports);
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-languageserver-protocol/lib/common/api.js"), exports);
function createProtocolConnection(reader, writer, logger, options) {
    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/api.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/api.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
__exportStar(__webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js"), exports);
__exportStar(__webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/esm/main.js"), exports);
__exportStar(__webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js"), exports);
__exportStar(__webpack_require__(/*! ./protocol */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.js"), exports);
var connection_1 = __webpack_require__(/*! ./connection */ "./node_modules/vscode-languageserver-protocol/lib/common/connection.js");
Object.defineProperty(exports, "createProtocolConnection", ({ enumerable: true, get: function () { return connection_1.createProtocolConnection; } }));
var LSPErrorCodes;
(function (LSPErrorCodes) {
    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.RequestFailed = -32803;
    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.ServerCancelled = -32802;
    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */
    LSPErrorCodes.ContentModified = -32801;
    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */
    LSPErrorCodes.RequestCancelled = -32800;
    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
})(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/connection.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/connection.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/messages.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
var MessageDirection;
(function (MessageDirection) {
    MessageDirection["clientToServer"] = "clientToServer";
    MessageDirection["serverToClient"] = "serverToClient";
    MessageDirection["both"] = "both";
})(MessageDirection = exports.MessageDirection || (exports.MessageDirection = {}));
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
exports.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
//# sourceMappingURL=protocol.callHierarchy.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.method = 'textDocument/colorPresentation';
    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
//# sourceMappingURL=protocol.colorProvider.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
//---- Get Configuration request ----
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.method = 'workspace/configuration';
    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
//# sourceMappingURL=protocol.configuration.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
//# sourceMappingURL=protocol.declaration.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * @since 3.17.0
 */
var DiagnosticServerCancellationData;
(function (DiagnosticServerCancellationData) {
    function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
    }
    DiagnosticServerCancellationData.is = is;
})(DiagnosticServerCancellationData = exports.DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = {}));
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticReportKind;
(function (DocumentDiagnosticReportKind) {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    DocumentDiagnosticReportKind.Full = 'full';
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    DocumentDiagnosticReportKind.Unchanged = 'unchanged';
})(DocumentDiagnosticReportKind = exports.DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = {}));
/**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticRequest;
(function (DocumentDiagnosticRequest) {
    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(DocumentDiagnosticRequest = exports.DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = {}));
/**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */
var WorkspaceDiagnosticRequest;
(function (WorkspaceDiagnosticRequest) {
    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceDiagnosticRequest = exports.WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = {}));
/**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */
var DiagnosticRefreshRequest;
(function (DiagnosticRefreshRequest) {
    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
})(DiagnosticRefreshRequest = exports.DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = {}));
//# sourceMappingURL=protocol.diagnostic.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
//# sourceMappingURL=protocol.fileOperations.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
//# sourceMappingURL=protocol.foldingRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
//# sourceMappingURL=protocol.implementation.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type [InlayHintsParams](#InlayHintsParams), the response is of type
 * [InlayHint[]](#InlayHint[]) or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintRequest;
(function (InlayHintRequest) {
    InlayHintRequest.method = 'textDocument/inlayHint';
    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
})(InlayHintRequest = exports.InlayHintRequest || (exports.InlayHintRequest = {}));
/**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type [InlayHint](#InlayHint), the response is
 * of type [InlayHint](#InlayHint) or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintResolveRequest;
(function (InlayHintResolveRequest) {
    InlayHintResolveRequest.method = 'inlayHint/resolve';
    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
})(InlayHintResolveRequest = exports.InlayHintResolveRequest || (exports.InlayHintResolveRequest = {}));
/**
 * @since 3.17.0
 */
var InlayHintRefreshRequest;
(function (InlayHintRefreshRequest) {
    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
})(InlayHintRefreshRequest = exports.InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = {}));
//# sourceMappingURL=protocol.inlayHint.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide inline values in a document. The request's parameter is of
 * type [InlineValueParams](#InlineValueParams), the response is of type
 * [InlineValue[]](#InlineValue[]) or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlineValueRequest;
(function (InlineValueRequest) {
    InlineValueRequest.method = 'textDocument/inlineValue';
    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
})(InlineValueRequest = exports.InlineValueRequest || (exports.InlineValueRequest = {}));
/**
 * @since 3.17.0
 */
var InlineValueRefreshRequest;
(function (InlineValueRefreshRequest) {
    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
})(InlineValueRefreshRequest = exports.InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = {}));
//# sourceMappingURL=protocol.inlineValue.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/esm/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const protocol_implementation_1 = __webpack_require__(/*! ./protocol.implementation */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js");
Object.defineProperty(exports, "ImplementationRequest", ({ enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } }));
const protocol_typeDefinition_1 = __webpack_require__(/*! ./protocol.typeDefinition */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js");
Object.defineProperty(exports, "TypeDefinitionRequest", ({ enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } }));
const protocol_workspaceFolder_1 = __webpack_require__(/*! ./protocol.workspaceFolder */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js");
Object.defineProperty(exports, "WorkspaceFoldersRequest", ({ enumerable: true, get: function () { return protocol_workspaceFolder_1.WorkspaceFoldersRequest; } }));
Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", ({ enumerable: true, get: function () { return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification; } }));
const protocol_configuration_1 = __webpack_require__(/*! ./protocol.configuration */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js");
Object.defineProperty(exports, "ConfigurationRequest", ({ enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } }));
const protocol_colorProvider_1 = __webpack_require__(/*! ./protocol.colorProvider */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js");
Object.defineProperty(exports, "DocumentColorRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } }));
Object.defineProperty(exports, "ColorPresentationRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } }));
const protocol_foldingRange_1 = __webpack_require__(/*! ./protocol.foldingRange */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js");
Object.defineProperty(exports, "FoldingRangeRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } }));
const protocol_declaration_1 = __webpack_require__(/*! ./protocol.declaration */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js");
Object.defineProperty(exports, "DeclarationRequest", ({ enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } }));
const protocol_selectionRange_1 = __webpack_require__(/*! ./protocol.selectionRange */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js");
Object.defineProperty(exports, "SelectionRangeRequest", ({ enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } }));
const protocol_progress_1 = __webpack_require__(/*! ./protocol.progress */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js");
Object.defineProperty(exports, "WorkDoneProgress", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } }));
Object.defineProperty(exports, "WorkDoneProgressCreateRequest", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } }));
Object.defineProperty(exports, "WorkDoneProgressCancelNotification", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } }));
const protocol_callHierarchy_1 = __webpack_require__(/*! ./protocol.callHierarchy */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js");
Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } }));
const protocol_semanticTokens_1 = __webpack_require__(/*! ./protocol.semanticTokens */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js");
Object.defineProperty(exports, "TokenFormat", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } }));
Object.defineProperty(exports, "SemanticTokensRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } }));
Object.defineProperty(exports, "SemanticTokensDeltaRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } }));
Object.defineProperty(exports, "SemanticTokensRangeRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } }));
Object.defineProperty(exports, "SemanticTokensRefreshRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } }));
Object.defineProperty(exports, "SemanticTokensRegistrationType", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } }));
const protocol_showDocument_1 = __webpack_require__(/*! ./protocol.showDocument */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js");
Object.defineProperty(exports, "ShowDocumentRequest", ({ enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } }));
const protocol_linkedEditingRange_1 = __webpack_require__(/*! ./protocol.linkedEditingRange */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js");
Object.defineProperty(exports, "LinkedEditingRangeRequest", ({ enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } }));
const protocol_fileOperations_1 = __webpack_require__(/*! ./protocol.fileOperations */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js");
Object.defineProperty(exports, "FileOperationPatternKind", ({ enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } }));
Object.defineProperty(exports, "DidCreateFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } }));
Object.defineProperty(exports, "WillCreateFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } }));
Object.defineProperty(exports, "DidRenameFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } }));
Object.defineProperty(exports, "WillRenameFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } }));
Object.defineProperty(exports, "DidDeleteFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } }));
Object.defineProperty(exports, "WillDeleteFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } }));
const protocol_moniker_1 = __webpack_require__(/*! ./protocol.moniker */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js");
Object.defineProperty(exports, "UniquenessLevel", ({ enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } }));
Object.defineProperty(exports, "MonikerKind", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } }));
Object.defineProperty(exports, "MonikerRequest", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } }));
const protocol_typeHierarchy_1 = __webpack_require__(/*! ./protocol.typeHierarchy */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js");
Object.defineProperty(exports, "TypeHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest; } }));
Object.defineProperty(exports, "TypeHierarchySubtypesRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest; } }));
Object.defineProperty(exports, "TypeHierarchySupertypesRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest; } }));
const protocol_inlineValue_1 = __webpack_require__(/*! ./protocol.inlineValue */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js");
Object.defineProperty(exports, "InlineValueRequest", ({ enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRequest; } }));
Object.defineProperty(exports, "InlineValueRefreshRequest", ({ enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRefreshRequest; } }));
const protocol_inlayHint_1 = __webpack_require__(/*! ./protocol.inlayHint */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js");
Object.defineProperty(exports, "InlayHintRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRequest; } }));
Object.defineProperty(exports, "InlayHintResolveRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintResolveRequest; } }));
Object.defineProperty(exports, "InlayHintRefreshRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRefreshRequest; } }));
const protocol_diagnostic_1 = __webpack_require__(/*! ./protocol.diagnostic */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js");
Object.defineProperty(exports, "DiagnosticServerCancellationData", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticServerCancellationData; } }));
Object.defineProperty(exports, "DocumentDiagnosticReportKind", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticReportKind; } }));
Object.defineProperty(exports, "DocumentDiagnosticRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticRequest; } }));
Object.defineProperty(exports, "WorkspaceDiagnosticRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.WorkspaceDiagnosticRequest; } }));
Object.defineProperty(exports, "DiagnosticRefreshRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticRefreshRequest; } }));
const protocol_notebook_1 = __webpack_require__(/*! ./protocol.notebook */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js");
Object.defineProperty(exports, "NotebookCellKind", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCellKind; } }));
Object.defineProperty(exports, "ExecutionSummary", ({ enumerable: true, get: function () { return protocol_notebook_1.ExecutionSummary; } }));
Object.defineProperty(exports, "NotebookCell", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCell; } }));
Object.defineProperty(exports, "NotebookDocument", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookDocument; } }));
Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookDocumentSyncRegistrationType; } }));
Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidOpenNotebookDocumentNotification; } }));
Object.defineProperty(exports, "NotebookCellArrayChange", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCellArrayChange; } }));
Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidChangeNotebookDocumentNotification; } }));
Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidSaveNotebookDocumentNotification; } }));
Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidCloseNotebookDocumentNotification; } }));
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * The TextDocumentFilter namespace provides helper functions to work with
 * [TextDocumentFilter](#TextDocumentFilter) literals.
 *
 * @since 3.17.0
 */
var TextDocumentFilter;
(function (TextDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    TextDocumentFilter.is = is;
})(TextDocumentFilter = exports.TextDocumentFilter || (exports.TextDocumentFilter = {}));
/**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * [NotebookDocumentFilter](#NotebookDocumentFilter) literals.
 *
 * @since 3.17.0
 */
var NotebookDocumentFilter;
(function (NotebookDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
    }
    NotebookDocumentFilter.is = is;
})(NotebookDocumentFilter = exports.NotebookDocumentFilter || (exports.NotebookDocumentFilter = {}));
/**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * [NotebookCellTextDocumentFilter](#NotebookCellTextDocumentFilter) literals.
 *
 * @since 3.17.0
 */
var NotebookCellTextDocumentFilter;
(function (NotebookCellTextDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate)
            && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook))
            && (candidate.language === undefined || Is.string(candidate.language));
    }
    NotebookCellTextDocumentFilter.is = is;
})(NotebookCellTextDocumentFilter = exports.NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.method = 'client/registerCapability';
    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.method = 'client/unregisterCapability';
    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */
var PositionEncodingKind;
(function (PositionEncodingKind) {
    /**
     * Character offsets count UTF-8 code units.
     */
    PositionEncodingKind.UTF8 = 'utf-8';
    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */
    PositionEncodingKind.UTF16 = 'utf-16';
    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode code points,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */
    PositionEncodingKind.UTF32 = 'utf-32';
})(PositionEncodingKind = exports.PositionEncodingKind || (exports.PositionEncodingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.method = 'initialize';
    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeErrorCodes`;
 */
var InitializeErrorCodes;
(function (InitializeErrorCodes) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeErrorCodes.unknownProtocolVersion = 1;
})(InitializeErrorCodes = exports.InitializeErrorCodes || (exports.InitializeErrorCodes = {}));
/**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.method = 'initialized';
    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.method = 'shutdown';
    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.method = 'exit';
    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.method = 'window/showMessage';
    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.method = 'window/showMessageRequest';
    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.method = 'window/logMessage';
    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.method = 'telemetry/event';
    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
var TextDocumentContentChangeEvent;
(function (TextDocumentContentChangeEvent) {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    TextDocumentContentChangeEvent.isIncremental = isIncremental;
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent.isFull = isFull;
})(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var RelativePattern;
(function (RelativePattern) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
    }
    RelativePattern.is = is;
})(RelativePattern = exports.RelativePattern || (exports.RelativePattern = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type [CodeAction](#CodeAction) the response
 * is of type [CodeAction](#CodeAction) or a Thenable that resolves to such.
 */
var CodeActionResolveRequest;
(function (CodeActionResolveRequest) {
    CodeActionResolveRequest.method = 'codeAction/resolve';
    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
})(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */
var WorkspaceSymbolResolveRequest;
(function (WorkspaceSymbolResolveRequest) {
    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
})(WorkspaceSymbolResolveRequest = exports.WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.method = 'textDocument/codeLens';
    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.method = 'codeLens/resolve';
    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */
var CodeLensRefreshRequest;
(function (CodeLensRefreshRequest) {
    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
})(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.method = 'documentLink/resolve';
    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
//---- Rename ----------------------------------------------
var PrepareSupportDefaultBehavior;
(function (PrepareSupportDefaultBehavior) {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    PrepareSupportDefaultBehavior.Identifier = 1;
})(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.method = 'workspace/executeCommand';
    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
//# sourceMappingURL=protocol.linkedEditingRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel.document = 'document';
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel.project = 'project';
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel.group = 'group';
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel.scheme = 'scheme';
    /**
     * The moniker is globally unique
     */
    UniquenessLevel.global = 'global';
})(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind.$import = 'import';
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind.$export = 'export';
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind.local = 'local';
})(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type [TextDocumentPositionParams](#TextDocumentPositionParams).
 * The response is of type [Moniker[]](#Moniker[]) or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
//# sourceMappingURL=protocol.moniker.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/esm/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */
var NotebookCellKind;
(function (NotebookCellKind) {
    /**
     * A markup-cell is formatted source that is used for display.
     */
    NotebookCellKind.Markup = 1;
    /**
     * A code-cell is source code.
     */
    NotebookCellKind.Code = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    NotebookCellKind.is = is;
})(NotebookCellKind = exports.NotebookCellKind || (exports.NotebookCellKind = {}));
var ExecutionSummary;
(function (ExecutionSummary) {
    function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
            result.success = success;
        }
        return result;
    }
    ExecutionSummary.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
    }
    ExecutionSummary.is = is;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
    }
    ExecutionSummary.equals = equals;
})(ExecutionSummary = exports.ExecutionSummary || (exports.ExecutionSummary = {}));
var NotebookCell;
(function (NotebookCell) {
    function create(kind, document) {
        return { kind, document };
    }
    NotebookCell.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) &&
            (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
    }
    NotebookCell.is = is;
    function diff(one, two) {
        const result = new Set();
        if (one.document !== two.document) {
            result.add('document');
        }
        if (one.kind !== two.kind) {
            result.add('kind');
        }
        if (one.executionSummary !== two.executionSummary) {
            result.add('executionSummary');
        }
        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add('metadata');
        }
        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add('executionSummary');
        }
        return result;
    }
    NotebookCell.diff = diff;
    function equalsMetadata(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
            return false;
        }
        if (oneArray && otherArray) {
            if (one.length !== other.length) {
                return false;
            }
            for (let i = 0; i < one.length; i++) {
                if (!equalsMetadata(one[i], other[i])) {
                    return false;
                }
            }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
                return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
                return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
                const prop = oneKeys[i];
                if (!equalsMetadata(one[prop], other[prop])) {
                    return false;
                }
            }
        }
        return true;
    }
})(NotebookCell = exports.NotebookCell || (exports.NotebookCell = {}));
var NotebookDocument;
(function (NotebookDocument) {
    function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
    }
    NotebookDocument.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
    }
    NotebookDocument.is = is;
})(NotebookDocument = exports.NotebookDocument || (exports.NotebookDocument = {}));
var NotebookDocumentSyncRegistrationType;
(function (NotebookDocumentSyncRegistrationType) {
    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
})(NotebookDocumentSyncRegistrationType = exports.NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = {}));
/**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */
var DidOpenNotebookDocumentNotification;
(function (DidOpenNotebookDocumentNotification) {
    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidOpenNotebookDocumentNotification = exports.DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = {}));
var NotebookCellArrayChange;
(function (NotebookCellArrayChange) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
    }
    NotebookCellArrayChange.is = is;
    function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== undefined) {
            result.cells = cells;
        }
        return result;
    }
    NotebookCellArrayChange.create = create;
})(NotebookCellArrayChange = exports.NotebookCellArrayChange || (exports.NotebookCellArrayChange = {}));
var DidChangeNotebookDocumentNotification;
(function (DidChangeNotebookDocumentNotification) {
    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidChangeNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */
var DidSaveNotebookDocumentNotification;
(function (DidSaveNotebookDocumentNotification) {
    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidSaveNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */
var DidCloseNotebookDocumentNotification;
(function (DidCloseNotebookDocumentNotification) {
    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidCloseNotebookDocumentNotification = exports.DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = {}));
//# sourceMappingURL=protocol.notebook.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
//# sourceMappingURL=protocol.progress.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
//# sourceMappingURL=protocol.selectionRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
//# sourceMappingURL=protocol.semanticTokens.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
//# sourceMappingURL=protocol.showDocument.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
//# sourceMappingURL=protocol.typeDefinition.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */
var TypeHierarchyPrepareRequest;
(function (TypeHierarchyPrepareRequest) {
    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
})(TypeHierarchyPrepareRequest = exports.TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = {}));
/**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySupertypesRequest;
(function (TypeHierarchySupertypesRequest) {
    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
})(TypeHierarchySupertypesRequest = exports.TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = {}));
/**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySubtypesRequest;
(function (TypeHierarchySubtypesRequest) {
    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
})(TypeHierarchySubtypesRequest = exports.TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = {}));
//# sourceMappingURL=protocol.typeHierarchy.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
//# sourceMappingURL=protocol.workspaceFolder.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/node/main.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/node/main.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const node_1 = __webpack_require__(/*! vscode-jsonrpc/node */ "./node_modules/vscode-jsonrpc/node.js");
__exportStar(__webpack_require__(/*! vscode-jsonrpc/node */ "./node_modules/vscode-jsonrpc/node.js"), exports);
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-languageserver-protocol/lib/common/api.js"), exports);
function createProtocolConnection(input, output, logger, options) {
    return (0, node_1.createMessageConnection)(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/node.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/node.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");

/***/ }),

/***/ "./node_modules/vscode-languageserver-types/lib/esm/main.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnnotatedTextEdit: () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   ChangeAnnotation: () => (/* binding */ ChangeAnnotation),
/* harmony export */   ChangeAnnotationIdentifier: () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   CodeAction: () => (/* binding */ CodeAction),
/* harmony export */   CodeActionContext: () => (/* binding */ CodeActionContext),
/* harmony export */   CodeActionKind: () => (/* binding */ CodeActionKind),
/* harmony export */   CodeActionTriggerKind: () => (/* binding */ CodeActionTriggerKind),
/* harmony export */   CodeDescription: () => (/* binding */ CodeDescription),
/* harmony export */   CodeLens: () => (/* binding */ CodeLens),
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   ColorInformation: () => (/* binding */ ColorInformation),
/* harmony export */   ColorPresentation: () => (/* binding */ ColorPresentation),
/* harmony export */   Command: () => (/* binding */ Command),
/* harmony export */   CompletionItem: () => (/* binding */ CompletionItem),
/* harmony export */   CompletionItemKind: () => (/* binding */ CompletionItemKind),
/* harmony export */   CompletionItemLabelDetails: () => (/* binding */ CompletionItemLabelDetails),
/* harmony export */   CompletionItemTag: () => (/* binding */ CompletionItemTag),
/* harmony export */   CompletionList: () => (/* binding */ CompletionList),
/* harmony export */   CreateFile: () => (/* binding */ CreateFile),
/* harmony export */   DeleteFile: () => (/* binding */ DeleteFile),
/* harmony export */   Diagnostic: () => (/* binding */ Diagnostic),
/* harmony export */   DiagnosticRelatedInformation: () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   DiagnosticSeverity: () => (/* binding */ DiagnosticSeverity),
/* harmony export */   DiagnosticTag: () => (/* binding */ DiagnosticTag),
/* harmony export */   DocumentHighlight: () => (/* binding */ DocumentHighlight),
/* harmony export */   DocumentHighlightKind: () => (/* binding */ DocumentHighlightKind),
/* harmony export */   DocumentLink: () => (/* binding */ DocumentLink),
/* harmony export */   DocumentSymbol: () => (/* binding */ DocumentSymbol),
/* harmony export */   DocumentUri: () => (/* binding */ DocumentUri),
/* harmony export */   EOL: () => (/* binding */ EOL),
/* harmony export */   FoldingRange: () => (/* binding */ FoldingRange),
/* harmony export */   FoldingRangeKind: () => (/* binding */ FoldingRangeKind),
/* harmony export */   FormattingOptions: () => (/* binding */ FormattingOptions),
/* harmony export */   Hover: () => (/* binding */ Hover),
/* harmony export */   InlayHint: () => (/* binding */ InlayHint),
/* harmony export */   InlayHintKind: () => (/* binding */ InlayHintKind),
/* harmony export */   InlayHintLabelPart: () => (/* binding */ InlayHintLabelPart),
/* harmony export */   InlineValueContext: () => (/* binding */ InlineValueContext),
/* harmony export */   InlineValueEvaluatableExpression: () => (/* binding */ InlineValueEvaluatableExpression),
/* harmony export */   InlineValueText: () => (/* binding */ InlineValueText),
/* harmony export */   InlineValueVariableLookup: () => (/* binding */ InlineValueVariableLookup),
/* harmony export */   InsertReplaceEdit: () => (/* binding */ InsertReplaceEdit),
/* harmony export */   InsertTextFormat: () => (/* binding */ InsertTextFormat),
/* harmony export */   InsertTextMode: () => (/* binding */ InsertTextMode),
/* harmony export */   Location: () => (/* binding */ Location),
/* harmony export */   LocationLink: () => (/* binding */ LocationLink),
/* harmony export */   MarkedString: () => (/* binding */ MarkedString),
/* harmony export */   MarkupContent: () => (/* binding */ MarkupContent),
/* harmony export */   MarkupKind: () => (/* binding */ MarkupKind),
/* harmony export */   OptionalVersionedTextDocumentIdentifier: () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   ParameterInformation: () => (/* binding */ ParameterInformation),
/* harmony export */   Position: () => (/* binding */ Position),
/* harmony export */   Range: () => (/* binding */ Range),
/* harmony export */   RenameFile: () => (/* binding */ RenameFile),
/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),
/* harmony export */   SemanticTokenModifiers: () => (/* binding */ SemanticTokenModifiers),
/* harmony export */   SemanticTokenTypes: () => (/* binding */ SemanticTokenTypes),
/* harmony export */   SemanticTokens: () => (/* binding */ SemanticTokens),
/* harmony export */   SignatureInformation: () => (/* binding */ SignatureInformation),
/* harmony export */   SymbolInformation: () => (/* binding */ SymbolInformation),
/* harmony export */   SymbolKind: () => (/* binding */ SymbolKind),
/* harmony export */   SymbolTag: () => (/* binding */ SymbolTag),
/* harmony export */   TextDocument: () => (/* binding */ TextDocument),
/* harmony export */   TextDocumentEdit: () => (/* binding */ TextDocumentEdit),
/* harmony export */   TextDocumentIdentifier: () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   TextDocumentItem: () => (/* binding */ TextDocumentItem),
/* harmony export */   TextEdit: () => (/* binding */ TextEdit),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   VersionedTextDocumentIdentifier: () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   WorkspaceChange: () => (/* binding */ WorkspaceChange),
/* harmony export */   WorkspaceEdit: () => (/* binding */ WorkspaceEdit),
/* harmony export */   WorkspaceFolder: () => (/* binding */ WorkspaceFolder),
/* harmony export */   WorkspaceSymbol: () => (/* binding */ WorkspaceSymbol),
/* harmony export */   integer: () => (/* binding */ integer),
/* harmony export */   uinteger: () => (/* binding */ uinteger)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var DocumentUri;
(function (DocumentUri) {
    function is(value) {
        return typeof value === 'string';
    }
    DocumentUri.is = is;
})(DocumentUri || (DocumentUri = {}));
var URI;
(function (URI) {
    function is(value) {
        return typeof value === 'string';
    }
    URI.is = is;
})(URI || (URI = {}));
var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
    }
    integer.is = is;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
    }
    uinteger.is = is;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && Range.is(candidate.targetSelectionRange)
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * A set of predefined range kinds.
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind.Comment = 'comment';
    /**
     * Folding range for an import or include
     */
    FoldingRangeKind.Imports = 'imports';
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind.Region = 'region';
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return Is.string(candidate);
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id ".concat(id, " is already in use."));
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id ".concat(id));
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function (CompletionItemLabelDetails) {
    function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    CompletionItemLabelDetails.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function (WorkspaceSymbol) {
    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */
    function create(name, kind, uri, range) {
        return range !== undefined
            ? { name: name, kind: kind, location: { uri: uri, range: range } }
            : { name: name, kind: kind, location: { uri: uri } };
    }
    WorkspaceSymbol.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */
var CodeActionTriggerKind;
(function (CodeActionTriggerKind) {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */
    CodeActionTriggerKind.Invoked = 1;
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */
    CodeActionTriggerKind.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only, triggerKind) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        if (triggerKind !== undefined && triggerKind !== null) {
            result.triggerKind = triggerKind;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)
            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))
            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
    /**
     * @since 3.17.0
     */
    SemanticTokenTypes["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens || (SemanticTokens = {}));
/**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */
var InlineValueText;
(function (InlineValueText) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, text) {
        return { range: range, text: text };
    }
    InlineValueText.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
    }
    InlineValueText.is = is;
})(InlineValueText || (InlineValueText = {}));
/**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */
var InlineValueVariableLookup;
(function (InlineValueVariableLookup) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, variableName, caseSensitiveLookup) {
        return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };
    }
    InlineValueVariableLookup.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)
            && (Is.string(candidate.variableName) || candidate.variableName === undefined);
    }
    InlineValueVariableLookup.is = is;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
/**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */
var InlineValueEvaluatableExpression;
(function (InlineValueEvaluatableExpression) {
    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */
    function create(range, expression) {
        return { range: range, expression: expression };
    }
    InlineValueEvaluatableExpression.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range)
            && (Is.string(candidate.expression) || candidate.expression === undefined);
    }
    InlineValueEvaluatableExpression.is = is;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
/**
 * The InlineValueContext namespace provides helper functions to work with
 * [InlineValueContext](#InlineValueContext) literals.
 *
 * @since 3.17.0
 */
var InlineValueContext;
(function (InlineValueContext) {
    /**
     * Creates a new InlineValueContext literal.
     */
    function create(frameId, stoppedLocation) {
        return { frameId: frameId, stoppedLocation: stoppedLocation };
    }
    InlineValueContext.create = create;
    /**
     * Checks whether the given literal conforms to the [InlineValueContext](#InlineValueContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
    }
    InlineValueContext.is = is;
})(InlineValueContext || (InlineValueContext = {}));
/**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */
var InlayHintKind;
(function (InlayHintKind) {
    /**
     * An inlay hint that for a type annotation.
     */
    InlayHintKind.Type = 1;
    /**
     * An inlay hint that is for a parameter.
     */
    InlayHintKind.Parameter = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    InlayHintKind.is = is;
})(InlayHintKind || (InlayHintKind = {}));
var InlayHintLabelPart;
(function (InlayHintLabelPart) {
    function create(value) {
        return { value: value };
    }
    InlayHintLabelPart.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.location === undefined || Location.is(candidate.location))
            && (candidate.command === undefined || Command.is(candidate.command));
    }
    InlayHintLabelPart.is = is;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function (InlayHint) {
    function create(position, label, kind) {
        var result = { position: position, label: label };
        if (kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    InlayHint.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position)
            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))
            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))
            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))
            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
    }
    InlayHint.is = is;
})(InlayHint || (InlayHint = {}));
var WorkspaceFolder;
(function (WorkspaceFolder) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
    }
    WorkspaceFolder.is = is;
})(WorkspaceFolder || (WorkspaceFolder = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),

/***/ "./node_modules/webidl-conversions/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/webidl-conversions/lib/index.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


var conversions = {};
module.exports = conversions;

function sign(x) {
    return x < 0 ? -1 : 1;
}

function evenRound(x) {
    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.
    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)
        return Math.floor(x);
    } else {
        return Math.round(x);
    }
}

function createNumberConversion(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
        --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;

    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);

    return function(V, opts) {
        if (!opts) opts = {};

        let x = +V;

        if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
                throw new TypeError("Argument is not a finite number");
            }

            x = sign(x) * Math.floor(Math.abs(x));
            if (x < lowerBound || x > upperBound) {
                throw new TypeError("Argument is not in byte range");
            }

            return x;
        }

        if (!isNaN(x) && opts.clamp) {
            x = evenRound(x);

            if (x < lowerBound) x = lowerBound;
            if (x > upperBound) x = upperBound;
            return x;
        }

        if (!Number.isFinite(x) || x === 0) {
            return 0;
        }

        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;

        if (!typeOpts.unsigned && x >= moduloBound) {
            return x - moduloVal;
        } else if (typeOpts.unsigned) {
            if (x < 0) {
              x += moduloVal;
            } else if (x === -0) { // don't return negative zero
              return 0;
            }
        }

        return x;
    }
}

conversions["void"] = function () {
    return undefined;
};

conversions["boolean"] = function (val) {
    return !!val;
};

conversions["byte"] = createNumberConversion(8, { unsigned: false });
conversions["octet"] = createNumberConversion(8, { unsigned: true });

conversions["short"] = createNumberConversion(16, { unsigned: false });
conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });

conversions["long"] = createNumberConversion(32, { unsigned: false });
conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });

conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });

conversions["double"] = function (V) {
    const x = +V;

    if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
    }

    return x;
};

conversions["unrestricted double"] = function (V) {
    const x = +V;

    if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
    }

    return x;
};

// not quite valid, but good enough for JS
conversions["float"] = conversions["double"];
conversions["unrestricted float"] = conversions["unrestricted double"];

conversions["DOMString"] = function (V, opts) {
    if (!opts) opts = {};

    if (opts.treatNullAsEmptyString && V === null) {
        return "";
    }

    return String(V);
};

conversions["ByteString"] = function (V, opts) {
    const x = String(V);
    let c = undefined;
    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {
        if (c > 255) {
            throw new TypeError("Argument is not a valid bytestring");
        }
    }

    return x;
};

conversions["USVString"] = function (V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 0xD800 || c > 0xDFFF) {
            U.push(String.fromCodePoint(c));
        } else if (0xDC00 <= c && c <= 0xDFFF) {
            U.push(String.fromCodePoint(0xFFFD));
        } else {
            if (i === n - 1) {
                U.push(String.fromCodePoint(0xFFFD));
            } else {
                const d = S.charCodeAt(i + 1);
                if (0xDC00 <= d && d <= 0xDFFF) {
                    const a = c & 0x3FF;
                    const b = d & 0x3FF;
                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                    ++i;
                } else {
                    U.push(String.fromCodePoint(0xFFFD));
                }
            }
        }
    }

    return U.join('');
};

conversions["Date"] = function (V, opts) {
    if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
        return undefined;
    }

    return V;
};

conversions["RegExp"] = function (V, opts) {
    if (!(V instanceof RegExp)) {
        V = new RegExp(V);
    }

    return V;
};


/***/ }),

/***/ "./node_modules/whatwg-url/lib/URL-impl.js":
/*!*************************************************!*\
  !*** ./node_modules/whatwg-url/lib/URL-impl.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const usm = __webpack_require__(/*! ./url-state-machine */ "./node_modules/whatwg-url/lib/url-state-machine.js");

exports.implementation = class URLImpl {
  constructor(constructorArgs) {
    const url = constructorArgs[0];
    const base = constructorArgs[1];

    let parsedBase = null;
    if (base !== undefined) {
      parsedBase = usm.basicURLParse(base);
      if (parsedBase === "failure") {
        throw new TypeError("Invalid base URL");
      }
    }

    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
    if (parsedURL === "failure") {
      throw new TypeError("Invalid URL");
    }

    this._url = parsedURL;

    // TODO: query stuff
  }

  get href() {
    return usm.serializeURL(this._url);
  }

  set href(v) {
    const parsedURL = usm.basicURLParse(v);
    if (parsedURL === "failure") {
      throw new TypeError("Invalid URL");
    }

    this._url = parsedURL;
  }

  get origin() {
    return usm.serializeURLOrigin(this._url);
  }

  get protocol() {
    return this._url.scheme + ":";
  }

  set protocol(v) {
    usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
  }

  get username() {
    return this._url.username;
  }

  set username(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    usm.setTheUsername(this._url, v);
  }

  get password() {
    return this._url.password;
  }

  set password(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    usm.setThePassword(this._url, v);
  }

  get host() {
    const url = this._url;

    if (url.host === null) {
      return "";
    }

    if (url.port === null) {
      return usm.serializeHost(url.host);
    }

    return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
  }

  set host(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
  }

  get hostname() {
    if (this._url.host === null) {
      return "";
    }

    return usm.serializeHost(this._url.host);
  }

  set hostname(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
  }

  get port() {
    if (this._url.port === null) {
      return "";
    }

    return usm.serializeInteger(this._url.port);
  }

  set port(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    if (v === "") {
      this._url.port = null;
    } else {
      usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
    }
  }

  get pathname() {
    if (this._url.cannotBeABaseURL) {
      return this._url.path[0];
    }

    if (this._url.path.length === 0) {
      return "";
    }

    return "/" + this._url.path.join("/");
  }

  set pathname(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    this._url.path = [];
    usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
  }

  get search() {
    if (this._url.query === null || this._url.query === "") {
      return "";
    }

    return "?" + this._url.query;
  }

  set search(v) {
    // TODO: query stuff

    const url = this._url;

    if (v === "") {
      url.query = null;
      return;
    }

    const input = v[0] === "?" ? v.substring(1) : v;
    url.query = "";
    usm.basicURLParse(input, { url, stateOverride: "query" });
  }

  get hash() {
    if (this._url.fragment === null || this._url.fragment === "") {
      return "";
    }

    return "#" + this._url.fragment;
  }

  set hash(v) {
    if (v === "") {
      this._url.fragment = null;
      return;
    }

    const input = v[0] === "#" ? v.substring(1) : v;
    this._url.fragment = "";
    usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
  }

  toJSON() {
    return this.href;
  }
};


/***/ }),

/***/ "./node_modules/whatwg-url/lib/URL.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-url/lib/URL.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const conversions = __webpack_require__(/*! webidl-conversions */ "./node_modules/webidl-conversions/lib/index.js");
const utils = __webpack_require__(/*! ./utils.js */ "./node_modules/whatwg-url/lib/utils.js");
const Impl = __webpack_require__(/*! .//URL-impl.js */ "./node_modules/whatwg-url/lib/URL-impl.js");

const impl = utils.implSymbol;

function URL(url) {
  if (!this || this[impl] || !(this instanceof URL)) {
    throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
  }
  const args = [];
  for (let i = 0; i < arguments.length && i < 2; ++i) {
    args[i] = arguments[i];
  }
  args[0] = conversions["USVString"](args[0]);
  if (args[1] !== undefined) {
  args[1] = conversions["USVString"](args[1]);
  }

  module.exports.setup(this, args);
}

URL.prototype.toJSON = function toJSON() {
  if (!this || !module.exports.is(this)) {
    throw new TypeError("Illegal invocation");
  }
  const args = [];
  for (let i = 0; i < arguments.length && i < 0; ++i) {
    args[i] = arguments[i];
  }
  return this[impl].toJSON.apply(this[impl], args);
};
Object.defineProperty(URL.prototype, "href", {
  get() {
    return this[impl].href;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].href = V;
  },
  enumerable: true,
  configurable: true
});

URL.prototype.toString = function () {
  if (!this || !module.exports.is(this)) {
    throw new TypeError("Illegal invocation");
  }
  return this.href;
};

Object.defineProperty(URL.prototype, "origin", {
  get() {
    return this[impl].origin;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "protocol", {
  get() {
    return this[impl].protocol;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].protocol = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "username", {
  get() {
    return this[impl].username;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].username = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "password", {
  get() {
    return this[impl].password;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].password = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "host", {
  get() {
    return this[impl].host;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].host = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "hostname", {
  get() {
    return this[impl].hostname;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].hostname = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "port", {
  get() {
    return this[impl].port;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].port = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "pathname", {
  get() {
    return this[impl].pathname;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].pathname = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "search", {
  get() {
    return this[impl].search;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].search = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "hash", {
  get() {
    return this[impl].hash;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].hash = V;
  },
  enumerable: true,
  configurable: true
});


module.exports = {
  is(obj) {
    return !!obj && obj[impl] instanceof Impl.implementation;
  },
  create(constructorArgs, privateData) {
    let obj = Object.create(URL.prototype);
    this.setup(obj, constructorArgs, privateData);
    return obj;
  },
  setup(obj, constructorArgs, privateData) {
    if (!privateData) privateData = {};
    privateData.wrapper = obj;

    obj[impl] = new Impl.implementation(constructorArgs, privateData);
    obj[impl][utils.wrapperSymbol] = obj;
  },
  interface: URL,
  expose: {
    Window: { URL: URL },
    Worker: { URL: URL }
  }
};



/***/ }),

/***/ "./node_modules/whatwg-url/lib/public-api.js":
/*!***************************************************!*\
  !*** ./node_modules/whatwg-url/lib/public-api.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.URL = __webpack_require__(/*! ./URL */ "./node_modules/whatwg-url/lib/URL.js")["interface"];
exports.serializeURL = __webpack_require__(/*! ./url-state-machine */ "./node_modules/whatwg-url/lib/url-state-machine.js").serializeURL;
exports.serializeURLOrigin = __webpack_require__(/*! ./url-state-machine */ "./node_modules/whatwg-url/lib/url-state-machine.js").serializeURLOrigin;
exports.basicURLParse = __webpack_require__(/*! ./url-state-machine */ "./node_modules/whatwg-url/lib/url-state-machine.js").basicURLParse;
exports.setTheUsername = __webpack_require__(/*! ./url-state-machine */ "./node_modules/whatwg-url/lib/url-state-machine.js").setTheUsername;
exports.setThePassword = __webpack_require__(/*! ./url-state-machine */ "./node_modules/whatwg-url/lib/url-state-machine.js").setThePassword;
exports.serializeHost = __webpack_require__(/*! ./url-state-machine */ "./node_modules/whatwg-url/lib/url-state-machine.js").serializeHost;
exports.serializeInteger = __webpack_require__(/*! ./url-state-machine */ "./node_modules/whatwg-url/lib/url-state-machine.js").serializeInteger;
exports.parseURL = __webpack_require__(/*! ./url-state-machine */ "./node_modules/whatwg-url/lib/url-state-machine.js").parseURL;


/***/ }),

/***/ "./node_modules/whatwg-url/lib/url-state-machine.js":
/*!**********************************************************!*\
  !*** ./node_modules/whatwg-url/lib/url-state-machine.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];

const punycode = __webpack_require__(/*! punycode */ "punycode");
const tr46 = __webpack_require__(/*! tr46 */ "./node_modules/tr46/index.js");

const specialSchemes = {
  ftp: 21,
  file: null,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

const failure = Symbol("failure");

function countSymbols(str) {
  return punycode.ucs2.decode(str).length;
}

function at(input, idx) {
  const c = input[idx];
  return isNaN(c) ? undefined : String.fromCodePoint(c);
}

function isASCIIDigit(c) {
  return c >= 0x30 && c <= 0x39;
}

function isASCIIAlpha(c) {
  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);
}

function isASCIIAlphanumeric(c) {
  return isASCIIAlpha(c) || isASCIIDigit(c);
}

function isASCIIHex(c) {
  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);
}

function isSingleDot(buffer) {
  return buffer === "." || buffer.toLowerCase() === "%2e";
}

function isDoubleDot(buffer) {
  buffer = buffer.toLowerCase();
  return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
}

function isWindowsDriveLetterCodePoints(cp1, cp2) {
  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
}

function isWindowsDriveLetterString(string) {
  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
}

function isNormalizedWindowsDriveLetterString(string) {
  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
}

function containsForbiddenHostCodePoint(string) {
  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
}

function containsForbiddenHostCodePointExcludingPercent(string) {
  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
}

function isSpecialScheme(scheme) {
  return specialSchemes[scheme] !== undefined;
}

function isSpecial(url) {
  return isSpecialScheme(url.scheme);
}

function defaultPort(scheme) {
  return specialSchemes[scheme];
}

function percentEncode(c) {
  let hex = c.toString(16).toUpperCase();
  if (hex.length === 1) {
    hex = "0" + hex;
  }

  return "%" + hex;
}

function utf8PercentEncode(c) {
  const buf = new Buffer(c);

  let str = "";

  for (let i = 0; i < buf.length; ++i) {
    str += percentEncode(buf[i]);
  }

  return str;
}

function utf8PercentDecode(str) {
  const input = new Buffer(str);
  const output = [];
  for (let i = 0; i < input.length; ++i) {
    if (input[i] !== 37) {
      output.push(input[i]);
    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
      i += 2;
    } else {
      output.push(input[i]);
    }
  }
  return new Buffer(output).toString();
}

function isC0ControlPercentEncode(c) {
  return c <= 0x1F || c > 0x7E;
}

const extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
function isPathPercentEncode(c) {
  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
}

const extraUserinfoPercentEncodeSet =
  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
function isUserinfoPercentEncode(c) {
  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
}

function percentEncodeChar(c, encodeSetPredicate) {
  const cStr = String.fromCodePoint(c);

  if (encodeSetPredicate(c)) {
    return utf8PercentEncode(cStr);
  }

  return cStr;
}

function parseIPv4Number(input) {
  let R = 10;

  if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
    input = input.substring(2);
    R = 16;
  } else if (input.length >= 2 && input.charAt(0) === "0") {
    input = input.substring(1);
    R = 8;
  }

  if (input === "") {
    return 0;
  }

  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);
  if (regex.test(input)) {
    return failure;
  }

  return parseInt(input, R);
}

function parseIPv4(input) {
  const parts = input.split(".");
  if (parts[parts.length - 1] === "") {
    if (parts.length > 1) {
      parts.pop();
    }
  }

  if (parts.length > 4) {
    return input;
  }

  const numbers = [];
  for (const part of parts) {
    if (part === "") {
      return input;
    }
    const n = parseIPv4Number(part);
    if (n === failure) {
      return input;
    }

    numbers.push(n);
  }

  for (let i = 0; i < numbers.length - 1; ++i) {
    if (numbers[i] > 255) {
      return failure;
    }
  }
  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
    return failure;
  }

  let ipv4 = numbers.pop();
  let counter = 0;

  for (const n of numbers) {
    ipv4 += n * Math.pow(256, 3 - counter);
    ++counter;
  }

  return ipv4;
}

function serializeIPv4(address) {
  let output = "";
  let n = address;

  for (let i = 1; i <= 4; ++i) {
    output = String(n % 256) + output;
    if (i !== 4) {
      output = "." + output;
    }
    n = Math.floor(n / 256);
  }

  return output;
}

function parseIPv6(input) {
  const address = [0, 0, 0, 0, 0, 0, 0, 0];
  let pieceIndex = 0;
  let compress = null;
  let pointer = 0;

  input = punycode.ucs2.decode(input);

  if (input[pointer] === 58) {
    if (input[pointer + 1] !== 58) {
      return failure;
    }

    pointer += 2;
    ++pieceIndex;
    compress = pieceIndex;
  }

  while (pointer < input.length) {
    if (pieceIndex === 8) {
      return failure;
    }

    if (input[pointer] === 58) {
      if (compress !== null) {
        return failure;
      }
      ++pointer;
      ++pieceIndex;
      compress = pieceIndex;
      continue;
    }

    let value = 0;
    let length = 0;

    while (length < 4 && isASCIIHex(input[pointer])) {
      value = value * 0x10 + parseInt(at(input, pointer), 16);
      ++pointer;
      ++length;
    }

    if (input[pointer] === 46) {
      if (length === 0) {
        return failure;
      }

      pointer -= length;

      if (pieceIndex > 6) {
        return failure;
      }

      let numbersSeen = 0;

      while (input[pointer] !== undefined) {
        let ipv4Piece = null;

        if (numbersSeen > 0) {
          if (input[pointer] === 46 && numbersSeen < 4) {
            ++pointer;
          } else {
            return failure;
          }
        }

        if (!isASCIIDigit(input[pointer])) {
          return failure;
        }

        while (isASCIIDigit(input[pointer])) {
          const number = parseInt(at(input, pointer));
          if (ipv4Piece === null) {
            ipv4Piece = number;
          } else if (ipv4Piece === 0) {
            return failure;
          } else {
            ipv4Piece = ipv4Piece * 10 + number;
          }
          if (ipv4Piece > 255) {
            return failure;
          }
          ++pointer;
        }

        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;

        ++numbersSeen;

        if (numbersSeen === 2 || numbersSeen === 4) {
          ++pieceIndex;
        }
      }

      if (numbersSeen !== 4) {
        return failure;
      }

      break;
    } else if (input[pointer] === 58) {
      ++pointer;
      if (input[pointer] === undefined) {
        return failure;
      }
    } else if (input[pointer] !== undefined) {
      return failure;
    }

    address[pieceIndex] = value;
    ++pieceIndex;
  }

  if (compress !== null) {
    let swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex !== 0 && swaps > 0) {
      const temp = address[compress + swaps - 1];
      address[compress + swaps - 1] = address[pieceIndex];
      address[pieceIndex] = temp;
      --pieceIndex;
      --swaps;
    }
  } else if (compress === null && pieceIndex !== 8) {
    return failure;
  }

  return address;
}

function serializeIPv6(address) {
  let output = "";
  const seqResult = findLongestZeroSequence(address);
  const compress = seqResult.idx;
  let ignore0 = false;

  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
    if (ignore0 && address[pieceIndex] === 0) {
      continue;
    } else if (ignore0) {
      ignore0 = false;
    }

    if (compress === pieceIndex) {
      const separator = pieceIndex === 0 ? "::" : ":";
      output += separator;
      ignore0 = true;
      continue;
    }

    output += address[pieceIndex].toString(16);

    if (pieceIndex !== 7) {
      output += ":";
    }
  }

  return output;
}

function parseHost(input, isSpecialArg) {
  if (input[0] === "[") {
    if (input[input.length - 1] !== "]") {
      return failure;
    }

    return parseIPv6(input.substring(1, input.length - 1));
  }

  if (!isSpecialArg) {
    return parseOpaqueHost(input);
  }

  const domain = utf8PercentDecode(input);
  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
  if (asciiDomain === null) {
    return failure;
  }

  if (containsForbiddenHostCodePoint(asciiDomain)) {
    return failure;
  }

  const ipv4Host = parseIPv4(asciiDomain);
  if (typeof ipv4Host === "number" || ipv4Host === failure) {
    return ipv4Host;
  }

  return asciiDomain;
}

function parseOpaqueHost(input) {
  if (containsForbiddenHostCodePointExcludingPercent(input)) {
    return failure;
  }

  let output = "";
  const decoded = punycode.ucs2.decode(input);
  for (let i = 0; i < decoded.length; ++i) {
    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
  }
  return output;
}

function findLongestZeroSequence(arr) {
  let maxIdx = null;
  let maxLen = 1; // only find elements > 1
  let currStart = null;
  let currLen = 0;

  for (let i = 0; i < arr.length; ++i) {
    if (arr[i] !== 0) {
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }

      currStart = null;
      currLen = 0;
    } else {
      if (currStart === null) {
        currStart = i;
      }
      ++currLen;
    }
  }

  // if trailing zeros
  if (currLen > maxLen) {
    maxIdx = currStart;
    maxLen = currLen;
  }

  return {
    idx: maxIdx,
    len: maxLen
  };
}

function serializeHost(host) {
  if (typeof host === "number") {
    return serializeIPv4(host);
  }

  // IPv6 serializer
  if (host instanceof Array) {
    return "[" + serializeIPv6(host) + "]";
  }

  return host;
}

function trimControlChars(url) {
  return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
}

function trimTabAndNewline(url) {
  return url.replace(/\u0009|\u000A|\u000D/g, "");
}

function shortenPath(url) {
  const path = url.path;
  if (path.length === 0) {
    return;
  }
  if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
    return;
  }

  path.pop();
}

function includesCredentials(url) {
  return url.username !== "" || url.password !== "";
}

function cannotHaveAUsernamePasswordPort(url) {
  return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
}

function isNormalizedWindowsDriveLetter(string) {
  return /^[A-Za-z]:$/.test(string);
}

function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
  this.pointer = 0;
  this.input = input;
  this.base = base || null;
  this.encodingOverride = encodingOverride || "utf-8";
  this.stateOverride = stateOverride;
  this.url = url;
  this.failure = false;
  this.parseError = false;

  if (!this.url) {
    this.url = {
      scheme: "",
      username: "",
      password: "",
      host: null,
      port: null,
      path: [],
      query: null,
      fragment: null,

      cannotBeABaseURL: false
    };

    const res = trimControlChars(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
  }

  const res = trimTabAndNewline(this.input);
  if (res !== this.input) {
    this.parseError = true;
  }
  this.input = res;

  this.state = stateOverride || "scheme start";

  this.buffer = "";
  this.atFlag = false;
  this.arrFlag = false;
  this.passwordTokenSeenFlag = false;

  this.input = punycode.ucs2.decode(this.input);

  for (; this.pointer <= this.input.length; ++this.pointer) {
    const c = this.input[this.pointer];
    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);

    // exec state machine
    const ret = this["parse " + this.state](c, cStr);
    if (!ret) {
      break; // terminate algorithm
    } else if (ret === failure) {
      this.failure = true;
      break;
    }
  }
}

URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
  if (isASCIIAlpha(c)) {
    this.buffer += cStr.toLowerCase();
    this.state = "scheme";
  } else if (!this.stateOverride) {
    this.state = "no scheme";
    --this.pointer;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
    this.buffer += cStr.toLowerCase();
  } else if (c === 58) {
    if (this.stateOverride) {
      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
        return false;
      }

      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
        return false;
      }

      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
        return false;
      }

      if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
        return false;
      }
    }
    this.url.scheme = this.buffer;
    this.buffer = "";
    if (this.stateOverride) {
      return false;
    }
    if (this.url.scheme === "file") {
      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
        this.parseError = true;
      }
      this.state = "file";
    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
      this.state = "special relative or authority";
    } else if (isSpecial(this.url)) {
      this.state = "special authority slashes";
    } else if (this.input[this.pointer + 1] === 47) {
      this.state = "path or authority";
      ++this.pointer;
    } else {
      this.url.cannotBeABaseURL = true;
      this.url.path.push("");
      this.state = "cannot-be-a-base-URL path";
    }
  } else if (!this.stateOverride) {
    this.buffer = "";
    this.state = "no scheme";
    this.pointer = -1;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {
    return failure;
  } else if (this.base.cannotBeABaseURL && c === 35) {
    this.url.scheme = this.base.scheme;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    this.url.fragment = "";
    this.url.cannotBeABaseURL = true;
    this.state = "fragment";
  } else if (this.base.scheme === "file") {
    this.state = "file";
    --this.pointer;
  } else {
    this.state = "relative";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
  if (c === 47 && this.input[this.pointer + 1] === 47) {
    this.state = "special authority ignore slashes";
    ++this.pointer;
  } else {
    this.parseError = true;
    this.state = "relative";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
  if (c === 47) {
    this.state = "authority";
  } else {
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
  this.url.scheme = this.base.scheme;
  if (isNaN(c)) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
  } else if (c === 47) {
    this.state = "relative slash";
  } else if (c === 63) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = "";
    this.state = "query";
  } else if (c === 35) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    this.url.fragment = "";
    this.state = "fragment";
  } else if (isSpecial(this.url) && c === 92) {
    this.parseError = true;
    this.state = "relative slash";
  } else {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice(0, this.base.path.length - 1);

    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
  if (isSpecial(this.url) && (c === 47 || c === 92)) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "special authority ignore slashes";
  } else if (c === 47) {
    this.state = "authority";
  } else {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
  if (c === 47 && this.input[this.pointer + 1] === 47) {
    this.state = "special authority ignore slashes";
    ++this.pointer;
  } else {
    this.parseError = true;
    this.state = "special authority ignore slashes";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
  if (c !== 47 && c !== 92) {
    this.state = "authority";
    --this.pointer;
  } else {
    this.parseError = true;
  }

  return true;
};

URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
  if (c === 64) {
    this.parseError = true;
    if (this.atFlag) {
      this.buffer = "%40" + this.buffer;
    }
    this.atFlag = true;

    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
    const len = countSymbols(this.buffer);
    for (let pointer = 0; pointer < len; ++pointer) {
      const codePoint = this.buffer.codePointAt(pointer);

      if (codePoint === 58 && !this.passwordTokenSeenFlag) {
        this.passwordTokenSeenFlag = true;
        continue;
      }
      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
      if (this.passwordTokenSeenFlag) {
        this.url.password += encodedCodePoints;
      } else {
        this.url.username += encodedCodePoints;
      }
    }
    this.buffer = "";
  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92)) {
    if (this.atFlag && this.buffer === "") {
      this.parseError = true;
      return failure;
    }
    this.pointer -= countSymbols(this.buffer) + 1;
    this.buffer = "";
    this.state = "host";
  } else {
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse hostname"] =
URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
  if (this.stateOverride && this.url.scheme === "file") {
    --this.pointer;
    this.state = "file host";
  } else if (c === 58 && !this.arrFlag) {
    if (this.buffer === "") {
      this.parseError = true;
      return failure;
    }

    const host = parseHost(this.buffer, isSpecial(this.url));
    if (host === failure) {
      return failure;
    }

    this.url.host = host;
    this.buffer = "";
    this.state = "port";
    if (this.stateOverride === "hostname") {
      return false;
    }
  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92)) {
    --this.pointer;
    if (isSpecial(this.url) && this.buffer === "") {
      this.parseError = true;
      return failure;
    } else if (this.stateOverride && this.buffer === "" &&
               (includesCredentials(this.url) || this.url.port !== null)) {
      this.parseError = true;
      return false;
    }

    const host = parseHost(this.buffer, isSpecial(this.url));
    if (host === failure) {
      return failure;
    }

    this.url.host = host;
    this.buffer = "";
    this.state = "path start";
    if (this.stateOverride) {
      return false;
    }
  } else {
    if (c === 91) {
      this.arrFlag = true;
    } else if (c === 93) {
      this.arrFlag = false;
    }
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
  if (isASCIIDigit(c)) {
    this.buffer += cStr;
  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92) ||
             this.stateOverride) {
    if (this.buffer !== "") {
      const port = parseInt(this.buffer);
      if (port > Math.pow(2, 16) - 1) {
        this.parseError = true;
        return failure;
      }
      this.url.port = port === defaultPort(this.url.scheme) ? null : port;
      this.buffer = "";
    }
    if (this.stateOverride) {
      return false;
    }
    this.state = "path start";
    --this.pointer;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

const fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);

URLStateMachine.prototype["parse file"] = function parseFile(c) {
  this.url.scheme = "file";

  if (c === 47 || c === 92) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "file slash";
  } else if (this.base !== null && this.base.scheme === "file") {
    if (isNaN(c)) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
    } else if (c === 63) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||
          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        shortenPath(this.url);
      } else {
        this.parseError = true;
      }

      this.state = "path";
      --this.pointer;
    }
  } else {
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
  if (c === 47 || c === 92) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "file host";
  } else {
    if (this.base !== null && this.base.scheme === "file") {
      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
        this.url.path.push(this.base.path[0]);
      } else {
        this.url.host = this.base.host;
      }
    }
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
    --this.pointer;
    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
      this.parseError = true;
      this.state = "path";
    } else if (this.buffer === "") {
      this.url.host = "";
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
    } else {
      let host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      if (host === "localhost") {
        host = "";
      }
      this.url.host = host;

      if (this.stateOverride) {
        return false;
      }

      this.buffer = "";
      this.state = "path start";
    }
  } else {
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
  if (isSpecial(this.url)) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "path";

    if (c !== 47 && c !== 92) {
      --this.pointer;
    }
  } else if (!this.stateOverride && c === 63) {
    this.url.query = "";
    this.state = "query";
  } else if (!this.stateOverride && c === 35) {
    this.url.fragment = "";
    this.state = "fragment";
  } else if (c !== undefined) {
    this.state = "path";
    if (c !== 47) {
      --this.pointer;
    }
  }

  return true;
};

URLStateMachine.prototype["parse path"] = function parsePath(c) {
  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||
      (!this.stateOverride && (c === 63 || c === 35))) {
    if (isSpecial(this.url) && c === 92) {
      this.parseError = true;
    }

    if (isDoubleDot(this.buffer)) {
      shortenPath(this.url);
      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
        this.url.path.push("");
      }
    } else if (isSingleDot(this.buffer) && c !== 47 &&
               !(isSpecial(this.url) && c === 92)) {
      this.url.path.push("");
    } else if (!isSingleDot(this.buffer)) {
      if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
        if (this.url.host !== "" && this.url.host !== null) {
          this.parseError = true;
          this.url.host = "";
        }
        this.buffer = this.buffer[0] + ":";
      }
      this.url.path.push(this.buffer);
    }
    this.buffer = "";
    if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
      while (this.url.path.length > 1 && this.url.path[0] === "") {
        this.parseError = true;
        this.url.path.shift();
      }
    }
    if (c === 63) {
      this.url.query = "";
      this.state = "query";
    }
    if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    }
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.

    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.buffer += percentEncodeChar(c, isPathPercentEncode);
  }

  return true;
};

URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
  if (c === 63) {
    this.url.query = "";
    this.state = "query";
  } else if (c === 35) {
    this.url.fragment = "";
    this.state = "fragment";
  } else {
    // TODO: Add: not a URL code point
    if (!isNaN(c) && c !== 37) {
      this.parseError = true;
    }

    if (c === 37 &&
        (!isASCIIHex(this.input[this.pointer + 1]) ||
         !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    if (!isNaN(c)) {
      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
    }
  }

  return true;
};

URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
  if (isNaN(c) || (!this.stateOverride && c === 35)) {
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
      this.encodingOverride = "utf-8";
    }

    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead
    for (let i = 0; i < buffer.length; ++i) {
      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||
          buffer[i] === 0x3C || buffer[i] === 0x3E) {
        this.url.query += percentEncode(buffer[i]);
      } else {
        this.url.query += String.fromCodePoint(buffer[i]);
      }
    }

    this.buffer = "";
    if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    }
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.
    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
  if (isNaN(c)) { // do nothing
  } else if (c === 0x0) {
    this.parseError = true;
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.
    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
  }

  return true;
};

function serializeURL(url, excludeFragment) {
  let output = url.scheme + ":";
  if (url.host !== null) {
    output += "//";

    if (url.username !== "" || url.password !== "") {
      output += url.username;
      if (url.password !== "") {
        output += ":" + url.password;
      }
      output += "@";
    }

    output += serializeHost(url.host);

    if (url.port !== null) {
      output += ":" + url.port;
    }
  } else if (url.host === null && url.scheme === "file") {
    output += "//";
  }

  if (url.cannotBeABaseURL) {
    output += url.path[0];
  } else {
    for (const string of url.path) {
      output += "/" + string;
    }
  }

  if (url.query !== null) {
    output += "?" + url.query;
  }

  if (!excludeFragment && url.fragment !== null) {
    output += "#" + url.fragment;
  }

  return output;
}

function serializeOrigin(tuple) {
  let result = tuple.scheme + "://";
  result += serializeHost(tuple.host);

  if (tuple.port !== null) {
    result += ":" + tuple.port;
  }

  return result;
}

module.exports.serializeURL = serializeURL;

module.exports.serializeURLOrigin = function (url) {
  // https://url.spec.whatwg.org/#concept-url-origin
  switch (url.scheme) {
    case "blob":
      try {
        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
      } catch (e) {
        // serializing an opaque origin returns "null"
        return "null";
      }
    case "ftp":
    case "gopher":
    case "http":
    case "https":
    case "ws":
    case "wss":
      return serializeOrigin({
        scheme: url.scheme,
        host: url.host,
        port: url.port
      });
    case "file":
      // spec says "exercise to the reader", chrome says "file://"
      return "file://";
    default:
      // serializing an opaque origin returns "null"
      return "null";
  }
};

module.exports.basicURLParse = function (input, options) {
  if (options === undefined) {
    options = {};
  }

  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
  if (usm.failure) {
    return "failure";
  }

  return usm.url;
};

module.exports.setTheUsername = function (url, username) {
  url.username = "";
  const decoded = punycode.ucs2.decode(username);
  for (let i = 0; i < decoded.length; ++i) {
    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  }
};

module.exports.setThePassword = function (url, password) {
  url.password = "";
  const decoded = punycode.ucs2.decode(password);
  for (let i = 0; i < decoded.length; ++i) {
    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  }
};

module.exports.serializeHost = serializeHost;

module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;

module.exports.serializeInteger = function (integer) {
  return String(integer);
};

module.exports.parseURL = function (input, options) {
  if (options === undefined) {
    options = {};
  }

  // We don't handle blobs, so this just delegates:
  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
};


/***/ }),

/***/ "./node_modules/whatwg-url/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/whatwg-url/lib/utils.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";


module.exports.mixin = function mixin(target, source) {
  const keys = Object.getOwnPropertyNames(source);
  for (let i = 0; i < keys.length; ++i) {
    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
  }
};

module.exports.wrapperSymbol = Symbol("wrapper");
module.exports.implSymbol = Symbol("impl");

module.exports.wrapperForImpl = function (impl) {
  return impl[module.exports.wrapperSymbol];
};

module.exports.implForWrapper = function (wrapper) {
  return wrapper[module.exports.implSymbol];
};



/***/ }),

/***/ "./node_modules/wrappy/wrappy.js":
/*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ "./node_modules/yallist/iterator.js":
/*!******************************************!*\
  !*** ./node_modules/yallist/iterator.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(/*! ./iterator.js */ "./node_modules/yallist/iterator.js")(Yallist)
} catch (er) {}


/***/ }),

/***/ "./src/api/api.ts":
/*!************************!*\
  !*** ./src/api/api.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getClient: () => (/* binding */ getClient),
/* harmony export */   userAgent: () => (/* binding */ userAgent)
/* harmony export */ });
/* harmony import */ var _octokit_rest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @octokit/rest */ "./node_modules/@octokit/rest/dist-web/index.js");
/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! undici */ "./node_modules/undici/index.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../package.json */ "./package.json");
/* harmony import */ var _configuration_configuration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../configuration/configuration */ "./src/configuration/configuration.ts");




const userAgent = `VS Code GitHub Actions (${_package_json__WEBPACK_IMPORTED_MODULE_1__.version})`;
const customFetch = (url, opts) => {
    return (0,undici__WEBPACK_IMPORTED_MODULE_0__.fetch)(url, {
        ...opts,
        dipatcher: new undici__WEBPACK_IMPORTED_MODULE_0__.ProxyAgent({
            uri: process.env.HTTPS_PROXY || "",
            keepAliveTimeout: 10,
            keepAliveMaxTimeout: 10,
        }),
    });
};
function getClient(token) {
    return new _octokit_rest__WEBPACK_IMPORTED_MODULE_3__.Octokit({
        auth: token,
        userAgent: userAgent,
        baseUrl: (0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_2__.getGitHubApiUri)(),
        request: { fetch: customFetch }
    });
}


/***/ }),

/***/ "./src/api/canReachGitHubAPI.ts":
/*!**************************************!*\
  !*** ./src/api/canReachGitHubAPI.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canReachGitHubAPI: () => (/* binding */ canReachGitHubAPI)
/* harmony export */ });
/* harmony import */ var _actions_languageserver_utils_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actions/languageserver/utils/cache */ "./node_modules/@actions/languageserver/dist/utils/cache.js");
/* harmony import */ var _auth_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../auth/auth */ "./src/auth/auth.ts");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../log */ "./src/log.ts");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api */ "./src/api/api.ts");




const API_ACCESS_TTL_MS = 10 * 1000;
const cache = new _actions_languageserver_utils_cache__WEBPACK_IMPORTED_MODULE_0__.TTLCache(API_ACCESS_TTL_MS);
async function canReachGitHubAPI() {
    const session = await (0,_auth_auth__WEBPACK_IMPORTED_MODULE_1__.getSession)();
    if (!session) {
        return false;
    }
    return await cache.get("canReachGitHubAPI", undefined, async () => {
        try {
            const octokit = (0,_api__WEBPACK_IMPORTED_MODULE_3__.getClient)(session.accessToken);
            await octokit.request("GET /");
        }
        catch (e) {
            (0,_log__WEBPACK_IMPORTED_MODULE_2__.logError)(e, "Error getting GitHub context");
            return false;
        }
        return true;
    });
}


/***/ }),

/***/ "./src/api/handleSamlError.ts":
/*!************************************!*\
  !*** ./src/api/handleSamlError.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   handleSamlError: () => (/* binding */ handleSamlError)
/* harmony export */ });
/* harmony import */ var _auth_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../auth/auth */ "./src/auth/auth.ts");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../log */ "./src/log.ts");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api */ "./src/api/api.ts");



async function handleSamlError(session, request) {
    try {
        const client = (0,_api__WEBPACK_IMPORTED_MODULE_2__.getClient)(session.accessToken);
        return await request(client);
    }
    catch (error) {
        if (error.message.includes("Resource protected by organization SAML enforcement.")) {
            (0,_log__WEBPACK_IMPORTED_MODULE_1__.logDebug)("SAML error, re-authenticating");
            const session = await (0,_auth_auth__WEBPACK_IMPORTED_MODULE_0__.newSession)("Your organization is protected by SAML enforcement. Please sign-in again to continue.");
            const client = (0,_api__WEBPACK_IMPORTED_MODULE_2__.getClient)(session.accessToken);
            return await request(client);
        }
        else {
            throw error;
        }
    }
}


/***/ }),

/***/ "./src/auth/auth.ts":
/*!**************************!*\
  !*** ./src/auth/auth.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSession: () => (/* binding */ getSession),
/* harmony export */   newSession: () => (/* binding */ newSession)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _configuration_configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../configuration/configuration */ "./src/configuration/configuration.ts");


const AUTH_PROVIDER_ID = "github";
const AUTH_PROVIDER_ID_ENTERPRISE = "github-enterprise";
const DEFAULT_SCOPES = ["repo", "workflow"];
let signInPrompted = false;
const SESSION_ERROR = "Could not get token from the GitHub authentication provider.\nPlease sign in and allow access.";
/**
 * Creates a session from the GitHub authentication provider
 * @param forceMessage Prompt to the user when forcing a new session
 * @returns A {@link vscode.AuthenticationSession}
 */
async function newSession(forceMessage) {
    const session = await getSessionInternal(forceMessage);
    if (session) {
        return session;
    }
    throw new Error(SESSION_ERROR);
}
/**
 * Retrieves a session from the GitHub authentication provider or prompts the user to sign in
 * @returns A {@link vscode.AuthenticationSession} or undefined
 */
async function getSession(skipPrompt = false) {
    const session = await getSessionInternal(skipPrompt);
    if (session) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "github-actions.signed-in", true);
        return session;
    }
    if (signInPrompted || skipPrompt) {
        return undefined;
    }
    signInPrompted = true;
    const signInAction = "Sign in to GitHub";
    vscode__WEBPACK_IMPORTED_MODULE_0__.window
        .showInformationMessage("Sign in to GitHub to access your repositories and GitHub Actions workflows.", signInAction)
        .then(async (result) => {
        if (result === signInAction) {
            const session = await getSessionInternal(true);
            if (session) {
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "github-actions.signed-in", true);
            }
        }
    }, () => {
        // Ignore rejected promise
    });
    // User chose to not sign in or hasn't signed in yet
    return undefined;
}
async function getSessionInternal(createOrForceMessage = false) {
    // forceNewSession and createIfNone are mutually exclusive
    const options = typeof createOrForceMessage === "string"
        ? { forceNewSession: { detail: createOrForceMessage } }
        : { createIfNone: createOrForceMessage };
    const authProviderId = (0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_1__.useEnterprise)() ? AUTH_PROVIDER_ID_ENTERPRISE : AUTH_PROVIDER_ID;
    return await vscode__WEBPACK_IMPORTED_MODULE_0__.authentication.getSession(authProviderId, getScopes(), options);
}
function getScopes() {
    return DEFAULT_SCOPES;
}


/***/ }),

/***/ "./src/commands/cancelWorkflowRun.ts":
/*!*******************************************!*\
  !*** ./src/commands/cancelWorkflowRun.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerCancelWorkflowRun: () => (/* binding */ registerCancelWorkflowRun)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

function registerCancelWorkflowRun(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.workflow.run.cancel", async (args) => {
        const gitHubRepoContext = args.gitHubRepoContext;
        const run = args.run;
        try {
            await gitHubRepoContext.client.actions.cancelWorkflowRun({
                owner: gitHubRepoContext.owner,
                repo: gitHubRepoContext.name,
                run_id: run.run.id
            });
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Could not cancel workflow: '${e.message}'`);
        }
        // Start refreshing the run to reflect cancellation in UI
        args.store.pollRun(run.run.id, gitHubRepoContext, 1000, 10);
    }));
}


/***/ }),

/***/ "./src/commands/openWorkflowFile.ts":
/*!******************************************!*\
  !*** ./src/commands/openWorkflowFile.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerOpenWorkflowFile: () => (/* binding */ registerOpenWorkflowFile)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _workflow_workflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../workflow/workflow */ "./src/workflow/workflow.ts");


function registerOpenWorkflowFile(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.explorer.openWorkflowFile", async (args) => {
        const { wf, gitHubRepoContext } = args;
        const fileUri = (0,_workflow_workflow__WEBPACK_IMPORTED_MODULE_1__.getWorkflowUri)(gitHubRepoContext, wf.path);
        if (fileUri) {
            try {
                const textDocument = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument(fileUri);
                await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showTextDocument(textDocument);
                return;
            }
            catch (e) {
                // Ignore error and show error message below
            }
        }
        // File not found in workspace
        await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Workflow ${wf.path} not found in current workspace`);
    }));
}


/***/ }),

/***/ "./src/commands/openWorkflowJobLogs.ts":
/*!*********************************************!*\
  !*** ./src/commands/openWorkflowJobLogs.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerOpenWorkflowJobLogs: () => (/* binding */ registerOpenWorkflowJobLogs)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logs_formatProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logs/formatProvider */ "./src/logs/formatProvider.ts");
/* harmony import */ var _logs_logInfo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logs/logInfo */ "./src/logs/logInfo.ts");
/* harmony import */ var _logs_scheme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logs/scheme */ "./src/logs/scheme.ts");




function registerOpenWorkflowJobLogs(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.workflow.logs", async (args) => {
        const gitHubRepoContext = args.gitHubRepoContext;
        const job = args.job;
        const uri = (0,_logs_scheme__WEBPACK_IMPORTED_MODULE_3__.buildLogURI)(`%23${job.job.run_id} - ${job.job.name}`, gitHubRepoContext.owner, gitHubRepoContext.name, job.job.id);
        const doc = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument(uri);
        const editor = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showTextDocument(doc, {
            preview: false
        });
        const logInfo = (0,_logs_logInfo__WEBPACK_IMPORTED_MODULE_2__.getLogInfo)(uri);
        if (!logInfo) {
            throw new Error("Could not get log info");
        }
        // Custom formatting after the editor has been opened
        (0,_logs_formatProvider__WEBPACK_IMPORTED_MODULE_1__.updateDecorations)(editor, logInfo);
    }));
}


/***/ }),

/***/ "./src/commands/openWorkflowRun.ts":
/*!*****************************************!*\
  !*** ./src/commands/openWorkflowRun.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerOpenWorkflowRun: () => (/* binding */ registerOpenWorkflowRun)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

function registerOpenWorkflowRun(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.workflow.run.open", async (args) => {
        const run = args.run;
        const url = run.run.html_url;
        await vscode__WEBPACK_IMPORTED_MODULE_0__.env.openExternal(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.parse(url));
    }));
}


/***/ }),

/***/ "./src/commands/openWorkflowStepLogs.ts":
/*!**********************************************!*\
  !*** ./src/commands/openWorkflowStepLogs.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerOpenWorkflowStepLogs: () => (/* binding */ registerOpenWorkflowStepLogs)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

function registerOpenWorkflowStepLogs(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.step.logs", async (args) => {
        const job = args.job.job;
        let url = job.html_url ?? "";
        const stepName = args.step.name;
        const index = job.steps && job.steps.findIndex(step => step.name === stepName) + 1;
        if (url && index) {
            url = url + "#step:" + index.toString() + ":1";
        }
        await vscode__WEBPACK_IMPORTED_MODULE_0__.env.openExternal(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.parse(url));
    }));
}


/***/ }),

/***/ "./src/commands/pinWorkflow.ts":
/*!*************************************!*\
  !*** ./src/commands/pinWorkflow.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerPinWorkflow: () => (/* binding */ registerPinWorkflow)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _configuration_configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../configuration/configuration */ "./src/configuration/configuration.ts");
/* harmony import */ var _workflow_workflow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../workflow/workflow */ "./src/workflow/workflow.ts");



function registerPinWorkflow(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.workflow.pin", async (args) => {
        const { gitHubRepoContext, wf } = args;
        if (!wf) {
            return;
        }
        const workflowFullPath = (0,_workflow_workflow__WEBPACK_IMPORTED_MODULE_2__.getWorkflowUri)(gitHubRepoContext, wf.path);
        if (!workflowFullPath) {
            return;
        }
        const relativeWorkflowPath = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.asRelativePath(workflowFullPath);
        await (0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_1__.pinWorkflow)(relativeWorkflowPath);
        args.updateContextValue();
        // Refresh tree to reflect updated `pin/unpin` icon
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("github-actions.explorer.refresh");
    }));
}


/***/ }),

/***/ "./src/commands/rerunWorkflowRun.ts":
/*!******************************************!*\
  !*** ./src/commands/rerunWorkflowRun.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerReRunWorkflowRun: () => (/* binding */ registerReRunWorkflowRun)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

function registerReRunWorkflowRun(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.workflow.run.rerun", async (args) => {
        const gitHubRepoContext = args.gitHubRepoContext;
        const run = args.run;
        try {
            await gitHubRepoContext.client.actions.reRunWorkflow({
                owner: gitHubRepoContext.owner,
                repo: gitHubRepoContext.name,
                run_id: run.run.id
            });
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Could not rerun workflow: '${e.message}'`);
        }
        // Start refreshing the run to reflect rerunning in UI
        args.store.pollRun(run.run.id, gitHubRepoContext, 1000, 20);
    }));
}


/***/ }),

/***/ "./src/commands/secrets/addSecret.ts":
/*!*******************************************!*\
  !*** ./src/commands/secrets/addSecret.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createOrUpdateEnvSecret: () => (/* binding */ createOrUpdateEnvSecret),
/* harmony export */   createOrUpdateRepoSecret: () => (/* binding */ createOrUpdateRepoSecret),
/* harmony export */   registerAddSecret: () => (/* binding */ registerAddSecret)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _secrets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../secrets */ "./src/secrets/index.ts");


function registerAddSecret(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.settings.secret.add", async (args) => {
        const { gitHubRepoContext } = args;
        const name = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: "Enter name for new secret",
            ignoreFocusOut: true
        });
        if (!name) {
            return;
        }
        const value = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: "Enter the new secret value",
            ignoreFocusOut: true
        });
        if (!value) {
            return;
        }
        try {
            if ("environment" in args) {
                await createOrUpdateEnvSecret(gitHubRepoContext, args.environment.name, name, value);
            }
            else {
                await createOrUpdateRepoSecret(gitHubRepoContext, name, value);
            }
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("github-actions.explorer.refresh");
    }));
}
async function createOrUpdateRepoSecret(context, name, value) {
    const keyResponse = await context.client.actions.getRepoPublicKey({
        owner: context.owner,
        repo: context.name
    });
    await context.client.actions.createOrUpdateRepoSecret({
        owner: context.owner,
        repo: context.name,
        secret_name: name,
        key_id: keyResponse.data.key_id,
        encrypted_value: await (0,_secrets__WEBPACK_IMPORTED_MODULE_1__.encodeSecret)(keyResponse.data.key, value)
    });
}
async function createOrUpdateEnvSecret(context, environment, name, value) {
    const keyResponse = await context.client.actions.getEnvironmentPublicKey({
        repository_id: context.id,
        environment_name: environment
    });
    await context.client.actions.createOrUpdateEnvironmentSecret({
        repository_id: context.id,
        environment_name: environment,
        secret_name: name,
        key_id: keyResponse.data.key_id,
        encrypted_value: await (0,_secrets__WEBPACK_IMPORTED_MODULE_1__.encodeSecret)(keyResponse.data.key, value)
    });
}


/***/ }),

/***/ "./src/commands/secrets/copySecret.ts":
/*!********************************************!*\
  !*** ./src/commands/secrets/copySecret.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerCopySecret: () => (/* binding */ registerCopySecret)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

function registerCopySecret(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.settings.secret.copy", async (args) => {
        const { secret } = args;
        await vscode__WEBPACK_IMPORTED_MODULE_0__.env.clipboard.writeText(secret.name);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.setStatusBarMessage(`Copied ${secret.name}`, 2000);
    }));
}


/***/ }),

/***/ "./src/commands/secrets/deleteSecret.ts":
/*!**********************************************!*\
  !*** ./src/commands/secrets/deleteSecret.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerDeleteSecret: () => (/* binding */ registerDeleteSecret)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

function registerDeleteSecret(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.settings.secret.delete", async (args) => {
        const { gitHubRepoContext, secret, environment } = args;
        const acceptText = "Yes, delete this secret";
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window
                .showInformationMessage(`Are you sure you want to delete ${secret.name}?`, { modal: true, detail: "Deleting this secret cannot be undone and may impact workflows in this repository" }, acceptText)
                .then(async (answer) => {
                if (answer === acceptText) {
                    if (environment) {
                        await gitHubRepoContext.client.actions.deleteEnvironmentSecret({
                            repository_id: gitHubRepoContext.id,
                            environment_name: environment.name,
                            secret_name: secret.name
                        });
                    }
                    else {
                        await gitHubRepoContext.client.actions.deleteRepoSecret({
                            owner: gitHubRepoContext.owner,
                            repo: gitHubRepoContext.name,
                            secret_name: secret.name
                        });
                    }
                }
            });
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("github-actions.explorer.refresh");
    }));
}


/***/ }),

/***/ "./src/commands/secrets/updateSecret.ts":
/*!**********************************************!*\
  !*** ./src/commands/secrets/updateSecret.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerUpdateSecret: () => (/* binding */ registerUpdateSecret)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _addSecret__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./addSecret */ "./src/commands/secrets/addSecret.ts");


function registerUpdateSecret(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.settings.secret.update", async (args) => {
        const { gitHubRepoContext, secret, environment } = args;
        const value = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: "Enter the new secret value"
        });
        if (!value) {
            return;
        }
        try {
            if (environment) {
                await (0,_addSecret__WEBPACK_IMPORTED_MODULE_1__.createOrUpdateEnvSecret)(gitHubRepoContext, environment.name, secret.name, value);
            }
            else {
                await (0,_addSecret__WEBPACK_IMPORTED_MODULE_1__.createOrUpdateRepoSecret)(gitHubRepoContext, secret.name, value);
            }
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
    }));
}


/***/ }),

/***/ "./src/commands/signIn.ts":
/*!********************************!*\
  !*** ./src/commands/signIn.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerSignIn: () => (/* binding */ registerSignIn)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _auth_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../auth/auth */ "./src/auth/auth.ts");
/* harmony import */ var _api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/canReachGitHubAPI */ "./src/api/canReachGitHubAPI.ts");
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../git/repository */ "./src/git/repository.ts");




function registerSignIn(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.sign-in", async () => {
        const session = await (0,_auth_auth__WEBPACK_IMPORTED_MODULE_1__.getSession)(true);
        if (session) {
            const canReachAPI = await (0,_api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_2__.canReachGitHubAPI)();
            const ghContext = await (0,_git_repository__WEBPACK_IMPORTED_MODULE_3__.getGitHubContext)();
            const hasGitHubRepos = ghContext && ghContext.repos.length > 0;
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "github-actions.signed-in", true);
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "github-actions.internet-access", canReachAPI);
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "github-actions.has-repos", hasGitHubRepos);
        }
    }));
}


/***/ }),

/***/ "./src/commands/triggerWorkflowRun.ts":
/*!********************************************!*\
  !*** ./src/commands/triggerWorkflowRun.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerTriggerWorkflowRun: () => (/* binding */ registerTriggerWorkflowRun)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../git/repository */ "./src/git/repository.ts");
/* harmony import */ var _workflow_workflow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../workflow/workflow */ "./src/workflow/workflow.ts");



function registerTriggerWorkflowRun(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.explorer.triggerRun", async (args) => {
        let workflowUri = null;
        if (args instanceof vscode__WEBPACK_IMPORTED_MODULE_0__.Uri) {
            workflowUri = args;
        }
        else if (args.wf) {
            const wf = args.wf;
            workflowUri = (0,_workflow_workflow__WEBPACK_IMPORTED_MODULE_2__.getWorkflowUri)(args.gitHubRepoContext, wf.path);
        }
        if (!workflowUri) {
            return;
        }
        // Parse
        const workspaceFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getWorkspaceFolder(workflowUri);
        if (!workspaceFolder) {
            return;
        }
        const gitHubRepoContext = await (0,_git_repository__WEBPACK_IMPORTED_MODULE_1__.getGitHubContextForWorkspaceUri)(workspaceFolder.uri);
        if (!gitHubRepoContext) {
            return;
        }
        const workflow = await (0,_workflow_workflow__WEBPACK_IMPORTED_MODULE_2__.parseWorkflowFile)(workflowUri);
        if (!workflow) {
            return;
        }
        let selectedEvent;
        if (workflow.events.workflow_dispatch !== undefined && workflow.events.repository_dispatch !== undefined) {
            selectedEvent = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(["repository_dispatch", "workflow_dispatch"], {
                placeHolder: "Which event to trigger?"
            });
            if (!selectedEvent) {
                return;
            }
        }
        if ((!selectedEvent || selectedEvent === "workflow_dispatch") &&
            workflow.events.workflow_dispatch !== undefined) {
            const ref = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: "Enter ref to trigger workflow on",
                value: (await (0,_git_repository__WEBPACK_IMPORTED_MODULE_1__.getGitHead)()) || gitHubRepoContext.defaultBranch
            });
            if (ref) {
                // Inputs
                let inputs;
                const definedInputs = workflow.events.workflow_dispatch?.inputs;
                if (definedInputs) {
                    inputs = {};
                    for (const definedInput of Object.keys(definedInputs)) {
                        const value = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                            prompt: `Value for input ${definedInput} ${definedInputs[definedInput].required ? "[required]" : ""}`,
                            value: definedInputs[definedInput].default?.toString() || ""
                        });
                        if (!value && definedInputs[definedInput].required) {
                            return vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Input ${definedInput} is required`);
                        }
                        if (value) {
                            inputs[definedInput] = value;
                        }
                    }
                }
                try {
                    const relativeWorkflowPath = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.asRelativePath(workflowUri, false);
                    await gitHubRepoContext.client.actions.createWorkflowDispatch({
                        owner: gitHubRepoContext.owner,
                        repo: gitHubRepoContext.name,
                        workflow_id: relativeWorkflowPath,
                        ref,
                        inputs
                    });
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.setStatusBarMessage(`GitHub Actions: Workflow event dispatched`, 2000);
                }
                catch (error) {
                    return vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Could not create workflow dispatch: ${error?.message}`);
                }
            }
        }
        else if ((!selectedEvent || selectedEvent === "repository_dispatch") &&
            workflow.events.repository_dispatch !== undefined) {
            let event_type;
            const event_types = workflow.events.repository_dispatch.types;
            if (Array.isArray(event_types) && event_types?.length > 0) {
                const custom_type = "✐ Enter custom type";
                const selection = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick([custom_type, ...event_types], {
                    placeHolder: "Select an event_type to dispatch"
                });
                if (selection === undefined) {
                    return;
                }
                else if (selection != custom_type) {
                    event_type = selection;
                }
            }
            if (event_type === undefined) {
                event_type = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                    prompt: "Enter `event_type` to dispatch to the repository",
                    value: "default"
                });
            }
            if (event_type) {
                await gitHubRepoContext.client.repos.createDispatchEvent({
                    owner: gitHubRepoContext.owner,
                    repo: gitHubRepoContext.name,
                    event_type,
                    client_payload: {}
                });
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.setStatusBarMessage(`GitHub Actions: Repository event '${event_type}' dispatched`, 2000);
            }
        }
        return vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("github-actions.explorer.refresh");
    }));
}


/***/ }),

/***/ "./src/commands/unpinWorkflow.ts":
/*!***************************************!*\
  !*** ./src/commands/unpinWorkflow.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerUnPinWorkflow: () => (/* binding */ registerUnPinWorkflow)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _configuration_configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../configuration/configuration */ "./src/configuration/configuration.ts");
/* harmony import */ var _workflow_workflow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../workflow/workflow */ "./src/workflow/workflow.ts");



function registerUnPinWorkflow(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.workflow.unpin", async (args) => {
        const { gitHubRepoContext, wf } = args;
        if (!wf) {
            return;
        }
        const workflowFullPath = (0,_workflow_workflow__WEBPACK_IMPORTED_MODULE_2__.getWorkflowUri)(gitHubRepoContext, wf.path);
        if (!workflowFullPath) {
            return;
        }
        const relativeWorkflowPath = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.asRelativePath(workflowFullPath);
        await (0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_1__.unpinWorkflow)(relativeWorkflowPath);
        args.updateContextValue();
        // Refresh tree to reflect updated `pin/unpin` icon
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("github-actions.explorer.refresh");
    }));
}


/***/ }),

/***/ "./src/commands/variables/addVariable.ts":
/*!***********************************************!*\
  !*** ./src/commands/variables/addVariable.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerAddVariable: () => (/* binding */ registerAddVariable)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

function registerAddVariable(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.settings.variable.add", async (args) => {
        const { gitHubRepoContext } = args;
        const name = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: "Enter name for new variable",
            placeHolder: "Variable name",
            ignoreFocusOut: true
        });
        if (!name) {
            return;
        }
        const value = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: "Enter the new variable value",
            ignoreFocusOut: true
        });
        if (!value) {
            return;
        }
        try {
            if ("environment" in args) {
                await gitHubRepoContext.client.actions.createEnvironmentVariable({
                    repository_id: gitHubRepoContext.id,
                    environment_name: args.environment.name,
                    name,
                    value
                });
            }
            else {
                await gitHubRepoContext.client.actions.createRepoVariable({
                    owner: gitHubRepoContext.owner,
                    repo: gitHubRepoContext.name,
                    name,
                    value
                });
            }
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("github-actions.explorer.refresh");
    }));
}


/***/ }),

/***/ "./src/commands/variables/copyVariable.ts":
/*!************************************************!*\
  !*** ./src/commands/variables/copyVariable.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerCopyVariable: () => (/* binding */ registerCopyVariable)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

function registerCopyVariable(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.settings.variable.copy-name", async (args) => {
        const { variable } = args;
        await vscode__WEBPACK_IMPORTED_MODULE_0__.env.clipboard.writeText(variable.name);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.setStatusBarMessage(`Copied ${variable.name}`, 2000);
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.settings.variable.copy-value", async (args) => {
        const { variable } = args;
        await vscode__WEBPACK_IMPORTED_MODULE_0__.env.clipboard.writeText(variable.value);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.setStatusBarMessage(`Copied ${variable.value}`, 2000);
    }));
}


/***/ }),

/***/ "./src/commands/variables/deleteVariable.ts":
/*!**************************************************!*\
  !*** ./src/commands/variables/deleteVariable.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerDeleteVariable: () => (/* binding */ registerDeleteVariable)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

function registerDeleteVariable(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.settings.variable.delete", async (args) => {
        const { gitHubRepoContext, variable, environment } = args;
        const acceptText = "Yes, delete this variable";
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window
                .showInformationMessage(`Are you sure you want to delete ${variable.name}?`, {
                modal: true,
                detail: "Deleting this variable cannot be undone and may impact workflows in this repository"
            }, acceptText)
                .then(async (answer) => {
                if (answer === acceptText) {
                    if (environment) {
                        await gitHubRepoContext.client.request(`DELETE /repositories/${gitHubRepoContext.id}/environments/${environment.name}/variables/${variable.name}`);
                    }
                    else {
                        await gitHubRepoContext.client.actions.deleteRepoVariable({
                            owner: gitHubRepoContext.owner,
                            repo: gitHubRepoContext.name,
                            name: variable.name
                        });
                    }
                }
            });
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("github-actions.explorer.refresh");
    }));
}


/***/ }),

/***/ "./src/commands/variables/updateVariable.ts":
/*!**************************************************!*\
  !*** ./src/commands/variables/updateVariable.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerUpdateVariable: () => (/* binding */ registerUpdateVariable)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

function registerUpdateVariable(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.settings.variable.update", async (args) => {
        const { gitHubRepoContext, variable, environment } = args;
        const name = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: "Enter the new variable name",
            value: variable.name
        });
        const value = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: "Enter the new variable value",
            value: variable.value
        });
        if (name == variable.name && value == variable.value) {
            return;
        }
        const payload = {};
        if (name != variable.name) {
            payload.name = name;
        }
        if (value != variable.value) {
            payload.value = value;
        }
        try {
            if (environment) {
                await gitHubRepoContext.client.request(`PATCH /repositories/${gitHubRepoContext.id}/environments/${environment.name}/variables/${variable.name}`, payload);
            }
            else {
                await gitHubRepoContext.client.request(`PATCH /repos/${gitHubRepoContext.owner}/${gitHubRepoContext.name}/actions/variables/${variable.name}`, payload);
            }
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("github-actions.explorer.refresh");
    }));
}


/***/ }),

/***/ "./src/configuration/configuration.ts":
/*!********************************************!*\
  !*** ./src/configuration/configuration.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGitHubApiUri: () => (/* binding */ getGitHubApiUri),
/* harmony export */   getPinnedWorkflows: () => (/* binding */ getPinnedWorkflows),
/* harmony export */   getRemoteName: () => (/* binding */ getRemoteName),
/* harmony export */   initConfiguration: () => (/* binding */ initConfiguration),
/* harmony export */   isPinnedWorkflowsRefreshEnabled: () => (/* binding */ isPinnedWorkflowsRefreshEnabled),
/* harmony export */   onPinnedWorkflowsChange: () => (/* binding */ onPinnedWorkflowsChange),
/* harmony export */   pinWorkflow: () => (/* binding */ pinWorkflow),
/* harmony export */   pinnedWorkflowsRefreshInterval: () => (/* binding */ pinnedWorkflowsRefreshInterval),
/* harmony export */   unpinWorkflow: () => (/* binding */ unpinWorkflow),
/* harmony export */   useEnterprise: () => (/* binding */ useEnterprise)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _workflow_languageServer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../workflow/languageServer */ "./src/workflow/languageServer.ts");
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../git/repository */ "./src/git/repository.ts");



const settingsKey = "github-actions";
const DEFAULT_GITHUB_API = "https://api.github.com";
function initConfiguration(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(async (e) => {
        if (e.affectsConfiguration(getSettingsKey("workflows.pinned"))) {
            pinnedWorkflowsChangeHandlers.forEach(h => h());
        }
        else if (e.affectsConfiguration(getSettingsKey("use-enterprise")) ||
            (useEnterprise() &&
                (e.affectsConfiguration("github-enterprise.uri") || e.affectsConfiguration(getSettingsKey("remote-name"))))) {
            await updateLanguageServerApiUrl(context);
            (0,_git_repository__WEBPACK_IMPORTED_MODULE_2__.resetGitHubContext)();
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("github-actions.explorer.refresh");
        }
    }));
}
function getConfiguration() {
    return vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration();
}
function getSettingsKey(settingsPath) {
    return `${settingsKey}.${settingsPath}`;
}
const pinnedWorkflowsChangeHandlers = [];
function onPinnedWorkflowsChange(handler) {
    pinnedWorkflowsChangeHandlers.push(handler);
}
function getPinnedWorkflows() {
    return getConfiguration().get(getSettingsKey("workflows.pinned.workflows"), []);
}
async function pinWorkflow(workflow) {
    const pinedWorkflows = Array.from(new Set(getPinnedWorkflows()).add(workflow));
    await getConfiguration().update(getSettingsKey("workflows.pinned.workflows"), pinedWorkflows);
}
async function unpinWorkflow(workflow) {
    const x = new Set(getPinnedWorkflows());
    x.delete(workflow);
    const pinnedWorkflows = Array.from(x);
    await getConfiguration().update(getSettingsKey("workflows.pinned.workflows"), pinnedWorkflows);
}
function isPinnedWorkflowsRefreshEnabled() {
    return getConfiguration().get(getSettingsKey("workflows.pinned.refresh.enabled"), false);
}
function pinnedWorkflowsRefreshInterval() {
    return getConfiguration().get(getSettingsKey("workflows.pinned.refresh.interval"), 60);
}
function getRemoteName() {
    return getConfiguration().get(getSettingsKey("remote-name"), "origin");
}
function useEnterprise() {
    return getConfiguration().get(getSettingsKey("use-enterprise"), false);
}
function getGitHubApiUri() {
    if (!useEnterprise())
        return DEFAULT_GITHUB_API;
    const base = getConfiguration().get("github-enterprise.uri", DEFAULT_GITHUB_API).replace(/\/$/, "");
    return base === DEFAULT_GITHUB_API ? base : `${base}/api/v3`;
}
async function updateLanguageServerApiUrl(context) {
    await (0,_workflow_languageServer__WEBPACK_IMPORTED_MODULE_1__.deactivateLanguageServer)();
    await (0,_workflow_languageServer__WEBPACK_IMPORTED_MODULE_1__.initLanguageServer)(context);
}


/***/ }),

/***/ "./src/external/protocol.ts":
/*!**********************************!*\
  !*** ./src/external/protocol.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Protocol: () => (/* binding */ Protocol),
/* harmony export */   ProtocolType: () => (/* binding */ ProtocolType)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ssh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ssh */ "./src/external/ssh.ts");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


var ProtocolType;
(function (ProtocolType) {
    ProtocolType[ProtocolType["Local"] = 0] = "Local";
    ProtocolType[ProtocolType["HTTP"] = 1] = "HTTP";
    ProtocolType[ProtocolType["SSH"] = 2] = "SSH";
    ProtocolType[ProtocolType["GIT"] = 3] = "GIT";
    ProtocolType[ProtocolType["OTHER"] = 4] = "OTHER";
})(ProtocolType || (ProtocolType = {}));
class Protocol {
    get nameWithOwner() {
        return this.owner ? `${this.owner}/${this.repositoryName}` : this.repositoryName;
    }
    constructor(uriString) {
        this.type = ProtocolType.OTHER;
        this.host = "";
        this.owner = "";
        this.repositoryName = "";
        if (this.parseSshProtocol(uriString)) {
            return;
        }
        try {
            this.url = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.parse(uriString);
            this.type = this.getType(this.url.scheme);
            this.host = this.getHostName(this.url.authority);
            if (this.host) {
                this.repositoryName = this.getRepositoryName(this.url.path) || "";
                this.owner = this.getOwnerName(this.url.path) || "";
            }
        }
        catch (e) {
            // Logger.appendLine(`Failed to parse '${uriString}'`);
            void vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage(`Unable to parse remote '${uriString}'. Please check that it is correctly formatted.`);
        }
    }
    getType(scheme) {
        switch (scheme) {
            case "file":
                return ProtocolType.Local;
            case "http":
            case "https":
                return ProtocolType.HTTP;
            case "git":
                return ProtocolType.GIT;
            case "ssh":
                return ProtocolType.SSH;
            default:
                return ProtocolType.OTHER;
        }
    }
    parseSshProtocol(uriString) {
        const sshConfig = (0,_ssh__WEBPACK_IMPORTED_MODULE_1__.resolve)(uriString);
        if (!sshConfig) {
            return false;
        }
        const { HostName, path } = sshConfig;
        this.host = HostName;
        this.owner = this.getOwnerName(path) || "";
        this.repositoryName = this.getRepositoryName(path) || "";
        this.type = ProtocolType.SSH;
        return true;
    }
    getHostName(authority) {
        // <username>:<password>@<authority>:<port>
        const matches = /^(?:.*:?@)?([^:]*)(?::.*)?$/.exec(authority);
        if (matches && matches.length >= 2) {
            // normalize to fix #903.
            // www.github.com will redirect anyways, so this is safe in this specific case, but potentially not in others.
            return matches[1].toLocaleLowerCase() === "www.github.com" ? "github.com" : matches[1];
        }
        return "";
    }
    getRepositoryName(path) {
        let normalized = path.replace(/\\/g, "/");
        if (normalized.endsWith("/")) {
            normalized = normalized.substr(0, normalized.length - 1);
        }
        const lastIndex = normalized.lastIndexOf("/");
        const lastSegment = normalized.substr(lastIndex + 1);
        if (lastSegment === "" || lastSegment === "/") {
            return;
        }
        return lastSegment.replace(/\/$/, "").replace(/\.git$/, "");
    }
    getOwnerName(path) {
        let normalized = path.replace(/\\/g, "/");
        if (normalized.endsWith("/")) {
            normalized = normalized.substr(0, normalized.length - 1);
        }
        const fragments = normalized.split("/");
        if (fragments.length > 1) {
            return fragments[fragments.length - 2];
        }
        return;
    }
    normalizeUri() {
        if (this.type === ProtocolType.OTHER && !this.url) {
            return;
        }
        if (this.type === ProtocolType.Local) {
            return this.url;
        }
        let scheme = "https";
        if (this.url && (this.url.scheme === "http" || this.url.scheme === "https")) {
            scheme = this.url.scheme;
        }
        try {
            return vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.parse(`${scheme}://${this.host.toLocaleLowerCase()}/${this.nameWithOwner.toLocaleLowerCase()}`);
        }
        catch (e) {
            return;
        }
    }
    toString() {
        // based on Uri scheme for SSH https://tools.ietf.org/id/draft-salowey-secsh-uri-00.html#anchor1 and heuristics of how GitHub handles ssh url
        // sshUri        = `ssh:`
        //    - omitted
        // hier-part     =  "//" authority path-abempty
        //    - // is omitted
        // authority     = [ [ ssh-info ] "@" host ] [ ":" port]
        //   - ssh-info: git
        //   - host: ${this.host}
        //   - port: omitted
        // path-abempty  = <as specified in [RFC3986]>
        //   - we use relative path here `${this.owner}/${this.repositoryName}`
        if (this.type === ProtocolType.SSH) {
            return `git@${this.host}:${this.owner}/${this.repositoryName}`;
        }
        if (this.type === ProtocolType.GIT) {
            return `git://git@${this.host}:${this.owner}/${this.repositoryName}`;
        }
        const normalizedUri = this.normalizeUri();
        if (normalizedUri) {
            return normalizedUri.toString();
        }
        return;
    }
    update(change) {
        if (change.type) {
            this.type = change.type;
        }
        if (change.host) {
            this.host = change.host;
        }
        if (change.owner) {
            this.owner = change.owner;
        }
        if (change.repositoryName) {
            this.repositoryName = change.repositoryName;
        }
        return this;
    }
    equals(other) {
        const normalizeUri = this.normalizeUri();
        if (!normalizeUri) {
            return false;
        }
        const otherNormalizeUri = other.normalizeUri();
        if (!otherNormalizeUri) {
            return false;
        }
        return normalizeUri.toString().toLocaleLowerCase() === otherNormalizeUri.toString().toLocaleLowerCase();
    }
}


/***/ }),

/***/ "./src/external/ssh.ts":
/*!*****************************!*\
  !*** ./src/external/ssh.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Resolvers: () => (/* binding */ Resolvers),
/* harmony export */   resolve: () => (/* binding */ resolve),
/* harmony export */   resolverFromConfig: () => (/* binding */ resolverFromConfig)
/* harmony export */ });
/* harmony import */ var ssh_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssh-config */ "./node_modules/ssh-config/index.js");
/* harmony import */ var ssh_config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ssh_config__WEBPACK_IMPORTED_MODULE_0__);

const SSH_URL_RE = /^(?:([^@:]+)@)?([^:/]+):?(.+)$/;
const URL_SCHEME_RE = /^([a-z-]+):\/\//;
/**
 * Parse and resolve an SSH url. Resolves host aliases using the configuration
 * specified by ~/.ssh/config, if present.
 *
 * Examples:
 *
 *    resolve("git@github.com:Microsoft/vscode")
 *      {
 *        Host: 'github.com',
 *        HostName: 'github.com',
 *        User: 'git',
 *        path: 'Microsoft/vscode',
 *      }
 *
 *    resolve("hub:queerviolet/vscode", resolverFromConfig("Host hub\n  HostName github.com\n  User git\n"))
 *      {
 *        Host: 'hub',
 *        HostName: 'github.com',
 *        User: 'git',
 *        path: 'queerviolet/vscode',
 *      }
 *
 * @param {string} url the url to parse
 * @param {ConfigResolver?} resolveConfig ssh config resolver (default: from ~/.ssh/config)
 * @returns {Config}
 */
const resolve = (url, resolveConfig = Resolvers.current) => {
    const config = parse(url);
    return config && resolveConfig(config);
};
class Resolvers {
    static fromConfig(conf) {
        return chainResolvers(baseResolver, resolverFromConfig(conf));
    }
}
Resolvers.default = chainResolvers(baseResolver /*, resolverFromConfigFile()*/);
Resolvers.current = Resolvers.default;
const parse = (url) => {
    const urlMatch = URL_SCHEME_RE.exec(url);
    if (urlMatch) {
        const [fullSchemePrefix, scheme] = urlMatch;
        if (scheme === "ssh") {
            url = url.slice(fullSchemePrefix.length);
        }
        else {
            return;
        }
    }
    const match = SSH_URL_RE.exec(url);
    if (!match) {
        return;
    }
    const [, User, Host, path] = match;
    return { User, Host, path };
};
function baseResolver(config) {
    return {
        ...config,
        HostName: config.Host
    };
}
// Temporarily disable this to remove `fs` dependency
// function resolverFromConfigFile(
//   configPath = join(homedir(), ".ssh", "config")
// ): ConfigResolver | undefined {
//   try {
//     const config = readFileSync(configPath).toString();
//     return resolverFromConfig(config);
//   } catch (error) {
//     // Logger.appendLine(`${configPath}: ${error.message}`);
//   }
// }
function resolverFromConfig(text) {
    // This causes many linter issues, ignore them in whole file for now
    const config = (0,ssh_config__WEBPACK_IMPORTED_MODULE_0__.parse)(text);
    return h => config.compute(h.Host);
}
function chainResolvers(...chain) {
    const resolvers = chain.filter(x => !!x);
    return (config) => resolvers.reduce((resolved, next) => ({
        ...resolved,
        ...next(resolved)
    }), config);
}


/***/ }),

/***/ "./src/git/repository-permissions.ts":
/*!*******************************************!*\
  !*** ./src/git/repository-permissions.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getRepositoryPermission: () => (/* binding */ getRepositoryPermission),
/* harmony export */   hasAdminPermission: () => (/* binding */ hasAdminPermission),
/* harmony export */   hasWritePermission: () => (/* binding */ hasWritePermission)
/* harmony export */ });
function getRepositoryPermission(permissions) {
    return permissions?.admin ? "admin" : permissions?.push ? "write" : "read";
}
function hasAdminPermission(permission) {
    return permission === "admin";
}
function hasWritePermission(permission) {
    return permission === "admin" || permission === "write";
}


/***/ }),

/***/ "./src/git/repository.ts":
/*!*******************************!*\
  !*** ./src/git/repository.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCurrentBranch: () => (/* binding */ getCurrentBranch),
/* harmony export */   getGitHead: () => (/* binding */ getGitHead),
/* harmony export */   getGitHubContext: () => (/* binding */ getGitHubContext),
/* harmony export */   getGitHubContextForDocumentUri: () => (/* binding */ getGitHubContextForDocumentUri),
/* harmony export */   getGitHubContextForRepo: () => (/* binding */ getGitHubContextForRepo),
/* harmony export */   getGitHubContextForWorkspaceUri: () => (/* binding */ getGitHubContextForWorkspaceUri),
/* harmony export */   getGitHubUrls: () => (/* binding */ getGitHubUrls),
/* harmony export */   resetGitHubContext: () => (/* binding */ resetGitHubContext)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/canReachGitHubAPI */ "./src/api/canReachGitHubAPI.ts");
/* harmony import */ var _api_handleSamlError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/handleSamlError */ "./src/api/handleSamlError.ts");
/* harmony import */ var _auth_auth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../auth/auth */ "./src/auth/auth.ts");
/* harmony import */ var _configuration_configuration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../configuration/configuration */ "./src/configuration/configuration.ts");
/* harmony import */ var _external_protocol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../external/protocol */ "./src/external/protocol.ts");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../log */ "./src/log.ts");
/* harmony import */ var _repository_permissions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./repository-permissions */ "./src/git/repository-permissions.ts");









async function getGitExtension() {
    const gitExtension = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension("vscode.git");
    if (gitExtension) {
        if (!gitExtension.isActive) {
            await gitExtension.activate();
        }
        const git = gitExtension.exports.getAPI(1);
        if (git.state !== "initialized") {
            // Wait for the plugin to be initialized
            await new Promise(resolve => {
                if (git.state === "initialized") {
                    resolve();
                }
                else {
                    const listener = git.onDidChangeState(state => {
                        if (state === "initialized") {
                            resolve();
                        }
                        listener.dispose();
                    });
                }
            });
        }
        return git;
    }
}
async function getGitHead() {
    const git = await getGitExtension();
    if (git && git.repositories.length > 0) {
        const head = git.repositories[0].state.HEAD;
        if (head && head.name && head.type === 0 /* RefType.Head */) {
            return `refs/heads/${head.name}`;
        }
    }
}
async function getGitHubUrls() {
    const git = await getGitExtension();
    if (git && git.repositories.length > 0) {
        (0,_log__WEBPACK_IMPORTED_MODULE_6__.logDebug)("Found git extension");
        const remoteName = (0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_4__.getRemoteName)();
        const p = await Promise.all(git.repositories.map(async (r) => {
            (0,_log__WEBPACK_IMPORTED_MODULE_6__.logDebug)("Find `origin` remote for repository", r.rootUri.path);
            await r.status();
            // Try to get "origin" remote first
            let remote = r.state.remotes.filter(remote => remote.name === remoteName);
            // If "origin" does not exist, automatically get another remote
            if (r.state.remotes.length !== 0 && remote.length === 0) {
                remote = [r.state.remotes[0]];
            }
            if (remote.length > 0 &&
                (remote[0].pushUrl?.indexOf("github.com") !== -1 ||
                    ((0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_4__.useEnterprise)() && remote[0].pushUrl?.indexOf(new URL((0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_4__.getGitHubApiUri)()).host) !== -1))) {
                const url = remote[0].pushUrl;
                return {
                    workspaceUri: r.rootUri,
                    url,
                    protocol: new _external_protocol__WEBPACK_IMPORTED_MODULE_5__.Protocol(url)
                };
            }
            (0,_log__WEBPACK_IMPORTED_MODULE_6__.logDebug)(`Remote "${remoteName}" not found, skipping repository`);
            return undefined;
        }));
        return p.filter(x => !!x);
    }
    // If we cannot find the git extension, assume for now that we are running a web context,
    // for instance, github.dev. I think ideally we'd check the workspace URIs first, but this
    // works for now. We'll revisit later.
    // if (!git) {
    // Support for virtual workspaces
    const isVirtualWorkspace = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders && vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders.every(f => f.uri.scheme !== "file");
    if (isVirtualWorkspace) {
        (0,_log__WEBPACK_IMPORTED_MODULE_6__.logDebug)("Found virtual workspace");
        const ghFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.find(x => x.uri.scheme === "vscode-vfs" && x.uri.authority === "github");
        if (ghFolder) {
            (0,_log__WEBPACK_IMPORTED_MODULE_6__.logDebug)("Found virtual GitHub workspace folder");
            const url = `https://github.com/${ghFolder.uri.path}`;
            const urls = [
                {
                    workspaceUri: ghFolder.uri,
                    url: url,
                    protocol: new _external_protocol__WEBPACK_IMPORTED_MODULE_5__.Protocol(url)
                }
            ];
            return urls;
        }
    }
    return null;
}
let gitHubContext;
async function getGitHubContext() {
    if (gitHubContext) {
        return gitHubContext;
    }
    if (!(await (0,_api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__.canReachGitHubAPI)())) {
        (0,_log__WEBPACK_IMPORTED_MODULE_6__.logError)(new Error("Cannot fetch github context"));
        return undefined;
    }
    try {
        const git = await getGitExtension();
        const allProtocolInfos = await getGitHubUrls();
        // Filter out wiki repositories because the GET call will fail and throw an error
        const protocolInfos = allProtocolInfos?.filter(info => !info.protocol.repositoryName.match(/\.wiki$/));
        if (!protocolInfos) {
            (0,_log__WEBPACK_IMPORTED_MODULE_6__.logDebug)("Could not get protocol infos");
            return undefined;
        }
        (0,_log__WEBPACK_IMPORTED_MODULE_6__.logDebug)("Found protocol infos", protocolInfos.length.toString());
        const session = await (0,_auth_auth__WEBPACK_IMPORTED_MODULE_3__.getSession)();
        if (!session) {
            // User is not signed in, getSession will prompt them to sign in
            return undefined;
        }
        const username = session.account.label;
        const repos = await (0,_api_handleSamlError__WEBPACK_IMPORTED_MODULE_2__.handleSamlError)(session, async (client) => {
            return await Promise.all(protocolInfos.map(async (protocolInfo) => {
                (0,_log__WEBPACK_IMPORTED_MODULE_6__.logDebug)("Getting infos for repository", protocolInfo.url);
                const repoInfo = await client.repos.get({
                    repo: protocolInfo.protocol.repositoryName,
                    owner: protocolInfo.protocol.owner
                });
                const repo = git && git.getRepository(protocolInfo.workspaceUri);
                return {
                    workspaceUri: protocolInfo.workspaceUri,
                    client,
                    repositoryState: repo?.state,
                    name: protocolInfo.protocol.repositoryName,
                    owner: protocolInfo.protocol.owner,
                    id: repoInfo.data.id,
                    defaultBranch: `refs/heads/${repoInfo.data.default_branch}`,
                    organizationOwned: repoInfo.data.owner.type === "Organization",
                    permissionLevel: (0,_repository_permissions__WEBPACK_IMPORTED_MODULE_7__.getRepositoryPermission)(repoInfo.data.permissions)
                };
            }));
        });
        gitHubContext = Promise.resolve({
            repos,
            reposByUri: new Map(repos.map(r => [r.workspaceUri.toString(), r])),
            reposByOwnerAndName: new Map(repos.map(r => [`${r.owner}/${r.name}`.toLocaleLowerCase(), r])),
            username
        });
    }
    catch (e) {
        // Reset the context so the next attempt will try this flow again
        gitHubContext = undefined;
        (0,_log__WEBPACK_IMPORTED_MODULE_6__.logError)(e, "Error getting GitHub context");
        // Rethrow original error
        throw e;
    }
    return gitHubContext;
}
function resetGitHubContext() {
    gitHubContext = undefined;
}
async function getGitHubContextForRepo(owner, name) {
    const gitHubContext = await getGitHubContext();
    if (!gitHubContext) {
        return undefined;
    }
    const searchKey = `${owner}/${name}`.toLocaleLowerCase();
    return gitHubContext.reposByOwnerAndName.get(searchKey);
}
async function getGitHubContextForWorkspaceUri(workspaceUri) {
    const gitHubContext = await getGitHubContext();
    if (!gitHubContext) {
        return undefined;
    }
    return gitHubContext.reposByUri.get(workspaceUri.toString());
}
async function getGitHubContextForDocumentUri(documentUri) {
    const gitHubContext = await getGitHubContext();
    if (!gitHubContext) {
        return undefined;
    }
    const workspaceUri = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getWorkspaceFolder(documentUri);
    if (!workspaceUri) {
        return;
    }
    return getGitHubContextForWorkspaceUri(workspaceUri.uri);
}
function getCurrentBranch(state) {
    if (!state) {
        return;
    }
    const head = state.HEAD;
    if (!head) {
        return;
    }
    if (head.type != 0 /* RefType.Head */) {
        return;
    }
    return head.name;
}


/***/ }),

/***/ "./src/log.ts":
/*!********************!*\
  !*** ./src/log.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   logDebug: () => (/* binding */ logDebug),
/* harmony export */   logError: () => (/* binding */ logError),
/* harmony export */   revealLog: () => (/* binding */ revealLog)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
})(LogLevel || (LogLevel = {}));
let logger;
const level =  false ? 0 : LogLevel.Debug;
function init() {
    logger = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createOutputChannel("GitHub Actions");
}
function log(...values) {
    logger.appendLine(values.join(" "));
}
function logDebug(...values) {
    if (level > LogLevel.Debug) {
        return;
    }
    logger.appendLine(values.join(" "));
}
function logError(e, ...values) {
    logger.appendLine(values.join(" "));
    logger.appendLine(e.message);
    if (e.stack) {
        logger.appendLine(e.stack);
    }
}
function revealLog() {
    logger.show();
}


/***/ }),

/***/ "./src/logs/constants.ts":
/*!*******************************!*\
  !*** ./src/logs/constants.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LogScheme: () => (/* binding */ LogScheme)
/* harmony export */ });
const LogScheme = "gh-actions";


/***/ }),

/***/ "./src/logs/fileProvider.ts":
/*!**********************************!*\
  !*** ./src/logs/fileProvider.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowStepLogProvider: () => (/* binding */ WorkflowStepLogProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../git/repository */ "./src/git/repository.ts");
/* harmony import */ var _logInfo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logInfo */ "./src/logs/logInfo.ts");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model */ "./src/logs/model.ts");
/* harmony import */ var _scheme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scheme */ "./src/logs/scheme.ts");





class WorkflowStepLogProvider {
    constructor() {
        this.onDidChangeEmitter = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.onDidChange = this.onDidChangeEmitter.event;
    }
    async provideTextDocumentContent(uri) {
        const { owner, repo, jobId } = (0,_scheme__WEBPACK_IMPORTED_MODULE_4__.parseUri)(uri);
        const githubRepoContext = await (0,_git_repository__WEBPACK_IMPORTED_MODULE_1__.getGitHubContextForRepo)(owner, repo);
        if (!githubRepoContext) {
            throw new Error("Could not load logs");
        }
        try {
            const result = await githubRepoContext?.client.actions.downloadJobLogsForWorkflowRun({
                owner: owner,
                repo: repo,
                job_id: jobId
            });
            const log = result.data;
            const logInfo = (0,_model__WEBPACK_IMPORTED_MODULE_3__.parseLog)(log);
            (0,_logInfo__WEBPACK_IMPORTED_MODULE_2__.cacheLogInfo)(uri, logInfo);
            return logInfo.updatedLogLines.join("\n");
        }
        catch (e) {
            const respErr = e;
            if (respErr.status === 410) {
                (0,_logInfo__WEBPACK_IMPORTED_MODULE_2__.cacheLogInfo)(uri, {
                    sections: [],
                    updatedLogLines: [],
                    styleFormats: []
                });
                return "Could not open logs, they are expired.";
            }
            console.error("Error loading logs", e);
            return `Could not open logs, unhandled error. ${e.message}`;
        }
    }
}


/***/ }),

/***/ "./src/logs/foldingProvider.ts":
/*!*************************************!*\
  !*** ./src/logs/foldingProvider.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowStepLogFoldingProvider: () => (/* binding */ WorkflowStepLogFoldingProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logInfo */ "./src/logs/logInfo.ts");


class WorkflowStepLogFoldingProvider {
    provideFoldingRanges(document) {
        const logInfo = (0,_logInfo__WEBPACK_IMPORTED_MODULE_1__.getLogInfo)(document.uri);
        if (!logInfo) {
            return [];
        }
        return logInfo.sections.map(s => new vscode__WEBPACK_IMPORTED_MODULE_0__.FoldingRange(s.start, s.end, vscode__WEBPACK_IMPORTED_MODULE_0__.FoldingRangeKind.Region));
    }
}


/***/ }),

/***/ "./src/logs/formatProvider.ts":
/*!************************************!*\
  !*** ./src/logs/formatProvider.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateDecorations: () => (/* binding */ updateDecorations)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser */ "./src/logs/parser.ts");


const timestampRE = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{7}Z/;
const timestampDecorationType = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createTextEditorDecorationType({
    color: "#99999959"
});
function updateDecorations(activeEditor, logInfo) {
    if (!activeEditor) {
        return;
    }
    // Decorate timestamps
    const numberOfLines = activeEditor.document.lineCount;
    activeEditor.setDecorations(timestampDecorationType, Array.from(Array(numberOfLines).keys())
        .filter(i => {
        const line = activeEditor.document.lineAt(i).text;
        return timestampRE.test(line);
    })
        .map(i => ({
        range: new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(i, 0, i, 28) // timestamps always have 28 chars
    })));
    // Custom decorations
    const decoratorTypes = {};
    for (let lineNo = 0; lineNo < logInfo.updatedLogLines.length; lineNo++) {
        // .filter() preserves the order of the array
        const lineStyles = logInfo.styleFormats.filter(style => style.line == lineNo);
        let pos = 0;
        for (let styleNo = 0; styleNo < lineStyles.length; styleNo++) {
            const styleInfo = lineStyles[styleNo];
            const endPos = pos + styleInfo.content.length;
            const range = new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(lineNo, pos, lineNo, endPos);
            pos = endPos;
            if (styleInfo.style) {
                const key = _parser__WEBPACK_IMPORTED_MODULE_1__.Parser.styleKey(styleInfo.style);
                let fgHex = "";
                let bgHex = "";
                // Convert to hex colors if RGB-formatted, or use lookup for predefined colors
                if (styleInfo.style.isFgRGB) {
                    const rgbValues = styleInfo.style.fg.split(",");
                    fgHex = rgbToHex(rgbValues);
                }
                else {
                    fgHex = _parser__WEBPACK_IMPORTED_MODULE_1__.VSCodeDefaultColors[styleInfo.style.fg] ?? "";
                }
                if (styleInfo.style.isBgRGB) {
                    const rgbValues = styleInfo.style.bg.split(",");
                    bgHex = rgbToHex(rgbValues);
                }
                else {
                    bgHex = _parser__WEBPACK_IMPORTED_MODULE_1__.VSCodeDefaultColors[styleInfo.style.bg] ?? "";
                }
                if (!decoratorTypes[key]) {
                    decoratorTypes[key] = {
                        type: vscode__WEBPACK_IMPORTED_MODULE_0__.window.createTextEditorDecorationType({
                            color: fgHex,
                            backgroundColor: bgHex,
                            fontWeight: styleInfo.style.bold ? "bold" : "normal",
                            fontStyle: styleInfo.style.italic ? "italic" : "normal",
                            textDecoration: styleInfo.style.underline ? "underline" : ""
                        }),
                        ranges: [range]
                    };
                }
                else {
                    decoratorTypes[key].ranges.push(range);
                }
            }
        }
    }
    for (const decoratorType of Object.values(decoratorTypes)) {
        activeEditor.setDecorations(decoratorType.type, decoratorType.ranges);
    }
}
function rgbToHex(rgbValues) {
    let hex = "";
    if (rgbValues.length == 3) {
        hex = "#";
        for (let i = 0; i < 3; i++) {
            hex = hex.concat(parseInt(rgbValues[i]).toString(16).padStart(2, "0"));
        }
    }
    return hex;
}


/***/ }),

/***/ "./src/logs/logInfo.ts":
/*!*****************************!*\
  !*** ./src/logs/logInfo.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cacheLogInfo: () => (/* binding */ cacheLogInfo),
/* harmony export */   getLogInfo: () => (/* binding */ getLogInfo)
/* harmony export */ });
const cache = new Map();
function cacheLogInfo(uri, logInfo) {
    cache.set(uri.toString(), logInfo);
}
function getLogInfo(uri) {
    return cache.get(uri.toString());
}


/***/ }),

/***/ "./src/logs/model.ts":
/*!***************************!*\
  !*** ./src/logs/model.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseLog: () => (/* binding */ parseLog)
/* harmony export */ });
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser */ "./src/logs/parser.ts");
// eslint-disable-next-line no-control-regex
const ansiColorRegex = /\u001b\[(\d+;?)+m/gm;
const groupMarker = "##[group]";

function parseLog(log) {
    let firstSection = {
        name: "Setup",
        start: 0,
        end: 1
    };
    // Assume there is always the setup section
    const sections = [firstSection];
    let currentRange = null;
    const parser = new _parser__WEBPACK_IMPORTED_MODULE_0__.Parser();
    const styleInfo = [];
    const lines = log.split(/\n|\r/).filter(l => !!l);
    let lineIdx = 0;
    for (const line of lines) {
        // Groups
        const groupMarkerStart = line.indexOf(groupMarker);
        if (groupMarkerStart !== -1) {
            // If this is the first group marker we encounter, the previous range was the job setup
            if (firstSection) {
                firstSection.end = lineIdx - 1;
                firstSection = null;
            }
            if (currentRange) {
                currentRange.end = lineIdx - 1;
                sections.push(currentRange);
            }
            const name = line.substring(groupMarkerStart + groupMarker.length);
            currentRange = {
                name,
                start: lineIdx,
                end: lineIdx + 1
            };
        }
        const stateFragments = parser.getStates(line);
        for (const state of stateFragments) {
            styleInfo.push({
                line: lineIdx,
                content: state.output,
                style: state.style
            });
        }
        // Remove all other commands and codes from the output, we don't support those
        lines[lineIdx] = line.replace(ansiColorRegex, "");
        ++lineIdx;
    }
    if (currentRange) {
        currentRange.end = lineIdx - 1;
        sections.push(currentRange);
    }
    return {
        updatedLogLines: lines,
        sections: sections,
        styleFormats: styleInfo
    };
}


/***/ }),

/***/ "./src/logs/parser.ts":
/*!****************************!*\
  !*** ./src/logs/parser.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Parser: () => (/* binding */ Parser),
/* harmony export */   URLRegex: () => (/* binding */ URLRegex),
/* harmony export */   VSCodeDefaultColors: () => (/* binding */ VSCodeDefaultColors)
/* harmony export */ });
// #region ANSI section
const ESC = "\u001b";
const BrightClassPostfix = "-br";
// match characters that could be enclosing url to cleanly handle url formatting
const URLRegex = /([{([]*https?:\/\/[a-z0-9]+(?:-[a-z0-9]+)*\.[^\s<>|'",]{2,})/gi;
/**
 * Regex for matching ANSI escape codes
 * \u001b - ESC character
 * ?: Non-capturing group
 * (?:\u001b[) : Match ESC[
 * (?:[\?|#])??: Match also ? and # formats that we don't supports but want to eat our special characters to get rid of ESC character
 * (?:[0-9]{1,3})?: Match one or more occurrences of the simple format we want with out semicolon
 * (?:(?:;[0-9]{0,3})*)?: Match one or more occurrences of the format we want with semicolon
 */
// eslint-disable-next-line no-control-regex
const _ansiEscapeCodeRegex = /(?:\u001b\[)(?:[?|#])?(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-Z|a-z])/;
/**
 * https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters
 * We support sequences of format:
 *  Esc[CONTENTHEREm
 *  Where CONTENTHERE can be of format: VALUE;VALUE;VALUE or VALUE
 *      Where VALUE is SGR parameter https://www.vt100.net/docs/vt510-rm/SGR
 *          We support: 0 (reset), 1 (bold), 3 (italic), 4 (underline), 22 (not bold), 23 (not italic), 24 (not underline), 38 (set fg), 39 (default fg), 48 (set bg), 49 (default bg),
 *                      fg colors - 30 (black), 31 (red), 32 (green), 33 (yellow), 34 (blue), 35 (magenta), 36 (cyan), 37 (white), 90 (grey)
 *                        with more brightness - 91 (red), 92 (green), 93 (yellow), 94 (blue), 95 (magenta), 96 (cyan), 97 (white)
 *                      bg colors - 40 (black), 41 (red), 42 (green), 43 (yellow), 44 (blue), 45 (magenta), 46 (cyan), 47 (white), 100 (grey)
 *                        with more brightness- 101 (red), 102 (green), 103 (yellow), 104 (blue), 105 (magenta), 106 (cyan), 107 (white)
 *  Where m refers to the "Graphics mode"
 *
 * 8-bit color is supported
 *  https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit
 *  Esc[38;5;<n> To set the foreground color
 *  Esc[48;5;<n> To set the background color
 *  n can be from 0-255
 *  0-7 are standard colors that match the 4_bit color palette
 *  8-15 are high intensity colors that match the 4_bit high intensity color palette
 *  16-231 are 216 colors that cover the entire spectrum
 *  232-255 are grayscale colors that go from black to white in 24 steps
 *
 * 24-bit color is also supported
 *  https://en.wikipedia.org/wiki/ANSI_escape_code#24-bit
 *  Esc[38;2;<r>;<g>;<b> To set the foreground color
 *  Esc[48;2;<r>;<g>;<b> To set the background color
 *  Where r,g and b must be between 0-255
 */
// #endregion ANSI section
// #region commands
var Resets;
(function (Resets) {
    Resets["Reset"] = "0";
    Resets["Bold"] = "22";
    Resets["Italic"] = "23";
    Resets["Underline"] = "24";
    Resets["Set_Fg"] = "38";
    Resets["Default_Fg"] = "39";
    Resets["Set_Bg"] = "48";
    Resets["Default_Bg"] = "49";
})(Resets || (Resets = {}));
const specials = {
    "1": "bold",
    "3": "italic",
    "4": "underline"
};
const bgColors = {
    // 40 (black), 41 (red), 42 (green), 43 (yellow), 44 (blue), 45 (magenta), 46 (cyan), 47 (white), 100 (grey)
    "40": "b",
    "41": "r",
    "42": "g",
    "43": "y",
    "44": "bl",
    "45": "m",
    "46": "c",
    "47": "w",
    "100": "gr"
};
const fgColors = {
    // 30 (black), 31 (red), 32 (green), 33 (yellow), 34 (blue), 35 (magenta), 36 (cyan), 37 (white), 90 (grey)
    "30": "b",
    "31": "r",
    "32": "g",
    "33": "y",
    "34": "bl",
    "35": "m",
    "36": "c",
    "37": "w",
    "90": "gr"
};
const base8BitColors = {
    // 0 (black), 1 (red), 2 (green), 3 (yellow), 4 (blue), 5 (magenta), 6 (cyan), 7 (white), 8 (grey)
    "0": "b",
    "1": "r",
    "2": "g",
    "3": "y",
    "4": "bl",
    "5": "m",
    "6": "c",
    "7": "w"
};
// VS Code default values taken from this table: https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit
const VSCodeDefaultColors = {
    b: "#000000",
    r: "#cd3131",
    g: "#0dbc79",
    y: "#e5e510",
    bl: "#2472c8",
    m: "#bc3fbc",
    c: "#11a8cd",
    w: "#e5e5e5",
    gr: "#666666",
    "b-br": "#666666",
    "r-br": "#f14c4c",
    "g-br": "#23d18b",
    "y-br": "#f5f543",
    "bl-br": "#3b8eea",
    "m-br": "#d670d6",
    "c-br": "#21b8db",
    "w-br": "#e5e5e5" // '97/107',
};
//0-255 in 6 increments, used to generate 216 equally incrementing colors
const colorIncrements216 = {
    0: 0,
    1: 51,
    2: 102,
    3: 153,
    4: 204,
    5: 255
};
class Parser {
    /**
     * Parses the content into ANSI states
     * @param content content to parse
     */
    getStates(content) {
        const result = [];
        // Eg: "ESC[0KESC[33;1mWorker informationESC[0m
        if (!_ansiEscapeCodeRegex.test(content)) {
            // Not of interest, don't touch content
            return [
                {
                    output: content
                }
            ];
        }
        let command = "";
        let currentText = "";
        let code = "";
        let state = {};
        let isCommandActive = false;
        let codes = [];
        for (let index = 0; index < content.length; index++) {
            const character = content[index];
            if (isCommandActive) {
                if (character === ";") {
                    if (code) {
                        codes.push(code);
                        code = "";
                    }
                }
                else if (character === "m") {
                    if (code) {
                        isCommandActive = false;
                        // done
                        codes.push(code);
                        state.style = state.style || {};
                        let setForeground = false;
                        let setBackground = false;
                        let isSingleColorCode = false;
                        let isRGBColorCode = false;
                        const rgbColors = [];
                        for (const currentCode of codes) {
                            const style = state.style;
                            const codeNumber = parseInt(currentCode);
                            if (setForeground && isSingleColorCode) {
                                // set foreground color using 8-bit (256 color) palette - Esc[ 38:5:<n> m
                                if (codeNumber >= 0 && codeNumber < 16) {
                                    style.fg = this._get8BitColorClasses(codeNumber);
                                }
                                else if (codeNumber >= 16 && codeNumber < 256) {
                                    style.fg = this._get8BitRGBColors(codeNumber);
                                    style.isFgRGB = true;
                                }
                                setForeground = false;
                                isSingleColorCode = false;
                            }
                            else if (setForeground && isRGBColorCode) {
                                // set foreground color using 24-bit (true color) palette - Esc[ 38:2:<r>:<g>:<b> m
                                if (codeNumber >= 0 && codeNumber < 256) {
                                    rgbColors.push(codeNumber);
                                    if (rgbColors.length === 3) {
                                        style.fg = `${rgbColors[0]},${rgbColors[1]},${rgbColors[2]}`;
                                        style.isFgRGB = true;
                                        rgbColors.length = 0; // clear array
                                        setForeground = false;
                                        isRGBColorCode = false;
                                    }
                                }
                            }
                            else if (setBackground && isSingleColorCode) {
                                // set background color using 8-bit (256 color) palette - Esc[ 48:5:<n> m
                                if (codeNumber >= 0 && codeNumber < 16) {
                                    style.bg = this._get8BitColorClasses(codeNumber);
                                }
                                else if (codeNumber >= 16 && codeNumber < 256) {
                                    style.bg = this._get8BitRGBColors(codeNumber);
                                    style.isBgRGB = true;
                                }
                                setBackground = false;
                                isSingleColorCode = false;
                            }
                            else if (setBackground && isRGBColorCode) {
                                // set background color using 24-bit (true color) palette - Esc[ 48:2:<r>:<g>:<b> m
                                if (codeNumber >= 0 && codeNumber < 256) {
                                    rgbColors.push(codeNumber);
                                    if (rgbColors.length === 3) {
                                        style.bg = `${rgbColors[0]},${rgbColors[1]},${rgbColors[2]}`;
                                        style.isBgRGB = true;
                                        rgbColors.length = 0; // clear array
                                        setBackground = false;
                                        isRGBColorCode = false;
                                    }
                                }
                            }
                            else if (setForeground || setBackground) {
                                if (codeNumber === 5) {
                                    isSingleColorCode = true;
                                }
                                else if (codeNumber === 2) {
                                    isRGBColorCode = true;
                                }
                            }
                            else if (fgColors[currentCode]) {
                                style.fg = fgColors[currentCode];
                            }
                            else if (bgColors[currentCode]) {
                                style.bg = bgColors[currentCode];
                            }
                            else if (currentCode === Resets.Reset) {
                                // reset
                                state.style = {};
                            }
                            else if (currentCode === Resets.Set_Bg) {
                                setBackground = true;
                            }
                            else if (currentCode === Resets.Set_Fg) {
                                setForeground = true;
                            }
                            else if (currentCode === Resets.Default_Fg) {
                                style.fg = "";
                            }
                            else if (currentCode === Resets.Default_Bg) {
                                style.bg = "";
                            }
                            else if (codeNumber >= 91 && codeNumber <= 97) {
                                style.fg = fgColors[codeNumber - 60] + BrightClassPostfix;
                            }
                            else if (codeNumber >= 101 && codeNumber <= 107) {
                                style.bg = bgColors[codeNumber - 60] + BrightClassPostfix;
                            }
                            else if (specials[currentCode]) {
                                style[specials[currentCode]] = true;
                            }
                            else if (currentCode === Resets.Bold) {
                                style.bold = false;
                            }
                            else if (currentCode === Resets.Italic) {
                                style.italic = false;
                            }
                            else if (currentCode === Resets.Underline) {
                                style.underline = false;
                            }
                        }
                        // clear
                        command = "";
                        currentText = "";
                        code = "";
                    }
                    else {
                        // To handle ESC[m, we should just ignore them
                        isCommandActive = false;
                        command = "";
                        state.style = {};
                    }
                    codes = [];
                }
                else if (isNaN(parseInt(character))) {
                    // if this is not a number, eg: 0K, this isn't something we support
                    code = "";
                    isCommandActive = false;
                    command = "";
                }
                else if (code.length === 4) {
                    // we probably got code that we don't support, ignore
                    code = "";
                    isCommandActive = false;
                    if (character !== ESC) {
                        // if this is not an ESC, let's not consider command from now on
                        // eg: ESC[0Ksometexthere, at this point, code would be 0K, character would be 's'
                        command = "";
                        currentText += character;
                    }
                }
                else {
                    code += character;
                }
                continue;
            }
            else if (command) {
                if (command === ESC && character === "[") {
                    isCommandActive = true;
                    // push state
                    if (currentText) {
                        state.output = currentText;
                        result.push(state);
                        // deep copy existing style for the line to preserve different styles between commands
                        let previousStyle;
                        if (state.style) {
                            previousStyle = Object.assign({}, state.style);
                        }
                        state = {};
                        if (previousStyle) {
                            state.style = previousStyle;
                        }
                        currentText = "";
                    }
                }
                continue;
            }
            if (character === ESC) {
                command = character;
            }
            else {
                currentText += character;
            }
        }
        // still pending text
        if (currentText) {
            state.output = currentText + (command ? command : "");
            result.push(state);
        }
        return result;
    }
    /**
     * Gets a unique key for each style
     * @param style style to get key for
     * @returns a string that is guaranteed to be unique for every different style
     */
    static styleKey(style) {
        const fg = style.fg ?? "-";
        const bg = style.bg ?? "-";
        const bold = style.bold ? "b" : "n";
        const ital = style.italic ? "i" : "n";
        const underline = style.underline ? "u" : "n";
        return fg + bg + bold + ital + underline;
    }
    /**
     * With 8 bit colors, from 16-256, rgb color combinations are used
     * 16-231 (216 colors) is a 6 x 6 x 6 color cube
     * 232 - 256 are grayscale colors
     * @param codeNumber 16-256 number
     */
    _get8BitRGBColors(codeNumber) {
        let rgbColor;
        if (codeNumber < 232) {
            rgbColor = this._get216Color(codeNumber - 16);
        }
        else {
            rgbColor = this._get8bitGrayscale(codeNumber - 232);
        }
        return `${rgbColor.r},${rgbColor.g},${rgbColor.b}`;
    }
    /**
     * With 8 bit color, from 0-15, css classes are used to represent customer colors
     * @param codeNumber 0-15 number that indicates the standard or high intensity color code that should be used
     */
    _get8BitColorClasses(codeNumber) {
        let colorClass = "";
        if (codeNumber < 8) {
            colorClass = `${base8BitColors[codeNumber]}`;
        }
        else {
            colorClass = `${base8BitColors[codeNumber - 8] + BrightClassPostfix}`;
        }
        return colorClass;
    }
    /**
     * 6 x 6 x 6 (216 colors) rgb color generator
     * https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors
     * @param increment 0-215 value
     */
    _get216Color(increment) {
        return {
            r: colorIncrements216[Math.floor(increment / 36)],
            g: colorIncrements216[Math.floor(increment / 6) % 6],
            b: colorIncrements216[increment % 6]
        };
    }
    /**
     * Grayscale from black to white in 24 steps. The first value of 0 represents rgb(8,8,8) while the last value represents rgb(238,238,238)
     * @param increment 0-23 value
     */
    _get8bitGrayscale(increment) {
        const colorCode = increment * 10 + 8;
        return {
            r: colorCode,
            g: colorCode,
            b: colorCode
        };
    }
}


/***/ }),

/***/ "./src/logs/scheme.ts":
/*!****************************!*\
  !*** ./src/logs/scheme.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildLogURI: () => (/* binding */ buildLogURI),
/* harmony export */   parseUri: () => (/* binding */ parseUri)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./src/logs/constants.ts");


/**
 * @param displayName Must not contain '/'
 */
function buildLogURI(displayName, owner, repo, jobId) {
    return vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.parse(`${_constants__WEBPACK_IMPORTED_MODULE_1__.LogScheme}://${owner}/${repo}/${displayName}?${jobId}`);
}
function parseUri(uri) {
    if (uri.scheme != _constants__WEBPACK_IMPORTED_MODULE_1__.LogScheme) {
        throw new Error("Uri is not of log scheme");
    }
    return {
        owner: uri.authority,
        repo: uri.path.split("/").slice(0, 2).join(""),
        jobId: parseInt(uri.query, 10)
    };
}


/***/ }),

/***/ "./src/logs/symbolProvider.ts":
/*!************************************!*\
  !*** ./src/logs/symbolProvider.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowStepLogSymbolProvider: () => (/* binding */ WorkflowStepLogSymbolProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logInfo */ "./src/logs/logInfo.ts");


class WorkflowStepLogSymbolProvider {
    provideDocumentSymbols(document) {
        const logInfo = (0,_logInfo__WEBPACK_IMPORTED_MODULE_1__.getLogInfo)(document.uri);
        if (!logInfo) {
            return [];
        }
        return logInfo.sections.map(s => new vscode__WEBPACK_IMPORTED_MODULE_0__.DocumentSymbol(s.name || "Setup", "Step", vscode__WEBPACK_IMPORTED_MODULE_0__.SymbolKind.Function, new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(s.start, 0, s.end, 0), new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(s.start, 0, s.end, 0)));
    }
}


/***/ }),

/***/ "./src/pinnedWorkflows/pinnedWorkflows.ts":
/*!************************************************!*\
  !*** ./src/pinnedWorkflows/pinnedWorkflows.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initPinnedWorkflows: () => (/* binding */ initPinnedWorkflows)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _configuration_configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../configuration/configuration */ "./src/configuration/configuration.ts");
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../git/repository */ "./src/git/repository.ts");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../log */ "./src/log.ts");
/* harmony import */ var _treeViews_icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../treeViews/icons */ "./src/treeViews/icons.ts");






const pinnedWorkflows = [];
let refreshTimer;
let runStore;
async function initPinnedWorkflows(store) {
    // Register handler for configuration changes
    (0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_1__.onPinnedWorkflowsChange)(() => void _init());
    runStore = store;
    runStore.event(({ run }) => {
        // Are we listening to this run?
        const workflowId = run.run.workflow_id;
        for (const pinnedWorkflow of pinnedWorkflows) {
            if (pinnedWorkflow.workflowId === workflowId && pinnedWorkflow.lastRunId === run.run.id) {
                updatePinnedWorkflow(pinnedWorkflow, run);
                break;
            }
        }
    });
    await _init();
}
async function _init() {
    await updatePinnedWorkflows();
    if (refreshTimer) {
        clearInterval(refreshTimer);
        refreshTimer = undefined;
    }
    if ((0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_1__.isPinnedWorkflowsRefreshEnabled)()) {
        refreshTimer = setInterval(() => void refreshPinnedWorkflows(), (0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_1__.pinnedWorkflowsRefreshInterval)() * 1000);
    }
}
async function updatePinnedWorkflows() {
    clearPinnedWorkflows();
    const pinnedWorkflows = (0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_1__.getPinnedWorkflows)();
    // Assume we have a folder open. Without a folder open, we can't do anything
    if (!vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.length) {
        return;
    }
    const firstWorkspaceFolderName = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders[0].name;
    const workflowsByWorkspace = new Map();
    for (const pinnedWorkflow of pinnedWorkflows) {
        const workflowPath = pinnedWorkflow;
        if (pinnedWorkflow.startsWith(".github/")) {
            // No workspace, attribute to the first workspace folder
            workflowsByWorkspace.set(firstWorkspaceFolderName, [
                pinnedWorkflow,
                ...(workflowsByWorkspace.get(firstWorkspaceFolderName) || [])
            ]);
        }
        else {
            const [workSpaceName, ...r] = workflowPath.split(path__WEBPACK_IMPORTED_MODULE_3__.sep);
            workflowsByWorkspace.set(workSpaceName, [r.join(path__WEBPACK_IMPORTED_MODULE_3__.sep), ...(workflowsByWorkspace.get(workSpaceName) || [])]);
        }
    }
    for (const workspaceName of workflowsByWorkspace.keys()) {
        const workspace = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.find(x => x.name === workspaceName);
        if (!workspace) {
            continue;
        }
        const gitHubRepoContext = await (0,_git_repository__WEBPACK_IMPORTED_MODULE_2__.getGitHubContextForWorkspaceUri)(workspace.uri);
        if (!gitHubRepoContext) {
            return;
        }
        // Get all workflows to resolve names. We could do this locally, but for now, let's make the API call.
        const workflows = await gitHubRepoContext.client.paginate(gitHubRepoContext.client.actions.listRepoWorkflows, {
            owner: gitHubRepoContext.owner,
            repo: gitHubRepoContext.name,
            per_page: 100
        }, response => response.data);
        const workflowByPath = {};
        workflows.forEach(w => (workflowByPath[w.path] = w));
        for (const pinnedWorkflow of workflowsByWorkspace.get(workspaceName) || []) {
            if (!workflowByPath[pinnedWorkflow]) {
                (0,_log__WEBPACK_IMPORTED_MODULE_4__.log)(`Unable to find pinned workflow ${pinnedWorkflow} in ${workspaceName}, ignoring`);
                continue;
            }
            const pW = createPinnedWorkflow(gitHubRepoContext, workflowByPath[pinnedWorkflow]);
            await refreshPinnedWorkflow(pW);
        }
    }
}
async function refreshPinnedWorkflows() {
    for (const pinnedWorkflow of pinnedWorkflows) {
        await refreshPinnedWorkflow(pinnedWorkflow);
    }
}
function clearPinnedWorkflows() {
    // Remove any existing pinned workflows
    for (const pinnedWorkflow of pinnedWorkflows) {
        pinnedWorkflow.statusBarItem.hide();
        pinnedWorkflow.statusBarItem.dispose();
    }
    pinnedWorkflows.splice(0, pinnedWorkflows.length);
}
function createPinnedWorkflow(gitHubRepoContext, workflow) {
    const statusBarItem = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createStatusBarItem(vscode__WEBPACK_IMPORTED_MODULE_0__.StatusBarAlignment.Left);
    const pinnedWorkflow = {
        gitHubRepoContext,
        workflowId: workflow.id,
        workflowName: workflow.name,
        lastRunId: undefined,
        statusBarItem
    };
    pinnedWorkflows.push(pinnedWorkflow);
    return pinnedWorkflow;
}
async function refreshPinnedWorkflow(pinnedWorkflow) {
    const { gitHubRepoContext } = pinnedWorkflow;
    try {
        const runs = await gitHubRepoContext.client.actions.listWorkflowRuns({
            owner: gitHubRepoContext.owner,
            repo: gitHubRepoContext.name,
            workflow_id: pinnedWorkflow.workflowId,
            per_page: 1
        });
        const { workflow_runs } = runs.data;
        // Add all runs to store
        for (const run of workflow_runs) {
            runStore.addRun(gitHubRepoContext, run);
        }
        const mostRecentRun = workflow_runs?.[0];
        updatePinnedWorkflow(pinnedWorkflow, mostRecentRun && runStore.getRun(mostRecentRun.id));
    }
    catch (e) {
        (0,_log__WEBPACK_IMPORTED_MODULE_4__.logError)(e, "Error updating pinned workflow");
    }
}
function updatePinnedWorkflow(pinnedWorkflow, run) {
    if (!run) {
        // Workflow has never run, set default text
        pinnedWorkflow.statusBarItem.text = `$(${(0,_treeViews_icons__WEBPACK_IMPORTED_MODULE_5__.getCodIconForWorkflowRun)()}) ${pinnedWorkflow.workflowName}`;
        // Can't do anything without a run
        pinnedWorkflow.statusBarItem.command = undefined;
    }
    else {
        pinnedWorkflow.statusBarItem.text = `$(${(0,_treeViews_icons__WEBPACK_IMPORTED_MODULE_5__.getCodIconForWorkflowRun)(run.run)}) ${pinnedWorkflow.workflowName}`;
        if (run.run.conclusion === "failure") {
            pinnedWorkflow.statusBarItem.backgroundColor = new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeColor("statusBarItem.errorBackground");
        }
        else {
            pinnedWorkflow.statusBarItem.backgroundColor = undefined;
        }
        pinnedWorkflow.statusBarItem.command = {
            title: "Open workflow run",
            command: "github-actions.workflow.run.open",
            arguments: [
                {
                    run: run,
                    store: runStore,
                    gitHubRepoContext: pinnedWorkflow.gitHubRepoContext
                }
            ]
        };
    }
    pinnedWorkflow.lastRunId = run?.run.id;
    // Ensure the status bar item is visible
    pinnedWorkflow.statusBarItem.show();
}


/***/ }),

/***/ "./src/secrets/index.ts":
/*!******************************!*\
  !*** ./src/secrets/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encodeSecret: () => (/* binding */ encodeSecret)
/* harmony export */ });
/* harmony import */ var libsodium_wrappers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! libsodium-wrappers */ "./node_modules/libsodium-wrappers/dist/modules/libsodium-wrappers.js");
/* harmony import */ var libsodium_wrappers__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(libsodium_wrappers__WEBPACK_IMPORTED_MODULE_0__);

async function encodeSecret(key, value) {
    await (libsodium_wrappers__WEBPACK_IMPORTED_MODULE_0___default().ready);
    const sec = libsodium_wrappers__WEBPACK_IMPORTED_MODULE_0___default().from_string(value);
    const k = libsodium_wrappers__WEBPACK_IMPORTED_MODULE_0___default().from_base64(key, (libsodium_wrappers__WEBPACK_IMPORTED_MODULE_0___default().base64_variants).ORIGINAL);
    const encsec = libsodium_wrappers__WEBPACK_IMPORTED_MODULE_0___default().crypto_box_seal(sec, k);
    return libsodium_wrappers__WEBPACK_IMPORTED_MODULE_0___default().to_base64(encsec, (libsodium_wrappers__WEBPACK_IMPORTED_MODULE_0___default().base64_variants).ORIGINAL);
}


/***/ }),

/***/ "./src/store/WorkflowJob.ts":
/*!**********************************!*\
  !*** ./src/store/WorkflowJob.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowJob: () => (/* binding */ WorkflowJob)
/* harmony export */ });
class WorkflowJob {
    constructor(gitHubRepoContext, job) {
        this.gitHubRepoContext = gitHubRepoContext;
        this.job = job;
    }
}


/***/ }),

/***/ "./src/store/store.ts":
/*!****************************!*\
  !*** ./src/store/store.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RunStore: () => (/* binding */ RunStore)
/* harmony export */ });
/* harmony import */ var timers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! timers */ "timers");
/* harmony import */ var timers__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(timers__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../log */ "./src/log.ts");
/* harmony import */ var _workflowRun__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./workflowRun */ "./src/store/workflowRun.ts");




class RunStore extends vscode__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {
    constructor() {
        super(...arguments);
        this.runs = new Map();
        this.updaters = new Map();
    }
    getRun(runId) {
        return this.runs.get(runId);
    }
    addRun(gitHubRepoContext, runData) {
        let run = this.runs.get(runData.id);
        if (!run) {
            run = new _workflowRun__WEBPACK_IMPORTED_MODULE_3__.WorkflowRun(gitHubRepoContext, runData);
            (0,_log__WEBPACK_IMPORTED_MODULE_2__.logDebug)("[Store]: adding run: ", runData.id, runData.updated_at);
        }
        else {
            run.updateRun(runData);
            (0,_log__WEBPACK_IMPORTED_MODULE_2__.logDebug)("[Store]: updating run: ", runData.id, runData.updated_at);
        }
        this.runs.set(runData.id, run);
        this.fire({ run });
        return run;
    }
    /**
     * Start polling for updates for the given run
     */
    pollRun(runId, repoContext, intervalMs, attempts = 10) {
        const existingUpdater = this.updaters.get(runId);
        if (existingUpdater && existingUpdater.handle) {
            clearInterval(existingUpdater.handle);
        }
        const updater = {
            intervalMs,
            repoContext,
            runId,
            remainingAttempts: attempts,
            handle: undefined
        };
        updater.handle = (0,timers__WEBPACK_IMPORTED_MODULE_0__.setInterval)(() => void this.fetchRun(updater), intervalMs);
        this.updaters.set(runId, updater);
    }
    async fetchRun(updater) {
        (0,_log__WEBPACK_IMPORTED_MODULE_2__.logDebug)("Updating run: ", updater.runId);
        updater.remainingAttempts--;
        if (updater.remainingAttempts === 0) {
            if (updater.handle) {
                clearInterval(updater.handle);
            }
            this.updaters.delete(updater.runId);
        }
        const result = await updater.repoContext.client.actions.getWorkflowRun({
            owner: updater.repoContext.owner,
            repo: updater.repoContext.name,
            run_id: updater.runId
        });
        const run = result.data;
        this.addRun(updater.repoContext, run);
    }
}


/***/ }),

/***/ "./src/store/workflowRun.ts":
/*!**********************************!*\
  !*** ./src/store/workflowRun.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowRun: () => (/* binding */ WorkflowRun),
/* harmony export */   WorkflowRunAttempt: () => (/* binding */ WorkflowRunAttempt)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _git_repository_permissions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../git/repository-permissions */ "./src/git/repository-permissions.ts");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../log */ "./src/log.ts");
/* harmony import */ var _WorkflowJob__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WorkflowJob */ "./src/store/WorkflowJob.ts");




class WorkflowRunBase {
    constructor(gitHubRepoContext, run) {
        this._gitHubRepoContext = gitHubRepoContext;
        this._run = run;
    }
    get run() {
        return this._run;
    }
    get hasPreviousAttempts() {
        return (this.run.run_attempt || 1) > 1;
    }
    duration() {
        if (this.run.run_started_at) {
            const started_at = new Date(this.run.run_started_at);
            const updated_at = new Date(this.run.updated_at);
            return updated_at.getTime() - started_at.getTime();
        }
        return 0;
    }
    updateRun(run) {
        if (this._run.status !== "completed" || this._run.updated_at !== run.updated_at) {
            // Refresh jobs if the run is not completed or it was updated (i.e. re-run)
            // For in-progress runs, we can't rely on updated at to change when jobs change
            this._jobs = undefined;
        }
        this._run = run;
    }
    jobs() {
        if (!this._jobs) {
            this._jobs = this.fetchJobs();
        }
        return this._jobs;
    }
    contextValue(permission) {
        const contextValues = ["run"];
        const completed = this._run.status === "completed";
        if ((0,_git_repository_permissions__WEBPACK_IMPORTED_MODULE_1__.hasWritePermission)(permission)) {
            contextValues.push(completed ? "rerunnable" : "cancelable");
        }
        if (completed) {
            contextValues.push("completed");
        }
        return contextValues.join(" ");
    }
}
class WorkflowRun extends WorkflowRunBase {
    constructor(gitHubRepoContext, run) {
        super(gitHubRepoContext, run);
    }
    async fetchJobs() {
        (0,_log__WEBPACK_IMPORTED_MODULE_2__.logDebug)("Getting workflow jobs");
        let jobs = [];
        try {
            jobs = await this._gitHubRepoContext.client.paginate(this._gitHubRepoContext.client.actions.listJobsForWorkflowRun, {
                owner: this._gitHubRepoContext.owner,
                repo: this._gitHubRepoContext.name,
                run_id: this.run.id,
                per_page: 100
            });
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        return jobs.map(j => new _WorkflowJob__WEBPACK_IMPORTED_MODULE_3__.WorkflowJob(this._gitHubRepoContext, j));
    }
    attempts() {
        if (!this._attempts) {
            this._attempts = this._updateAttempts();
        }
        return this._attempts;
    }
    async _updateAttempts() {
        const attempts = [];
        const attempt = this.run.run_attempt || 1;
        if (attempt > 1) {
            for (let i = 1; i < attempt; i++) {
                const runAttemptResp = await this._gitHubRepoContext.client.actions.getWorkflowRunAttempt({
                    owner: this._gitHubRepoContext.owner,
                    repo: this._gitHubRepoContext.name,
                    run_id: this._run.id,
                    attempt_number: i
                });
                if (runAttemptResp.status !== 200) {
                    (0,_log__WEBPACK_IMPORTED_MODULE_2__.log)("Failed to get workflow run attempt", this._run.id, "for attempt", i, runAttemptResp.status, runAttemptResp.data);
                    continue;
                }
                const runAttempt = runAttemptResp.data;
                attempts.push(new WorkflowRunAttempt(this._gitHubRepoContext, runAttempt, i));
            }
        }
        return attempts;
    }
}
class WorkflowRunAttempt extends WorkflowRunBase {
    constructor(gitHubRepoContext, run, attempt) {
        super(gitHubRepoContext, run);
        this.attempt = attempt;
    }
    async fetchJobs() {
        (0,_log__WEBPACK_IMPORTED_MODULE_2__.logDebug)("Getting workflow run attempt jobs", this._run.id, "for attempt", this.attempt);
        let jobs = [];
        try {
            jobs = await this._gitHubRepoContext.client.paginate(this._gitHubRepoContext.client.actions.listJobsForWorkflowRunAttempt, {
                owner: this._gitHubRepoContext.owner,
                repo: this._gitHubRepoContext.name,
                run_id: this.run.id,
                attempt_number: this.attempt,
                per_page: 100
            });
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        return jobs.map(j => new _WorkflowJob__WEBPACK_IMPORTED_MODULE_3__.WorkflowJob(this._gitHubRepoContext, j));
    }
}


/***/ }),

/***/ "./src/tracker/workflowDocumentTracker.ts":
/*!************************************************!*\
  !*** ./src/tracker/workflowDocumentTracker.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initWorkflowDocumentTracking: () => (/* binding */ initWorkflowDocumentTracking)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logs_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logs/constants */ "./src/logs/constants.ts");
/* harmony import */ var _logs_formatProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logs/formatProvider */ "./src/logs/formatProvider.ts");
/* harmony import */ var _logs_logInfo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logs/logInfo */ "./src/logs/logInfo.ts");
/* harmony import */ var _workflow_workflow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../workflow/workflow */ "./src/workflow/workflow.ts");






async function initWorkflowDocumentTracking(context) {
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.window.onDidChangeActiveTextEditor(onDidChangeActiveTextEditor));
    // Check for initial document
    await onDidChangeActiveTextEditor(vscode__WEBPACK_IMPORTED_MODULE_0__.window.activeTextEditor);
}
async function onDidChangeActiveTextEditor(editor) {
    if (!editor || !isTextEditor(editor)) {
        return;
    }
    // Check if the file is saved and could be a workflow
    if (editor.document.uri?.fsPath &&
        editor.document.uri.scheme === "file" &&
        (0,path__WEBPACK_IMPORTED_MODULE_1__.extname)(editor.document.fileName).match(/\.ya?ml/) &&
        editor.document.fileName.indexOf(".github/workflows") !== -1) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "githubActions:activeFile", await (0,_workflow_workflow__WEBPACK_IMPORTED_MODULE_5__.getContextStringForWorkflow)(editor.document.uri));
    }
    // Is is a log file?
    if (editor.document.uri?.scheme === _logs_constants__WEBPACK_IMPORTED_MODULE_2__.LogScheme) {
        const logInfo = (0,_logs_logInfo__WEBPACK_IMPORTED_MODULE_4__.getLogInfo)(editor.document.uri);
        if (logInfo) {
            (0,_logs_formatProvider__WEBPACK_IMPORTED_MODULE_3__.updateDecorations)(editor, logInfo);
        }
    }
}
// Adapted from https://github.com/eamodio/vscode-gitlens/blob/f22a9cd4199ac498c217643282a6a412e1fc01ae/src/constants.ts#L74
var DocumentSchemes;
(function (DocumentSchemes) {
    DocumentSchemes["DebugConsole"] = "debug";
    DocumentSchemes["Output"] = "output";
})(DocumentSchemes || (DocumentSchemes = {}));
function isTextEditor(editor) {
    const scheme = editor.document.uri.scheme;
    return scheme !== DocumentSchemes.Output && scheme !== DocumentSchemes.DebugConsole;
}


/***/ }),

/***/ "./src/tracker/workspaceTracker.ts":
/*!*****************************************!*\
  !*** ./src/tracker/workspaceTracker.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initWorkspaceChangeTracker: () => (/* binding */ initWorkspaceChangeTracker)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../git/repository */ "./src/git/repository.ts");


function initWorkspaceChangeTracker(context) {
    const onDidChangeWorkspaceFolders = async (event) => {
        if (event.added.length > 0 || event.removed.length > 0) {
            (0,_git_repository__WEBPACK_IMPORTED_MODULE_1__.resetGitHubContext)();
            const context = await (0,_git_repository__WEBPACK_IMPORTED_MODULE_1__.getGitHubContext)();
            const hasGitHubRepos = context && context.repos.length > 0;
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "github-actions.has-repos", hasGitHubRepos);
        }
    };
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeWorkspaceFolders(onDidChangeWorkspaceFolders));
}


/***/ }),

/***/ "./src/treeViews/current-branch/currentBranchRepoNode.ts":
/*!***************************************************************!*\
  !*** ./src/treeViews/current-branch/currentBranchRepoNode.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CurrentBranchRepoNode: () => (/* binding */ CurrentBranchRepoNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

class CurrentBranchRepoNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext, currentBranchName) {
        super(gitHubRepoContext.name, vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.currentBranchName = currentBranchName;
        this.description = currentBranchName;
        this.contextValue = "cb-repo";
    }
}


/***/ }),

/***/ "./src/treeViews/currentBranch.ts":
/*!****************************************!*\
  !*** ./src/treeViews/currentBranch.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CurrentBranchTreeProvider: () => (/* binding */ CurrentBranchTreeProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/canReachGitHubAPI */ "./src/api/canReachGitHubAPI.ts");
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../git/repository */ "./src/git/repository.ts");
/* harmony import */ var _current_branch_currentBranchRepoNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./current-branch/currentBranchRepoNode */ "./src/treeViews/current-branch/currentBranchRepoNode.ts");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../log */ "./src/log.ts");
/* harmony import */ var _shared_attemptNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shared/attemptNode */ "./src/treeViews/shared/attemptNode.ts");
/* harmony import */ var _shared_gitHubApiUnreachableNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shared/gitHubApiUnreachableNode */ "./src/treeViews/shared/gitHubApiUnreachableNode.ts");
/* harmony import */ var _shared_previousAttemptsNode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shared/previousAttemptsNode */ "./src/treeViews/shared/previousAttemptsNode.ts");
/* harmony import */ var _shared_workflowJobNode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shared/workflowJobNode */ "./src/treeViews/shared/workflowJobNode.ts");
/* harmony import */ var _shared_workflowRunNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./shared/workflowRunNode */ "./src/treeViews/shared/workflowRunNode.ts");
/* harmony import */ var _workflowRunTreeDataProvider__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./workflowRunTreeDataProvider */ "./src/treeViews/workflowRunTreeDataProvider.ts");











class CurrentBranchTreeProvider extends _workflowRunTreeDataProvider__WEBPACK_IMPORTED_MODULE_10__.WorkflowRunTreeDataProvider {
    constructor(store) {
        super(store);
        this._onDidChangeTreeData = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    }
    _updateNode(node) {
        this._onDidChangeTreeData.fire(node);
    }
    async refresh() {
        // Don't delete all the nodes if we can't reach GitHub API
        if (await (0,_api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__.canReachGitHubAPI)()) {
            this._onDidChangeTreeData.fire(null);
        }
        else {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage("Unable to refresh, could not reach GitHub API");
        }
    }
    getTreeItem(element) {
        return element;
    }
    async getChildren(element) {
        if (!element) {
            const gitHubContext = await (0,_git_repository__WEBPACK_IMPORTED_MODULE_2__.getGitHubContext)();
            if (!gitHubContext) {
                return [new _shared_gitHubApiUnreachableNode__WEBPACK_IMPORTED_MODULE_6__.GitHubAPIUnreachableNode()];
            }
            if (gitHubContext.repos.length === 1) {
                const repoContext = gitHubContext.repos[0];
                const currentBranch = (0,_git_repository__WEBPACK_IMPORTED_MODULE_2__.getCurrentBranch)(repoContext.repositoryState);
                if (!currentBranch) {
                    (0,_log__WEBPACK_IMPORTED_MODULE_4__.log)(`Could not find current branch for ${repoContext.name}`);
                    return [];
                }
                return (await this.getRuns(repoContext, currentBranch)) || [];
            }
            if (gitHubContext.repos.length > 1) {
                return gitHubContext.repos
                    .map((repoContext) => {
                    const currentBranch = (0,_git_repository__WEBPACK_IMPORTED_MODULE_2__.getCurrentBranch)(repoContext.repositoryState);
                    if (!currentBranch) {
                        (0,_log__WEBPACK_IMPORTED_MODULE_4__.log)(`Could not find current branch for ${repoContext.name}`);
                        return undefined;
                    }
                    return new _current_branch_currentBranchRepoNode__WEBPACK_IMPORTED_MODULE_3__.CurrentBranchRepoNode(repoContext, currentBranch);
                })
                    .filter(x => x !== undefined);
            }
        }
        else if (element instanceof _current_branch_currentBranchRepoNode__WEBPACK_IMPORTED_MODULE_3__.CurrentBranchRepoNode) {
            return this.getRuns(element.gitHubRepoContext, element.currentBranchName);
        }
        else if (element instanceof _shared_workflowRunNode__WEBPACK_IMPORTED_MODULE_9__.WorkflowRunNode) {
            return element.getJobs();
        }
        else if (element instanceof _shared_previousAttemptsNode__WEBPACK_IMPORTED_MODULE_7__.PreviousAttemptsNode) {
            return element.getAttempts();
        }
        else if (element instanceof _shared_attemptNode__WEBPACK_IMPORTED_MODULE_5__.AttemptNode) {
            return element.getJobs();
        }
        else if (element instanceof _shared_workflowJobNode__WEBPACK_IMPORTED_MODULE_8__.WorkflowJobNode) {
            return element.getSteps();
        }
        return [];
    }
    async getRuns(gitHubRepoContext, currentBranchName) {
        (0,_log__WEBPACK_IMPORTED_MODULE_4__.logDebug)("Getting workflow runs for branch");
        const result = await gitHubRepoContext.client.actions.listWorkflowRunsForRepo({
            owner: gitHubRepoContext.owner,
            repo: gitHubRepoContext.name,
            branch: currentBranchName,
            per_page: 100
        });
        const resp = result.data;
        const runs = resp.workflow_runs;
        // We are removing newlines from workflow names for presentation purposes
        for (const run of runs) {
            run.name = run.name?.replace(/(\r\n|\n|\r)/gm, " ");
        }
        return this.runNodes(gitHubRepoContext, runs, true);
    }
}


/***/ }),

/***/ "./src/treeViews/icons.ts":
/*!********************************!*\
  !*** ./src/treeViews/icons.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAbsoluteIconPath: () => (/* binding */ getAbsoluteIconPath),
/* harmony export */   getCodIconForWorkflowRun: () => (/* binding */ getCodIconForWorkflowRun),
/* harmony export */   getIconForWorkflowRun: () => (/* binding */ getIconForWorkflowRun),
/* harmony export */   getIconForWorkflowStep: () => (/* binding */ getIconForWorkflowStep),
/* harmony export */   initResources: () => (/* binding */ initResources)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

let _context;
function initResources(context) {
    _context = context;
}
function getAbsoluteIconPath(relativeIconPath) {
    return {
        light: vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(_context.extensionUri, "resources", "icons", "light", relativeIconPath),
        dark: vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(_context.extensionUri, "resources", "icons", "dark", relativeIconPath)
    };
}
function getIconForWorkflowRun({ status, conclusion }) {
    switch (status) {
        case "completed": {
            switch (conclusion) {
                case "success":
                    return getAbsoluteIconPath("workflowruns/wr_success.svg");
                case "startup_failure":
                case "failure":
                    return getAbsoluteIconPath("workflowruns/wr_failure.svg");
                case "skipped":
                    return getAbsoluteIconPath("workflowruns/wr_skipped.svg");
                case "cancelled":
                    return getAbsoluteIconPath("workflowruns/wr_cancelled.svg");
            }
            break;
        }
        case "pending":
            return getAbsoluteIconPath("workflowruns/wr_pending.svg");
        case "requested":
        case "queued":
            return getAbsoluteIconPath("workflowruns/wr_queued.svg");
        case "waiting":
            return getAbsoluteIconPath("workflowruns/wr_waiting.svg");
        case "inprogress":
        case "in_progress":
            return getAbsoluteIconPath("workflowruns/wr_inprogress.svg");
    }
    return "";
}
function getIconForWorkflowStep({ status, conclusion }) {
    switch (status) {
        case "completed": {
            switch (conclusion) {
                case "success":
                    return getAbsoluteIconPath("steps/step_success.svg");
                case "failure":
                    return getAbsoluteIconPath("steps/step_failure.svg");
                case "skipped":
                    return getAbsoluteIconPath("steps/step_skipped.svg");
                case "cancelled":
                    return getAbsoluteIconPath("steps/step_cancelled.svg");
            }
            break;
        }
        case "queued":
            return getAbsoluteIconPath("steps/step_queued.svg");
        case "inprogress":
        case "in_progress":
            return getAbsoluteIconPath("steps/step_inprogress.svg");
    }
    return "";
}
/** Get one of the built-in VS Code icons */
function getCodIconForWorkflowRun(runOrJob) {
    if (!runOrJob) {
        return "circle-outline";
    }
    switch (runOrJob.status) {
        case "completed": {
            switch (runOrJob.conclusion) {
                case "success":
                    return "pass";
                case "failure":
                    return "error";
                case "skipped":
                case "cancelled":
                    return "circle-slash";
            }
            break;
        }
        case "queued":
            return "primitive-dot";
        case "waiting":
            return "bell";
        case "inprogress":
        case "in_progress":
            return "sync~spin";
    }
    // Default to circle if there is no match
    return "circle";
}


/***/ }),

/***/ "./src/treeViews/settings.ts":
/*!***********************************!*\
  !*** ./src/treeViews/settings.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingsTreeProvider: () => (/* binding */ SettingsTreeProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/canReachGitHubAPI */ "./src/api/canReachGitHubAPI.ts");
/* harmony import */ var _settings_settingsRepoNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings/settingsRepoNode */ "./src/treeViews/settings/settingsRepoNode.ts");
/* harmony import */ var _settings_environmentNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings/environmentNode */ "./src/treeViews/settings/environmentNode.ts");
/* harmony import */ var _settings_environmentsNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./settings/environmentsNode */ "./src/treeViews/settings/environmentsNode.ts");
/* harmony import */ var _settings_repoSecretsNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./settings/repoSecretsNode */ "./src/treeViews/settings/repoSecretsNode.ts");
/* harmony import */ var _settings_secretsNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./settings/secretsNode */ "./src/treeViews/settings/secretsNode.ts");
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../git/repository */ "./src/git/repository.ts");
/* harmony import */ var _settings_repoVariablesNode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./settings/repoVariablesNode */ "./src/treeViews/settings/repoVariablesNode.ts");
/* harmony import */ var _settings_variablesNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./settings/variablesNode */ "./src/treeViews/settings/variablesNode.ts");
/* harmony import */ var _settings_environmentSecretsNode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./settings/environmentSecretsNode */ "./src/treeViews/settings/environmentSecretsNode.ts");
/* harmony import */ var _settings_environmentVariablesNode__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./settings/environmentVariablesNode */ "./src/treeViews/settings/environmentVariablesNode.ts");
/* harmony import */ var _settings_orgVariablesNode__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./settings/orgVariablesNode */ "./src/treeViews/settings/orgVariablesNode.ts");
/* harmony import */ var _settings_orgSecretsNode__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./settings/orgSecretsNode */ "./src/treeViews/settings/orgSecretsNode.ts");
/* harmony import */ var _shared_gitHubApiUnreachableNode__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./shared/gitHubApiUnreachableNode */ "./src/treeViews/shared/gitHubApiUnreachableNode.ts");















class SettingsTreeProvider {
    constructor() {
        this._onDidChangeTreeData = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    }
    async refresh() {
        // Don't delete all the nodes if we can't reach GitHub API
        if (await (0,_api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__.canReachGitHubAPI)()) {
            this._onDidChangeTreeData.fire(null);
        }
        else {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage("Unable to refresh, could not reach GitHub API");
        }
    }
    getTreeItem(element) {
        return element;
    }
    async getChildren(element) {
        const gitHubContext = await (0,_git_repository__WEBPACK_IMPORTED_MODULE_7__.getGitHubContext)();
        if (!gitHubContext) {
            return [new _shared_gitHubApiUnreachableNode__WEBPACK_IMPORTED_MODULE_14__.GitHubAPIUnreachableNode()];
        }
        if (!element) {
            if (gitHubContext.repos.length > 0) {
                if (gitHubContext.repos.length == 1) {
                    return (0,_settings_settingsRepoNode__WEBPACK_IMPORTED_MODULE_2__.getSettingNodes)(gitHubContext.repos[0]);
                }
                return gitHubContext.repos.map(r => new _settings_settingsRepoNode__WEBPACK_IMPORTED_MODULE_2__.SettingsRepoNode(r));
            }
        }
        if (element instanceof _settings_settingsRepoNode__WEBPACK_IMPORTED_MODULE_2__.SettingsRepoNode) {
            return element.getSettings();
        }
        //
        // Secrets
        //
        if (element instanceof _settings_secretsNode__WEBPACK_IMPORTED_MODULE_6__.SecretsNode) {
            return element.nodes;
        }
        if (element instanceof _settings_repoSecretsNode__WEBPACK_IMPORTED_MODULE_5__.RepoSecretsNode || element instanceof _settings_orgSecretsNode__WEBPACK_IMPORTED_MODULE_13__.OrgSecretsNode) {
            return element.getSecrets();
        }
        //
        // Variables
        //
        if (element instanceof _settings_variablesNode__WEBPACK_IMPORTED_MODULE_9__.VariablesNode) {
            return element.nodes;
        }
        if (element instanceof _settings_repoVariablesNode__WEBPACK_IMPORTED_MODULE_8__.RepoVariablesNode || element instanceof _settings_orgVariablesNode__WEBPACK_IMPORTED_MODULE_12__.OrgVariablesNode) {
            return element.getVariables();
        }
        //
        // Environments
        //
        if (element instanceof _settings_environmentsNode__WEBPACK_IMPORTED_MODULE_4__.EnvironmentsNode) {
            return element.getEnvironments();
        }
        if (element instanceof _settings_environmentNode__WEBPACK_IMPORTED_MODULE_3__.EnvironmentNode) {
            return element.getNodes();
        }
        if (element instanceof _settings_environmentSecretsNode__WEBPACK_IMPORTED_MODULE_10__.EnvironmentSecretsNode) {
            return element.getSecrets();
        }
        if (element instanceof _settings_environmentVariablesNode__WEBPACK_IMPORTED_MODULE_11__.EnvironmentVariablesNode) {
            return element.getVariables();
        }
        return [];
    }
}


/***/ }),

/***/ "./src/treeViews/settings/emptyNode.ts":
/*!*********************************************!*\
  !*** ./src/treeViews/settings/emptyNode.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmptyNode: () => (/* binding */ EmptyNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

class EmptyNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(message) {
        super(message);
    }
}


/***/ }),

/***/ "./src/treeViews/settings/environmentNode.ts":
/*!***************************************************!*\
  !*** ./src/treeViews/settings/environmentNode.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnvironmentNode: () => (/* binding */ EnvironmentNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _git_repository_permissions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../git/repository-permissions */ "./src/git/repository-permissions.ts");
/* harmony import */ var _environmentSecretsNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./environmentSecretsNode */ "./src/treeViews/settings/environmentSecretsNode.ts");
/* harmony import */ var _environmentVariablesNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./environmentVariablesNode */ "./src/treeViews/settings/environmentVariablesNode.ts");




class EnvironmentNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext, environment) {
        const state = (0,_git_repository_permissions__WEBPACK_IMPORTED_MODULE_1__.hasWritePermission)(gitHubRepoContext.permissionLevel)
            ? vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed
            : vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.None;
        super(environment.name, state);
        this.gitHubRepoContext = gitHubRepoContext;
        this.environment = environment;
        this.contextValue = "environment";
    }
    getNodes() {
        return [
            new _environmentSecretsNode__WEBPACK_IMPORTED_MODULE_2__.EnvironmentSecretsNode(this.gitHubRepoContext, this.environment),
            new _environmentVariablesNode__WEBPACK_IMPORTED_MODULE_3__.EnvironmentVariablesNode(this.gitHubRepoContext, this.environment)
        ];
    }
}


/***/ }),

/***/ "./src/treeViews/settings/environmentSecretsNode.ts":
/*!**********************************************************!*\
  !*** ./src/treeViews/settings/environmentSecretsNode.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnvironmentSecretsNode: () => (/* binding */ EnvironmentSecretsNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _emptyNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emptyNode */ "./src/treeViews/settings/emptyNode.ts");
/* harmony import */ var _secretNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./secretNode */ "./src/treeViews/settings/secretNode.ts");



class EnvironmentSecretsNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext, environment) {
        super("Secrets", vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.environment = environment;
        this.iconPath = new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon("lock");
        this.contextValue = "environment-secrets";
    }
    async getSecrets() {
        let secrets = [];
        try {
            secrets = await this.gitHubRepoContext.client.paginate(this.gitHubRepoContext.client.actions.listEnvironmentSecrets, {
                repository_id: this.gitHubRepoContext.id,
                environment_name: this.environment.name,
                per_page: 100
            }, response => response.data.map(s => new _secretNode__WEBPACK_IMPORTED_MODULE_2__.SecretNode(this.gitHubRepoContext, s, this.environment)));
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        if (!secrets || secrets.length === 0) {
            return [new _emptyNode__WEBPACK_IMPORTED_MODULE_1__.EmptyNode("No environment secrets defined")];
        }
        return secrets;
    }
}


/***/ }),

/***/ "./src/treeViews/settings/environmentVariablesNode.ts":
/*!************************************************************!*\
  !*** ./src/treeViews/settings/environmentVariablesNode.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnvironmentVariablesNode: () => (/* binding */ EnvironmentVariablesNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _emptyNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emptyNode */ "./src/treeViews/settings/emptyNode.ts");
/* harmony import */ var _variableNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./variableNode */ "./src/treeViews/settings/variableNode.ts");



class EnvironmentVariablesNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext, environment) {
        super("Variables", vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.environment = environment;
        this.iconPath = new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon("symbol-text");
        this.contextValue = "environment-variables";
    }
    async getVariables() {
        let variables = [];
        try {
            variables = await this.gitHubRepoContext.client.paginate(this.gitHubRepoContext.client.actions.listEnvironmentVariables, {
                repository_id: this.gitHubRepoContext.id,
                environment_name: this.environment.name,
                per_page: 100
            }, response => response.data.map(v => new _variableNode__WEBPACK_IMPORTED_MODULE_2__.VariableNode(this.gitHubRepoContext, v, this.environment)));
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        if (!variables || variables.length === 0) {
            return [new _emptyNode__WEBPACK_IMPORTED_MODULE_1__.EmptyNode("No environment variables defined")];
        }
        return variables;
    }
}


/***/ }),

/***/ "./src/treeViews/settings/environmentsNode.ts":
/*!****************************************************!*\
  !*** ./src/treeViews/settings/environmentsNode.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnvironmentsNode: () => (/* binding */ EnvironmentsNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _environmentNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environmentNode */ "./src/treeViews/settings/environmentNode.ts");


class EnvironmentsNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext) {
        super("Environments", vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.iconPath = new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon("server-environment");
    }
    async getEnvironments() {
        const result = await this.gitHubRepoContext.client.repos.getAllEnvironments({
            owner: this.gitHubRepoContext.owner,
            repo: this.gitHubRepoContext.name
        });
        const data = result.data.environments || [];
        return data.map(e => new _environmentNode__WEBPACK_IMPORTED_MODULE_1__.EnvironmentNode(this.gitHubRepoContext, e));
    }
}


/***/ }),

/***/ "./src/treeViews/settings/orgSecretsNode.ts":
/*!**************************************************!*\
  !*** ./src/treeViews/settings/orgSecretsNode.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrgSecretsNode: () => (/* binding */ OrgSecretsNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _emptyNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emptyNode */ "./src/treeViews/settings/emptyNode.ts");
/* harmony import */ var _secretNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./secretNode */ "./src/treeViews/settings/secretNode.ts");



class OrgSecretsNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext) {
        super("Organization Secrets", vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.contextValue = "org-secrets";
    }
    async getSecrets() {
        let secrets = [];
        try {
            secrets = await this.gitHubRepoContext.client.paginate("GET /repos/{owner}/{repo}/actions/organization-secrets", {
                owner: this.gitHubRepoContext.owner,
                repo: this.gitHubRepoContext.name,
                per_page: 100
            });
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        if (!secrets || secrets.length === 0) {
            return [new _emptyNode__WEBPACK_IMPORTED_MODULE_1__.EmptyNode("No organization secrets shared with this repository")];
        }
        return secrets.map(s => new _secretNode__WEBPACK_IMPORTED_MODULE_2__.SecretNode(this.gitHubRepoContext, s, undefined, true));
    }
}


/***/ }),

/***/ "./src/treeViews/settings/orgVariablesNode.ts":
/*!****************************************************!*\
  !*** ./src/treeViews/settings/orgVariablesNode.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrgVariablesNode: () => (/* binding */ OrgVariablesNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _emptyNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emptyNode */ "./src/treeViews/settings/emptyNode.ts");
/* harmony import */ var _variableNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./variableNode */ "./src/treeViews/settings/variableNode.ts");



class OrgVariablesNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext) {
        super("Organization Variables", vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.contextValue = "org-variables";
    }
    async getVariables() {
        let variables = [];
        try {
            variables = await this.gitHubRepoContext.client.paginate("GET /repos/{owner}/{repo}/actions/organization-variables", {
                owner: this.gitHubRepoContext.owner,
                repo: this.gitHubRepoContext.name,
                per_page: 100
            });
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        if (!variables || variables.length === 0) {
            return [new _emptyNode__WEBPACK_IMPORTED_MODULE_1__.EmptyNode("No organization variables shared with this repository")];
        }
        return variables.map(s => new _variableNode__WEBPACK_IMPORTED_MODULE_2__.VariableNode(this.gitHubRepoContext, s, undefined, true));
    }
}


/***/ }),

/***/ "./src/treeViews/settings/repoSecretsNode.ts":
/*!***************************************************!*\
  !*** ./src/treeViews/settings/repoSecretsNode.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RepoSecretsNode: () => (/* binding */ RepoSecretsNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _emptyNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emptyNode */ "./src/treeViews/settings/emptyNode.ts");
/* harmony import */ var _secretNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./secretNode */ "./src/treeViews/settings/secretNode.ts");



class RepoSecretsNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext) {
        super("Repository Secrets", vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.contextValue = "secrets";
    }
    async getSecrets() {
        let secrets = [];
        try {
            secrets = await this.gitHubRepoContext.client.paginate(this.gitHubRepoContext.client.actions.listRepoSecrets, {
                owner: this.gitHubRepoContext.owner,
                repo: this.gitHubRepoContext.name,
                per_page: 100
            }, response => response.data.map(s => new _secretNode__WEBPACK_IMPORTED_MODULE_2__.SecretNode(this.gitHubRepoContext, s)));
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        if (!secrets || secrets.length === 0) {
            return [new _emptyNode__WEBPACK_IMPORTED_MODULE_1__.EmptyNode("No repository secrets defined")];
        }
        return secrets;
    }
}


/***/ }),

/***/ "./src/treeViews/settings/repoVariablesNode.ts":
/*!*****************************************************!*\
  !*** ./src/treeViews/settings/repoVariablesNode.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RepoVariablesNode: () => (/* binding */ RepoVariablesNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _emptyNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emptyNode */ "./src/treeViews/settings/emptyNode.ts");
/* harmony import */ var _variableNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./variableNode */ "./src/treeViews/settings/variableNode.ts");



class RepoVariablesNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext) {
        super("Repository Variables", vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.contextValue = "repo-variables";
    }
    async getVariables() {
        let variables = [];
        try {
            variables = await this.gitHubRepoContext.client.paginate(this.gitHubRepoContext.client.actions.listRepoVariables, {
                owner: this.gitHubRepoContext.owner,
                repo: this.gitHubRepoContext.name,
                per_page: 100
            }, response => response.data.map(s => new _variableNode__WEBPACK_IMPORTED_MODULE_2__.VariableNode(this.gitHubRepoContext, s)));
        }
        catch (e) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(e.message);
        }
        if (!variables || variables.length === 0) {
            return [new _emptyNode__WEBPACK_IMPORTED_MODULE_1__.EmptyNode("No repository variables defined")];
        }
        return variables;
    }
}


/***/ }),

/***/ "./src/treeViews/settings/secretNode.ts":
/*!**********************************************!*\
  !*** ./src/treeViews/settings/secretNode.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecretNode: () => (/* binding */ SecretNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

class SecretNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext, secret, environment, org) {
        super(secret.name);
        this.gitHubRepoContext = gitHubRepoContext;
        this.secret = secret;
        this.environment = environment;
        this.org = org;
        this.contextValue = environment ? "env-secret" : org ? "org-secret" : "repo-secret";
    }
}


/***/ }),

/***/ "./src/treeViews/settings/secretsNode.ts":
/*!***********************************************!*\
  !*** ./src/treeViews/settings/secretsNode.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecretsNode: () => (/* binding */ SecretsNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _orgSecretsNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./orgSecretsNode */ "./src/treeViews/settings/orgSecretsNode.ts");
/* harmony import */ var _repoSecretsNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./repoSecretsNode */ "./src/treeViews/settings/repoSecretsNode.ts");



class SecretsNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext) {
        super("Secrets", vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.iconPath = new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon("lock");
    }
    get nodes() {
        if (this.gitHubRepoContext.organizationOwned) {
            return [new _repoSecretsNode__WEBPACK_IMPORTED_MODULE_2__.RepoSecretsNode(this.gitHubRepoContext), new _orgSecretsNode__WEBPACK_IMPORTED_MODULE_1__.OrgSecretsNode(this.gitHubRepoContext)];
        }
        return [new _repoSecretsNode__WEBPACK_IMPORTED_MODULE_2__.RepoSecretsNode(this.gitHubRepoContext)];
    }
}


/***/ }),

/***/ "./src/treeViews/settings/settingsRepoNode.ts":
/*!****************************************************!*\
  !*** ./src/treeViews/settings/settingsRepoNode.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SettingsRepoNode: () => (/* binding */ SettingsRepoNode),
/* harmony export */   getSettingNodes: () => (/* binding */ getSettingNodes)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _environmentsNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environmentsNode */ "./src/treeViews/settings/environmentsNode.ts");
/* harmony import */ var _git_repository_permissions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../git/repository-permissions */ "./src/git/repository-permissions.ts");
/* harmony import */ var _secretsNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./secretsNode */ "./src/treeViews/settings/secretsNode.ts");
/* harmony import */ var _variablesNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./variablesNode */ "./src/treeViews/settings/variablesNode.ts");





class SettingsRepoNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext) {
        super(gitHubRepoContext.name, vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.contextValue = "settings-repo";
    }
    getSettings() {
        return getSettingNodes(this.gitHubRepoContext);
    }
}
function getSettingNodes(gitHubContext) {
    const nodes = [];
    nodes.push(new _environmentsNode__WEBPACK_IMPORTED_MODULE_1__.EnvironmentsNode(gitHubContext));
    if ((0,_git_repository_permissions__WEBPACK_IMPORTED_MODULE_2__.hasWritePermission)(gitHubContext.permissionLevel)) {
        nodes.push(new _secretsNode__WEBPACK_IMPORTED_MODULE_3__.SecretsNode(gitHubContext));
        nodes.push(new _variablesNode__WEBPACK_IMPORTED_MODULE_4__.VariablesNode(gitHubContext));
    }
    return nodes;
}


/***/ }),

/***/ "./src/treeViews/settings/variableNode.ts":
/*!************************************************!*\
  !*** ./src/treeViews/settings/variableNode.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VariableNode: () => (/* binding */ VariableNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

class VariableNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext, variable, environment, org) {
        super(variable.name);
        this.gitHubRepoContext = gitHubRepoContext;
        this.variable = variable;
        this.environment = environment;
        this.org = org;
        this.description = variable.value;
        this.contextValue = environment ? "env-variable" : org ? "org-variable" : "repo-variable";
    }
}


/***/ }),

/***/ "./src/treeViews/settings/variablesNode.ts":
/*!*************************************************!*\
  !*** ./src/treeViews/settings/variablesNode.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VariablesNode: () => (/* binding */ VariablesNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _orgVariablesNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./orgVariablesNode */ "./src/treeViews/settings/orgVariablesNode.ts");
/* harmony import */ var _repoVariablesNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./repoVariablesNode */ "./src/treeViews/settings/repoVariablesNode.ts");



class VariablesNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext) {
        super("Variables", vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.iconPath = new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon("symbol-text");
    }
    get nodes() {
        if (this.gitHubRepoContext.organizationOwned) {
            return [new _repoVariablesNode__WEBPACK_IMPORTED_MODULE_2__.RepoVariablesNode(this.gitHubRepoContext), new _orgVariablesNode__WEBPACK_IMPORTED_MODULE_1__.OrgVariablesNode(this.gitHubRepoContext)];
        }
        return [new _repoVariablesNode__WEBPACK_IMPORTED_MODULE_2__.RepoVariablesNode(this.gitHubRepoContext)];
    }
}


/***/ }),

/***/ "./src/treeViews/shared/attemptNode.ts":
/*!*********************************************!*\
  !*** ./src/treeViews/shared/attemptNode.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttemptNode: () => (/* binding */ AttemptNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../icons */ "./src/treeViews/icons.ts");
/* harmony import */ var _runTooltipHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runTooltipHelper */ "./src/treeViews/shared/runTooltipHelper.ts");
/* harmony import */ var _workflowJobNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./workflowJobNode */ "./src/treeViews/shared/workflowJobNode.ts");




class AttemptNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext, attempt) {
        super(`Attempt #${attempt.attempt}`, vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.attempt = attempt;
        this.iconPath = (0,_icons__WEBPACK_IMPORTED_MODULE_1__.getIconForWorkflowRun)(this.attempt.run);
        this.tooltip = this.getTooltip();
    }
    getTooltip() {
        let markdownString = `#${this.attempt.attempt}: `;
        markdownString += (0,_runTooltipHelper__WEBPACK_IMPORTED_MODULE_2__.getStatusString)(this.attempt);
        markdownString += `\n\n`;
        markdownString += (0,_runTooltipHelper__WEBPACK_IMPORTED_MODULE_2__.getEventString)(this.attempt);
        return new vscode__WEBPACK_IMPORTED_MODULE_0__.MarkdownString(markdownString);
    }
    async getJobs() {
        const jobs = await this.attempt.jobs();
        return jobs.map(job => new _workflowJobNode__WEBPACK_IMPORTED_MODULE_3__.WorkflowJobNode(this.gitHubRepoContext, job));
    }
}


/***/ }),

/***/ "./src/treeViews/shared/authenticationNode.ts":
/*!****************************************************!*\
  !*** ./src/treeViews/shared/authenticationNode.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthenticationNode: () => (/* binding */ AuthenticationNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

class AuthenticationNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor() {
        super("Please sign-in in the Accounts menu.");
    }
}


/***/ }),

/***/ "./src/treeViews/shared/errorNode.ts":
/*!*******************************************!*\
  !*** ./src/treeViews/shared/errorNode.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ErrorNode: () => (/* binding */ ErrorNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

class ErrorNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(message) {
        super(message);
    }
}


/***/ }),

/***/ "./src/treeViews/shared/gitHubApiUnreachableNode.ts":
/*!**********************************************************!*\
  !*** ./src/treeViews/shared/gitHubApiUnreachableNode.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GitHubAPIUnreachableNode: () => (/* binding */ GitHubAPIUnreachableNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Shown when no calls to the github API can be made.
 */
class GitHubAPIUnreachableNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor() {
        super("Cannot reach GitHub API");
        this.iconPath = new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon("notebook-state-error");
    }
}


/***/ }),

/***/ "./src/treeViews/shared/previousAttemptsNode.ts":
/*!******************************************************!*\
  !*** ./src/treeViews/shared/previousAttemptsNode.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PreviousAttemptsNode: () => (/* binding */ PreviousAttemptsNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _attemptNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attemptNode */ "./src/treeViews/shared/attemptNode.ts");


class PreviousAttemptsNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext, run) {
        super("Previous attempts", vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.run = run;
    }
    async getAttempts() {
        const attempts = await this.run.attempts();
        return attempts.map(attempt => new _attemptNode__WEBPACK_IMPORTED_MODULE_1__.AttemptNode(this.gitHubRepoContext, attempt));
    }
}


/***/ }),

/***/ "./src/treeViews/shared/runTooltipHelper.ts":
/*!**************************************************!*\
  !*** ./src/treeViews/shared/runTooltipHelper.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getEventString: () => (/* binding */ getEventString),
/* harmony export */   getStatusString: () => (/* binding */ getStatusString)
/* harmony export */ });
/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dayjs */ "./node_modules/dayjs/dayjs.min.js");
/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var dayjs_plugin_localizedFormat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dayjs/plugin/localizedFormat.js */ "./node_modules/dayjs/plugin/localizedFormat.js");
/* harmony import */ var dayjs_plugin_localizedFormat_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_localizedFormat_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var dayjs_plugin_relativeTime_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dayjs/plugin/relativeTime.js */ "./node_modules/dayjs/plugin/relativeTime.js");
/* harmony import */ var dayjs_plugin_relativeTime_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_relativeTime_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var dayjs_plugin_duration_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dayjs/plugin/duration.js */ "./node_modules/dayjs/plugin/duration.js");
/* harmony import */ var dayjs_plugin_duration_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_duration_js__WEBPACK_IMPORTED_MODULE_3__);




dayjs__WEBPACK_IMPORTED_MODULE_0___default().extend((dayjs_plugin_duration_js__WEBPACK_IMPORTED_MODULE_3___default()));
dayjs__WEBPACK_IMPORTED_MODULE_0___default().extend((dayjs_plugin_localizedFormat_js__WEBPACK_IMPORTED_MODULE_1___default()));
dayjs__WEBPACK_IMPORTED_MODULE_0___default().extend((dayjs_plugin_relativeTime_js__WEBPACK_IMPORTED_MODULE_2___default()));
// Returns a string like "**Succeeded** in **1m 2s**"
// For use in markdown tooltip
function getStatusString(item, capitalize = false) {
    let statusText = item.run.conclusion || item.run.status || "";
    switch (statusText) {
        case "success":
            statusText = "succeeded";
            break;
        case "failure":
            statusText = "failed";
            break;
    }
    statusText = statusText.replace("_", " ");
    if (capitalize) {
        statusText = statusText.charAt(0).toUpperCase() + statusText.slice(1);
    }
    statusText = `**${statusText}**`;
    if (item.run.conclusion && item.run.conclusion !== "skipped") {
        const duration = dayjs__WEBPACK_IMPORTED_MODULE_0___default().duration(item.duration());
        // Format and remove leading 0's
        const formattedDuration = duration
            .format("D[d] H[h] m[m] s[s]")
            .replace(/^0d /, "")
            .replace(/^0h /, "")
            .replace(/^0m /, "");
        statusText += ` in **${formattedDuration}**`;
    }
    return statusText;
}
// Returns a string like "Manually run by [user](user_url) 4 minutes ago *(December 31, 1969 7:00 PM)*"
// For use in markdown tooltip
function getEventString(item) {
    let eventString = "Triggered";
    if (item.hasPreviousAttempts) {
        eventString = "Re-run";
    }
    else {
        const event = item.run.event;
        if (event) {
            switch (event) {
                case "workflow_dispatch":
                    eventString = "Manually triggered";
                    break;
                case "dynamic":
                    eventString = "Triggered";
                    break;
                default:
                    eventString = "Triggered via " + event.replace("_", " ");
            }
        }
    }
    if (item.run.triggering_actor) {
        eventString += ` by [${item.run.triggering_actor.login}](${item.run.triggering_actor.html_url})`;
    }
    if (item.run.run_started_at) {
        const started_at = dayjs__WEBPACK_IMPORTED_MODULE_0___default()(item.run.run_started_at);
        eventString += ` ${started_at.fromNow()} *(${started_at.format("LLL")})*`;
    }
    return eventString;
}


/***/ }),

/***/ "./src/treeViews/shared/workflowJobNode.ts":
/*!*************************************************!*\
  !*** ./src/treeViews/shared/workflowJobNode.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowJobNode: () => (/* binding */ WorkflowJobNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../icons */ "./src/treeViews/icons.ts");
/* harmony import */ var _workflows_workflowStepNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../workflows/workflowStepNode */ "./src/treeViews/workflows/workflowStepNode.ts");



class WorkflowJobNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext, job) {
        super(job.job.name, (job.job.steps && job.job.steps.length > 0 && vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed) || undefined);
        this.gitHubRepoContext = gitHubRepoContext;
        this.job = job;
        this.contextValue = "job";
        if (this.job.job.status === "completed") {
            this.contextValue += " completed";
        }
        this.iconPath = (0,_icons__WEBPACK_IMPORTED_MODULE_1__.getIconForWorkflowRun)(this.job.job);
    }
    hasSteps() {
        return !!(this.job.job.steps && this.job.job.steps.length > 0);
    }
    getSteps() {
        return (this.job.job.steps || []).map(s => new _workflows_workflowStepNode__WEBPACK_IMPORTED_MODULE_2__.WorkflowStepNode(this.gitHubRepoContext, this.job, s));
    }
}


/***/ }),

/***/ "./src/treeViews/shared/workflowRunNode.ts":
/*!*************************************************!*\
  !*** ./src/treeViews/shared/workflowRunNode.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowRunNode: () => (/* binding */ WorkflowRunNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../icons */ "./src/treeViews/icons.ts");
/* harmony import */ var _runTooltipHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runTooltipHelper */ "./src/treeViews/shared/runTooltipHelper.ts");
/* harmony import */ var _previousAttemptsNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./previousAttemptsNode */ "./src/treeViews/shared/previousAttemptsNode.ts");
/* harmony import */ var _workflowJobNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./workflowJobNode */ "./src/treeViews/shared/workflowJobNode.ts");





class WorkflowRunNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(store, gitHubRepoContext, run, workflowName) {
        super(WorkflowRunNode._getLabel(run, workflowName), vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.store = store;
        this.gitHubRepoContext = gitHubRepoContext;
        this.run = run;
        this.workflowName = workflowName;
        this.updateRun(run);
    }
    updateRun(run) {
        this.run = run;
        this.label = WorkflowRunNode._getLabel(run, this.workflowName);
        this.contextValue = this.run.contextValue(this.gitHubRepoContext.permissionLevel);
        this.iconPath = (0,_icons__WEBPACK_IMPORTED_MODULE_1__.getIconForWorkflowRun)(this.run.run);
        this.tooltip = this.getTooltip();
    }
    async getJobs() {
        const jobs = await this.run.jobs();
        const children = jobs.map(job => new _workflowJobNode__WEBPACK_IMPORTED_MODULE_4__.WorkflowJobNode(this.gitHubRepoContext, job));
        if (this.run.hasPreviousAttempts) {
            children.push(new _previousAttemptsNode__WEBPACK_IMPORTED_MODULE_3__.PreviousAttemptsNode(this.gitHubRepoContext, this.run));
        }
        return children;
    }
    getTooltip() {
        let markdownString = "";
        if (this.run.hasPreviousAttempts && this.run.run.run_attempt) {
            markdownString += `Attempt #${this.run.run.run_attempt} `;
        }
        markdownString += (0,_runTooltipHelper__WEBPACK_IMPORTED_MODULE_2__.getStatusString)(this.run, markdownString.length == 0);
        markdownString += `\n\n`;
        markdownString += (0,_runTooltipHelper__WEBPACK_IMPORTED_MODULE_2__.getEventString)(this.run);
        return new vscode__WEBPACK_IMPORTED_MODULE_0__.MarkdownString(markdownString);
    }
    static _getLabel(run, workflowName) {
        return `${workflowName ? workflowName + " " : ""}#${run.run.run_number}`;
    }
}


/***/ }),

/***/ "./src/treeViews/treeViews.ts":
/*!************************************!*\
  !*** ./src/treeViews/treeViews.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initTreeViews: () => (/* binding */ initTreeViews)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/canReachGitHubAPI */ "./src/api/canReachGitHubAPI.ts");
/* harmony import */ var _workflow_languageServer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../workflow/languageServer */ "./src/workflow/languageServer.ts");
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../git/repository */ "./src/git/repository.ts");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../log */ "./src/log.ts");
/* harmony import */ var _currentBranch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./currentBranch */ "./src/treeViews/currentBranch.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./settings */ "./src/treeViews/settings.ts");
/* harmony import */ var _workflows__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./workflows */ "./src/treeViews/workflows.ts");








async function initTreeViews(context, store) {
    const workflowTreeProvider = new _workflows__WEBPACK_IMPORTED_MODULE_7__.WorkflowsTreeProvider(store);
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.window.registerTreeDataProvider("github-actions.workflows", workflowTreeProvider));
    const settingsTreeProvider = new _settings__WEBPACK_IMPORTED_MODULE_6__.SettingsTreeProvider();
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.window.registerTreeDataProvider("github-actions.settings", settingsTreeProvider));
    const currentBranchTreeProvider = new _currentBranch__WEBPACK_IMPORTED_MODULE_5__.CurrentBranchTreeProvider(store);
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.window.registerTreeDataProvider("github-actions.current-branch", currentBranchTreeProvider));
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.explorer.refresh", async () => {
        const canReachAPI = await (0,_api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__.canReachGitHubAPI)();
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "github-actions.internet-access", canReachAPI);
        const ghContext = await (0,_git_repository__WEBPACK_IMPORTED_MODULE_3__.getGitHubContext)();
        const hasGitHubRepos = ghContext && ghContext.repos.length > 0;
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "github-actions.has-repos", hasGitHubRepos);
        if (canReachAPI && hasGitHubRepos) {
            await workflowTreeProvider.refresh();
            await settingsTreeProvider.refresh();
        }
        await (0,_workflow_languageServer__WEBPACK_IMPORTED_MODULE_2__.executeCacheClearCommand)();
    }));
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand("github-actions.explorer.current-branch.refresh", async () => {
        await currentBranchTreeProvider.refresh();
    }));
    const gitHubContext = await (0,_git_repository__WEBPACK_IMPORTED_MODULE_3__.getGitHubContext)();
    if (!gitHubContext) {
        (0,_log__WEBPACK_IMPORTED_MODULE_4__.logDebug)("Could not register branch change event handler");
        return;
    }
    for (const repo of gitHubContext.repos) {
        if (!repo.repositoryState) {
            continue;
        }
        let currentAhead = repo.repositoryState.HEAD?.ahead;
        let currentHeadName = repo.repositoryState.HEAD?.name;
        repo.repositoryState.onDidChange(async () => {
            // When the current head/branch changes, or the number of commits ahead changes (which indicates
            // a push), refresh the current-branch view
            if (repo.repositoryState?.HEAD?.name !== currentHeadName ||
                (repo.repositoryState?.HEAD?.ahead || 0) < (currentAhead || 0)) {
                currentHeadName = repo.repositoryState?.HEAD?.name;
                currentAhead = repo.repositoryState?.HEAD?.ahead;
                await currentBranchTreeProvider.refresh();
            }
        });
    }
}


/***/ }),

/***/ "./src/treeViews/workflowRunTreeDataProvider.ts":
/*!******************************************************!*\
  !*** ./src/treeViews/workflowRunTreeDataProvider.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowRunTreeDataProvider: () => (/* binding */ WorkflowRunTreeDataProvider)
/* harmony export */ });
/* harmony import */ var _shared_workflowRunNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/workflowRunNode */ "./src/treeViews/shared/workflowRunNode.ts");

class WorkflowRunTreeDataProvider {
    constructor(store) {
        this.store = store;
        this._runNodes = new Map();
        this.store.event(({ run }) => {
            // Get tree node
            const node = this._runNodes.get(run.run.id);
            if (node) {
                node.updateRun(run);
                this._updateNode(node);
            }
        });
    }
    runNodes(gitHubRepoContext, runData, includeWorkflowName = false) {
        return runData.map(runData => {
            const workflowRun = this.store.addRun(gitHubRepoContext, runData);
            const node = new _shared_workflowRunNode__WEBPACK_IMPORTED_MODULE_0__.WorkflowRunNode(this.store, gitHubRepoContext, workflowRun, includeWorkflowName ? workflowRun.run.name || undefined : undefined);
            this._runNodes.set(runData.id, node);
            return node;
        });
    }
}


/***/ }),

/***/ "./src/treeViews/workflows.ts":
/*!************************************!*\
  !*** ./src/treeViews/workflows.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowsTreeProvider: () => (/* binding */ WorkflowsTreeProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/canReachGitHubAPI */ "./src/api/canReachGitHubAPI.ts");
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../git/repository */ "./src/git/repository.ts");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../log */ "./src/log.ts");
/* harmony import */ var _shared_attemptNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/attemptNode */ "./src/treeViews/shared/attemptNode.ts");
/* harmony import */ var _shared_authenticationNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shared/authenticationNode */ "./src/treeViews/shared/authenticationNode.ts");
/* harmony import */ var _shared_errorNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shared/errorNode */ "./src/treeViews/shared/errorNode.ts");
/* harmony import */ var _shared_gitHubApiUnreachableNode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shared/gitHubApiUnreachableNode */ "./src/treeViews/shared/gitHubApiUnreachableNode.ts");
/* harmony import */ var _shared_previousAttemptsNode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shared/previousAttemptsNode */ "./src/treeViews/shared/previousAttemptsNode.ts");
/* harmony import */ var _shared_workflowJobNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./shared/workflowJobNode */ "./src/treeViews/shared/workflowJobNode.ts");
/* harmony import */ var _shared_workflowRunNode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./shared/workflowRunNode */ "./src/treeViews/shared/workflowRunNode.ts");
/* harmony import */ var _workflowRunTreeDataProvider__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./workflowRunTreeDataProvider */ "./src/treeViews/workflowRunTreeDataProvider.ts");
/* harmony import */ var _workflows_workflowNode__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./workflows/workflowNode */ "./src/treeViews/workflows/workflowNode.ts");
/* harmony import */ var _workflows_workflowsRepoNode__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./workflows/workflowsRepoNode */ "./src/treeViews/workflows/workflowsRepoNode.ts");














class WorkflowsTreeProvider extends _workflowRunTreeDataProvider__WEBPACK_IMPORTED_MODULE_11__.WorkflowRunTreeDataProvider {
    constructor(store) {
        super(store);
        this._onDidChangeTreeData = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    }
    _updateNode(node) {
        this._onDidChangeTreeData.fire(node);
    }
    async refresh() {
        // Don't delete all the nodes if we can't reach GitHub API
        if (await (0,_api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__.canReachGitHubAPI)()) {
            this._onDidChangeTreeData.fire(null);
        }
        else {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage("Unable to refresh, could not reach GitHub API");
        }
    }
    getTreeItem(element) {
        return element;
    }
    async getChildren(element) {
        if (!element) {
            (0,_log__WEBPACK_IMPORTED_MODULE_3__.logDebug)("Getting root children");
            try {
                const gitHubContext = await (0,_git_repository__WEBPACK_IMPORTED_MODULE_2__.getGitHubContext)();
                if (!gitHubContext) {
                    (0,_log__WEBPACK_IMPORTED_MODULE_3__.logDebug)("could not get github context for workflows");
                    return [new _shared_gitHubApiUnreachableNode__WEBPACK_IMPORTED_MODULE_7__.GitHubAPIUnreachableNode()];
                }
                if (gitHubContext.repos.length > 0) {
                    // Special case, if there is only one repo, return workflow nodes directly
                    if (gitHubContext.repos.length == 1) {
                        return (0,_workflows_workflowsRepoNode__WEBPACK_IMPORTED_MODULE_13__.getWorkflowNodes)(gitHubContext.repos[0]);
                    }
                    return gitHubContext.repos.map(r => new _workflows_workflowsRepoNode__WEBPACK_IMPORTED_MODULE_13__.WorkflowsRepoNode(r));
                }
                (0,_log__WEBPACK_IMPORTED_MODULE_3__.log)("No GitHub repositories found");
                return [];
            }
            catch (e) {
                (0,_log__WEBPACK_IMPORTED_MODULE_3__.logError)(e, "Failed to get GitHub context");
                if (`${e.message}`.startsWith("Could not get token from the GitHub authentication provider.")) {
                    return [new _shared_authenticationNode__WEBPACK_IMPORTED_MODULE_5__.AuthenticationNode()];
                }
                return [new _shared_errorNode__WEBPACK_IMPORTED_MODULE_6__.ErrorNode(`An error has occurred: ${e.message}`)];
            }
        }
        if (element instanceof _workflows_workflowsRepoNode__WEBPACK_IMPORTED_MODULE_13__.WorkflowsRepoNode) {
            return element.getWorkflows();
        }
        else if (element instanceof _workflows_workflowNode__WEBPACK_IMPORTED_MODULE_12__.WorkflowNode) {
            return this.getRuns(element);
        }
        else if (element instanceof _shared_workflowRunNode__WEBPACK_IMPORTED_MODULE_10__.WorkflowRunNode) {
            return element.getJobs();
        }
        else if (element instanceof _shared_previousAttemptsNode__WEBPACK_IMPORTED_MODULE_8__.PreviousAttemptsNode) {
            return element.getAttempts();
        }
        else if (element instanceof _shared_attemptNode__WEBPACK_IMPORTED_MODULE_4__.AttemptNode) {
            return element.getJobs();
        }
        else if (element instanceof _shared_workflowJobNode__WEBPACK_IMPORTED_MODULE_9__.WorkflowJobNode) {
            return element.getSteps();
        }
        return [];
    }
    async getRuns(wfNode) {
        (0,_log__WEBPACK_IMPORTED_MODULE_3__.logDebug)("Getting workflow runs for workflow");
        const result = await wfNode.gitHubRepoContext.client.actions.listWorkflowRuns({
            owner: wfNode.gitHubRepoContext.owner,
            repo: wfNode.gitHubRepoContext.name,
            workflow_id: wfNode.wf.id
        });
        return this.runNodes(wfNode.gitHubRepoContext, result.data.workflow_runs);
    }
}


/***/ }),

/***/ "./src/treeViews/workflows/workflowNode.ts":
/*!*************************************************!*\
  !*** ./src/treeViews/workflows/workflowNode.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowNode: () => (/* binding */ WorkflowNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _configuration_configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../configuration/configuration */ "./src/configuration/configuration.ts");
/* harmony import */ var _workflow_workflow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../workflow/workflow */ "./src/workflow/workflow.ts");



class WorkflowNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext, wf, workflowContext) {
        super(wf.name, vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.wf = wf;
        this.workflowContext = workflowContext;
        this.updateContextValue();
    }
    updateContextValue() {
        this.contextValue = "workflow";
        const workflowFullPath = (0,_workflow_workflow__WEBPACK_IMPORTED_MODULE_2__.getWorkflowUri)(this.gitHubRepoContext, this.wf.path);
        if (workflowFullPath) {
            const relativeWorkflowPath = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.asRelativePath(workflowFullPath);
            if (new Set((0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_1__.getPinnedWorkflows)()).has(relativeWorkflowPath)) {
                this.contextValue += " pinned";
            }
            else {
                this.contextValue += " pinnable";
            }
        }
        if (this.workflowContext) {
            this.contextValue += this.workflowContext;
        }
    }
}


/***/ }),

/***/ "./src/treeViews/workflows/workflowStepNode.ts":
/*!*****************************************************!*\
  !*** ./src/treeViews/workflows/workflowStepNode.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowStepNode: () => (/* binding */ WorkflowStepNode)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../icons */ "./src/treeViews/icons.ts");


class WorkflowStepNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext, job, step) {
        super(step.name);
        this.gitHubRepoContext = gitHubRepoContext;
        this.job = job;
        this.step = step;
        this.contextValue = "step";
        if (this.step.status === "completed") {
            this.contextValue += " completed";
        }
        this.iconPath = (0,_icons__WEBPACK_IMPORTED_MODULE_1__.getIconForWorkflowStep)(this.step);
    }
}


/***/ }),

/***/ "./src/treeViews/workflows/workflowsRepoNode.ts":
/*!******************************************************!*\
  !*** ./src/treeViews/workflows/workflowsRepoNode.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowsRepoNode: () => (/* binding */ WorkflowsRepoNode),
/* harmony export */   getWorkflowNodes: () => (/* binding */ getWorkflowNodes)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../log */ "./src/log.ts");
/* harmony import */ var _workflow_workflow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../workflow/workflow */ "./src/workflow/workflow.ts");
/* harmony import */ var _workflowNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./workflowNode */ "./src/treeViews/workflows/workflowNode.ts");




class WorkflowsRepoNode extends vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem {
    constructor(gitHubRepoContext) {
        super(gitHubRepoContext.name, vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed);
        this.gitHubRepoContext = gitHubRepoContext;
        this.contextValue = "wf-repo";
    }
    async getWorkflows() {
        (0,_log__WEBPACK_IMPORTED_MODULE_1__.logDebug)("Getting workflows");
        return getWorkflowNodes(this.gitHubRepoContext);
    }
}
async function getWorkflowNodes(gitHubRepoContext) {
    const opts = gitHubRepoContext.client.actions.listRepoWorkflows.endpoint.merge({
        owner: gitHubRepoContext.owner,
        repo: gitHubRepoContext.name,
        per_page: 100
    });
    // retrieve all pages
    const workflows = await gitHubRepoContext.client.paginate(opts);
    workflows.sort((a, b) => a.name.localeCompare(b.name));
    return await Promise.all(workflows.map(async (wf) => {
        const workflowUri = (0,_workflow_workflow__WEBPACK_IMPORTED_MODULE_2__.getWorkflowUri)(gitHubRepoContext, wf.path);
        const workflowContext = await (0,_workflow_workflow__WEBPACK_IMPORTED_MODULE_2__.getContextStringForWorkflow)(workflowUri);
        const nameWithoutNewlines = wf.name.replace(/(\r\n|\n|\r)/gm, " ");
        // We are removing all newline characters from the workflow name for presentation purposes
        wf.name = nameWithoutNewlines;
        return new _workflowNode__WEBPACK_IMPORTED_MODULE_3__.WorkflowNode(gitHubRepoContext, wf, workflowContext);
    }));
}


/***/ }),

/***/ "./src/workflow/documentSelector.ts":
/*!******************************************!*\
  !*** ./src/workflow/documentSelector.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowSelector: () => (/* binding */ WorkflowSelector)
/* harmony export */ });
const WorkflowSelector = {
    pattern: "**/.github/workflows/*.{yaml,yml}"
};


/***/ }),

/***/ "./src/workflow/languageServer.ts":
/*!****************************************!*\
  !*** ./src/workflow/languageServer.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deactivateLanguageServer: () => (/* binding */ deactivateLanguageServer),
/* harmony export */   executeCacheClearCommand: () => (/* binding */ executeCacheClearCommand),
/* harmony export */   initLanguageServer: () => (/* binding */ initLanguageServer)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _actions_languageserver_commands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @actions/languageserver/commands */ "./node_modules/@actions/languageserver/dist/commands.js");
/* harmony import */ var _actions_languageserver_initializationOptions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @actions/languageserver/initializationOptions */ "./node_modules/@actions/languageserver/dist/initializationOptions.js");
/* harmony import */ var _actions_languageserver_request__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @actions/languageserver/request */ "./node_modules/@actions/languageserver/dist/request.js");
/* harmony import */ var vscode_languageclient_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vscode-languageclient/browser */ "./node_modules/vscode-languageclient/browser.js");
/* harmony import */ var vscode_languageclient_browser__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(vscode_languageclient_browser__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var vscode_languageclient_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vscode-languageclient/node */ "./node_modules/vscode-languageclient/node.js");
/* harmony import */ var vscode_languageclient_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(vscode_languageclient_node__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _api_api__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../api/api */ "./src/api/api.ts");
/* harmony import */ var _auth_auth__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../auth/auth */ "./src/auth/auth.ts");
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../git/repository */ "./src/git/repository.ts");
/* harmony import */ var _documentSelector__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./documentSelector */ "./src/workflow/documentSelector.ts");
/* harmony import */ var _configuration_configuration__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../configuration/configuration */ "./src/configuration/configuration.ts");












let client;
/** Helper function determining whether we are executing with node runtime */
function isNode() {
    return typeof process !== "undefined" && process.versions?.node != null;
}
async function initLanguageServer(context) {
    const session = await (0,_auth_auth__WEBPACK_IMPORTED_MODULE_8__.getSession)();
    const ghContext = await (0,_git_repository__WEBPACK_IMPORTED_MODULE_9__.getGitHubContext)();
    const initializationOptions = {
        sessionToken: session?.accessToken,
        userAgent: _api_api__WEBPACK_IMPORTED_MODULE_7__.userAgent,
        gitHubApiUrl: (0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_11__.useEnterprise)() ? (0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_11__.getGitHubApiUri)() : undefined,
        repos: ghContext?.repos.map(repo => ({
            id: repo.id,
            owner: repo.owner,
            name: repo.name,
            workspaceUri: repo.workspaceUri.toString(),
            organizationOwned: repo.organizationOwned
        })),
        logLevel:  false ? 0 : _actions_languageserver_initializationOptions__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug
    };
    const clientOptions = {
        documentSelector: [_documentSelector__WEBPACK_IMPORTED_MODULE_10__.WorkflowSelector],
        initializationOptions: initializationOptions,
        progressOnInitialization: true
    };
    // Create the language client and start the client.
    if (isNode()) {
        const debugOptions = { execArgv: ["--nolazy", "--inspect=6010"] };
        const serverModule = context.asAbsolutePath(path__WEBPACK_IMPORTED_MODULE_0__.join("dist", "server-node.js"));
        const serverOptions = {
            run: { module: serverModule, transport: vscode_languageclient_node__WEBPACK_IMPORTED_MODULE_6__.TransportKind.ipc },
            debug: {
                module: serverModule,
                transport: vscode_languageclient_node__WEBPACK_IMPORTED_MODULE_6__.TransportKind.ipc,
                options: debugOptions
            }
        };
        client = new vscode_languageclient_node__WEBPACK_IMPORTED_MODULE_6__.LanguageClient("actions-language", "GitHub Actions Language Server", serverOptions, clientOptions);
    }
    else {
        const serverModule = vscode__WEBPACK_IMPORTED_MODULE_1__.Uri.joinPath(context.extensionUri, "dist", "server-web.js");
        const worker = new Worker(serverModule.toString());
        client = new vscode_languageclient_browser__WEBPACK_IMPORTED_MODULE_5__.LanguageClient("actions-language", "GitHub Actions Language Server", clientOptions, worker);
    }
    client.onRequest(_actions_languageserver_request__WEBPACK_IMPORTED_MODULE_4__.Requests.ReadFile, async (event) => {
        if (typeof event?.path !== "string") {
            return null;
        }
        const uri = vscode__WEBPACK_IMPORTED_MODULE_1__.Uri.parse(event?.path);
        const content = await vscode__WEBPACK_IMPORTED_MODULE_1__.workspace.fs.readFile(uri);
        return new TextDecoder().decode(content);
    });
    return client.start();
}
function deactivateLanguageServer() {
    if (!client) {
        return Promise.resolve();
    }
    return client.stop();
}
function executeCacheClearCommand() {
    if (!client) {
        return Promise.resolve();
    }
    return client.sendRequest("workspace/executeCommand", { command: _actions_languageserver_commands__WEBPACK_IMPORTED_MODULE_2__.Commands.ClearCache });
}


/***/ }),

/***/ "./src/workflow/workflow.ts":
/*!**********************************!*\
  !*** ./src/workflow/workflow.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getContextStringForWorkflow: () => (/* binding */ getContextStringForWorkflow),
/* harmony export */   getWorkflowUri: () => (/* binding */ getWorkflowUri),
/* harmony export */   parseWorkflowFile: () => (/* binding */ parseWorkflowFile)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _actions_workflow_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @actions/workflow-parser */ "./node_modules/@actions/workflow-parser/dist/index.js");
/* harmony import */ var _actions_workflow_parser_model_convert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @actions/workflow-parser/model/convert */ "./node_modules/@actions/workflow-parser/dist/model/convert.js");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);




async function getContextStringForWorkflow(workflowUri) {
    try {
        const content = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(workflowUri);
        const file = new TextDecoder().decode(content);
        const fileName = "";
        const result = (0,_actions_workflow_parser__WEBPACK_IMPORTED_MODULE_1__.parseWorkflow)({
            name: fileName,
            content: file
        }, new _actions_workflow_parser__WEBPACK_IMPORTED_MODULE_1__.NoOperationTraceWriter());
        if (result.value) {
            const template = await (0,_actions_workflow_parser__WEBPACK_IMPORTED_MODULE_1__.convertWorkflowTemplate)(result.context, result.value, undefined, {
                errorPolicy: _actions_workflow_parser_model_convert__WEBPACK_IMPORTED_MODULE_2__.ErrorPolicy.TryConversion
            });
            const context = [];
            if (template.events["repository_dispatch"]) {
                context.push("rdispatch");
            }
            if (template.events["workflow_dispatch"]) {
                context.push("wdispatch");
            }
            return context.join("");
        }
    }
    catch (e) {
        // Ignore
    }
    return "";
}
/**
 * Try to get Uri to workflow in currently open workspace folders
 *
 * @param path Path for workflow. E.g., `.github/workflows/somebuild.yaml`
 */
function getWorkflowUri(gitHubRepoContext, path) {
    return vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(gitHubRepoContext.workspaceUri, path);
}
async function parseWorkflowFile(uri) {
    try {
        const b = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(uri);
        const workflowInput = new TextDecoder().decode(b);
        const fileName = (0,path__WEBPACK_IMPORTED_MODULE_3__.basename)(uri.fsPath);
        const result = (0,_actions_workflow_parser__WEBPACK_IMPORTED_MODULE_1__.parseWorkflow)({
            name: fileName,
            content: workflowInput
        }, new _actions_workflow_parser__WEBPACK_IMPORTED_MODULE_1__.NoOperationTraceWriter());
        if (result.value) {
            return await (0,_actions_workflow_parser__WEBPACK_IMPORTED_MODULE_1__.convertWorkflowTemplate)(result.context, result.value);
        }
    }
    catch {
        // Ignore error here
    }
    return undefined;
}


/***/ }),

/***/ "vscode":
/*!*************************!*\
  !*** external "vscode" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "node:assert":
/*!******************************!*\
  !*** external "node:assert" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:assert");

/***/ }),

/***/ "node:async_hooks":
/*!***********************************!*\
  !*** external "node:async_hooks" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:async_hooks");

/***/ }),

/***/ "node:buffer":
/*!******************************!*\
  !*** external "node:buffer" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:buffer");

/***/ }),

/***/ "node:console":
/*!*******************************!*\
  !*** external "node:console" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:console");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "node:diagnostics_channel":
/*!*******************************************!*\
  !*** external "node:diagnostics_channel" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:diagnostics_channel");

/***/ }),

/***/ "node:events":
/*!******************************!*\
  !*** external "node:events" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:events");

/***/ }),

/***/ "node:http":
/*!****************************!*\
  !*** external "node:http" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:http");

/***/ }),

/***/ "node:http2":
/*!*****************************!*\
  !*** external "node:http2" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:http2");

/***/ }),

/***/ "node:net":
/*!***************************!*\
  !*** external "node:net" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:net");

/***/ }),

/***/ "node:perf_hooks":
/*!**********************************!*\
  !*** external "node:perf_hooks" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:perf_hooks");

/***/ }),

/***/ "node:querystring":
/*!***********************************!*\
  !*** external "node:querystring" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:querystring");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:stream");

/***/ }),

/***/ "node:tls":
/*!***************************!*\
  !*** external "node:tls" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:tls");

/***/ }),

/***/ "node:url":
/*!***************************!*\
  !*** external "node:url" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:url");

/***/ }),

/***/ "node:util":
/*!****************************!*\
  !*** external "node:util" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:util");

/***/ }),

/***/ "node:util/types":
/*!**********************************!*\
  !*** external "node:util/types" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:util/types");

/***/ }),

/***/ "node:worker_threads":
/*!**************************************!*\
  !*** external "node:worker_threads" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:worker_threads");

/***/ }),

/***/ "node:zlib":
/*!****************************!*\
  !*** external "node:zlib" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:zlib");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "./node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const WritableStream = (__webpack_require__(/*! node:stream */ "node:stream").Writable)
const inherits = (__webpack_require__(/*! node:util */ "node:util").inherits)

const StreamSearch = __webpack_require__(/*! ../../streamsearch/sbmh */ "./node_modules/@fastify/busboy/deps/streamsearch/sbmh.js")

const PartStream = __webpack_require__(/*! ./PartStream */ "./node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js")
const HeaderParser = __webpack_require__(/*! ./HeaderParser */ "./node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js")

const DASH = 45
const B_ONEDASH = Buffer.from('-')
const B_CRLF = Buffer.from('\r\n')
const EMPTY_FN = function () {}

function Dicer (cfg) {
  if (!(this instanceof Dicer)) { return new Dicer(cfg) }
  WritableStream.call(this, cfg)

  if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string')) { throw new TypeError('Boundary required') }

  if (typeof cfg.boundary === 'string') { this.setBoundary(cfg.boundary) } else { this._bparser = undefined }

  this._headerFirst = cfg.headerFirst

  this._dashes = 0
  this._parts = 0
  this._finished = false
  this._realFinish = false
  this._isPreamble = true
  this._justMatched = false
  this._firstWrite = true
  this._inHeader = true
  this._part = undefined
  this._cb = undefined
  this._ignoreData = false
  this._partOpts = { highWaterMark: cfg.partHwm }
  this._pause = false

  const self = this
  this._hparser = new HeaderParser(cfg)
  this._hparser.on('header', function (header) {
    self._inHeader = false
    self._part.emit('header', header)
  })
}
inherits(Dicer, WritableStream)

Dicer.prototype.emit = function (ev) {
  if (ev === 'finish' && !this._realFinish) {
    if (!this._finished) {
      const self = this
      process.nextTick(function () {
        self.emit('error', new Error('Unexpected end of multipart data'))
        if (self._part && !self._ignoreData) {
          const type = (self._isPreamble ? 'Preamble' : 'Part')
          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'))
          self._part.push(null)
          process.nextTick(function () {
            self._realFinish = true
            self.emit('finish')
            self._realFinish = false
          })
          return
        }
        self._realFinish = true
        self.emit('finish')
        self._realFinish = false
      })
    }
  } else { WritableStream.prototype.emit.apply(this, arguments) }
}

Dicer.prototype._write = function (data, encoding, cb) {
  // ignore unexpected data (e.g. extra trailer data after finished)
  if (!this._hparser && !this._bparser) { return cb() }

  if (this._headerFirst && this._isPreamble) {
    if (!this._part) {
      this._part = new PartStream(this._partOpts)
      if (this.listenerCount('preamble') !== 0) { this.emit('preamble', this._part) } else { this._ignore() }
    }
    const r = this._hparser.push(data)
    if (!this._inHeader && r !== undefined && r < data.length) { data = data.slice(r) } else { return cb() }
  }

  // allows for "easier" testing
  if (this._firstWrite) {
    this._bparser.push(B_CRLF)
    this._firstWrite = false
  }

  this._bparser.push(data)

  if (this._pause) { this._cb = cb } else { cb() }
}

Dicer.prototype.reset = function () {
  this._part = undefined
  this._bparser = undefined
  this._hparser = undefined
}

Dicer.prototype.setBoundary = function (boundary) {
  const self = this
  this._bparser = new StreamSearch('\r\n--' + boundary)
  this._bparser.on('info', function (isMatch, data, start, end) {
    self._oninfo(isMatch, data, start, end)
  })
}

Dicer.prototype._ignore = function () {
  if (this._part && !this._ignoreData) {
    this._ignoreData = true
    this._part.on('error', EMPTY_FN)
    // we must perform some kind of read on the stream even though we are
    // ignoring the data, otherwise node's Readable stream will not emit 'end'
    // after pushing null to the stream
    this._part.resume()
  }
}

Dicer.prototype._oninfo = function (isMatch, data, start, end) {
  let buf; const self = this; let i = 0; let r; let shouldWriteMore = true

  if (!this._part && this._justMatched && data) {
    while (this._dashes < 2 && (start + i) < end) {
      if (data[start + i] === DASH) {
        ++i
        ++this._dashes
      } else {
        if (this._dashes) { buf = B_ONEDASH }
        this._dashes = 0
        break
      }
    }
    if (this._dashes === 2) {
      if ((start + i) < end && this.listenerCount('trailer') !== 0) { this.emit('trailer', data.slice(start + i, end)) }
      this.reset()
      this._finished = true
      // no more parts will be added
      if (self._parts === 0) {
        self._realFinish = true
        self.emit('finish')
        self._realFinish = false
      }
    }
    if (this._dashes) { return }
  }
  if (this._justMatched) { this._justMatched = false }
  if (!this._part) {
    this._part = new PartStream(this._partOpts)
    this._part._read = function (n) {
      self._unpause()
    }
    if (this._isPreamble && this.listenerCount('preamble') !== 0) {
      this.emit('preamble', this._part)
    } else if (this._isPreamble !== true && this.listenerCount('part') !== 0) {
      this.emit('part', this._part)
    } else {
      this._ignore()
    }
    if (!this._isPreamble) { this._inHeader = true }
  }
  if (data && start < end && !this._ignoreData) {
    if (this._isPreamble || !this._inHeader) {
      if (buf) { shouldWriteMore = this._part.push(buf) }
      shouldWriteMore = this._part.push(data.slice(start, end))
      if (!shouldWriteMore) { this._pause = true }
    } else if (!this._isPreamble && this._inHeader) {
      if (buf) { this._hparser.push(buf) }
      r = this._hparser.push(data.slice(start, end))
      if (!this._inHeader && r !== undefined && r < end) { this._oninfo(false, data, start + r, end) }
    }
  }
  if (isMatch) {
    this._hparser.reset()
    if (this._isPreamble) { this._isPreamble = false } else {
      if (start !== end) {
        ++this._parts
        this._part.on('end', function () {
          if (--self._parts === 0) {
            if (self._finished) {
              self._realFinish = true
              self.emit('finish')
              self._realFinish = false
            } else {
              self._unpause()
            }
          }
        })
      }
    }
    this._part.push(null)
    this._part = undefined
    this._ignoreData = false
    this._justMatched = true
    this._dashes = 0
  }
}

Dicer.prototype._unpause = function () {
  if (!this._pause) { return }

  this._pause = false
  if (this._cb) {
    const cb = this._cb
    this._cb = undefined
    cb()
  }
}

module.exports = Dicer


/***/ }),

/***/ "./node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


const EventEmitter = (__webpack_require__(/*! node:events */ "node:events").EventEmitter)
const inherits = (__webpack_require__(/*! node:util */ "node:util").inherits)
const getLimit = __webpack_require__(/*! ../../../lib/utils/getLimit */ "./node_modules/@fastify/busboy/lib/utils/getLimit.js")

const StreamSearch = __webpack_require__(/*! ../../streamsearch/sbmh */ "./node_modules/@fastify/busboy/deps/streamsearch/sbmh.js")

const B_DCRLF = Buffer.from('\r\n\r\n')
const RE_CRLF = /\r\n/g
const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/ // eslint-disable-line no-control-regex

function HeaderParser (cfg) {
  EventEmitter.call(this)

  cfg = cfg || {}
  const self = this
  this.nread = 0
  this.maxed = false
  this.npairs = 0
  this.maxHeaderPairs = getLimit(cfg, 'maxHeaderPairs', 2000)
  this.maxHeaderSize = getLimit(cfg, 'maxHeaderSize', 80 * 1024)
  this.buffer = ''
  this.header = {}
  this.finished = false
  this.ss = new StreamSearch(B_DCRLF)
  this.ss.on('info', function (isMatch, data, start, end) {
    if (data && !self.maxed) {
      if (self.nread + end - start >= self.maxHeaderSize) {
        end = self.maxHeaderSize - self.nread + start
        self.nread = self.maxHeaderSize
        self.maxed = true
      } else { self.nread += (end - start) }

      self.buffer += data.toString('binary', start, end)
    }
    if (isMatch) { self._finish() }
  })
}
inherits(HeaderParser, EventEmitter)

HeaderParser.prototype.push = function (data) {
  const r = this.ss.push(data)
  if (this.finished) { return r }
}

HeaderParser.prototype.reset = function () {
  this.finished = false
  this.buffer = ''
  this.header = {}
  this.ss.reset()
}

HeaderParser.prototype._finish = function () {
  if (this.buffer) { this._parseHeader() }
  this.ss.matches = this.ss.maxMatches
  const header = this.header
  this.header = {}
  this.buffer = ''
  this.finished = true
  this.nread = this.npairs = 0
  this.maxed = false
  this.emit('header', header)
}

HeaderParser.prototype._parseHeader = function () {
  if (this.npairs === this.maxHeaderPairs) { return }

  const lines = this.buffer.split(RE_CRLF)
  const len = lines.length
  let m, h

  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
    if (lines[i].length === 0) { continue }
    if (lines[i][0] === '\t' || lines[i][0] === ' ') {
      // folded header content
      // RFC2822 says to just remove the CRLF and not the whitespace following
      // it, so we follow the RFC and include the leading whitespace ...
      if (h) {
        this.header[h][this.header[h].length - 1] += lines[i]
        continue
      }
    }

    const posColon = lines[i].indexOf(':')
    if (
      posColon === -1 ||
      posColon === 0
    ) {
      return
    }
    m = RE_HDR.exec(lines[i])
    h = m[1].toLowerCase()
    this.header[h] = this.header[h] || []
    this.header[h].push((m[2] || ''))
    if (++this.npairs === this.maxHeaderPairs) { break }
  }
}

module.exports = HeaderParser


/***/ }),

/***/ "./node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const inherits = (__webpack_require__(/*! node:util */ "node:util").inherits)
const ReadableStream = (__webpack_require__(/*! node:stream */ "node:stream").Readable)

function PartStream (opts) {
  ReadableStream.call(this, opts)
}
inherits(PartStream, ReadableStream)

PartStream.prototype._read = function (n) {}

module.exports = PartStream


/***/ }),

/***/ "./node_modules/@fastify/busboy/deps/streamsearch/sbmh.js":
/*!****************************************************************!*\
  !*** ./node_modules/@fastify/busboy/deps/streamsearch/sbmh.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


/**
 * Copyright Brian White. All rights reserved.
 *
 * @see https://github.com/mscdex/streamsearch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
 * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
 */
const EventEmitter = (__webpack_require__(/*! node:events */ "node:events").EventEmitter)
const inherits = (__webpack_require__(/*! node:util */ "node:util").inherits)

function SBMH (needle) {
  if (typeof needle === 'string') {
    needle = Buffer.from(needle)
  }

  if (!Buffer.isBuffer(needle)) {
    throw new TypeError('The needle has to be a String or a Buffer.')
  }

  const needleLength = needle.length

  if (needleLength === 0) {
    throw new Error('The needle cannot be an empty String/Buffer.')
  }

  if (needleLength > 256) {
    throw new Error('The needle cannot have a length bigger than 256.')
  }

  this.maxMatches = Infinity
  this.matches = 0

  this._occ = new Array(256)
    .fill(needleLength) // Initialize occurrence table.
  this._lookbehind_size = 0
  this._needle = needle
  this._bufpos = 0

  this._lookbehind = Buffer.alloc(needleLength)

  // Populate occurrence table with analysis of the needle,
  // ignoring last letter.
  for (var i = 0; i < needleLength - 1; ++i) { // eslint-disable-line no-var
    this._occ[needle[i]] = needleLength - 1 - i
  }
}
inherits(SBMH, EventEmitter)

SBMH.prototype.reset = function () {
  this._lookbehind_size = 0
  this.matches = 0
  this._bufpos = 0
}

SBMH.prototype.push = function (chunk, pos) {
  if (!Buffer.isBuffer(chunk)) {
    chunk = Buffer.from(chunk, 'binary')
  }
  const chlen = chunk.length
  this._bufpos = pos || 0
  let r
  while (r !== chlen && this.matches < this.maxMatches) { r = this._sbmh_feed(chunk) }
  return r
}

SBMH.prototype._sbmh_feed = function (data) {
  const len = data.length
  const needle = this._needle
  const needleLength = needle.length
  const lastNeedleChar = needle[needleLength - 1]

  // Positive: points to a position in `data`
  //           pos == 3 points to data[3]
  // Negative: points to a position in the lookbehind buffer
  //           pos == -2 points to lookbehind[lookbehind_size - 2]
  let pos = -this._lookbehind_size
  let ch

  if (pos < 0) {
    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool
    // search with character lookup code that considers both the
    // lookbehind buffer and the current round's haystack data.
    //
    // Loop until
    //   there is a match.
    // or until
    //   we've moved past the position that requires the
    //   lookbehind buffer. In this case we switch to the
    //   optimized loop.
    // or until
    //   the character to look at lies outside the haystack.
    while (pos < 0 && pos <= len - needleLength) {
      ch = this._sbmh_lookup_char(data, pos + needleLength - 1)

      if (
        ch === lastNeedleChar &&
        this._sbmh_memcmp(data, pos, needleLength - 1)
      ) {
        this._lookbehind_size = 0
        ++this.matches
        this.emit('info', true)

        return (this._bufpos = pos + needleLength)
      }
      pos += this._occ[ch]
    }

    // No match.

    if (pos < 0) {
      // There's too few data for Boyer-Moore-Horspool to run,
      // so let's use a different algorithm to skip as much as
      // we can.
      // Forward pos until
      //   the trailing part of lookbehind + data
      //   looks like the beginning of the needle
      // or until
      //   pos == 0
      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) { ++pos }
    }

    if (pos >= 0) {
      // Discard lookbehind buffer.
      this.emit('info', false, this._lookbehind, 0, this._lookbehind_size)
      this._lookbehind_size = 0
    } else {
      // Cut off part of the lookbehind buffer that has
      // been processed and append the entire haystack
      // into it.
      const bytesToCutOff = this._lookbehind_size + pos
      if (bytesToCutOff > 0) {
        // The cut off data is guaranteed not to contain the needle.
        this.emit('info', false, this._lookbehind, 0, bytesToCutOff)
      }

      this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff,
        this._lookbehind_size - bytesToCutOff)
      this._lookbehind_size -= bytesToCutOff

      data.copy(this._lookbehind, this._lookbehind_size)
      this._lookbehind_size += len

      this._bufpos = len
      return len
    }
  }

  pos += (pos >= 0) * this._bufpos

  // Lookbehind buffer is now empty. We only need to check if the
  // needle is in the haystack.
  if (data.indexOf(needle, pos) !== -1) {
    pos = data.indexOf(needle, pos)
    ++this.matches
    if (pos > 0) { this.emit('info', true, data, this._bufpos, pos) } else { this.emit('info', true) }

    return (this._bufpos = pos + needleLength)
  } else {
    pos = len - needleLength
  }

  // There was no match. If there's trailing haystack data that we cannot
  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing
  // data is less than the needle size) then match using a modified
  // algorithm that starts matching from the beginning instead of the end.
  // Whatever trailing data is left after running this algorithm is added to
  // the lookbehind buffer.
  while (
    pos < len &&
    (
      data[pos] !== needle[0] ||
      (
        (Buffer.compare(
          data.subarray(pos, pos + len - pos),
          needle.subarray(0, len - pos)
        ) !== 0)
      )
    )
  ) {
    ++pos
  }
  if (pos < len) {
    data.copy(this._lookbehind, 0, pos, pos + (len - pos))
    this._lookbehind_size = len - pos
  }

  // Everything until pos is guaranteed not to contain needle data.
  if (pos > 0) { this.emit('info', false, data, this._bufpos, pos < len ? pos : len) }

  this._bufpos = len
  return len
}

SBMH.prototype._sbmh_lookup_char = function (data, pos) {
  return (pos < 0)
    ? this._lookbehind[this._lookbehind_size + pos]
    : data[pos]
}

SBMH.prototype._sbmh_memcmp = function (data, pos, len) {
  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
    if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) { return false }
  }
  return true
}

module.exports = SBMH


/***/ }),

/***/ "./node_modules/@fastify/busboy/lib/main.js":
/*!**************************************************!*\
  !*** ./node_modules/@fastify/busboy/lib/main.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const WritableStream = (__webpack_require__(/*! node:stream */ "node:stream").Writable)
const { inherits } = __webpack_require__(/*! node:util */ "node:util")
const Dicer = __webpack_require__(/*! ../deps/dicer/lib/Dicer */ "./node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js")

const MultipartParser = __webpack_require__(/*! ./types/multipart */ "./node_modules/@fastify/busboy/lib/types/multipart.js")
const UrlencodedParser = __webpack_require__(/*! ./types/urlencoded */ "./node_modules/@fastify/busboy/lib/types/urlencoded.js")
const parseParams = __webpack_require__(/*! ./utils/parseParams */ "./node_modules/@fastify/busboy/lib/utils/parseParams.js")

function Busboy (opts) {
  if (!(this instanceof Busboy)) { return new Busboy(opts) }

  if (typeof opts !== 'object') {
    throw new TypeError('Busboy expected an options-Object.')
  }
  if (typeof opts.headers !== 'object') {
    throw new TypeError('Busboy expected an options-Object with headers-attribute.')
  }
  if (typeof opts.headers['content-type'] !== 'string') {
    throw new TypeError('Missing Content-Type-header.')
  }

  const {
    headers,
    ...streamOptions
  } = opts

  this.opts = {
    autoDestroy: false,
    ...streamOptions
  }
  WritableStream.call(this, this.opts)

  this._done = false
  this._parser = this.getParserByHeaders(headers)
  this._finished = false
}
inherits(Busboy, WritableStream)

Busboy.prototype.emit = function (ev) {
  if (ev === 'finish') {
    if (!this._done) {
      this._parser?.end()
      return
    } else if (this._finished) {
      return
    }
    this._finished = true
  }
  WritableStream.prototype.emit.apply(this, arguments)
}

Busboy.prototype.getParserByHeaders = function (headers) {
  const parsed = parseParams(headers['content-type'])

  const cfg = {
    defCharset: this.opts.defCharset,
    fileHwm: this.opts.fileHwm,
    headers,
    highWaterMark: this.opts.highWaterMark,
    isPartAFile: this.opts.isPartAFile,
    limits: this.opts.limits,
    parsedConType: parsed,
    preservePath: this.opts.preservePath
  }

  if (MultipartParser.detect.test(parsed[0])) {
    return new MultipartParser(this, cfg)
  }
  if (UrlencodedParser.detect.test(parsed[0])) {
    return new UrlencodedParser(this, cfg)
  }
  throw new Error('Unsupported Content-Type.')
}

Busboy.prototype._write = function (chunk, encoding, cb) {
  this._parser.write(chunk, cb)
}

module.exports = Busboy
module.exports["default"] = Busboy
module.exports.Busboy = Busboy

module.exports.Dicer = Dicer


/***/ }),

/***/ "./node_modules/@fastify/busboy/lib/types/multipart.js":
/*!*************************************************************!*\
  !*** ./node_modules/@fastify/busboy/lib/types/multipart.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// TODO:
//  * support 1 nested multipart level
//    (see second multipart example here:
//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)
//  * support limits.fieldNameSize
//     -- this will require modifications to utils.parseParams

const { Readable } = __webpack_require__(/*! node:stream */ "node:stream")
const { inherits } = __webpack_require__(/*! node:util */ "node:util")

const Dicer = __webpack_require__(/*! ../../deps/dicer/lib/Dicer */ "./node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js")

const parseParams = __webpack_require__(/*! ../utils/parseParams */ "./node_modules/@fastify/busboy/lib/utils/parseParams.js")
const decodeText = __webpack_require__(/*! ../utils/decodeText */ "./node_modules/@fastify/busboy/lib/utils/decodeText.js")
const basename = __webpack_require__(/*! ../utils/basename */ "./node_modules/@fastify/busboy/lib/utils/basename.js")
const getLimit = __webpack_require__(/*! ../utils/getLimit */ "./node_modules/@fastify/busboy/lib/utils/getLimit.js")

const RE_BOUNDARY = /^boundary$/i
const RE_FIELD = /^form-data$/i
const RE_CHARSET = /^charset$/i
const RE_FILENAME = /^filename$/i
const RE_NAME = /^name$/i

Multipart.detect = /^multipart\/form-data/i
function Multipart (boy, cfg) {
  let i
  let len
  const self = this
  let boundary
  const limits = cfg.limits
  const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => (contentType === 'application/octet-stream' || fileName !== undefined))
  const parsedConType = cfg.parsedConType || []
  const defCharset = cfg.defCharset || 'utf8'
  const preservePath = cfg.preservePath
  const fileOpts = { highWaterMark: cfg.fileHwm }

  for (i = 0, len = parsedConType.length; i < len; ++i) {
    if (Array.isArray(parsedConType[i]) &&
      RE_BOUNDARY.test(parsedConType[i][0])) {
      boundary = parsedConType[i][1]
      break
    }
  }

  function checkFinished () {
    if (nends === 0 && finished && !boy._done) {
      finished = false
      self.end()
    }
  }

  if (typeof boundary !== 'string') { throw new Error('Multipart: Boundary not found') }

  const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024)
  const fileSizeLimit = getLimit(limits, 'fileSize', Infinity)
  const filesLimit = getLimit(limits, 'files', Infinity)
  const fieldsLimit = getLimit(limits, 'fields', Infinity)
  const partsLimit = getLimit(limits, 'parts', Infinity)
  const headerPairsLimit = getLimit(limits, 'headerPairs', 2000)
  const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024)

  let nfiles = 0
  let nfields = 0
  let nends = 0
  let curFile
  let curField
  let finished = false

  this._needDrain = false
  this._pause = false
  this._cb = undefined
  this._nparts = 0
  this._boy = boy

  const parserCfg = {
    boundary,
    maxHeaderPairs: headerPairsLimit,
    maxHeaderSize: headerSizeLimit,
    partHwm: fileOpts.highWaterMark,
    highWaterMark: cfg.highWaterMark
  }

  this.parser = new Dicer(parserCfg)
  this.parser.on('drain', function () {
    self._needDrain = false
    if (self._cb && !self._pause) {
      const cb = self._cb
      self._cb = undefined
      cb()
    }
  }).on('part', function onPart (part) {
    if (++self._nparts > partsLimit) {
      self.parser.removeListener('part', onPart)
      self.parser.on('part', skipPart)
      boy.hitPartsLimit = true
      boy.emit('partsLimit')
      return skipPart(part)
    }

    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let
    // us emit 'end' early since we know the part has ended if we are already
    // seeing the next part
    if (curField) {
      const field = curField
      field.emit('end')
      field.removeAllListeners('end')
    }

    part.on('header', function (header) {
      let contype
      let fieldname
      let parsed
      let charset
      let encoding
      let filename
      let nsize = 0

      if (header['content-type']) {
        parsed = parseParams(header['content-type'][0])
        if (parsed[0]) {
          contype = parsed[0].toLowerCase()
          for (i = 0, len = parsed.length; i < len; ++i) {
            if (RE_CHARSET.test(parsed[i][0])) {
              charset = parsed[i][1].toLowerCase()
              break
            }
          }
        }
      }

      if (contype === undefined) { contype = 'text/plain' }
      if (charset === undefined) { charset = defCharset }

      if (header['content-disposition']) {
        parsed = parseParams(header['content-disposition'][0])
        if (!RE_FIELD.test(parsed[0])) { return skipPart(part) }
        for (i = 0, len = parsed.length; i < len; ++i) {
          if (RE_NAME.test(parsed[i][0])) {
            fieldname = parsed[i][1]
          } else if (RE_FILENAME.test(parsed[i][0])) {
            filename = parsed[i][1]
            if (!preservePath) { filename = basename(filename) }
          }
        }
      } else { return skipPart(part) }

      if (header['content-transfer-encoding']) { encoding = header['content-transfer-encoding'][0].toLowerCase() } else { encoding = '7bit' }

      let onData,
        onEnd

      if (isPartAFile(fieldname, contype, filename)) {
        // file/binary field
        if (nfiles === filesLimit) {
          if (!boy.hitFilesLimit) {
            boy.hitFilesLimit = true
            boy.emit('filesLimit')
          }
          return skipPart(part)
        }

        ++nfiles

        if (boy.listenerCount('file') === 0) {
          self.parser._ignore()
          return
        }

        ++nends
        const file = new FileStream(fileOpts)
        curFile = file
        file.on('end', function () {
          --nends
          self._pause = false
          checkFinished()
          if (self._cb && !self._needDrain) {
            const cb = self._cb
            self._cb = undefined
            cb()
          }
        })
        file._read = function (n) {
          if (!self._pause) { return }
          self._pause = false
          if (self._cb && !self._needDrain) {
            const cb = self._cb
            self._cb = undefined
            cb()
          }
        }
        boy.emit('file', fieldname, file, filename, encoding, contype)

        onData = function (data) {
          if ((nsize += data.length) > fileSizeLimit) {
            const extralen = fileSizeLimit - nsize + data.length
            if (extralen > 0) { file.push(data.slice(0, extralen)) }
            file.truncated = true
            file.bytesRead = fileSizeLimit
            part.removeAllListeners('data')
            file.emit('limit')
            return
          } else if (!file.push(data)) { self._pause = true }

          file.bytesRead = nsize
        }

        onEnd = function () {
          curFile = undefined
          file.push(null)
        }
      } else {
        // non-file field
        if (nfields === fieldsLimit) {
          if (!boy.hitFieldsLimit) {
            boy.hitFieldsLimit = true
            boy.emit('fieldsLimit')
          }
          return skipPart(part)
        }

        ++nfields
        ++nends
        let buffer = ''
        let truncated = false
        curField = part

        onData = function (data) {
          if ((nsize += data.length) > fieldSizeLimit) {
            const extralen = (fieldSizeLimit - (nsize - data.length))
            buffer += data.toString('binary', 0, extralen)
            truncated = true
            part.removeAllListeners('data')
          } else { buffer += data.toString('binary') }
        }

        onEnd = function () {
          curField = undefined
          if (buffer.length) { buffer = decodeText(buffer, 'binary', charset) }
          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype)
          --nends
          checkFinished()
        }
      }

      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become
         broken. Streams2/streams3 is a huge black box of confusion, but
         somehow overriding the sync state seems to fix things again (and still
         seems to work for previous node versions).
      */
      part._readableState.sync = false

      part.on('data', onData)
      part.on('end', onEnd)
    }).on('error', function (err) {
      if (curFile) { curFile.emit('error', err) }
    })
  }).on('error', function (err) {
    boy.emit('error', err)
  }).on('finish', function () {
    finished = true
    checkFinished()
  })
}

Multipart.prototype.write = function (chunk, cb) {
  const r = this.parser.write(chunk)
  if (r && !this._pause) {
    cb()
  } else {
    this._needDrain = !r
    this._cb = cb
  }
}

Multipart.prototype.end = function () {
  const self = this

  if (self.parser.writable) {
    self.parser.end()
  } else if (!self._boy._done) {
    process.nextTick(function () {
      self._boy._done = true
      self._boy.emit('finish')
    })
  }
}

function skipPart (part) {
  part.resume()
}

function FileStream (opts) {
  Readable.call(this, opts)

  this.bytesRead = 0

  this.truncated = false
}

inherits(FileStream, Readable)

FileStream.prototype._read = function (n) {}

module.exports = Multipart


/***/ }),

/***/ "./node_modules/@fastify/busboy/lib/types/urlencoded.js":
/*!**************************************************************!*\
  !*** ./node_modules/@fastify/busboy/lib/types/urlencoded.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Decoder = __webpack_require__(/*! ../utils/Decoder */ "./node_modules/@fastify/busboy/lib/utils/Decoder.js")
const decodeText = __webpack_require__(/*! ../utils/decodeText */ "./node_modules/@fastify/busboy/lib/utils/decodeText.js")
const getLimit = __webpack_require__(/*! ../utils/getLimit */ "./node_modules/@fastify/busboy/lib/utils/getLimit.js")

const RE_CHARSET = /^charset$/i

UrlEncoded.detect = /^application\/x-www-form-urlencoded/i
function UrlEncoded (boy, cfg) {
  const limits = cfg.limits
  const parsedConType = cfg.parsedConType
  this.boy = boy

  this.fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024)
  this.fieldNameSizeLimit = getLimit(limits, 'fieldNameSize', 100)
  this.fieldsLimit = getLimit(limits, 'fields', Infinity)

  let charset
  for (var i = 0, len = parsedConType.length; i < len; ++i) { // eslint-disable-line no-var
    if (Array.isArray(parsedConType[i]) &&
        RE_CHARSET.test(parsedConType[i][0])) {
      charset = parsedConType[i][1].toLowerCase()
      break
    }
  }

  if (charset === undefined) { charset = cfg.defCharset || 'utf8' }

  this.decoder = new Decoder()
  this.charset = charset
  this._fields = 0
  this._state = 'key'
  this._checkingBytes = true
  this._bytesKey = 0
  this._bytesVal = 0
  this._key = ''
  this._val = ''
  this._keyTrunc = false
  this._valTrunc = false
  this._hitLimit = false
}

UrlEncoded.prototype.write = function (data, cb) {
  if (this._fields === this.fieldsLimit) {
    if (!this.boy.hitFieldsLimit) {
      this.boy.hitFieldsLimit = true
      this.boy.emit('fieldsLimit')
    }
    return cb()
  }

  let idxeq; let idxamp; let i; let p = 0; const len = data.length

  while (p < len) {
    if (this._state === 'key') {
      idxeq = idxamp = undefined
      for (i = p; i < len; ++i) {
        if (!this._checkingBytes) { ++p }
        if (data[i] === 0x3D/* = */) {
          idxeq = i
          break
        } else if (data[i] === 0x26/* & */) {
          idxamp = i
          break
        }
        if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
          this._hitLimit = true
          break
        } else if (this._checkingBytes) { ++this._bytesKey }
      }

      if (idxeq !== undefined) {
        // key with assignment
        if (idxeq > p) { this._key += this.decoder.write(data.toString('binary', p, idxeq)) }
        this._state = 'val'

        this._hitLimit = false
        this._checkingBytes = true
        this._val = ''
        this._bytesVal = 0
        this._valTrunc = false
        this.decoder.reset()

        p = idxeq + 1
      } else if (idxamp !== undefined) {
        // key with no assignment
        ++this._fields
        let key; const keyTrunc = this._keyTrunc
        if (idxamp > p) { key = (this._key += this.decoder.write(data.toString('binary', p, idxamp))) } else { key = this._key }

        this._hitLimit = false
        this._checkingBytes = true
        this._key = ''
        this._bytesKey = 0
        this._keyTrunc = false
        this.decoder.reset()

        if (key.length) {
          this.boy.emit('field', decodeText(key, 'binary', this.charset),
            '',
            keyTrunc,
            false)
        }

        p = idxamp + 1
        if (this._fields === this.fieldsLimit) { return cb() }
      } else if (this._hitLimit) {
        // we may not have hit the actual limit if there are encoded bytes...
        if (i > p) { this._key += this.decoder.write(data.toString('binary', p, i)) }
        p = i
        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
          // yep, we actually did hit the limit
          this._checkingBytes = false
          this._keyTrunc = true
        }
      } else {
        if (p < len) { this._key += this.decoder.write(data.toString('binary', p)) }
        p = len
      }
    } else {
      idxamp = undefined
      for (i = p; i < len; ++i) {
        if (!this._checkingBytes) { ++p }
        if (data[i] === 0x26/* & */) {
          idxamp = i
          break
        }
        if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
          this._hitLimit = true
          break
        } else if (this._checkingBytes) { ++this._bytesVal }
      }

      if (idxamp !== undefined) {
        ++this._fields
        if (idxamp > p) { this._val += this.decoder.write(data.toString('binary', p, idxamp)) }
        this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
          decodeText(this._val, 'binary', this.charset),
          this._keyTrunc,
          this._valTrunc)
        this._state = 'key'

        this._hitLimit = false
        this._checkingBytes = true
        this._key = ''
        this._bytesKey = 0
        this._keyTrunc = false
        this.decoder.reset()

        p = idxamp + 1
        if (this._fields === this.fieldsLimit) { return cb() }
      } else if (this._hitLimit) {
        // we may not have hit the actual limit if there are encoded bytes...
        if (i > p) { this._val += this.decoder.write(data.toString('binary', p, i)) }
        p = i
        if ((this._val === '' && this.fieldSizeLimit === 0) ||
            (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
          // yep, we actually did hit the limit
          this._checkingBytes = false
          this._valTrunc = true
        }
      } else {
        if (p < len) { this._val += this.decoder.write(data.toString('binary', p)) }
        p = len
      }
    }
  }
  cb()
}

UrlEncoded.prototype.end = function () {
  if (this.boy._done) { return }

  if (this._state === 'key' && this._key.length > 0) {
    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
      '',
      this._keyTrunc,
      false)
  } else if (this._state === 'val') {
    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
      decodeText(this._val, 'binary', this.charset),
      this._keyTrunc,
      this._valTrunc)
  }
  this.boy._done = true
  this.boy.emit('finish')
}

module.exports = UrlEncoded


/***/ }),

/***/ "./node_modules/@fastify/busboy/lib/utils/Decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fastify/busboy/lib/utils/Decoder.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";


const RE_PLUS = /\+/g

const HEX = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
]

function Decoder () {
  this.buffer = undefined
}
Decoder.prototype.write = function (str) {
  // Replace '+' with ' ' before decoding
  str = str.replace(RE_PLUS, ' ')
  let res = ''
  let i = 0; let p = 0; const len = str.length
  for (; i < len; ++i) {
    if (this.buffer !== undefined) {
      if (!HEX[str.charCodeAt(i)]) {
        res += '%' + this.buffer
        this.buffer = undefined
        --i // retry character
      } else {
        this.buffer += str[i]
        ++p
        if (this.buffer.length === 2) {
          res += String.fromCharCode(parseInt(this.buffer, 16))
          this.buffer = undefined
        }
      }
    } else if (str[i] === '%') {
      if (i > p) {
        res += str.substring(p, i)
        p = i
      }
      this.buffer = ''
      ++p
    }
  }
  if (p < len && this.buffer === undefined) { res += str.substring(p) }
  return res
}
Decoder.prototype.reset = function () {
  this.buffer = undefined
}

module.exports = Decoder


/***/ }),

/***/ "./node_modules/@fastify/busboy/lib/utils/basename.js":
/*!************************************************************!*\
  !*** ./node_modules/@fastify/busboy/lib/utils/basename.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function basename (path) {
  if (typeof path !== 'string') { return '' }
  for (var i = path.length - 1; i >= 0; --i) { // eslint-disable-line no-var
    switch (path.charCodeAt(i)) {
      case 0x2F: // '/'
      case 0x5C: // '\'
        path = path.slice(i + 1)
        return (path === '..' || path === '.' ? '' : path)
    }
  }
  return (path === '..' || path === '.' ? '' : path)
}


/***/ }),

/***/ "./node_modules/@fastify/busboy/lib/utils/decodeText.js":
/*!**************************************************************!*\
  !*** ./node_modules/@fastify/busboy/lib/utils/decodeText.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


// Node has always utf-8
const utf8Decoder = new TextDecoder('utf-8')
const textDecoders = new Map([
  ['utf-8', utf8Decoder],
  ['utf8', utf8Decoder]
])

function getDecoder (charset) {
  let lc
  while (true) {
    switch (charset) {
      case 'utf-8':
      case 'utf8':
        return decoders.utf8
      case 'latin1':
      case 'ascii': // TODO: Make these a separate, strict decoder?
      case 'us-ascii':
      case 'iso-8859-1':
      case 'iso8859-1':
      case 'iso88591':
      case 'iso_8859-1':
      case 'windows-1252':
      case 'iso_8859-1:1987':
      case 'cp1252':
      case 'x-cp1252':
        return decoders.latin1
      case 'utf16le':
      case 'utf-16le':
      case 'ucs2':
      case 'ucs-2':
        return decoders.utf16le
      case 'base64':
        return decoders.base64
      default:
        if (lc === undefined) {
          lc = true
          charset = charset.toLowerCase()
          continue
        }
        return decoders.other.bind(charset)
    }
  }
}

const decoders = {
  utf8: (data, sourceEncoding) => {
    if (data.length === 0) {
      return ''
    }
    if (typeof data === 'string') {
      data = Buffer.from(data, sourceEncoding)
    }
    return data.utf8Slice(0, data.length)
  },

  latin1: (data, sourceEncoding) => {
    if (data.length === 0) {
      return ''
    }
    if (typeof data === 'string') {
      return data
    }
    return data.latin1Slice(0, data.length)
  },

  utf16le: (data, sourceEncoding) => {
    if (data.length === 0) {
      return ''
    }
    if (typeof data === 'string') {
      data = Buffer.from(data, sourceEncoding)
    }
    return data.ucs2Slice(0, data.length)
  },

  base64: (data, sourceEncoding) => {
    if (data.length === 0) {
      return ''
    }
    if (typeof data === 'string') {
      data = Buffer.from(data, sourceEncoding)
    }
    return data.base64Slice(0, data.length)
  },

  other: (data, sourceEncoding) => {
    if (data.length === 0) {
      return ''
    }
    if (typeof data === 'string') {
      data = Buffer.from(data, sourceEncoding)
    }

    if (textDecoders.has(this.toString())) {
      try {
        return textDecoders.get(this).decode(data)
      } catch {}
    }
    return typeof data === 'string'
      ? data
      : data.toString()
  }
}

function decodeText (text, sourceEncoding, destEncoding) {
  if (text) {
    return getDecoder(destEncoding)(text, sourceEncoding)
  }
  return text
}

module.exports = decodeText


/***/ }),

/***/ "./node_modules/@fastify/busboy/lib/utils/getLimit.js":
/*!************************************************************!*\
  !*** ./node_modules/@fastify/busboy/lib/utils/getLimit.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function getLimit (limits, name, defaultLimit) {
  if (
    !limits ||
    limits[name] === undefined ||
    limits[name] === null
  ) { return defaultLimit }

  if (
    typeof limits[name] !== 'number' ||
    isNaN(limits[name])
  ) { throw new TypeError('Limit ' + name + ' is not a valid number') }

  return limits[name]
}


/***/ }),

/***/ "./node_modules/@fastify/busboy/lib/utils/parseParams.js":
/*!***************************************************************!*\
  !*** ./node_modules/@fastify/busboy/lib/utils/parseParams.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable object-property-newline */


const decodeText = __webpack_require__(/*! ./decodeText */ "./node_modules/@fastify/busboy/lib/utils/decodeText.js")

const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g

const EncodedLookup = {
  '%00': '\x00', '%01': '\x01', '%02': '\x02', '%03': '\x03', '%04': '\x04',
  '%05': '\x05', '%06': '\x06', '%07': '\x07', '%08': '\x08', '%09': '\x09',
  '%0a': '\x0a', '%0A': '\x0a', '%0b': '\x0b', '%0B': '\x0b', '%0c': '\x0c',
  '%0C': '\x0c', '%0d': '\x0d', '%0D': '\x0d', '%0e': '\x0e', '%0E': '\x0e',
  '%0f': '\x0f', '%0F': '\x0f', '%10': '\x10', '%11': '\x11', '%12': '\x12',
  '%13': '\x13', '%14': '\x14', '%15': '\x15', '%16': '\x16', '%17': '\x17',
  '%18': '\x18', '%19': '\x19', '%1a': '\x1a', '%1A': '\x1a', '%1b': '\x1b',
  '%1B': '\x1b', '%1c': '\x1c', '%1C': '\x1c', '%1d': '\x1d', '%1D': '\x1d',
  '%1e': '\x1e', '%1E': '\x1e', '%1f': '\x1f', '%1F': '\x1f', '%20': '\x20',
  '%21': '\x21', '%22': '\x22', '%23': '\x23', '%24': '\x24', '%25': '\x25',
  '%26': '\x26', '%27': '\x27', '%28': '\x28', '%29': '\x29', '%2a': '\x2a',
  '%2A': '\x2a', '%2b': '\x2b', '%2B': '\x2b', '%2c': '\x2c', '%2C': '\x2c',
  '%2d': '\x2d', '%2D': '\x2d', '%2e': '\x2e', '%2E': '\x2e', '%2f': '\x2f',
  '%2F': '\x2f', '%30': '\x30', '%31': '\x31', '%32': '\x32', '%33': '\x33',
  '%34': '\x34', '%35': '\x35', '%36': '\x36', '%37': '\x37', '%38': '\x38',
  '%39': '\x39', '%3a': '\x3a', '%3A': '\x3a', '%3b': '\x3b', '%3B': '\x3b',
  '%3c': '\x3c', '%3C': '\x3c', '%3d': '\x3d', '%3D': '\x3d', '%3e': '\x3e',
  '%3E': '\x3e', '%3f': '\x3f', '%3F': '\x3f', '%40': '\x40', '%41': '\x41',
  '%42': '\x42', '%43': '\x43', '%44': '\x44', '%45': '\x45', '%46': '\x46',
  '%47': '\x47', '%48': '\x48', '%49': '\x49', '%4a': '\x4a', '%4A': '\x4a',
  '%4b': '\x4b', '%4B': '\x4b', '%4c': '\x4c', '%4C': '\x4c', '%4d': '\x4d',
  '%4D': '\x4d', '%4e': '\x4e', '%4E': '\x4e', '%4f': '\x4f', '%4F': '\x4f',
  '%50': '\x50', '%51': '\x51', '%52': '\x52', '%53': '\x53', '%54': '\x54',
  '%55': '\x55', '%56': '\x56', '%57': '\x57', '%58': '\x58', '%59': '\x59',
  '%5a': '\x5a', '%5A': '\x5a', '%5b': '\x5b', '%5B': '\x5b', '%5c': '\x5c',
  '%5C': '\x5c', '%5d': '\x5d', '%5D': '\x5d', '%5e': '\x5e', '%5E': '\x5e',
  '%5f': '\x5f', '%5F': '\x5f', '%60': '\x60', '%61': '\x61', '%62': '\x62',
  '%63': '\x63', '%64': '\x64', '%65': '\x65', '%66': '\x66', '%67': '\x67',
  '%68': '\x68', '%69': '\x69', '%6a': '\x6a', '%6A': '\x6a', '%6b': '\x6b',
  '%6B': '\x6b', '%6c': '\x6c', '%6C': '\x6c', '%6d': '\x6d', '%6D': '\x6d',
  '%6e': '\x6e', '%6E': '\x6e', '%6f': '\x6f', '%6F': '\x6f', '%70': '\x70',
  '%71': '\x71', '%72': '\x72', '%73': '\x73', '%74': '\x74', '%75': '\x75',
  '%76': '\x76', '%77': '\x77', '%78': '\x78', '%79': '\x79', '%7a': '\x7a',
  '%7A': '\x7a', '%7b': '\x7b', '%7B': '\x7b', '%7c': '\x7c', '%7C': '\x7c',
  '%7d': '\x7d', '%7D': '\x7d', '%7e': '\x7e', '%7E': '\x7e', '%7f': '\x7f',
  '%7F': '\x7f', '%80': '\x80', '%81': '\x81', '%82': '\x82', '%83': '\x83',
  '%84': '\x84', '%85': '\x85', '%86': '\x86', '%87': '\x87', '%88': '\x88',
  '%89': '\x89', '%8a': '\x8a', '%8A': '\x8a', '%8b': '\x8b', '%8B': '\x8b',
  '%8c': '\x8c', '%8C': '\x8c', '%8d': '\x8d', '%8D': '\x8d', '%8e': '\x8e',
  '%8E': '\x8e', '%8f': '\x8f', '%8F': '\x8f', '%90': '\x90', '%91': '\x91',
  '%92': '\x92', '%93': '\x93', '%94': '\x94', '%95': '\x95', '%96': '\x96',
  '%97': '\x97', '%98': '\x98', '%99': '\x99', '%9a': '\x9a', '%9A': '\x9a',
  '%9b': '\x9b', '%9B': '\x9b', '%9c': '\x9c', '%9C': '\x9c', '%9d': '\x9d',
  '%9D': '\x9d', '%9e': '\x9e', '%9E': '\x9e', '%9f': '\x9f', '%9F': '\x9f',
  '%a0': '\xa0', '%A0': '\xa0', '%a1': '\xa1', '%A1': '\xa1', '%a2': '\xa2',
  '%A2': '\xa2', '%a3': '\xa3', '%A3': '\xa3', '%a4': '\xa4', '%A4': '\xa4',
  '%a5': '\xa5', '%A5': '\xa5', '%a6': '\xa6', '%A6': '\xa6', '%a7': '\xa7',
  '%A7': '\xa7', '%a8': '\xa8', '%A8': '\xa8', '%a9': '\xa9', '%A9': '\xa9',
  '%aa': '\xaa', '%Aa': '\xaa', '%aA': '\xaa', '%AA': '\xaa', '%ab': '\xab',
  '%Ab': '\xab', '%aB': '\xab', '%AB': '\xab', '%ac': '\xac', '%Ac': '\xac',
  '%aC': '\xac', '%AC': '\xac', '%ad': '\xad', '%Ad': '\xad', '%aD': '\xad',
  '%AD': '\xad', '%ae': '\xae', '%Ae': '\xae', '%aE': '\xae', '%AE': '\xae',
  '%af': '\xaf', '%Af': '\xaf', '%aF': '\xaf', '%AF': '\xaf', '%b0': '\xb0',
  '%B0': '\xb0', '%b1': '\xb1', '%B1': '\xb1', '%b2': '\xb2', '%B2': '\xb2',
  '%b3': '\xb3', '%B3': '\xb3', '%b4': '\xb4', '%B4': '\xb4', '%b5': '\xb5',
  '%B5': '\xb5', '%b6': '\xb6', '%B6': '\xb6', '%b7': '\xb7', '%B7': '\xb7',
  '%b8': '\xb8', '%B8': '\xb8', '%b9': '\xb9', '%B9': '\xb9', '%ba': '\xba',
  '%Ba': '\xba', '%bA': '\xba', '%BA': '\xba', '%bb': '\xbb', '%Bb': '\xbb',
  '%bB': '\xbb', '%BB': '\xbb', '%bc': '\xbc', '%Bc': '\xbc', '%bC': '\xbc',
  '%BC': '\xbc', '%bd': '\xbd', '%Bd': '\xbd', '%bD': '\xbd', '%BD': '\xbd',
  '%be': '\xbe', '%Be': '\xbe', '%bE': '\xbe', '%BE': '\xbe', '%bf': '\xbf',
  '%Bf': '\xbf', '%bF': '\xbf', '%BF': '\xbf', '%c0': '\xc0', '%C0': '\xc0',
  '%c1': '\xc1', '%C1': '\xc1', '%c2': '\xc2', '%C2': '\xc2', '%c3': '\xc3',
  '%C3': '\xc3', '%c4': '\xc4', '%C4': '\xc4', '%c5': '\xc5', '%C5': '\xc5',
  '%c6': '\xc6', '%C6': '\xc6', '%c7': '\xc7', '%C7': '\xc7', '%c8': '\xc8',
  '%C8': '\xc8', '%c9': '\xc9', '%C9': '\xc9', '%ca': '\xca', '%Ca': '\xca',
  '%cA': '\xca', '%CA': '\xca', '%cb': '\xcb', '%Cb': '\xcb', '%cB': '\xcb',
  '%CB': '\xcb', '%cc': '\xcc', '%Cc': '\xcc', '%cC': '\xcc', '%CC': '\xcc',
  '%cd': '\xcd', '%Cd': '\xcd', '%cD': '\xcd', '%CD': '\xcd', '%ce': '\xce',
  '%Ce': '\xce', '%cE': '\xce', '%CE': '\xce', '%cf': '\xcf', '%Cf': '\xcf',
  '%cF': '\xcf', '%CF': '\xcf', '%d0': '\xd0', '%D0': '\xd0', '%d1': '\xd1',
  '%D1': '\xd1', '%d2': '\xd2', '%D2': '\xd2', '%d3': '\xd3', '%D3': '\xd3',
  '%d4': '\xd4', '%D4': '\xd4', '%d5': '\xd5', '%D5': '\xd5', '%d6': '\xd6',
  '%D6': '\xd6', '%d7': '\xd7', '%D7': '\xd7', '%d8': '\xd8', '%D8': '\xd8',
  '%d9': '\xd9', '%D9': '\xd9', '%da': '\xda', '%Da': '\xda', '%dA': '\xda',
  '%DA': '\xda', '%db': '\xdb', '%Db': '\xdb', '%dB': '\xdb', '%DB': '\xdb',
  '%dc': '\xdc', '%Dc': '\xdc', '%dC': '\xdc', '%DC': '\xdc', '%dd': '\xdd',
  '%Dd': '\xdd', '%dD': '\xdd', '%DD': '\xdd', '%de': '\xde', '%De': '\xde',
  '%dE': '\xde', '%DE': '\xde', '%df': '\xdf', '%Df': '\xdf', '%dF': '\xdf',
  '%DF': '\xdf', '%e0': '\xe0', '%E0': '\xe0', '%e1': '\xe1', '%E1': '\xe1',
  '%e2': '\xe2', '%E2': '\xe2', '%e3': '\xe3', '%E3': '\xe3', '%e4': '\xe4',
  '%E4': '\xe4', '%e5': '\xe5', '%E5': '\xe5', '%e6': '\xe6', '%E6': '\xe6',
  '%e7': '\xe7', '%E7': '\xe7', '%e8': '\xe8', '%E8': '\xe8', '%e9': '\xe9',
  '%E9': '\xe9', '%ea': '\xea', '%Ea': '\xea', '%eA': '\xea', '%EA': '\xea',
  '%eb': '\xeb', '%Eb': '\xeb', '%eB': '\xeb', '%EB': '\xeb', '%ec': '\xec',
  '%Ec': '\xec', '%eC': '\xec', '%EC': '\xec', '%ed': '\xed', '%Ed': '\xed',
  '%eD': '\xed', '%ED': '\xed', '%ee': '\xee', '%Ee': '\xee', '%eE': '\xee',
  '%EE': '\xee', '%ef': '\xef', '%Ef': '\xef', '%eF': '\xef', '%EF': '\xef',
  '%f0': '\xf0', '%F0': '\xf0', '%f1': '\xf1', '%F1': '\xf1', '%f2': '\xf2',
  '%F2': '\xf2', '%f3': '\xf3', '%F3': '\xf3', '%f4': '\xf4', '%F4': '\xf4',
  '%f5': '\xf5', '%F5': '\xf5', '%f6': '\xf6', '%F6': '\xf6', '%f7': '\xf7',
  '%F7': '\xf7', '%f8': '\xf8', '%F8': '\xf8', '%f9': '\xf9', '%F9': '\xf9',
  '%fa': '\xfa', '%Fa': '\xfa', '%fA': '\xfa', '%FA': '\xfa', '%fb': '\xfb',
  '%Fb': '\xfb', '%fB': '\xfb', '%FB': '\xfb', '%fc': '\xfc', '%Fc': '\xfc',
  '%fC': '\xfc', '%FC': '\xfc', '%fd': '\xfd', '%Fd': '\xfd', '%fD': '\xfd',
  '%FD': '\xfd', '%fe': '\xfe', '%Fe': '\xfe', '%fE': '\xfe', '%FE': '\xfe',
  '%ff': '\xff', '%Ff': '\xff', '%fF': '\xff', '%FF': '\xff'
}

function encodedReplacer (match) {
  return EncodedLookup[match]
}

const STATE_KEY = 0
const STATE_VALUE = 1
const STATE_CHARSET = 2
const STATE_LANG = 3

function parseParams (str) {
  const res = []
  let state = STATE_KEY
  let charset = ''
  let inquote = false
  let escaping = false
  let p = 0
  let tmp = ''
  const len = str.length

  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
    const char = str[i]
    if (char === '\\' && inquote) {
      if (escaping) { escaping = false } else {
        escaping = true
        continue
      }
    } else if (char === '"') {
      if (!escaping) {
        if (inquote) {
          inquote = false
          state = STATE_KEY
        } else { inquote = true }
        continue
      } else { escaping = false }
    } else {
      if (escaping && inquote) { tmp += '\\' }
      escaping = false
      if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
        if (state === STATE_CHARSET) {
          state = STATE_LANG
          charset = tmp.substring(1)
        } else { state = STATE_VALUE }
        tmp = ''
        continue
      } else if (state === STATE_KEY &&
        (char === '*' || char === '=') &&
        res.length) {
        state = char === '*'
          ? STATE_CHARSET
          : STATE_VALUE
        res[p] = [tmp, undefined]
        tmp = ''
        continue
      } else if (!inquote && char === ';') {
        state = STATE_KEY
        if (charset) {
          if (tmp.length) {
            tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
              'binary',
              charset)
          }
          charset = ''
        } else if (tmp.length) {
          tmp = decodeText(tmp, 'binary', 'utf8')
        }
        if (res[p] === undefined) { res[p] = tmp } else { res[p][1] = tmp }
        tmp = ''
        ++p
        continue
      } else if (!inquote && (char === ' ' || char === '\t')) { continue }
    }
    tmp += char
  }
  if (charset && tmp.length) {
    tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
      'binary',
      charset)
  } else if (tmp) {
    tmp = decodeText(tmp, 'binary', 'utf8')
  }

  if (res[p] === undefined) {
    if (tmp) { res[p] = tmp }
  } else { res[p][1] = tmp }

  return res
}

module.exports = parseParams


/***/ }),

/***/ "./node_modules/yaml/dist/compose/compose-collection.js":
/*!**************************************************************!*\
  !*** ./node_modules/yaml/dist/compose/compose-collection.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Scalar = __webpack_require__(/*! ../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var YAMLMap = __webpack_require__(/*! ../nodes/YAMLMap.js */ "./node_modules/yaml/dist/nodes/YAMLMap.js");
var YAMLSeq = __webpack_require__(/*! ../nodes/YAMLSeq.js */ "./node_modules/yaml/dist/nodes/YAMLSeq.js");
var resolveBlockMap = __webpack_require__(/*! ./resolve-block-map.js */ "./node_modules/yaml/dist/compose/resolve-block-map.js");
var resolveBlockSeq = __webpack_require__(/*! ./resolve-block-seq.js */ "./node_modules/yaml/dist/compose/resolve-block-seq.js");
var resolveFlowCollection = __webpack_require__(/*! ./resolve-flow-collection.js */ "./node_modules/yaml/dist/compose/resolve-flow-collection.js");

function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === 'block-map'
        ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag)
        : token.type === 'block-seq'
            ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag)
            : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    // If we got a tagName matching the class, or the tag name is '!',
    // then use the tagName from the node class used to create it.
    if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    if (tagName)
        coll.tag = tagName;
    return coll;
}
function composeCollection(CN, ctx, token, tagToken, onError) {
    const tagName = !tagToken
        ? null
        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
    const expType = token.type === 'block-map'
        ? 'map'
        : token.type === 'block-seq'
            ? 'seq'
            : token.start.source === '{'
                ? 'map'
                : 'seq';
    // shortcut: check if it's a generic YAMLMap or YAMLSeq
    // before jumping into the custom tag logic.
    if (!tagToken ||
        !tagName ||
        tagName === '!' ||
        (tagName === YAMLMap.YAMLMap.tagName && expType === 'map') ||
        (tagName === YAMLSeq.YAMLSeq.tagName && expType === 'seq') ||
        !expType) {
        return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
            tag = kt;
        }
        else {
            if (kt?.collection) {
                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
            }
            else {
                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
            }
            return resolveCollection(CN, ctx, token, onError, tagName);
        }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;
    const node = identity.isNode(res)
        ? res
        : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
        node.format = tag.format;
    return node;
}

exports.composeCollection = composeCollection;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/compose-doc.js":
/*!*******************************************************!*\
  !*** ./node_modules/yaml/dist/compose/compose-doc.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Document = __webpack_require__(/*! ../doc/Document.js */ "./node_modules/yaml/dist/doc/Document.js");
var composeNode = __webpack_require__(/*! ./compose-node.js */ "./node_modules/yaml/dist/compose/compose-node.js");
var resolveEnd = __webpack_require__(/*! ./resolve-end.js */ "./node_modules/yaml/dist/compose/resolve-end.js");
var resolveProps = __webpack_require__(/*! ./resolve-props.js */ "./node_modules/yaml/dist/compose/resolve-props.js");

function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
        indicator: 'doc-start',
        next: value ?? end?.[0],
        offset,
        onError,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value &&
            (value.type === 'block-map' || value.type === 'block-seq') &&
            !props.hasNewline)
            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
    }
    // @ts-expect-error If Contents is set, let's trust the user
    doc.contents = value
        ? composeNode.composeNode(ctx, value, props, onError)
        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
        doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
}

exports.composeDoc = composeDoc;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/compose-node.js":
/*!********************************************************!*\
  !*** ./node_modules/yaml/dist/compose/compose-node.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(/*! ../nodes/Alias.js */ "./node_modules/yaml/dist/nodes/Alias.js");
var composeCollection = __webpack_require__(/*! ./compose-collection.js */ "./node_modules/yaml/dist/compose/compose-collection.js");
var composeScalar = __webpack_require__(/*! ./compose-scalar.js */ "./node_modules/yaml/dist/compose/compose-scalar.js");
var resolveEnd = __webpack_require__(/*! ./resolve-end.js */ "./node_modules/yaml/dist/compose/resolve-end.js");
var utilEmptyScalarPosition = __webpack_require__(/*! ./util-empty-scalar-position.js */ "./node_modules/yaml/dist/compose/util-empty-scalar-position.js");

const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
        case 'alias':
            node = composeAlias(ctx, token, onError);
            if (anchor || tag)
                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
            break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
            node = composeScalar.composeScalar(ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
            node = composeCollection.composeCollection(CN, ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        default: {
            const message = token.type === 'error'
                ? token.message
                : `Unsupported token (type: ${token.type})`;
            onError(token, 'UNEXPECTED_TOKEN', message);
            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
            isSrcToken = false;
        }
    }
    if (anchor && node.anchor === '')
        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        if (token.type === 'scalar' && token.source === '')
            node.comment = comment;
        else
            node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
    return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
        type: 'scalar',
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ''
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '')
            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        node.comment = comment;
        node.range[2] = end;
    }
    return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === '')
        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
    if (alias.source.endsWith(':'))
        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
        alias.comment = re.comment;
    return alias;
}

exports.composeEmptyNode = composeEmptyNode;
exports.composeNode = composeNode;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/compose-scalar.js":
/*!**********************************************************!*\
  !*** ./node_modules/yaml/dist/compose/compose-scalar.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Scalar = __webpack_require__(/*! ../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var resolveBlockScalar = __webpack_require__(/*! ./resolve-block-scalar.js */ "./node_modules/yaml/dist/compose/resolve-block-scalar.js");
var resolveFlowScalar = __webpack_require__(/*! ./resolve-flow-scalar.js */ "./node_modules/yaml/dist/compose/resolve-flow-scalar.js");

function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === 'block-scalar'
        ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError)
        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
    const tag = tagToken && tagName
        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)
        : token.type === 'scalar'
            ? findScalarTagByTest(ctx, value, token, onError)
            : ctx.schema[identity.SCALAR];
    let scalar;
    try {
        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    }
    catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
        scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
        scalar.type = type;
    if (tagName)
        scalar.tag = tagName;
    if (tag.format)
        scalar.format = tag.format;
    if (comment)
        scalar.comment = comment;
    return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === '!')
        return schema[identity.SCALAR]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
            if (tag.default && tag.test)
                matchWithTest.push(tag);
            else
                return tag;
        }
    }
    for (const tag of matchWithTest)
        if (tag.test?.test(value))
            return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
    }
    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
    return schema[identity.SCALAR];
}
function findScalarTagByTest({ directives, schema }, value, token, onError) {
    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[identity.SCALAR];
    if (schema.compat) {
        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??
            schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, 'TAG_RESOLVE_FAILED', msg, true);
        }
    }
    return tag;
}

exports.composeScalar = composeScalar;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/composer.js":
/*!****************************************************!*\
  !*** ./node_modules/yaml/dist/compose/composer.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var directives = __webpack_require__(/*! ../doc/directives.js */ "./node_modules/yaml/dist/doc/directives.js");
var Document = __webpack_require__(/*! ../doc/Document.js */ "./node_modules/yaml/dist/doc/Document.js");
var errors = __webpack_require__(/*! ../errors.js */ "./node_modules/yaml/dist/errors.js");
var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var composeDoc = __webpack_require__(/*! ./compose-doc.js */ "./node_modules/yaml/dist/compose/compose-doc.js");
var resolveEnd = __webpack_require__(/*! ./resolve-end.js */ "./node_modules/yaml/dist/compose/resolve-end.js");

function getErrorPos(src) {
    if (typeof src === 'number')
        return [src, src + 1];
    if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
    let comment = '';
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
            case '#':
                comment +=
                    (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                        (source.substring(1) || ' ');
                atComment = true;
                afterEmptyLine = false;
                break;
            case '%':
                if (prelude[i + 1]?.[0] !== '#')
                    i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment)
                    afterEmptyLine = true;
                atComment = false;
        }
    }
    return { comment, afterEmptyLine };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
    constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
            const pos = getErrorPos(source);
            if (warning)
                this.warnings.push(new errors.YAMLWarning(pos, code, message));
            else
                this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new directives.Directives({ version: options.version || '1.2' });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            }
            else if (afterEmptyLine || doc.directives.docStart || !dc) {
                doc.commentBefore = comment;
            }
            else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (identity.isPair(it))
                    it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
            else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        }
        else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
        return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
            yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
        if (process.env.LOG_STREAM)
            console.dir(token, { depth: null });
        switch (token.type) {
            case 'directive':
                this.directives.add(token.source, (offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case 'document': {
                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.docStart)
                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
                this.decorate(doc, false);
                if (this.doc)
                    yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
            }
            case 'byte-order-mark':
            case 'space':
                break;
            case 'comment':
            case 'newline':
                this.prelude.push(token.source);
                break;
            case 'error': {
                const msg = token.source
                    ? `${token.message}: ${JSON.stringify(token.source)}`
                    : token.message;
                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                if (this.atDirectives || !this.doc)
                    this.errors.push(error);
                else
                    this.doc.errors.push(error);
                break;
            }
            case 'doc-end': {
                if (!this.doc) {
                    const msg = 'Unexpected doc-end without preceding document';
                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                    break;
                }
                this.doc.directives.docEnd = true;
                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                    const dc = this.doc.comment;
                    this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
            }
            default:
                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        }
        else if (forceDoc) {
            const opts = Object.assign({ _directives: this.directives }, this.options);
            const doc = new Document.Document(undefined, opts);
            if (this.atDirectives)
                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

exports.Composer = Composer;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/resolve-block-map.js":
/*!*************************************************************!*\
  !*** ./node_modules/yaml/dist/compose/resolve-block-map.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Pair = __webpack_require__(/*! ../nodes/Pair.js */ "./node_modules/yaml/dist/nodes/Pair.js");
var YAMLMap = __webpack_require__(/*! ../nodes/YAMLMap.js */ "./node_modules/yaml/dist/nodes/YAMLMap.js");
var resolveProps = __webpack_require__(/*! ./resolve-props.js */ "./node_modules/yaml/dist/compose/resolve-props.js");
var utilContainsNewline = __webpack_require__(/*! ./util-contains-newline.js */ "./node_modules/yaml/dist/compose/util-contains-newline.js");
var utilFlowIndentCheck = __webpack_require__(/*! ./util-flow-indent-check.js */ "./node_modules/yaml/dist/compose/util-flow-indent-check.js");
var utilMapIncludes = __webpack_require__(/*! ./util-map-includes.js */ "./node_modules/yaml/dist/compose/util-map-includes.js");

const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps.resolveProps(start, {
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === 'block-seq')
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                else if ('indent' in key && key.indent !== bm.indent)
                    onError(offset, 'BAD_INDENT', startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                commentEnd = keyProps.end;
                if (keyProps.comment) {
                    if (map.comment)
                        map.comment += '\n' + keyProps.comment;
                    else
                        map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {
                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
            }
        }
        else if (keyProps.found?.indent !== bm.indent) {
            onError(offset, 'BAD_INDENT', startColMsg);
        }
        // key value
        const keyStart = keyProps.end;
        const keyNode = key
            ? composeNode(ctx, key, keyProps, onError)
            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps.resolveProps(sep ?? [], {
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: !key || key.type === 'block-scalar'
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === 'block-map' && !valueProps.hasNewline)
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                if (ctx.options.strict &&
                    keyProps.start < valueProps.found.offset - 1024)
                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat)
                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
        else {
            // key with no value
            if (implicitKey)
                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
            if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    if (commentEnd && commentEnd < offset)
        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
}

exports.resolveBlockMap = resolveBlockMap;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/resolve-block-scalar.js":
/*!****************************************************************!*\
  !*** ./node_modules/yaml/dist/compose/resolve-block-scalar.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(/*! ../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");

function resolveBlockScalar(scalar, strict, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, strict, onError);
    if (!header)
        return { value: '', type: null, comment: '', range: [start, start, start] };
    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r')
            chompStart = i;
        else
            break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === '+' && lines.length > 0
            ? '\n'.repeat(Math.max(1, lines.length - 1))
            : '';
        let end = start + header.length;
        if (scalar.source)
            end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
            if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
        }
        else {
            if (indent.length < trimIndent) {
                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                onError(offset + indent.length, 'MISSING_CHAR', message);
            }
            if (header.indent === 0)
                trimIndent = indent.length;
            contentStart = i;
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
            chompStart = i + 1;
    }
    let value = '';
    let sep = '';
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + '\n';
    for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf)
            content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
            const src = header.indent
                ? 'explicit indentation indicator'
                : 'first line';
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
            indent = '';
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
        }
        else if (indent.length > trimIndent || content[0] === '\t') {
            // more-indented content within a folded block
            if (sep === ' ')
                sep = '\n';
            else if (!prevMoreIndented && sep === '\n')
                sep = '\n\n';
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
            prevMoreIndented = true;
        }
        else if (content === '') {
            // empty line
            if (sep === '\n')
                value += '\n';
            else
                sep = '\n';
        }
        else {
            value += sep + content;
            sep = ' ';
            prevMoreIndented = false;
        }
    }
    switch (header.chomp) {
        case '-':
            break;
        case '+':
            for (let i = chompStart; i < lines.length; ++i)
                value += '\n' + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== '\n')
                value += '\n';
            break;
        default:
            value += '\n';
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
    /* istanbul ignore if should not happen */
    if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = '';
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+'))
            chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n)
                indent = n;
            else if (error === -1)
                error = offset + i;
        }
    }
    if (error !== -1)
        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = '';
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
            case 'space':
                hasSpace = true;
            // fallthrough
            case 'newline':
                length += token.source.length;
                break;
            case 'comment':
                if (strict && !hasSpace) {
                    const message = 'Comments must be separated from other tokens by white space characters';
                    onError(token, 'MISSING_CHAR', message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case 'error':
                onError(token, 'UNEXPECTED_TOKEN', token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */
            default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, 'UNEXPECTED_TOKEN', message);
                const ts = token.source;
                if (ts && typeof ts === 'string')
                    length += ts.length;
            }
        }
    }
    return { mode, indent, chomp, comment, length };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1]
        ? [m[1], first.slice(m[1].length)]
        : ['', first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
    return lines;
}

exports.resolveBlockScalar = resolveBlockScalar;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/resolve-block-seq.js":
/*!*************************************************************!*\
  !*** ./node_modules/yaml/dist/compose/resolve-block-seq.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var YAMLSeq = __webpack_require__(/*! ../nodes/YAMLSeq.js */ "./node_modules/yaml/dist/nodes/YAMLSeq.js");
var resolveProps = __webpack_require__(/*! ./resolve-props.js */ "./node_modules/yaml/dist/compose/resolve-props.js");
var utilFlowIndentCheck = __webpack_require__(/*! ./util-flow-indent-check.js */ "./node_modules/yaml/dist/compose/util-flow-indent-check.js");

function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
            indicator: 'seq-item-ind',
            next: value,
            offset,
            onError,
            startOnNewline: true
        });
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === 'block-seq')
                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');
                else
                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
            }
            else {
                commentEnd = props.end;
                if (props.comment)
                    seq.comment = props.comment;
                continue;
            }
        }
        const node = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
}

exports.resolveBlockSeq = resolveBlockSeq;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/resolve-end.js":
/*!*******************************************************!*\
  !*** ./node_modules/yaml/dist/compose/resolve-end.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveEnd(end, offset, reqSpace, onError) {
    let comment = '';
    if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
            const { source, type } = token;
            switch (type) {
                case 'space':
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (reqSpace && !hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += sep + cb;
                    sep = '';
                    break;
                }
                case 'newline':
                    if (comment)
                        sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return { comment, offset };
}

exports.resolveEnd = resolveEnd;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/resolve-flow-collection.js":
/*!*******************************************************************!*\
  !*** ./node_modules/yaml/dist/compose/resolve-flow-collection.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Pair = __webpack_require__(/*! ../nodes/Pair.js */ "./node_modules/yaml/dist/nodes/Pair.js");
var YAMLMap = __webpack_require__(/*! ../nodes/YAMLMap.js */ "./node_modules/yaml/dist/nodes/YAMLMap.js");
var YAMLSeq = __webpack_require__(/*! ../nodes/YAMLSeq.js */ "./node_modules/yaml/dist/nodes/YAMLSeq.js");
var resolveEnd = __webpack_require__(/*! ./resolve-end.js */ "./node_modules/yaml/dist/compose/resolve-end.js");
var resolveProps = __webpack_require__(/*! ./resolve-props.js */ "./node_modules/yaml/dist/compose/resolve-props.js");
var utilContainsNewline = __webpack_require__(/*! ./util-contains-newline.js */ "./node_modules/yaml/dist/compose/util-contains-newline.js");
var utilMapIncludes = __webpack_require__(/*! ./util-map-includes.js */ "./node_modules/yaml/dist/compose/util-map-includes.js");

const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === '{';
    const fcName = isMap ? 'flow map' : 'flow sequence';
    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq));
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
        ctx.atRoot = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
            flow: fcName,
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment)
                        coll.comment += '\n' + props.comment;
                    else
                        coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
        }
        if (i === 0) {
            if (props.comma)
                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        }
        else {
            if (!props.comma)
                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = '';
                loop: for (const st of start) {
                    switch (st.type) {
                        case 'comma':
                        case 'space':
                            break;
                        case 'comment':
                            prevItemComment = st.source.substring(1);
                            break loop;
                        default:
                            break loop;
                    }
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if (identity.isPair(prev))
                        prev = prev.value ?? prev.key;
                    if (prev.comment)
                        prev.comment += '\n' + prevItemComment;
                    else
                        prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            // → key & sep are empty, start does not include ? or :
            const valueNode = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if (isBlock(value))
                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        }
        else {
            // item is a key+value pair
            // key value
            const keyStart = props.end;
            const keyNode = key
                ? composeNode(ctx, key, props, onError)
                : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if (isBlock(key))
                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
            // value properties
            const valueProps = resolveProps.resolveProps(sep ?? [], {
                flow: fcName,
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep)
                        for (const st of sep) {
                            if (st === valueProps.found)
                                break;
                            if (st.type === 'newline') {
                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                break;
                            }
                        }
                    if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                }
            }
            else if (value) {
                if ('source' in value && value.source && value.source[0] === ':')
                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                else
                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : valueProps.found
                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                    : null;
            if (valueNode) {
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                map.items.push(pair);
            }
            else {
                const map = new YAMLMap.YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? '}' : ']';
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
            ? `${name} must end with a ${expectedEnd}`
            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
        if (ce && ce.source.length !== 1)
            ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment)
                coll.comment += '\n' + end.comment;
            else
                coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
    }
    else {
        coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
}

exports.resolveFlowCollection = resolveFlowCollection;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/resolve-flow-scalar.js":
/*!***************************************************************!*\
  !*** ./node_modules/yaml/dist/compose/resolve-flow-scalar.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(/*! ../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var resolveEnd = __webpack_require__(/*! ./resolve-end.js */ "./node_modules/yaml/dist/compose/resolve-end.js");

function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
        case 'scalar':
            _type = Scalar.Scalar.PLAIN;
            value = plainValue(source, _onError);
            break;
        case 'single-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_SINGLE;
            value = singleQuotedValue(source, _onError);
            break;
        case 'double-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_DOUBLE;
            value = doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */
        default:
            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
            return {
                value: '',
                type: null,
                comment: '',
                range: [offset, offset + source.length, offset + source.length]
            };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
    };
}
function plainValue(source, onError) {
    let badChar = '';
    switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
            badChar = 'a tab character';
            break;
        case ',':
            badChar = 'flow indicator character ,';
            break;
        case '%':
            badChar = 'directive indicator character %';
            break;
        case '|':
        case '>': {
            badChar = `block scalar indicator ${source[0]}`;
            break;
        }
        case '@':
        case '`': {
            badChar = `reserved character ${source[0]}`;
            break;
        }
    }
    if (badChar)
        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
    return foldLines(source);
}
function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */
    let first, line;
    try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
    }
    catch (_) {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
        return source;
    let res = match[1];
    let sep = ' ';
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while ((match = line.exec(source))) {
        if (match[1] === '') {
            if (sep === '\n')
                res += sep;
            else
                sep = '\n';
        }
        else {
            res += sep + match[1];
            sep = ' ';
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? '');
}
function doubleQuotedValue(source, onError) {
    let res = '';
    for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n')
            continue;
        if (ch === '\n') {
            const { fold, offset } = foldNewline(source, i);
            res += fold;
            i = offset;
        }
        else if (ch === '\\') {
            let next = source[++i];
            const cc = escapeCodes[next];
            if (cc)
                res += cc;
            else if (next === '\n') {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === '\r' && source[i + 1] === '\n') {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === 'x' || next === 'u' || next === 'U') {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
            }
            else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                res += raw;
            }
        }
        else if (ch === ' ' || ch === '\t') {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while (next === ' ' || next === '\t')
                next = source[++i + 1];
            if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n'))
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        }
        else {
            res += ch;
        }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
    let fold = '';
    let ch = source[offset + 1];
    while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n')
            break;
        if (ch === '\n')
            fold += '\n';
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold)
        fold = ' ';
    return { fold, offset };
}
const escapeCodes = {
    '0': '\0',
    a: '\x07',
    b: '\b',
    e: '\x1b',
    f: '\f',
    n: '\n',
    r: '\r',
    t: '\t',
    v: '\v',
    N: '\u0085',
    _: '\u00a0',
    L: '\u2028',
    P: '\u2029',
    ' ': ' ',
    '"': '"',
    '/': '/',
    '\\': '\\',
    '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}

exports.resolveFlowScalar = resolveFlowScalar;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/resolve-props.js":
/*!*********************************************************!*\
  !*** ./node_modules/yaml/dist/compose/resolve-props.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = '';
    let commentSep = '';
    let hasNewline = false;
    let hasNewlineAfterProp = false;
    let reqSpace = false;
    let anchor = null;
    let tag = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
        if (reqSpace) {
            if (token.type !== 'space' &&
                token.type !== 'newline' &&
                token.type !== 'comma')
                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
            reqSpace = false;
        }
        switch (token.type) {
            case 'space':
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow &&
                    atNewline &&
                    indicator !== 'doc-start' &&
                    token.source[0] === '\t')
                    onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
                hasSpace = true;
                break;
            case 'comment': {
                if (!hasSpace)
                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                const cb = token.source.substring(1) || ' ';
                if (!comment)
                    comment = cb;
                else
                    comment += commentSep + cb;
                commentSep = '';
                atNewline = false;
                break;
            }
            case 'newline':
                if (atNewline) {
                    if (comment)
                        comment += token.source;
                    else
                        spaceBefore = true;
                }
                else
                    commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag)
                    hasNewlineAfterProp = true;
                hasSpace = true;
                break;
            case 'anchor':
                if (anchor)
                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                if (token.source.endsWith(':'))
                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
                anchor = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case 'tag': {
                if (tag)
                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                tag = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            }
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag)
                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                if (found)
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
                found = token;
                atNewline = false;
                hasSpace = false;
                break;
            case 'comma':
                if (flow) {
                    if (comma)
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== ''))
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
    return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        hasNewlineAfterProp,
        anchor,
        tag,
        end,
        start: start ?? end
    };
}

exports.resolveProps = resolveProps;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/util-contains-newline.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yaml/dist/compose/util-contains-newline.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function containsNewline(key) {
    if (!key)
        return null;
    switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            if (key.source.includes('\n'))
                return true;
            if (key.end)
                for (const st of key.end)
                    if (st.type === 'newline')
                        return true;
            return false;
        case 'flow-collection':
            for (const it of key.items) {
                for (const st of it.start)
                    if (st.type === 'newline')
                        return true;
                if (it.sep)
                    for (const st of it.sep)
                        if (st.type === 'newline')
                            return true;
                if (containsNewline(it.key) || containsNewline(it.value))
                    return true;
            }
            return false;
        default:
            return true;
    }
}

exports.containsNewline = containsNewline;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/util-empty-scalar-position.js":
/*!**********************************************************************!*\
  !*** ./node_modules/yaml/dist/compose/util-empty-scalar-position.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function emptyScalarPosition(offset, before, pos) {
    if (before) {
        if (pos === null)
            pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
            let st = before[i];
            switch (st.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while (st?.type === 'space') {
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}

exports.emptyScalarPosition = emptyScalarPosition;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/util-flow-indent-check.js":
/*!******************************************************************!*\
  !*** ./node_modules/yaml/dist/compose/util-flow-indent-check.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utilContainsNewline = __webpack_require__(/*! ./util-contains-newline.js */ "./node_modules/yaml/dist/compose/util-contains-newline.js");

function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === 'flow-collection') {
        const end = fc.end[0];
        if (end.indent === indent &&
            (end.source === ']' || end.source === '}') &&
            utilContainsNewline.containsNewline(fc)) {
            const msg = 'Flow end indicator should be more indented than parent';
            onError(end, 'BAD_INDENT', msg, true);
        }
    }
}

exports.flowIndentCheck = flowIndentCheck;


/***/ }),

/***/ "./node_modules/yaml/dist/compose/util-map-includes.js":
/*!*************************************************************!*\
  !*** ./node_modules/yaml/dist/compose/util-map-includes.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");

function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
        return false;
    const isEqual = typeof uniqueKeys === 'function'
        ? uniqueKeys
        : (a, b) => a === b ||
            (identity.isScalar(a) &&
                identity.isScalar(b) &&
                a.value === b.value &&
                !(a.value === '<<' && ctx.schema.merge));
    return items.some(pair => isEqual(pair.key, search));
}

exports.mapIncludes = mapIncludes;


/***/ }),

/***/ "./node_modules/yaml/dist/doc/Document.js":
/*!************************************************!*\
  !*** ./node_modules/yaml/dist/doc/Document.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(/*! ../nodes/Alias.js */ "./node_modules/yaml/dist/nodes/Alias.js");
var Collection = __webpack_require__(/*! ../nodes/Collection.js */ "./node_modules/yaml/dist/nodes/Collection.js");
var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Pair = __webpack_require__(/*! ../nodes/Pair.js */ "./node_modules/yaml/dist/nodes/Pair.js");
var toJS = __webpack_require__(/*! ../nodes/toJS.js */ "./node_modules/yaml/dist/nodes/toJS.js");
var Schema = __webpack_require__(/*! ../schema/Schema.js */ "./node_modules/yaml/dist/schema/Schema.js");
var stringifyDocument = __webpack_require__(/*! ../stringify/stringifyDocument.js */ "./node_modules/yaml/dist/stringify/stringifyDocument.js");
var anchors = __webpack_require__(/*! ./anchors.js */ "./node_modules/yaml/dist/doc/anchors.js");
var applyReviver = __webpack_require__(/*! ./applyReviver.js */ "./node_modules/yaml/dist/doc/applyReviver.js");
var createNode = __webpack_require__(/*! ./createNode.js */ "./node_modules/yaml/dist/doc/createNode.js");
var directives = __webpack_require__(/*! ./directives.js */ "./node_modules/yaml/dist/doc/directives.js");

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
            value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = identity.isNode(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchors.anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return identity.isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
            return !keepScalar && identity.isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return identity.isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (Collection.isEmptyPath(path))
            return this.contents !== undefined;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
        if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = Collection.collectionFromPath(this.schema, [key], value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
        }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        if (Collection.isEmptyPath(path)) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = value;
        }
        else if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.setIn(path, value);
        }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
        if (typeof version === 'number')
            version = String(version);
        let opt;
        switch (version) {
            case '1.1':
                if (this.directives)
                    this.directives.yaml.version = '1.1';
                else
                    this.directives = new directives.Directives({ version: '1.1' });
                opt = { merge: true, resolveKnownTags: false, schema: 'yaml-1.1' };
                break;
            case '1.2':
            case 'next':
                if (this.directives)
                    this.directives.yaml.version = version;
                else
                    this.directives = new directives.Directives({ version });
                opt = { merge: false, resolveKnownTags: true, schema: 'core' };
                break;
            case null:
                if (this.directives)
                    delete this.directives;
                opt = null;
                break;
            default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
            }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object)
            this.schema = options.schema;
        else if (opt)
            this.schema = new Schema.Schema(Object.assign(opt, options));
        else
            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver.applyReviver(reviver, { '': res }, '', res)
            : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
        if (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (identity.isCollection(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

exports.Document = Document;


/***/ }),

/***/ "./node_modules/yaml/dist/doc/anchors.js":
/*!***********************************************!*\
  !*** ./node_modules/yaml/dist/doc/anchors.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var visit = __webpack_require__(/*! ../visit.js */ "./node_modules/yaml/dist/visit.js");

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function anchorNames(root) {
    const anchors = new Set();
    visit.visit(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
            return name;
    }
}
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source) => {
            aliasObjects.push(source);
            if (!prevAnchors)
                prevAnchors = anchorNames(doc);
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
                    ref.node.anchor = ref.anchor;
                }
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects
    };
}

exports.anchorIsValid = anchorIsValid;
exports.anchorNames = anchorNames;
exports.createNodeAnchors = createNodeAnchors;
exports.findNewAnchor = findNewAnchor;


/***/ }),

/***/ "./node_modules/yaml/dist/doc/applyReviver.js":
/*!****************************************************!*\
  !*** ./node_modules/yaml/dist/doc/applyReviver.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
            for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                if (v1 === undefined)
                    delete val[i];
                else if (v1 !== v0)
                    val[i] = v1;
            }
        }
        else if (val instanceof Map) {
            for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    val.delete(k);
                else if (v1 !== v0)
                    val.set(k, v1);
            }
        }
        else if (val instanceof Set) {
            for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === undefined)
                    val.delete(v0);
                else if (v1 !== v0) {
                    val.delete(v0);
                    val.add(v1);
                }
            }
        }
        else {
            for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    delete val[k];
                else if (v1 !== v0)
                    val[k] = v1;
            }
        }
    }
    return reviver.call(obj, key, val);
}

exports.applyReviver = applyReviver;


/***/ }),

/***/ "./node_modules/yaml/dist/doc/createNode.js":
/*!**************************************************!*\
  !*** ./node_modules/yaml/dist/doc/createNode.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(/*! ../nodes/Alias.js */ "./node_modules/yaml/dist/nodes/Alias.js");
var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Scalar = __webpack_require__(/*! ../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");

const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) ?? match[0];
        if (!tagObj)
            throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find(t => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
    if (identity.isDocument(value))
        value = value.contents;
    if (identity.isNode(value))
        return value;
    if (identity.isPair(value)) {
        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere
    ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
            if (!ref.anchor)
                ref.anchor = onAnchor(value);
            return new Alias.Alias(ref.anchor);
        }
        else {
            ref = { anchor: null, node: null };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith('!!'))
        tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            value = value.toJSON();
        }
        if (!value || typeof value !== 'object') {
            const node = new Scalar.Scalar(value);
            if (ref)
                ref.node = node;
            return node;
        }
        tagObj =
            value instanceof Map
                ? schema[identity.MAP]
                : Symbol.iterator in Object(value)
                    ? schema[identity.SEQ]
                    : schema[identity.MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : typeof tagObj?.nodeClass?.from === 'function'
            ? tagObj.nodeClass.from(ctx.schema, value, ctx)
            : new Scalar.Scalar(value);
    if (tagName)
        node.tag = tagName;
    else if (!tagObj.default)
        node.tag = tagObj.tag;
    if (ref)
        ref.node = node;
    return node;
}

exports.createNode = createNode;


/***/ }),

/***/ "./node_modules/yaml/dist/doc/directives.js":
/*!**************************************************!*\
  !*** ./node_modules/yaml/dist/doc/directives.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var visit = __webpack_require__(/*! ../visit.js */ "./node_modules/yaml/dist/visit.js");

const escapeChars = {
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
    constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
            case '1.1':
                this.atNextDocument = true;
                break;
            case '1.2':
                this.atNextDocument = false;
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.2'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
            this.tags = Object.assign({}, Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
            case '%TAG': {
                if (parts.length !== 2) {
                    onError(0, '%TAG directive should contain exactly two parts');
                    if (parts.length < 2)
                        return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
            }
            case '%YAML': {
                this.yaml.explicit = true;
                if (parts.length !== 1) {
                    onError(0, '%YAML directive should contain exactly one part');
                    return false;
                }
                const [version] = parts;
                if (version === '1.1' || version === '1.2') {
                    this.yaml.version = version;
                    return true;
                }
                else {
                    const isValid = /^\d+\.\d+$/.test(version);
                    onError(6, `Unsupported YAML version ${version}`, isValid);
                    return false;
                }
            }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
        if (source === '!')
            return '!'; // non-specific tag
        if (source[0] !== '!') {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === '<') {
            const verbatim = source.slice(2, -1);
            if (verbatim === '!' || verbatim === '!!') {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== '>')
                onError('Verbatim tags must end with a >');
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
        if (!suffix)
            onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix)
            return prefix + decodeURIComponent(suffix);
        if (handle === '!')
            return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit
            ? [`%YAML ${this.yaml.version || '1.2'}`]
            : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
            const tags = {};
            visit.visit(doc.contents, (_key, node) => {
                if (identity.isNode(node) && node.tag)
                    tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        }
        else
            tagNames = [];
        for (const [handle, prefix] of tagEntries) {
            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                continue;
            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
    }
}
Directives.defaultYaml = { explicit: false, version: '1.2' };
Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

exports.Directives = Directives;


/***/ }),

/***/ "./node_modules/yaml/dist/errors.js":
/*!******************************************!*\
  !*** ./node_modules/yaml/dist/errors.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class YAMLError extends Error {
    constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
    }
}
class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
    }
}
const prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
        return;
    error.linePos = error.pos.map(pos => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, '');
    // Trim to max 80 chars, keeping col position near the middle
    if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = '…' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + '…';
    // Include previous line in context if pointing at line start
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
            prev = prev.substring(0, 79) + '…\n';
        lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
            count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
};

exports.YAMLError = YAMLError;
exports.YAMLParseError = YAMLParseError;
exports.YAMLWarning = YAMLWarning;
exports.prettifyError = prettifyError;


/***/ }),

/***/ "./node_modules/yaml/dist/index.js":
/*!*****************************************!*\
  !*** ./node_modules/yaml/dist/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var composer = __webpack_require__(/*! ./compose/composer.js */ "./node_modules/yaml/dist/compose/composer.js");
var Document = __webpack_require__(/*! ./doc/Document.js */ "./node_modules/yaml/dist/doc/Document.js");
var Schema = __webpack_require__(/*! ./schema/Schema.js */ "./node_modules/yaml/dist/schema/Schema.js");
var errors = __webpack_require__(/*! ./errors.js */ "./node_modules/yaml/dist/errors.js");
var Alias = __webpack_require__(/*! ./nodes/Alias.js */ "./node_modules/yaml/dist/nodes/Alias.js");
var identity = __webpack_require__(/*! ./nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Pair = __webpack_require__(/*! ./nodes/Pair.js */ "./node_modules/yaml/dist/nodes/Pair.js");
var Scalar = __webpack_require__(/*! ./nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var YAMLMap = __webpack_require__(/*! ./nodes/YAMLMap.js */ "./node_modules/yaml/dist/nodes/YAMLMap.js");
var YAMLSeq = __webpack_require__(/*! ./nodes/YAMLSeq.js */ "./node_modules/yaml/dist/nodes/YAMLSeq.js");
var cst = __webpack_require__(/*! ./parse/cst.js */ "./node_modules/yaml/dist/parse/cst.js");
var lexer = __webpack_require__(/*! ./parse/lexer.js */ "./node_modules/yaml/dist/parse/lexer.js");
var lineCounter = __webpack_require__(/*! ./parse/line-counter.js */ "./node_modules/yaml/dist/parse/line-counter.js");
var parser = __webpack_require__(/*! ./parse/parser.js */ "./node_modules/yaml/dist/parse/parser.js");
var publicApi = __webpack_require__(/*! ./public-api.js */ "./node_modules/yaml/dist/public-api.js");
var visit = __webpack_require__(/*! ./visit.js */ "./node_modules/yaml/dist/visit.js");



exports.Composer = composer.Composer;
exports.Document = Document.Document;
exports.Schema = Schema.Schema;
exports.YAMLError = errors.YAMLError;
exports.YAMLParseError = errors.YAMLParseError;
exports.YAMLWarning = errors.YAMLWarning;
exports.Alias = Alias.Alias;
exports.isAlias = identity.isAlias;
exports.isCollection = identity.isCollection;
exports.isDocument = identity.isDocument;
exports.isMap = identity.isMap;
exports.isNode = identity.isNode;
exports.isPair = identity.isPair;
exports.isScalar = identity.isScalar;
exports.isSeq = identity.isSeq;
exports.Pair = Pair.Pair;
exports.Scalar = Scalar.Scalar;
exports.YAMLMap = YAMLMap.YAMLMap;
exports.YAMLSeq = YAMLSeq.YAMLSeq;
exports.CST = cst;
exports.Lexer = lexer.Lexer;
exports.LineCounter = lineCounter.LineCounter;
exports.Parser = parser.Parser;
exports.parse = publicApi.parse;
exports.parseAllDocuments = publicApi.parseAllDocuments;
exports.parseDocument = publicApi.parseDocument;
exports.stringify = publicApi.stringify;
exports.visit = visit.visit;
exports.visitAsync = visit.visitAsync;


/***/ }),

/***/ "./node_modules/yaml/dist/log.js":
/*!***************************************!*\
  !*** ./node_modules/yaml/dist/log.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function debug(logLevel, ...messages) {
    if (logLevel === 'debug')
        console.log(...messages);
}
function warn(logLevel, warning) {
    if (logLevel === 'debug' || logLevel === 'warn') {
        // https://github.com/typescript-eslint/typescript-eslint/issues/7478
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        if (typeof process !== 'undefined' && process.emitWarning)
            process.emitWarning(warning);
        else
            console.warn(warning);
    }
}

exports.debug = debug;
exports.warn = warn;


/***/ }),

/***/ "./node_modules/yaml/dist/nodes/Alias.js":
/*!***********************************************!*\
  !*** ./node_modules/yaml/dist/nodes/Alias.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var anchors = __webpack_require__(/*! ../doc/anchors.js */ "./node_modules/yaml/dist/doc/anchors.js");
var visit = __webpack_require__(/*! ../visit.js */ "./node_modules/yaml/dist/visit.js");
var identity = __webpack_require__(/*! ./identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Node = __webpack_require__(/*! ./Node.js */ "./node_modules/yaml/dist/nodes/Node.js");
var toJS = __webpack_require__(/*! ./toJS.js */ "./node_modules/yaml/dist/nodes/toJS.js");

class Alias extends Node.NodeBase {
    constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc) {
        let found = undefined;
        visit.visit(doc, {
            Node: (_key, node) => {
                if (node === this)
                    return visit.visit.BREAK;
                if (node.anchor === this.source)
                    found = node;
            }
        });
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
            // Resolve anchors for Node.prototype.toJS()
            toJS.toJS(source, null, ctx);
            data = anchors.get(source);
        }
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            anchors.anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey)
                return `${src} `;
        }
        return src;
    }
}
function getAliasCount(doc, node, anchors) {
    if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        }
        return count;
    }
    else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}

exports.Alias = Alias;


/***/ }),

/***/ "./node_modules/yaml/dist/nodes/Collection.js":
/*!****************************************************!*\
  !*** ./node_modules/yaml/dist/nodes/Collection.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(/*! ../doc/createNode.js */ "./node_modules/yaml/dist/doc/createNode.js");
var identity = __webpack_require__(/*! ./identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Node = __webpack_require__(/*! ./Node.js */ "./node_modules/yaml/dist/nodes/Node.js");

function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        }
        else {
            v = new Map([[k, v]]);
        }
    }
    return createNode.createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
            throw new Error('This should not happen, please report a bug.');
        },
        schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = (path) => path == null ||
    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
class Collection extends Node.NodeBase {
    constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
            copy.schema = schema;
        copy.items = copy.items.map(it => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
        if (isEmptyPath(path))
            this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if (identity.isCollection(node))
                node.addIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
            return node.deleteIn(rest);
        else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
            return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
            return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every(node => {
            if (!identity.isPair(node))
                return false;
            const n = node.value;
            return (n == null ||
                (allowScalar &&
                    identity.isScalar(n) &&
                    n.value == null &&
                    !n.commentBefore &&
                    !n.comment &&
                    !n.tag));
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
            this.set(key, value);
        }
        else {
            const node = this.get(key, true);
            if (identity.isCollection(node))
                node.setIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}
Collection.maxFlowStringSingleLineLength = 60;

exports.Collection = Collection;
exports.collectionFromPath = collectionFromPath;
exports.isEmptyPath = isEmptyPath;


/***/ }),

/***/ "./node_modules/yaml/dist/nodes/Node.js":
/*!**********************************************!*\
  !*** ./node_modules/yaml/dist/nodes/Node.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var applyReviver = __webpack_require__(/*! ../doc/applyReviver.js */ "./node_modules/yaml/dist/doc/applyReviver.js");
var identity = __webpack_require__(/*! ./identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var toJS = __webpack_require__(/*! ./toJS.js */ "./node_modules/yaml/dist/nodes/toJS.js");

class NodeBase {
    constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    /** Create a copy of this node.  */
    clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** A plain JavaScript representation of this node. */
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
            throw new TypeError('A document argument is required');
        const ctx = {
            anchors: new Map(),
            doc,
            keep: true,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver.applyReviver(reviver, { '': res }, '', res)
            : res;
    }
}

exports.NodeBase = NodeBase;


/***/ }),

/***/ "./node_modules/yaml/dist/nodes/Pair.js":
/*!**********************************************!*\
  !*** ./node_modules/yaml/dist/nodes/Pair.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(/*! ../doc/createNode.js */ "./node_modules/yaml/dist/doc/createNode.js");
var stringifyPair = __webpack_require__(/*! ../stringify/stringifyPair.js */ "./node_modules/yaml/dist/stringify/stringifyPair.js");
var addPairToJSMap = __webpack_require__(/*! ./addPairToJSMap.js */ "./node_modules/yaml/dist/nodes/addPairToJSMap.js");
var identity = __webpack_require__(/*! ./identity.js */ "./node_modules/yaml/dist/nodes/identity.js");

function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
}
class Pair {
    constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key))
            key = key.clone(schema);
        if (identity.isNode(value))
            value = value.clone(schema);
        return new Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc
            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)
            : JSON.stringify(this);
    }
}

exports.Pair = Pair;
exports.createPair = createPair;


/***/ }),

/***/ "./node_modules/yaml/dist/nodes/Scalar.js":
/*!************************************************!*\
  !*** ./node_modules/yaml/dist/nodes/Scalar.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ./identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Node = __webpack_require__(/*! ./Node.js */ "./node_modules/yaml/dist/nodes/Node.js");
var toJS = __webpack_require__(/*! ./toJS.js */ "./node_modules/yaml/dist/nodes/toJS.js");

const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
class Scalar extends Node.NodeBase {
    constructor(value) {
        super(identity.SCALAR);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

exports.Scalar = Scalar;
exports.isScalarValue = isScalarValue;


/***/ }),

/***/ "./node_modules/yaml/dist/nodes/YAMLMap.js":
/*!*************************************************!*\
  !*** ./node_modules/yaml/dist/nodes/YAMLMap.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyCollection = __webpack_require__(/*! ../stringify/stringifyCollection.js */ "./node_modules/yaml/dist/stringify/stringifyCollection.js");
var addPairToJSMap = __webpack_require__(/*! ./addPairToJSMap.js */ "./node_modules/yaml/dist/nodes/addPairToJSMap.js");
var Collection = __webpack_require__(/*! ./Collection.js */ "./node_modules/yaml/dist/nodes/Collection.js");
var identity = __webpack_require__(/*! ./identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Pair = __webpack_require__(/*! ./Pair.js */ "./node_modules/yaml/dist/nodes/Pair.js");
var Scalar = __webpack_require__(/*! ./Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");

function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
        if (identity.isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (identity.isScalar(it.key) && it.key.value === k)
                return it;
        }
    }
    return undefined;
}
class YAMLMap extends Collection.Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    }
    constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
            if (typeof replacer === 'function')
                value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
                return;
            if (value !== undefined || keepUndefined)
                map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
            for (const [key, value] of obj)
                add(key, value);
        }
        else if (obj && typeof obj === 'object') {
            for (const key of Object.keys(obj))
                add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === 'function') {
            map.items.sort(schema.sortMapEntries);
        }
        return map;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair.Pair(pair, pair?.value);
        }
        else
            _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        }
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        }
        else {
            this.items.push(_pair);
        }
    }
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!findPair(this.items, key);
    }
    set(key, value) {
        this.add(new Pair.Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!identity.isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '',
            flowChars: { start: '{', end: '}' },
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        });
    }
}

exports.YAMLMap = YAMLMap;
exports.findPair = findPair;


/***/ }),

/***/ "./node_modules/yaml/dist/nodes/YAMLSeq.js":
/*!*************************************************!*\
  !*** ./node_modules/yaml/dist/nodes/YAMLSeq.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(/*! ../doc/createNode.js */ "./node_modules/yaml/dist/doc/createNode.js");
var stringifyCollection = __webpack_require__(/*! ../stringify/stringifyCollection.js */ "./node_modules/yaml/dist/stringify/stringifyCollection.js");
var Collection = __webpack_require__(/*! ./Collection.js */ "./node_modules/yaml/dist/nodes/Collection.js");
var identity = __webpack_require__(/*! ./identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Scalar = __webpack_require__(/*! ./Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var toJS = __webpack_require__(/*! ./toJS.js */ "./node_modules/yaml/dist/nodes/toJS.js");

class YAMLSeq extends Collection.Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '- ',
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
    static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj) {
                if (typeof replacer === 'function') {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push(createNode.createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
}
function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

exports.YAMLSeq = YAMLSeq;


/***/ }),

/***/ "./node_modules/yaml/dist/nodes/addPairToJSMap.js":
/*!********************************************************!*\
  !*** ./node_modules/yaml/dist/nodes/addPairToJSMap.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var log = __webpack_require__(/*! ../log.js */ "./node_modules/yaml/dist/log.js");
var stringify = __webpack_require__(/*! ../stringify/stringify.js */ "./node_modules/yaml/dist/stringify/stringify.js");
var identity = __webpack_require__(/*! ./identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Scalar = __webpack_require__(/*! ./Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var toJS = __webpack_require__(/*! ./toJS.js */ "./node_modules/yaml/dist/nodes/toJS.js");

const MERGE_KEY = '<<';
function addPairToJSMap(ctx, map, { key, value }) {
    if (ctx?.doc.schema.merge && isMergeKey(key)) {
        value = identity.isAlias(value) ? value.resolve(ctx.doc) : value;
        if (identity.isSeq(value))
            for (const it of value.items)
                mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value))
            for (const it of value)
                mergeToJSMap(ctx, map, it);
        else
            mergeToJSMap(ctx, map, value);
    }
    else {
        const jsKey = toJS.toJS(key, '', ctx);
        if (map instanceof Map) {
            map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        }
        else if (map instanceof Set) {
            map.add(jsKey);
        }
        else {
            const stringKey = stringifyKey(key, jsKey, ctx);
            const jsValue = toJS.toJS(value, stringKey, ctx);
            if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            else
                map[stringKey] = jsValue;
        }
    }
    return map;
}
const isMergeKey = (key) => key === MERGE_KEY ||
    (identity.isScalar(key) &&
        key.value === MERGE_KEY &&
        (!key.type || key.type === Scalar.Scalar.PLAIN));
// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
function mergeToJSMap(ctx, map, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source))
        throw new Error('Merge sources must be maps or map aliases');
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) {
        if (map instanceof Map) {
            if (!map.has(key))
                map.set(key, value);
        }
        else if (map instanceof Set) {
            map.add(key);
        }
        else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    return map;
}
function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
        return '';
    if (typeof jsKey !== 'object')
        return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
            strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}

exports.addPairToJSMap = addPairToJSMap;


/***/ }),

/***/ "./node_modules/yaml/dist/nodes/identity.js":
/*!**************************************************!*\
  !*** ./node_modules/yaml/dist/nodes/identity.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;
const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case MAP:
            case SEQ:
                return true;
        }
    return false;
}
function isNode(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case ALIAS:
            case MAP:
            case SCALAR:
            case SEQ:
                return true;
        }
    return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

exports.ALIAS = ALIAS;
exports.DOC = DOC;
exports.MAP = MAP;
exports.NODE_TYPE = NODE_TYPE;
exports.PAIR = PAIR;
exports.SCALAR = SCALAR;
exports.SEQ = SEQ;
exports.hasAnchor = hasAnchor;
exports.isAlias = isAlias;
exports.isCollection = isCollection;
exports.isDocument = isDocument;
exports.isMap = isMap;
exports.isNode = isNode;
exports.isPair = isPair;
exports.isScalar = isScalar;
exports.isSeq = isSeq;


/***/ }),

/***/ "./node_modules/yaml/dist/nodes/toJS.js":
/*!**********************************************!*\
  !*** ./node_modules/yaml/dist/nodes/toJS.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ./identity.js */ "./node_modules/yaml/dist/nodes/identity.js");

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !identity.hasAnchor(value))
            return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
            ctx.onCreate(res);
        return res;
    }
    if (typeof value === 'bigint' && !ctx?.keep)
        return Number(value);
    return value;
}

exports.toJS = toJS;


/***/ }),

/***/ "./node_modules/yaml/dist/parse/cst-scalar.js":
/*!****************************************************!*\
  !*** ./node_modules/yaml/dist/parse/cst-scalar.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var resolveBlockScalar = __webpack_require__(/*! ../compose/resolve-block-scalar.js */ "./node_modules/yaml/dist/compose/resolve-block-scalar.js");
var resolveFlowScalar = __webpack_require__(/*! ../compose/resolve-flow-scalar.js */ "./node_modules/yaml/dist/compose/resolve-flow-scalar.js");
var errors = __webpack_require__(/*! ../errors.js */ "./node_modules/yaml/dist/errors.js");
var stringifyString = __webpack_require__(/*! ../stringify/stringifyString.js */ "./node_modules/yaml/dist/stringify/stringifyString.js");

function resolveAsScalar(token, strict = true, onError) {
    if (token) {
        const _onError = (pos, code, message) => {
            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
            if (onError)
                onError(offset, code, message);
            else
                throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
            case 'block-scalar':
                return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
        }
    }
    return null;
}
/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
        { type: 'newline', offset: -1, indent, source: '\n' }
    ];
    switch (source[0]) {
        case '|':
        case '>': {
            const he = source.indexOf('\n');
            const head = source.substring(0, he);
            const body = source.substring(he + 1) + '\n';
            const props = [
                { type: 'block-scalar-header', offset, indent, source: head }
            ];
            if (!addEndtoBlockProps(props, end))
                props.push({ type: 'newline', offset: -1, indent, source: '\n' });
            return { type: 'block-scalar', offset, indent, props, source: body };
        }
        case '"':
            return { type: 'double-quoted-scalar', offset, indent, source, end };
        case "'":
            return { type: 'single-quoted-scalar', offset, indent, source, end };
        default:
            return { type: 'scalar', offset, indent, source, end };
    }
}
/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = 'indent' in token ? token.indent : null;
    if (afterKey && typeof indent === 'number')
        indent += 2;
    if (!type)
        switch (token.type) {
            case 'single-quoted-scalar':
                type = 'QUOTE_SINGLE';
                break;
            case 'double-quoted-scalar':
                type = 'QUOTE_DOUBLE';
                break;
            case 'block-scalar': {
                const header = token.props[0];
                if (header.type !== 'block-scalar-header')
                    throw new Error('Invalid block scalar header');
                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';
                break;
            }
            default:
                type = 'PLAIN';
        }
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
        case '|':
        case '>':
            setBlockScalarValue(token, source);
            break;
        case '"':
            setFlowScalarValue(token, source, 'double-quoted-scalar');
            break;
        case "'":
            setFlowScalarValue(token, source, 'single-quoted-scalar');
            break;
        default:
            setFlowScalarValue(token, source, 'scalar');
    }
}
function setBlockScalarValue(token, source) {
    const he = source.indexOf('\n');
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + '\n';
    if (token.type === 'block-scalar') {
        const header = token.props[0];
        if (header.type !== 'block-scalar-header')
            throw new Error('Invalid block scalar header');
        header.source = head;
        token.source = body;
    }
    else {
        const { offset } = token;
        const indent = 'indent' in token ? token.indent : -1;
        const props = [
            { type: 'block-scalar-header', offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))
            props.push({ type: 'newline', offset: -1, indent, source: '\n' });
        for (const key of Object.keys(token))
            if (key !== 'type' && key !== 'offset')
                delete token[key];
        Object.assign(token, { type: 'block-scalar', indent, props, source: body });
    }
}
/** @returns `true` if last token is a newline */
function addEndtoBlockProps(props, end) {
    if (end)
        for (const st of end)
            switch (st.type) {
                case 'space':
                case 'comment':
                    props.push(st);
                    break;
                case 'newline':
                    props.push(st);
                    return true;
            }
    return false;
}
function setFlowScalarValue(token, source, type) {
    switch (token.type) {
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            token.type = type;
            token.source = source;
            break;
        case 'block-scalar': {
            const end = token.props.slice(1);
            let oa = source.length;
            if (token.props[0].type === 'block-scalar-header')
                oa -= token.props[0].source.length;
            for (const tok of end)
                tok.offset += oa;
            delete token.props;
            Object.assign(token, { type, source, end });
            break;
        }
        case 'block-map':
        case 'block-seq': {
            const offset = token.offset + source.length;
            const nl = { type: 'newline', offset, indent: token.indent, source: '\n' };
            delete token.items;
            Object.assign(token, { type, source, end: [nl] });
            break;
        }
        default: {
            const indent = 'indent' in token ? token.indent : -1;
            const end = 'end' in token && Array.isArray(token.end)
                ? token.end.filter(st => st.type === 'space' ||
                    st.type === 'comment' ||
                    st.type === 'newline')
                : [];
            for (const key of Object.keys(token))
                if (key !== 'type' && key !== 'offset')
                    delete token[key];
            Object.assign(token, { type, indent, source, end });
        }
    }
}

exports.createScalarToken = createScalarToken;
exports.resolveAsScalar = resolveAsScalar;
exports.setScalarValue = setScalarValue;


/***/ }),

/***/ "./node_modules/yaml/dist/parse/cst-stringify.js":
/*!*******************************************************!*\
  !*** ./node_modules/yaml/dist/parse/cst-stringify.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */
const stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
    switch (token.type) {
        case 'block-scalar': {
            let res = '';
            for (const tok of token.props)
                res += stringifyToken(tok);
            return res + token.source;
        }
        case 'block-map':
        case 'block-seq': {
            let res = '';
            for (const item of token.items)
                res += stringifyItem(item);
            return res;
        }
        case 'flow-collection': {
            let res = token.start.source;
            for (const item of token.items)
                res += stringifyItem(item);
            for (const st of token.end)
                res += st.source;
            return res;
        }
        case 'document': {
            let res = stringifyItem(token);
            if (token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
        default: {
            let res = token.source;
            if ('end' in token && token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
    }
}
function stringifyItem({ start, key, sep, value }) {
    let res = '';
    for (const st of start)
        res += st.source;
    if (key)
        res += stringifyToken(key);
    if (sep)
        for (const st of sep)
            res += st.source;
    if (value)
        res += stringifyToken(value);
    return res;
}

exports.stringify = stringify;


/***/ }),

/***/ "./node_modules/yaml/dist/parse/cst-visit.js":
/*!***************************************************!*\
  !*** ./node_modules/yaml/dist/parse/cst-visit.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove item');
/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]` – Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null` – Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]` – Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token` – The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */
function visit(cst, visitor) {
    if ('type' in cst && cst.type === 'document')
        cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current item */
visit.SKIP = SKIP;
/** Remove the current item */
visit.REMOVE = REMOVE;
/** Find the item at `path` from `cst` as the root */
visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && 'items' in tok) {
            item = tok.items[index];
        }
        else
            return undefined;
    }
    return item;
};
/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */
visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && 'items' in coll)
        return coll;
    throw new Error('Parent collection not found');
};
function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === 'symbol')
        return ctrl;
    for (const field of ['key', 'value']) {
        const token = item[field];
        if (token && 'items' in token) {
            for (let i = 0; i < token.items.length; ++i) {
                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    token.items.splice(i, 1);
                    i -= 1;
                }
            }
            if (typeof ctrl === 'function' && field === 'key')
                ctrl = ctrl(item, path);
        }
    }
    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;
}

exports.visit = visit;


/***/ }),

/***/ "./node_modules/yaml/dist/parse/cst.js":
/*!*********************************************!*\
  !*** ./node_modules/yaml/dist/parse/cst.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cstScalar = __webpack_require__(/*! ./cst-scalar.js */ "./node_modules/yaml/dist/parse/cst-scalar.js");
var cstStringify = __webpack_require__(/*! ./cst-stringify.js */ "./node_modules/yaml/dist/parse/cst-stringify.js");
var cstVisit = __webpack_require__(/*! ./cst-visit.js */ "./node_modules/yaml/dist/parse/cst-visit.js");

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** @returns `true` if `token` is a flow or block collection */
const isCollection = (token) => !!token && 'items' in token;
/** @returns `true` if `token` is a flow or block scalar; not an alias */
const isScalar = (token) => !!token &&
    (token.type === 'scalar' ||
        token.type === 'single-quoted-scalar' ||
        token.type === 'double-quoted-scalar' ||
        token.type === 'block-scalar');
/* istanbul ignore next */
/** Get a printable representation of a lexer token */
function prettyToken(token) {
    switch (token) {
        case BOM:
            return '<BOM>';
        case DOCUMENT:
            return '<DOC>';
        case FLOW_END:
            return '<FLOW_END>';
        case SCALAR:
            return '<SCALAR>';
        default:
            return JSON.stringify(token);
    }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
    switch (source) {
        case BOM:
            return 'byte-order-mark';
        case DOCUMENT:
            return 'doc-mode';
        case FLOW_END:
            return 'flow-error-end';
        case SCALAR:
            return 'scalar';
        case '---':
            return 'doc-start';
        case '...':
            return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
            return 'newline';
        case '-':
            return 'seq-item-ind';
        case '?':
            return 'explicit-key-ind';
        case ':':
            return 'map-value-ind';
        case '{':
            return 'flow-map-start';
        case '}':
            return 'flow-map-end';
        case '[':
            return 'flow-seq-start';
        case ']':
            return 'flow-seq-end';
        case ',':
            return 'comma';
    }
    switch (source[0]) {
        case ' ':
        case '\t':
            return 'space';
        case '#':
            return 'comment';
        case '%':
            return 'directive-line';
        case '*':
            return 'alias';
        case '&':
            return 'anchor';
        case '!':
            return 'tag';
        case "'":
            return 'single-quoted-scalar';
        case '"':
            return 'double-quoted-scalar';
        case '|':
        case '>':
            return 'block-scalar-header';
    }
    return null;
}

exports.createScalarToken = cstScalar.createScalarToken;
exports.resolveAsScalar = cstScalar.resolveAsScalar;
exports.setScalarValue = cstScalar.setScalarValue;
exports.stringify = cstStringify.stringify;
exports.visit = cstVisit.visit;
exports.BOM = BOM;
exports.DOCUMENT = DOCUMENT;
exports.FLOW_END = FLOW_END;
exports.SCALAR = SCALAR;
exports.isCollection = isCollection;
exports.isScalar = isScalar;
exports.prettyToken = prettyToken;
exports.tokenType = tokenType;


/***/ }),

/***/ "./node_modules/yaml/dist/parse/lexer.js":
/*!***********************************************!*\
  !*** ./node_modules/yaml/dist/parse/lexer.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cst = __webpack_require__(/*! ./cst.js */ "./node_modules/yaml/dist/parse/cst.js");

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === cst.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if (s === '---' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return 'doc';
            }
            else if (s === '...' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield cst.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else
                this.indentNext += this.blockScalarIndent;
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ' || ch === '\t')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && next === ','))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && invalidFlowScalarChars.includes(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.includes(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.includes(this.buffer[i + 1]) &&
                    hexDigits.includes(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

exports.Lexer = Lexer;


/***/ }),

/***/ "./node_modules/yaml/dist/parse/line-counter.js":
/*!******************************************************!*\
  !*** ./node_modules/yaml/dist/parse/line-counter.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
    constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset)
                    low = mid + 1;
                else
                    high = mid;
            }
            if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
            if (low === 0)
                return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
        };
    }
}

exports.LineCounter = LineCounter;


/***/ }),

/***/ "./node_modules/yaml/dist/parse/parser.js":
/*!************************************************!*\
  !*** ./node_modules/yaml/dist/parse/parser.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cst = __webpack_require__(/*! ./cst.js */ "./node_modules/yaml/dist/parse/cst.js");
var lexer = __webpack_require__(/*! ./lexer.js */ "./node_modules/yaml/dist/parse/lexer.js");

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
            console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = cst.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {
                        it.start.push(this.sourceToken);
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken] }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (includesToken(it.start, 'explicit-key-ind')) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (atNextItem &&
                            bv.type !== 'block-seq' &&
                            includesToken(it.start, 'explicit-key-ind')) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

exports.Parser = Parser;


/***/ }),

/***/ "./node_modules/yaml/dist/public-api.js":
/*!**********************************************!*\
  !*** ./node_modules/yaml/dist/public-api.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var composer = __webpack_require__(/*! ./compose/composer.js */ "./node_modules/yaml/dist/compose/composer.js");
var Document = __webpack_require__(/*! ./doc/Document.js */ "./node_modules/yaml/dist/doc/Document.js");
var errors = __webpack_require__(/*! ./errors.js */ "./node_modules/yaml/dist/errors.js");
var log = __webpack_require__(/*! ./log.js */ "./node_modules/yaml/dist/log.js");
var lineCounter = __webpack_require__(/*! ./parse/line-counter.js */ "./node_modules/yaml/dist/parse/line-counter.js");
var parser = __webpack_require__(/*! ./parse/parser.js */ "./node_modules/yaml/dist/parse/parser.js");

function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;
    return { lineCounter: lineCounter$1, prettyErrors };
}
/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */
function parseAllDocuments(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter)
        for (const doc of docs) {
            doc.errors.forEach(errors.prettifyError(source, lineCounter));
            doc.warnings.forEach(errors.prettifyError(source, lineCounter));
        }
    if (docs.length > 0)
        return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
            doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter));
    }
    return doc;
}
function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === 'function') {
        _reviver = reviver;
    }
    else if (options === undefined && reviver && typeof reviver === 'object') {
        options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
        return null;
    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== 'silent')
            throw doc.errors[0];
        else
            doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === 'function' || Array.isArray(replacer)) {
        _replacer = replacer;
    }
    else if (options === undefined && replacer) {
        options = replacer;
    }
    if (typeof options === 'string')
        options = options.length;
    if (typeof options === 'number') {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
            return undefined;
    }
    return new Document.Document(value, _replacer, options).toString(options);
}

exports.parse = parse;
exports.parseAllDocuments = parseAllDocuments;
exports.parseDocument = parseDocument;
exports.stringify = stringify;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/Schema.js":
/*!*************************************************!*\
  !*** ./node_modules/yaml/dist/schema/Schema.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var map = __webpack_require__(/*! ./common/map.js */ "./node_modules/yaml/dist/schema/common/map.js");
var seq = __webpack_require__(/*! ./common/seq.js */ "./node_modules/yaml/dist/schema/common/seq.js");
var string = __webpack_require__(/*! ./common/string.js */ "./node_modules/yaml/dist/schema/common/string.js");
var tags = __webpack_require__(/*! ./tags.js */ "./node_modules/yaml/dist/schema/tags.js");

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat)
            ? tags.getTags(compat, 'compat')
            : compat
                ? tags.getTags(null, compat)
                : null;
        this.merge = !!merge;
        this.name = (typeof schema === 'string' && schema) || 'core';
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        // Used by createMap()
        this.sortMapEntries =
            typeof sortMapEntries === 'function'
                ? sortMapEntries
                : sortMapEntries === true
                    ? sortMapEntriesByKey
                    : null;
    }
    clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}

exports.Schema = Schema;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/common/map.js":
/*!*****************************************************!*\
  !*** ./node_modules/yaml/dist/schema/common/map.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var YAMLMap = __webpack_require__(/*! ../../nodes/YAMLMap.js */ "./node_modules/yaml/dist/nodes/YAMLMap.js");

const map = {
    collection: 'map',
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve(map, onError) {
        if (!identity.isMap(map))
            onError('Expected a mapping for this tag');
        return map;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
};

exports.map = map;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/common/null.js":
/*!******************************************************!*\
  !*** ./node_modules/yaml/dist/schema/common/null.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(/*! ../../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");

const nullTag = {
    identify: value => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)
        ? source
        : ctx.options.nullStr
};

exports.nullTag = nullTag;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/common/seq.js":
/*!*****************************************************!*\
  !*** ./node_modules/yaml/dist/schema/common/seq.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var YAMLSeq = __webpack_require__(/*! ../../nodes/YAMLSeq.js */ "./node_modules/yaml/dist/nodes/YAMLSeq.js");

const seq = {
    collection: 'seq',
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve(seq, onError) {
        if (!identity.isSeq(seq))
            onError('Expected a sequence for this tag');
        return seq;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
};

exports.seq = seq;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/common/string.js":
/*!********************************************************!*\
  !*** ./node_modules/yaml/dist/schema/common/string.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyString = __webpack_require__(/*! ../../stringify/stringifyString.js */ "./node_modules/yaml/dist/stringify/stringifyString.js");

const string = {
    identify: value => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: str => str,
    stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
};

exports.string = string;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/core/bool.js":
/*!****************************************************!*\
  !*** ./node_modules/yaml/dist/schema/core/bool.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(/*! ../../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");

const boolTag = {
    identify: value => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),
    stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
            const sv = source[0] === 't' || source[0] === 'T';
            if (value === sv)
                return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};

exports.boolTag = boolTag;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/core/float.js":
/*!*****************************************************!*\
  !*** ./node_modules/yaml/dist/schema/core/float.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(/*! ../../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var stringifyNumber = __webpack_require__(/*! ../../stringify/stringifyNumber.js */ "./node_modules/yaml/dist/stringify/stringifyNumber.js");

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
    resolve: str => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0')
            node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/core/int.js":
/*!***************************************************!*\
  !*** ./node_modules/yaml/dist/schema/core/int.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(/*! ../../stringify/stringifyNumber.js */ "./node_modules/yaml/dist/stringify/stringifyNumber.js");

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
const intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
}
const intOct = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: node => intStringify(node, 8, '0o')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/core/schema.js":
/*!******************************************************!*\
  !*** ./node_modules/yaml/dist/schema/core/schema.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(/*! ../common/map.js */ "./node_modules/yaml/dist/schema/common/map.js");
var _null = __webpack_require__(/*! ../common/null.js */ "./node_modules/yaml/dist/schema/common/null.js");
var seq = __webpack_require__(/*! ../common/seq.js */ "./node_modules/yaml/dist/schema/common/seq.js");
var string = __webpack_require__(/*! ../common/string.js */ "./node_modules/yaml/dist/schema/common/string.js");
var bool = __webpack_require__(/*! ./bool.js */ "./node_modules/yaml/dist/schema/core/bool.js");
var float = __webpack_require__(/*! ./float.js */ "./node_modules/yaml/dist/schema/core/float.js");
var int = __webpack_require__(/*! ./int.js */ "./node_modules/yaml/dist/schema/core/int.js");

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
];

exports.schema = schema;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/json/schema.js":
/*!******************************************************!*\
  !*** ./node_modules/yaml/dist/schema/json/schema.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(/*! ../../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var map = __webpack_require__(/*! ../common/map.js */ "./node_modules/yaml/dist/schema/common/map.js");
var seq = __webpack_require__(/*! ../common/seq.js */ "./node_modules/yaml/dist/schema/common/seq.js");

function intIdentify(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
    {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON
    },
    {
        identify: value => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    },
    {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true|false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON
    },
    {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    }
];
const jsonError = {
    default: true,
    tag: '',
    test: /^/,
    resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const schema = [map.map, seq.seq].concat(jsonScalars, jsonError);

exports.schema = schema;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/tags.js":
/*!***********************************************!*\
  !*** ./node_modules/yaml/dist/schema/tags.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(/*! ./common/map.js */ "./node_modules/yaml/dist/schema/common/map.js");
var _null = __webpack_require__(/*! ./common/null.js */ "./node_modules/yaml/dist/schema/common/null.js");
var seq = __webpack_require__(/*! ./common/seq.js */ "./node_modules/yaml/dist/schema/common/seq.js");
var string = __webpack_require__(/*! ./common/string.js */ "./node_modules/yaml/dist/schema/common/string.js");
var bool = __webpack_require__(/*! ./core/bool.js */ "./node_modules/yaml/dist/schema/core/bool.js");
var float = __webpack_require__(/*! ./core/float.js */ "./node_modules/yaml/dist/schema/core/float.js");
var int = __webpack_require__(/*! ./core/int.js */ "./node_modules/yaml/dist/schema/core/int.js");
var schema = __webpack_require__(/*! ./core/schema.js */ "./node_modules/yaml/dist/schema/core/schema.js");
var schema$1 = __webpack_require__(/*! ./json/schema.js */ "./node_modules/yaml/dist/schema/json/schema.js");
var binary = __webpack_require__(/*! ./yaml-1.1/binary.js */ "./node_modules/yaml/dist/schema/yaml-1.1/binary.js");
var omap = __webpack_require__(/*! ./yaml-1.1/omap.js */ "./node_modules/yaml/dist/schema/yaml-1.1/omap.js");
var pairs = __webpack_require__(/*! ./yaml-1.1/pairs.js */ "./node_modules/yaml/dist/schema/yaml-1.1/pairs.js");
var schema$2 = __webpack_require__(/*! ./yaml-1.1/schema.js */ "./node_modules/yaml/dist/schema/yaml-1.1/schema.js");
var set = __webpack_require__(/*! ./yaml-1.1/set.js */ "./node_modules/yaml/dist/schema/yaml-1.1/set.js");
var timestamp = __webpack_require__(/*! ./yaml-1.1/timestamp.js */ "./node_modules/yaml/dist/schema/yaml-1.1/timestamp.js");

const schemas = new Map([
    ['core', schema.schema],
    ['failsafe', [map.map, seq.seq, string.string]],
    ['json', schema$1.schema],
    ['yaml11', schema$2.schema],
    ['yaml-1.1', schema$2.schema]
]);
const tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
};
const coreKnownTags = {
    'tag:yaml.org,2002:binary': binary.binary,
    'tag:yaml.org,2002:omap': omap.omap,
    'tag:yaml.org,2002:pairs': pairs.pairs,
    'tag:yaml.org,2002:set': set.set,
    'tag:yaml.org,2002:timestamp': timestamp.timestamp
};
function getTags(customTags, schemaName) {
    let tags = schemas.get(schemaName);
    if (!tags) {
        if (Array.isArray(customTags))
            tags = [];
        else {
            const keys = Array.from(schemas.keys())
                .filter(key => key !== 'yaml11')
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) {
        for (const tag of customTags)
            tags = tags.concat(tag);
    }
    else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
    }
    return tags.map(tag => {
        if (typeof tag !== 'string')
            return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
            return tagObj;
        const keys = Object.keys(tagsByName)
            .map(key => JSON.stringify(key))
            .join(', ');
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    });
}

exports.coreKnownTags = coreKnownTags;
exports.getTags = getTags;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/yaml-1.1/binary.js":
/*!**********************************************************!*\
  !*** ./node_modules/yaml/dist/schema/yaml-1.1/binary.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];


var Scalar = __webpack_require__(/*! ../../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var stringifyString = __webpack_require__(/*! ../../stringify/stringifyString.js */ "./node_modules/yaml/dist/stringify/stringifyString.js");

const binary = {
    identify: value => value instanceof Uint8Array,
    default: false,
    tag: 'tag:yaml.org,2002:binary',
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
        if (typeof Buffer === 'function') {
            return Buffer.from(src, 'base64');
        }
        else if (typeof atob === 'function') {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ''));
            const buffer = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
            return buffer;
        }
        else {
            onError('This environment does not support reading binary tags; either Buffer or atob is required');
            return src;
        }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof Buffer === 'function') {
            str =
                buf instanceof Buffer
                    ? buf.toString('base64')
                    : Buffer.from(buf.buffer).toString('base64');
        }
        else if (typeof btoa === 'function') {
            let s = '';
            for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
            str = btoa(s);
        }
        else {
            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        if (!type)
            type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
            }
            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
};

exports.binary = binary;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/yaml-1.1/bool.js":
/*!********************************************************!*\
  !*** ./node_modules/yaml/dist/schema/yaml-1.1/bool.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(/*! ../../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");

function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
        return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
    identify: value => value === true,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
};
const falseTag = {
    identify: value => value === false,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
};

exports.falseTag = falseTag;
exports.trueTag = trueTag;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/yaml-1.1/float.js":
/*!*********************************************************!*\
  !*** ./node_modules/yaml/dist/schema/yaml-1.1/float.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(/*! ../../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var stringifyNumber = __webpack_require__(/*! ../../stringify/stringifyNumber.js */ "./node_modules/yaml/dist/stringify/stringifyNumber.js");

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, '')),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, '');
            if (f[f.length - 1] === '0')
                node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/yaml-1.1/int.js":
/*!*******************************************************!*\
  !*** ./node_modules/yaml/dist/schema/yaml-1.1/int.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(/*! ../../stringify/stringifyNumber.js */ "./node_modules/yaml/dist/stringify/stringifyNumber.js");

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === '-' || sign === '+')
        offset += 1;
    str = str.substring(offset).replace(/_/g, '');
    if (intAsBigInt) {
        switch (radix) {
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
}
const intBin = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'BIN',
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, '0')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intBin = intBin;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/yaml-1.1/omap.js":
/*!********************************************************!*\
  !*** ./node_modules/yaml/dist/schema/yaml-1.1/omap.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var toJS = __webpack_require__(/*! ../../nodes/toJS.js */ "./node_modules/yaml/dist/nodes/toJS.js");
var YAMLMap = __webpack_require__(/*! ../../nodes/YAMLMap.js */ "./node_modules/yaml/dist/nodes/YAMLMap.js");
var YAMLSeq = __webpack_require__(/*! ../../nodes/YAMLSeq.js */ "./node_modules/yaml/dist/nodes/YAMLSeq.js");
var pairs = __webpack_require__(/*! ./pairs.js */ "./node_modules/yaml/dist/schema/yaml-1.1/pairs.js");

class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
        if (!ctx)
            return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const pair of this.items) {
            let key, value;
            if (identity.isPair(pair)) {
                key = toJS.toJS(pair.key, '', ctx);
                value = toJS.toJS(pair.value, key, ctx);
            }
            else {
                key = toJS.toJS(pair, '', ctx);
            }
            if (map.has(key))
                throw new Error('Ordered maps must not include duplicate keys');
            map.set(key, value);
        }
        return map;
    }
    static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs$1.items;
        return omap;
    }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
    collection: 'seq',
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
            if (identity.isScalar(key)) {
                if (seenKeys.includes(key.value)) {
                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                }
                else {
                    seenKeys.push(key.value);
                }
            }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
};

exports.YAMLOMap = YAMLOMap;
exports.omap = omap;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/yaml-1.1/pairs.js":
/*!*********************************************************!*\
  !*** ./node_modules/yaml/dist/schema/yaml-1.1/pairs.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Pair = __webpack_require__(/*! ../../nodes/Pair.js */ "./node_modules/yaml/dist/nodes/Pair.js");
var Scalar = __webpack_require__(/*! ../../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var YAMLSeq = __webpack_require__(/*! ../../nodes/YAMLSeq.js */ "./node_modules/yaml/dist/nodes/YAMLSeq.js");

function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (identity.isPair(item))
                continue;
            else if (identity.isMap(item)) {
                if (item.items.length > 1)
                    onError('Each pair must have its own sequence indicator');
                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
                if (item.commentBefore)
                    pair.key.commentBefore = pair.key.commentBefore
                        ? `${item.commentBefore}\n${pair.key.commentBefore}`
                        : item.commentBefore;
                if (item.comment) {
                    const cn = pair.value ?? pair.key;
                    cn.comment = cn.comment
                        ? `${item.comment}\n${cn.comment}`
                        : item.comment;
                }
                item = pair;
            }
            seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
    }
    else
        onError('Expected a sequence for this tag');
    return seq;
}
function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new YAMLSeq.YAMLSeq(schema);
    pairs.tag = 'tag:yaml.org,2002:pairs';
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
            if (typeof replacer === 'function')
                it = replacer.call(iterable, String(i++), it);
            let key, value;
            if (Array.isArray(it)) {
                if (it.length === 2) {
                    key = it[0];
                    value = it[1];
                }
                else
                    throw new TypeError(`Expected [key, value] tuple: ${it}`);
            }
            else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                    key = keys[0];
                    value = it[key];
                }
                else {
                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
                }
            }
            else {
                key = it;
            }
            pairs.items.push(Pair.createPair(key, value, ctx));
        }
    return pairs;
}
const pairs = {
    collection: 'seq',
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: resolvePairs,
    createNode: createPairs
};

exports.createPairs = createPairs;
exports.pairs = pairs;
exports.resolvePairs = resolvePairs;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/yaml-1.1/schema.js":
/*!**********************************************************!*\
  !*** ./node_modules/yaml/dist/schema/yaml-1.1/schema.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(/*! ../common/map.js */ "./node_modules/yaml/dist/schema/common/map.js");
var _null = __webpack_require__(/*! ../common/null.js */ "./node_modules/yaml/dist/schema/common/null.js");
var seq = __webpack_require__(/*! ../common/seq.js */ "./node_modules/yaml/dist/schema/common/seq.js");
var string = __webpack_require__(/*! ../common/string.js */ "./node_modules/yaml/dist/schema/common/string.js");
var binary = __webpack_require__(/*! ./binary.js */ "./node_modules/yaml/dist/schema/yaml-1.1/binary.js");
var bool = __webpack_require__(/*! ./bool.js */ "./node_modules/yaml/dist/schema/yaml-1.1/bool.js");
var float = __webpack_require__(/*! ./float.js */ "./node_modules/yaml/dist/schema/yaml-1.1/float.js");
var int = __webpack_require__(/*! ./int.js */ "./node_modules/yaml/dist/schema/yaml-1.1/int.js");
var omap = __webpack_require__(/*! ./omap.js */ "./node_modules/yaml/dist/schema/yaml-1.1/omap.js");
var pairs = __webpack_require__(/*! ./pairs.js */ "./node_modules/yaml/dist/schema/yaml-1.1/pairs.js");
var set = __webpack_require__(/*! ./set.js */ "./node_modules/yaml/dist/schema/yaml-1.1/set.js");
var timestamp = __webpack_require__(/*! ./timestamp.js */ "./node_modules/yaml/dist/schema/yaml-1.1/timestamp.js");

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
];

exports.schema = schema;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/yaml-1.1/set.js":
/*!*******************************************************!*\
  !*** ./node_modules/yaml/dist/schema/yaml-1.1/set.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Pair = __webpack_require__(/*! ../../nodes/Pair.js */ "./node_modules/yaml/dist/nodes/Pair.js");
var YAMLMap = __webpack_require__(/*! ../../nodes/YAMLMap.js */ "./node_modules/yaml/dist/nodes/YAMLMap.js");

class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
    }
    add(key) {
        let pair;
        if (identity.isPair(key))
            pair = key;
        else if (key &&
            typeof key === 'object' &&
            'key' in key &&
            'value' in key &&
            key.value === null)
            pair = new Pair.Pair(key.key, null);
        else
            pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
            this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair)
            ? identity.isScalar(pair.key)
                ? pair.key.value
                : pair.key
            : pair;
    }
    set(key, value) {
        if (typeof value !== 'boolean')
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
        }
        else if (!prev && value) {
            this.items.push(new Pair.Pair(key));
        }
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
            throw new Error('Set items must all have null values');
    }
    static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
                if (typeof replacer === 'function')
                    value = replacer.call(iterable, value, value);
                set.items.push(Pair.createPair(value, null, ctx));
            }
        return set;
    }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
    collection: 'map',
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
        if (identity.isMap(map)) {
            if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
            else
                onError('Set items must all have null values');
        }
        else
            onError('Expected a mapping for this tag');
        return map;
    }
};

exports.YAMLSet = YAMLSet;
exports.set = set;


/***/ }),

/***/ "./node_modules/yaml/dist/schema/yaml-1.1/timestamp.js":
/*!*************************************************************!*\
  !*** ./node_modules/yaml/dist/schema/yaml-1.1/timestamp.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(/*! ../../stringify/stringifyNumber.js */ "./node_modules/yaml/dist/stringify/stringifyNumber.js");

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
    return (sign === '-' ? num(-1) * res : res);
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === 'bigint')
        num = n => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
    let sign = '';
    if (value < 0) {
        sign = '-';
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60]; // seconds, including ms
    if (value < 60) {
        parts.unshift(0); // at least one : is required
    }
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return (sign +
        parts
            .map(n => String(n).padStart(2, '0'))
            .join(':')
            .replace(/000000\d*$/, '') // % 60 may introduce error
    );
}
const intTime = {
    identify: value => typeof value === 'bigint' || Number.isInteger(value),
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
};
const floatTime = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
};
const timestamp = {
    identify: value => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
    resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
            let d = parseSexagesimal(tz, false);
            if (Math.abs(d) < 30)
                d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};

exports.floatTime = floatTime;
exports.intTime = intTime;
exports.timestamp = timestamp;


/***/ }),

/***/ "./node_modules/yaml/dist/stringify/foldFlowLines.js":
/*!***********************************************************!*\
  !*** ./node_modules/yaml/dist/stringify/foldFlowLines.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
        return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
        return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
            folds.push(0);
        else
            end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1)
            end = i + endStep;
    }
    for (let ch; (ch = text[(i += 1)]);) {
        if (mode === FOLD_QUOTED && ch === '\\') {
            escStart = i;
            switch (text[i + 1]) {
                case 'x':
                    i += 3;
                    break;
                case 'u':
                    i += 5;
                    break;
                case 'U':
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === '\n') {
            if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i);
            end = i + endStep;
            split = undefined;
        }
        else {
            if (ch === ' ' &&
                prev &&
                prev !== ' ' &&
                prev !== '\n' &&
                prev !== '\t') {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== ' ' && next !== '\n' && next !== '\t')
                    split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                }
                else if (mode === FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while (prev === ' ' || prev === '\t') {
                        prev = ch;
                        ch = text[(i += 1)];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j])
                        return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                }
                else {
                    overflow = true;
                }
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow)
        onOverflow();
    if (folds.length === 0)
        return text;
    if (onFold)
        onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0)
            res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i) {
    let ch = text[i + 1];
    while (ch === ' ' || ch === '\t') {
        do {
            ch = text[(i += 1)];
        } while (ch && ch !== '\n');
        ch = text[i + 1];
    }
    return i;
}

exports.FOLD_BLOCK = FOLD_BLOCK;
exports.FOLD_FLOW = FOLD_FLOW;
exports.FOLD_QUOTED = FOLD_QUOTED;
exports.foldFlowLines = foldFlowLines;


/***/ }),

/***/ "./node_modules/yaml/dist/stringify/stringify.js":
/*!*******************************************************!*\
  !*** ./node_modules/yaml/dist/stringify/stringify.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var anchors = __webpack_require__(/*! ../doc/anchors.js */ "./node_modules/yaml/dist/doc/anchors.js");
var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var stringifyComment = __webpack_require__(/*! ./stringifyComment.js */ "./node_modules/yaml/dist/stringify/stringifyComment.js");
var stringifyString = __webpack_require__(/*! ./stringifyString.js */ "./node_modules/yaml/dist/stringify/stringifyString.js");

function createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: null,
        trueStr: 'true',
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
        case 'block':
            inFlow = false;
            break;
        case 'flow':
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow,
        options: opt
    };
}
function getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0)
            return match.find(t => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
        obj = item.value;
        const match = tags.filter(t => t.identify?.(obj));
        tagObj =
            match.find(t => t.format === item.format) ?? match.find(t => !t.format);
    }
    else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
        return '';
    const props = [];
    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag)
        props.push(doc.directives.tagString(tag));
    return props.join(' ');
}
function stringify(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
        if (ctx.doc.directives)
            return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
            throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        }
        else {
            if (ctx.resolvedAliases)
                ctx.resolvedAliases.add(item);
            else
                ctx.resolvedAliases = new Set([item]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = identity.isNode(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
    if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : identity.isScalar(node)
            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return identity.isScalar(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
}

exports.createStringifyContext = createStringifyContext;
exports.stringify = stringify;


/***/ }),

/***/ "./node_modules/yaml/dist/stringify/stringifyCollection.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yaml/dist/stringify/stringifyCollection.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Collection = __webpack_require__(/*! ../nodes/Collection.js */ "./node_modules/yaml/dist/nodes/Collection.js");
var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var stringify = __webpack_require__(/*! ./stringify.js */ "./node_modules/yaml/dist/stringify/stringify.js");
var stringifyComment = __webpack_require__(/*! ./stringifyComment.js */ "./node_modules/yaml/dist/stringify/stringifyComment.js");

function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
            if (!chompKeep && item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment)
                comment = item.comment;
        }
        else if (identity.isPair(item)) {
            const ik = identity.isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment)
            chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
            const line = lines[i];
            str += line ? `\n${indent}${line}` : '\n';
        }
    }
    if (comment) {
        str += '\n' + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
            if (item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment)
                comment = item.comment;
        }
        else if (identity.isPair(item)) {
            const ik = identity.isNode(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment)
                    reqNewline = true;
            }
            const iv = identity.isNode(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment)
                    comment = iv.comment;
                if (iv.commentBefore)
                    reqNewline = true;
            }
            else if (item.value == null && ik?.comment) {
                comment = ik.comment;
            }
        }
        if (comment)
            reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => (comment = null));
        if (i < items.length - 1)
            str += ',';
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes('\n')))
            reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    let str;
    const { start, end } = flowChars;
    if (lines.length === 0) {
        str = start + end;
    }
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
            reqNewline = len > Collection.Collection.maxFlowStringSingleLineLength;
        }
        if (reqNewline) {
            str = start;
            for (const line of lines)
                str += line ? `\n${indentStep}${indent}${line}` : '\n';
            str += `\n${indent}${end}`;
        }
        else {
            str = `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;
        }
    }
    if (comment) {
        str += stringifyComment.lineComment(str, indent, commentString(comment));
        if (onComment)
            onComment();
    }
    return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
        comment = comment.replace(/^\n+/, '');
    if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}

exports.stringifyCollection = stringifyCollection;


/***/ }),

/***/ "./node_modules/yaml/dist/stringify/stringifyComment.js":
/*!**************************************************************!*\
  !*** ./node_modules/yaml/dist/stringify/stringifyComment.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');
function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
        return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith('\n')
    ? indentComment(comment, indent)
    : comment.includes('\n')
        ? '\n' + indentComment(comment, indent)
        : (str.endsWith(' ') ? '' : ' ') + comment;

exports.indentComment = indentComment;
exports.lineComment = lineComment;
exports.stringifyComment = stringifyComment;


/***/ }),

/***/ "./node_modules/yaml/dist/stringify/stringifyDocument.js":
/*!***************************************************************!*\
  !*** ./node_modules/yaml/dist/stringify/stringifyDocument.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var stringify = __webpack_require__(/*! ./stringify.js */ "./node_modules/yaml/dist/stringify/stringify.js");
var stringifyComment = __webpack_require__(/*! ./stringifyComment.js */ "./node_modules/yaml/dist/stringify/stringifyComment.js");

function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        }
        else if (doc.directives.docStart)
            hasDirectives = true;
    }
    if (hasDirectives)
        lines.push('---');
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1)
            lines.unshift('');
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ''));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if (identity.isNode(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives)
                lines.push('');
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment)
            body += stringifyComment.lineComment(body, '', commentString(contentComment));
        if ((body[0] === '|' || body[0] === '>') &&
            lines[lines.length - 1] === '---') {
            // Top-level block scalars with a preceding doc marker ought to use the
            // same line for their header.
            lines[lines.length - 1] = `--- ${body}`;
        }
        else
            lines.push(body);
    }
    else {
        lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes('\n')) {
                lines.push('...');
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            else {
                lines.push(`... ${cs}`);
            }
        }
        else {
            lines.push('...');
        }
    }
    else {
        let dc = doc.comment;
        if (dc && chompKeep)
            dc = dc.replace(/^\n+/, '');
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                lines.push('');
            lines.push(stringifyComment.indentComment(commentString(dc), ''));
        }
    }
    return lines.join('\n') + '\n';
}

exports.stringifyDocument = stringifyDocument;


/***/ }),

/***/ "./node_modules/yaml/dist/stringify/stringifyNumber.js":
/*!*************************************************************!*\
  !*** ./node_modules/yaml/dist/stringify/stringifyNumber.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint')
        return String(value);
    const num = typeof value === 'number' ? value : Number(value);
    if (!isFinite(num))
        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
    let n = JSON.stringify(value);
    if (!format &&
        minFractionDigits &&
        (!tag || tag === 'tag:yaml.org,2002:float') &&
        /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
            i = n.length;
            n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
            n += '0';
    }
    return n;
}

exports.stringifyNumber = stringifyNumber;


/***/ }),

/***/ "./node_modules/yaml/dist/stringify/stringifyPair.js":
/*!***********************************************************!*\
  !*** ./node_modules/yaml/dist/stringify/stringifyPair.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ../nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");
var Scalar = __webpack_require__(/*! ../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var stringify = __webpack_require__(/*! ./stringify.js */ "./node_modules/yaml/dist/stringify/stringify.js");
var stringifyComment = __webpack_require__(/*! ./stringifyComment.js */ "./node_modules/yaml/dist/stringify/stringifyComment.js");

function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = (identity.isNode(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (identity.isCollection(key)) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            identity.isCollection(key) ||
            (identity.isScalar(key)
                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return str === '' ? '?' : explicitKey ? `? ${str}` : str;
        }
    }
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        }
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    }
    if (keyCommentDone)
        keyComment = null;
    if (explicitKey) {
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    }
    else {
        str = `${str}:`;
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    }
    else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === 'object')
            value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        identity.isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (keyComment || vsb || vcb) {
        ws = vsb ? '\n' : '';
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === '' && !ctx.inFlow) {
            if (ws === '\n')
                ws = '\n\n';
        }
        else {
            ws += `\n${ctx.indent}`;
        }
    }
    else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf('\n');
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === '&' || vs0 === '!')) {
                let sp0 = valueStr.indexOf(' ');
                if (vs0 === '&' &&
                    sp0 !== -1 &&
                    sp0 < nl0 &&
                    valueStr[sp0 + 1] === '!') {
                    sp0 = valueStr.indexOf(' ', sp0 + 1);
                }
                if (sp0 === -1 || nl0 < sp0)
                    hasPropsLine = true;
            }
            if (!hasPropsLine)
                ws = `\n${ctx.indent}`;
        }
    }
    else if (valueStr === '' || valueStr[0] === '\n') {
        ws = '';
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
    }
    else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    }
    else if (chompKeep && onChompKeep) {
        onChompKeep();
    }
    return str;
}

exports.stringifyPair = stringifyPair;


/***/ }),

/***/ "./node_modules/yaml/dist/stringify/stringifyString.js":
/*!*************************************************************!*\
  !*** ./node_modules/yaml/dist/stringify/stringifyString.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(/*! ../nodes/Scalar.js */ "./node_modules/yaml/dist/nodes/Scalar.js");
var foldFlowLines = __webpack_require__(/*! ./foldFlowLines.js */ "./node_modules/yaml/dist/stringify/foldFlowLines.js");

const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let blockEndNewlines;
try {
    blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
}
catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? '2' : '1'; // root is at -1
    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;
    if (comment) {
        header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
        if (onComment)
            onComment();
    }
    if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}\n${indent}${start}${value}${end}`;
    }
    value = value
        .replace(/\n+/g, '\n$&')
        .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
        .replace(/\n+/g, `$&${indent}`);
    const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, true));
    return `${header}\n${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if ((implicitKey && value.includes('\n')) ||
        (inFlow && /[[\]{},]/.test(value))) {
        return quotedString(value, ctx);
    }
    if (!value ||
        /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        // not allowed:
        // - empty string, '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes('\n')
            ? quotedString(value, ctx)
            : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey &&
        !inFlow &&
        type !== Scalar.Scalar.PLAIN &&
        value.includes('\n')) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
        if (indent === '') {
            ctx.forceBlockIndent = true;
            return blockString(item, ctx, onComment, onChompKeep);
        }
        else if (implicitKey && indent === indentStep) {
            return quotedString(value, ctx);
        }
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
            return quotedString(value, ctx);
    }
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === 'string'
        ? item
        : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
            type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
        switch (_type) {
            case Scalar.Scalar.BLOCK_FOLDED:
            case Scalar.Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow
                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                    : blockString(ss, ctx, onComment, onChompKeep);
            case Scalar.Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
            case Scalar.Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
            case Scalar.Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

exports.stringifyString = stringifyString;


/***/ }),

/***/ "./node_modules/yaml/dist/visit.js":
/*!*****************************************!*\
  !*** ./node_modules/yaml/dist/visit.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(/*! ./nodes/identity.js */ "./node_modules/yaml/dist/nodes/identity.js");

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (identity.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = visit_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (identity.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = visit_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = visit_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visitAsync.BREAK = BREAK;
/** Do not visit the children of the current node */
visitAsync.SKIP = SKIP;
/** Remove the current node */
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (identity.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = await visitAsync_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (identity.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = await visitAsync_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = await visitAsync_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
function initVisitor(visitor) {
    if (typeof visitor === 'object' &&
        (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor);
    }
    return visitor;
}
function callVisitor(key, node, visitor, path) {
    if (typeof visitor === 'function')
        return visitor(key, node, path);
    if (identity.isMap(node))
        return visitor.Map?.(key, node, path);
    if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path);
    if (identity.isPair(node))
        return visitor.Pair?.(key, node, path);
    if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path);
    if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path);
    return undefined;
}
function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) {
        parent.items[key] = node;
    }
    else if (identity.isPair(parent)) {
        if (key === 'key')
            parent.key = node;
        else
            parent.value = node;
    }
    else if (identity.isDocument(parent)) {
        parent.contents = node;
    }
    else {
        const pt = identity.isAlias(parent) ? 'alias' : 'scalar';
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}

exports.visit = visit;
exports.visitAsync = visitAsync;


/***/ }),

/***/ "./node_modules/@octokit/endpoint/node_modules/is-plain-object/dist/is-plain-object.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@octokit/endpoint/node_modules/is-plain-object/dist/is-plain-object.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject)
/* harmony export */ });
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}




/***/ }),

/***/ "./node_modules/@octokit/request/node_modules/is-plain-object/dist/is-plain-object.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@octokit/request/node_modules/is-plain-object/dist/is-plain-object.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject)
/* harmony export */ });
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}




/***/ }),

/***/ "./node_modules/node-fetch/lib/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/node-fetch/lib/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchError: () => (/* binding */ FetchError),
/* harmony export */   Headers: () => (/* binding */ Headers),
/* harmony export */   Request: () => (/* binding */ Request),
/* harmony export */   Response: () => (/* binding */ Response),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ "http");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ "url");
/* harmony import */ var whatwg_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! whatwg-url */ "./node_modules/whatwg-url/lib/public-api.js");
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! https */ "https");
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zlib */ "zlib");
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "buffer")["Buffer"];







// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = stream__WEBPACK_IMPORTED_MODULE_0__.Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];
		let size = 0;

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				size += buffer.length;
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = require('encoding').convert;
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof stream__WEBPACK_IMPORTED_MODULE_0__)) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
		if (!res) {
			res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
			if (res) {
				res.pop(); // drop last quote
			}
		}

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__ && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = http__WEBPACK_IMPORTED_MODULE_1__.STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
}

Body.mixIn(Response.prototype);

Object.defineProperties(Response.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');
const URL = url__WEBPACK_IMPORTED_MODULE_2__.URL || whatwg_url__WEBPACK_IMPORTED_MODULE_3__.URL;

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = url__WEBPACK_IMPORTED_MODULE_2__.parse;
const format_url = url__WEBPACK_IMPORTED_MODULE_2__.format;

/**
 * Wrapper around `new URL` to handle arbitrary URLs
 *
 * @param  {string} urlStr
 * @return {void}
 */
function parseURL(urlStr) {
	/*
 	Check whether the URL is absolute or not
 		Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
 	Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
 */
	if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
		urlStr = new URL(urlStr).toString();
	}

	// Fallback to old implementation for arbitrary URLs
	return parse_url(urlStr);
}

const streamDestructionSupported = "destroy" in stream__WEBPACK_IMPORTED_MODULE_0__.Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parseURL(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parseURL(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parseURL(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
}

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	if (!headers.has('Connection') && !agent) {
		headers.set('Connection', 'close');
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

const URL$1 = url__WEBPACK_IMPORTED_MODULE_2__.URL || whatwg_url__WEBPACK_IMPORTED_MODULE_3__.URL;

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;

const isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
	const orig = new URL$1(original).hostname;
	const dest = new URL$1(destination).hostname;

	return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);
};

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch(url, opts) {

	// allow custom promise
	if (!fetch.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch.Promise;

	// wrap http.request into fetch
	return new fetch.Promise(function (resolve, reject) {
		// build request object
		const request = new Request(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? https__WEBPACK_IMPORTED_MODULE_4__ : http__WEBPACK_IMPORTED_MODULE_1__).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable) {
				request.body.destroy(error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
			finalize();
		});

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				let locationURL = null;
				try {
					locationURL = location === null ? null : new URL$1(location, request.url).toString();
				} catch (err) {
					// error here can only be invalid URL in Location: header
					// do not throw when options.redirect == manual
					// let the user extract the errorneous redirect URL
					if (request.redirect !== 'manual') {
						reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
						finalize();
						return;
					}
				}

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout,
							size: request.size
						};

						if (!isDomainOrSubdomain(request.url, locationURL)) {
							for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {
								requestOpts.headers.delete(name);
							}
						}

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new Request(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: zlib__WEBPACK_IMPORTED_MODULE_5__.Z_SYNC_FLUSH,
				finishFlush: zlib__WEBPACK_IMPORTED_MODULE_5__.Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createGunzip(zlibOptions));
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createInflate());
					} else {
						body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createInflateRaw());
					}
					response = new Response(body, response_options);
					resolve(response);
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress === 'function') {
				body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress());
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch.Promise = global.Promise;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fetch);



/***/ }),

/***/ "./node_modules/@actions/expressions/dist/ast.js":
/*!*******************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/ast.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Binary: () => (/* binding */ Binary),
/* harmony export */   ContextAccess: () => (/* binding */ ContextAccess),
/* harmony export */   Expr: () => (/* binding */ Expr),
/* harmony export */   FunctionCall: () => (/* binding */ FunctionCall),
/* harmony export */   Grouping: () => (/* binding */ Grouping),
/* harmony export */   IndexAccess: () => (/* binding */ IndexAccess),
/* harmony export */   Literal: () => (/* binding */ Literal),
/* harmony export */   Logical: () => (/* binding */ Logical),
/* harmony export */   Star: () => (/* binding */ Star),
/* harmony export */   Unary: () => (/* binding */ Unary)
/* harmony export */ });
class Expr {
}
class Literal extends Expr {
    constructor(literal, token) {
        super();
        this.literal = literal;
        this.token = token;
    }
    accept(v) {
        return v.visitLiteral(this);
    }
}
class Unary extends Expr {
    constructor(operator, expr) {
        super();
        this.operator = operator;
        this.expr = expr;
    }
    accept(v) {
        return v.visitUnary(this);
    }
}
class FunctionCall extends Expr {
    constructor(functionName, args) {
        super();
        this.functionName = functionName;
        this.args = args;
    }
    accept(v) {
        return v.visitFunctionCall(this);
    }
}
class Binary extends Expr {
    constructor(left, operator, right) {
        super();
        this.left = left;
        this.operator = operator;
        this.right = right;
    }
    accept(v) {
        return v.visitBinary(this);
    }
}
class Logical extends Expr {
    constructor(operator, args) {
        super();
        this.operator = operator;
        this.args = args;
    }
    accept(v) {
        return v.visitLogical(this);
    }
}
class Grouping extends Expr {
    constructor(group) {
        super();
        this.group = group;
    }
    accept(v) {
        return v.visitGrouping(this);
    }
}
class ContextAccess extends Expr {
    constructor(name) {
        super();
        this.name = name;
    }
    accept(v) {
        return v.visitContextAccess(this);
    }
}
class IndexAccess extends Expr {
    constructor(expr, index) {
        super();
        this.expr = expr;
        this.index = index;
    }
    accept(v) {
        return v.visitIndexAccess(this);
    }
}
class Star extends Expr {
    accept() {
        throw new Error("Method not implemented.");
    }
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/completion.js":
/*!**************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/completion.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   complete: () => (/* binding */ complete),
/* harmony export */   trimTokenVector: () => (/* binding */ trimTokenVector)
/* harmony export */ });
/* harmony import */ var _data_dictionary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data/dictionary */ "./node_modules/@actions/expressions/dist/data/dictionary.js");
/* harmony import */ var _evaluator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./evaluator */ "./node_modules/@actions/expressions/dist/evaluator.js");
/* harmony import */ var _funcs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./funcs */ "./node_modules/@actions/expressions/dist/funcs.js");
/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lexer */ "./node_modules/@actions/expressions/dist/lexer.js");
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parser */ "./node_modules/@actions/expressions/dist/parser.js");





/**
 * Complete returns a list of completion items for the given expression.
 * The main functionality is auto-completing functions and context access:
 * We can only provide assistance if the input is in one of the following forms (with | denoting the cursor position):
 * - context.path.inp| or context.path['inp| -- auto-complete context access
 * - context.path.| or context.path['| -- auto-complete context access
 * - toJS| -- auto-complete function call or top-level
 * - | -- auto-complete function call or top-level context access
 *
 * @param input Input expression
 * @param context Context available for the expression
 * @param extensionFunctions List of functions available
 * @param functions Optional map of functions to use during evaluation
 * @returns Array of completion items
 */
function complete(input, context, extensionFunctions, functions) {
    // Lex
    const lexer = new _lexer__WEBPACK_IMPORTED_MODULE_3__.Lexer(input);
    const lexResult = lexer.lex();
    // Find interesting part of the tokenVector. For example, for an expression like `github.actor == env.actor.log|`, we are
    // only interested in the `env.actor.log` part for auto-completion
    const tokenInputVector = trimTokenVector(lexResult.tokens);
    // Start by skipping the EOF token
    let tokenIdx = tokenInputVector.length - 2;
    if (tokenIdx >= 0) {
        switch (tokenInputVector[tokenIdx].type) {
            // If there is a (partial) identifier under the cursor, ignore that
            case _lexer__WEBPACK_IMPORTED_MODULE_3__.TokenType.IDENTIFIER:
                tokenIdx--;
                break;
            case _lexer__WEBPACK_IMPORTED_MODULE_3__.TokenType.STRING:
                // TODO: Support string for `context.name['test|`
                return [];
        }
    }
    if (tokenIdx < 0) {
        // Vector only contains the EOF token. Suggest functions and root context access
        const result = contextKeys(context);
        // Merge with functions
        result.push(...functionItems(extensionFunctions));
        return result;
    }
    // Determine path that led to the last token
    // Use parser & evaluator to determine context to complete.
    const pathTokenVector = tokenInputVector.slice(0, tokenIdx);
    // Include the original EOF token to make the parser happy
    pathTokenVector.push(tokenInputVector[tokenInputVector.length - 1]);
    const p = new _parser__WEBPACK_IMPORTED_MODULE_4__.Parser(pathTokenVector, context.pairs().map(x => x.key), extensionFunctions);
    const expr = p.parse();
    const ev = new _evaluator__WEBPACK_IMPORTED_MODULE_1__.Evaluator(expr, context, functions);
    const result = ev.evaluate();
    return contextKeys(result);
}
function functionItems(extensionFunctions) {
    const result = [];
    for (const fdef of [...Object.values(_funcs__WEBPACK_IMPORTED_MODULE_2__.wellKnownFunctions), ...extensionFunctions]) {
        result.push({
            label: fdef.name,
            description: fdef.description,
            function: true
        });
    }
    // Sort functions
    result.sort((a, b) => a.label.localeCompare(b.label));
    return result;
}
function contextKeys(context) {
    if ((0,_data_dictionary__WEBPACK_IMPORTED_MODULE_0__.isDictionary)(context)) {
        return (context
            .pairs()
            .map(x => completionItemFromContext(x))
            // Sort contexts
            .sort((a, b) => a.label.localeCompare(b.label)));
    }
    return [];
}
function completionItemFromContext(pair) {
    const context = pair.key.toString();
    const parenIndex = context.indexOf("(");
    const isFunc = parenIndex >= 0 && context.indexOf(")") >= 0;
    return {
        label: isFunc ? context.substring(0, parenIndex) : context,
        description: pair.description,
        function: isFunc
    };
}
function trimTokenVector(tokenVector) {
    let tokenIdx = tokenVector.length;
    let openParen = 0;
    while (tokenIdx > 0) {
        const token = tokenVector[tokenIdx - 1];
        switch (token.type) {
            case _lexer__WEBPACK_IMPORTED_MODULE_3__.TokenType.LEFT_PAREN:
                if (openParen == 0) {
                    // Encountered an open parenthesis without a closing first, stop here
                    break;
                }
                openParen--;
                tokenIdx--;
                continue;
            case _lexer__WEBPACK_IMPORTED_MODULE_3__.TokenType.RIGHT_PAREN:
                openParen++;
                tokenIdx--;
                continue;
            case _lexer__WEBPACK_IMPORTED_MODULE_3__.TokenType.IDENTIFIER:
            case _lexer__WEBPACK_IMPORTED_MODULE_3__.TokenType.DOT:
            case _lexer__WEBPACK_IMPORTED_MODULE_3__.TokenType.EOF:
            case _lexer__WEBPACK_IMPORTED_MODULE_3__.TokenType.LEFT_BRACKET:
            case _lexer__WEBPACK_IMPORTED_MODULE_3__.TokenType.RIGHT_BRACKET:
            case _lexer__WEBPACK_IMPORTED_MODULE_3__.TokenType.STRING:
                tokenIdx--;
                continue;
        }
        break;
    }
    // Only keep the part of the token vector we're interested in
    return tokenVector.slice(tokenIdx);
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/completion/descriptionDictionary.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/completion/descriptionDictionary.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DescriptionDictionary: () => (/* binding */ DescriptionDictionary),
/* harmony export */   isDescriptionDictionary: () => (/* binding */ isDescriptionDictionary)
/* harmony export */ });
/* harmony import */ var _data_dictionary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/dictionary */ "./node_modules/@actions/expressions/dist/data/dictionary.js");
/* harmony import */ var _data_expressiondata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/expressiondata */ "./node_modules/@actions/expressions/dist/data/expressiondata.js");


function isDescriptionDictionary(x) {
    return x.kind === _data_expressiondata__WEBPACK_IMPORTED_MODULE_1__.Kind.Dictionary && x instanceof DescriptionDictionary;
}
class DescriptionDictionary extends _data_dictionary__WEBPACK_IMPORTED_MODULE_0__.Dictionary {
    constructor(...pairs) {
        super();
        this.descriptions = new Map();
        this.complete = true;
        for (const p of pairs) {
            this.add(p.key, p.value, p.description);
        }
    }
    add(key, value, description) {
        if (this.get(key) !== undefined) {
            // Key already added, ignore
            return;
        }
        super.add(key, value);
        if (description) {
            this.descriptions.set(key, description);
        }
    }
    pairs() {
        const pairs = super.pairs();
        return pairs.map(p => ({ ...p, description: this.descriptions.get(p.key) }));
    }
    getDescription(key) {
        return this.descriptions.get(key);
    }
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/data/array.js":
/*!**************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/data/array.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Array: () => (/* binding */ Array)
/* harmony export */ });
/* harmony import */ var _expressiondata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expressiondata */ "./node_modules/@actions/expressions/dist/data/expressiondata.js");

class Array {
    constructor(...data) {
        this.v = [];
        this.kind = _expressiondata__WEBPACK_IMPORTED_MODULE_0__.Kind.Array;
        this.primitive = false;
        for (const d of data) {
            this.add(d);
        }
    }
    coerceString() {
        return (0,_expressiondata__WEBPACK_IMPORTED_MODULE_0__.kindStr)(this.kind);
    }
    number() {
        return NaN;
    }
    add(value) {
        this.v.push(value);
    }
    get(index) {
        return this.v[index];
    }
    values() {
        return this.v;
    }
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/data/boolean.js":
/*!****************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/data/boolean.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BooleanData: () => (/* binding */ BooleanData)
/* harmony export */ });
/* harmony import */ var _expressiondata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expressiondata */ "./node_modules/@actions/expressions/dist/data/expressiondata.js");

class BooleanData {
    constructor(value) {
        this.value = value;
        this.kind = _expressiondata__WEBPACK_IMPORTED_MODULE_0__.Kind.Boolean;
        this.primitive = true;
    }
    coerceString() {
        if (this.value) {
            return "true";
        }
        return "false";
    }
    number() {
        if (this.value) {
            return 1;
        }
        return 0;
    }
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/data/dictionary.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/data/dictionary.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dictionary: () => (/* binding */ Dictionary),
/* harmony export */   isDictionary: () => (/* binding */ isDictionary)
/* harmony export */ });
/* harmony import */ var _expressiondata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expressiondata */ "./node_modules/@actions/expressions/dist/data/expressiondata.js");

class Dictionary {
    constructor(...pairs) {
        this.keys = [];
        this.v = [];
        this.indexMap = {};
        this.kind = _expressiondata__WEBPACK_IMPORTED_MODULE_0__.Kind.Dictionary;
        this.primitive = false;
        for (const p of pairs) {
            this.add(p.key, p.value);
        }
    }
    coerceString() {
        return (0,_expressiondata__WEBPACK_IMPORTED_MODULE_0__.kindStr)(this.kind);
    }
    number() {
        return NaN;
    }
    add(key, value) {
        if (key.toLowerCase() in this.indexMap) {
            return;
        }
        this.keys.push(key);
        this.v.push(value);
        this.indexMap[key.toLowerCase()] = this.v.length - 1;
    }
    get(key) {
        const index = this.indexMap[key.toLowerCase()];
        if (index === undefined) {
            return undefined;
        }
        return this.v[index];
    }
    values() {
        return this.v;
    }
    pairs() {
        const result = [];
        for (const key of this.keys) {
            result.push({ key, value: this.v[this.indexMap[key.toLowerCase()]] });
        }
        return result;
    }
}
function isDictionary(x) {
    return x.kind === _expressiondata__WEBPACK_IMPORTED_MODULE_0__.Kind.Dictionary;
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/data/expressiondata.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/data/expressiondata.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Kind: () => (/* binding */ Kind),
/* harmony export */   kindStr: () => (/* binding */ kindStr)
/* harmony export */ });
var Kind;
(function (Kind) {
    Kind[Kind["String"] = 0] = "String";
    Kind[Kind["Array"] = 1] = "Array";
    Kind[Kind["Dictionary"] = 2] = "Dictionary";
    Kind[Kind["Boolean"] = 3] = "Boolean";
    Kind[Kind["Number"] = 4] = "Number";
    Kind[Kind["CaseSensitiveDictionary"] = 5] = "CaseSensitiveDictionary";
    Kind[Kind["Null"] = 6] = "Null";
})(Kind || (Kind = {}));
function kindStr(k) {
    switch (k) {
        case Kind.Array:
            return "Array";
        case Kind.Boolean:
            return "Boolean";
        case Kind.Null:
            return "Null";
        case Kind.Number:
            return "Number";
        case Kind.Dictionary:
            return "Object";
        case Kind.String:
            return "String";
    }
    return "unknown";
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/data/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/data/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Array: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_0__.Array),
/* harmony export */   BooleanData: () => (/* reexport safe */ _boolean__WEBPACK_IMPORTED_MODULE_1__.BooleanData),
/* harmony export */   Dictionary: () => (/* reexport safe */ _dictionary__WEBPACK_IMPORTED_MODULE_2__.Dictionary),
/* harmony export */   Kind: () => (/* reexport safe */ _expressiondata__WEBPACK_IMPORTED_MODULE_3__.Kind),
/* harmony export */   Null: () => (/* reexport safe */ _null__WEBPACK_IMPORTED_MODULE_4__.Null),
/* harmony export */   NumberData: () => (/* reexport safe */ _number__WEBPACK_IMPORTED_MODULE_5__.NumberData),
/* harmony export */   StringData: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_8__.StringData),
/* harmony export */   replacer: () => (/* reexport safe */ _replacer__WEBPACK_IMPORTED_MODULE_6__.replacer),
/* harmony export */   reviver: () => (/* reexport safe */ _reviver__WEBPACK_IMPORTED_MODULE_7__.reviver)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/@actions/expressions/dist/data/array.js");
/* harmony import */ var _boolean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boolean */ "./node_modules/@actions/expressions/dist/data/boolean.js");
/* harmony import */ var _dictionary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dictionary */ "./node_modules/@actions/expressions/dist/data/dictionary.js");
/* harmony import */ var _expressiondata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./expressiondata */ "./node_modules/@actions/expressions/dist/data/expressiondata.js");
/* harmony import */ var _null__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./null */ "./node_modules/@actions/expressions/dist/data/null.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./number */ "./node_modules/@actions/expressions/dist/data/number.js");
/* harmony import */ var _replacer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./replacer */ "./node_modules/@actions/expressions/dist/data/replacer.js");
/* harmony import */ var _reviver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./reviver */ "./node_modules/@actions/expressions/dist/data/reviver.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./string */ "./node_modules/@actions/expressions/dist/data/string.js");











/***/ }),

/***/ "./node_modules/@actions/expressions/dist/data/null.js":
/*!*************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/data/null.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Null: () => (/* binding */ Null)
/* harmony export */ });
/* harmony import */ var _expressiondata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expressiondata */ "./node_modules/@actions/expressions/dist/data/expressiondata.js");

class Null {
    constructor() {
        this.kind = _expressiondata__WEBPACK_IMPORTED_MODULE_0__.Kind.Null;
        this.primitive = true;
    }
    coerceString() {
        return "";
    }
    number() {
        return 0;
    }
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/data/number.js":
/*!***************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/data/number.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NumberData: () => (/* binding */ NumberData)
/* harmony export */ });
/* harmony import */ var _expressiondata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expressiondata */ "./node_modules/@actions/expressions/dist/data/expressiondata.js");

class NumberData {
    constructor(value) {
        this.value = value;
        this.kind = _expressiondata__WEBPACK_IMPORTED_MODULE_0__.Kind.Number;
        this.primitive = true;
    }
    coerceString() {
        if (this.value === 0) {
            return "0";
        }
        // Workaround to limit the precision to at most 15 digits. Format the number to a string, then parse
        // it back to a number to remove trailing zeroes to prevent numbers to be converted to 1.200000000...
        return (+this.value.toFixed(15)).toString();
    }
    number() {
        return this.value;
    }
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/data/replacer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/data/replacer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   replacer: () => (/* binding */ replacer)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/@actions/expressions/dist/data/array.js");
/* harmony import */ var _boolean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boolean */ "./node_modules/@actions/expressions/dist/data/boolean.js");
/* harmony import */ var _dictionary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dictionary */ "./node_modules/@actions/expressions/dist/data/dictionary.js");
/* harmony import */ var _null__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./null */ "./node_modules/@actions/expressions/dist/data/null.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number */ "./node_modules/@actions/expressions/dist/data/number.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./string */ "./node_modules/@actions/expressions/dist/data/string.js");






/**
 * Replacer can be passed to JSON.stringify to convert an ExpressionData object into plain JSON
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#replacer
 */
function replacer(_key, value) {
    if (value instanceof _null__WEBPACK_IMPORTED_MODULE_3__.Null) {
        return null;
    }
    if (value instanceof _boolean__WEBPACK_IMPORTED_MODULE_1__.BooleanData) {
        return value.value;
    }
    if (value instanceof _number__WEBPACK_IMPORTED_MODULE_4__.NumberData) {
        return value.number();
    }
    if (value instanceof _string__WEBPACK_IMPORTED_MODULE_5__.StringData) {
        return value.coerceString();
    }
    if (value instanceof _array__WEBPACK_IMPORTED_MODULE_0__.Array) {
        return value.values();
    }
    if (value instanceof _dictionary__WEBPACK_IMPORTED_MODULE_2__.Dictionary) {
        const pairs = value.pairs();
        const r = {};
        for (const p of pairs) {
            r[p.key] = p.value;
        }
        return r;
    }
    return value;
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/data/reviver.js":
/*!****************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/data/reviver.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reviver: () => (/* binding */ reviver)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/@actions/expressions/dist/data/array.js");
/* harmony import */ var _boolean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boolean */ "./node_modules/@actions/expressions/dist/data/boolean.js");
/* harmony import */ var _dictionary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dictionary */ "./node_modules/@actions/expressions/dist/data/dictionary.js");
/* harmony import */ var _null__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./null */ "./node_modules/@actions/expressions/dist/data/null.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number */ "./node_modules/@actions/expressions/dist/data/number.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./string */ "./node_modules/@actions/expressions/dist/data/string.js");






/**
 * Reviver can be passed to `JSON.parse` to convert plain JSON into an `ExpressionData` object.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#reviver
 */
function reviver(_key, val) {
    if (val === null) {
        return new _null__WEBPACK_IMPORTED_MODULE_3__.Null();
    }
    if (typeof val === "string") {
        return new _string__WEBPACK_IMPORTED_MODULE_5__.StringData(val);
    }
    if (typeof val === "number") {
        return new _number__WEBPACK_IMPORTED_MODULE_4__.NumberData(val);
    }
    if (typeof val === "boolean") {
        return new _boolean__WEBPACK_IMPORTED_MODULE_1__.BooleanData(val);
    }
    if (Array.isArray(val)) {
        return new _array__WEBPACK_IMPORTED_MODULE_0__.Array(...val);
    }
    if (typeof val === "object") {
        return new _dictionary__WEBPACK_IMPORTED_MODULE_2__.Dictionary(...Object.keys(val).map(k => ({
            key: k,
            value: val[k]
        })));
    }
    // Pass through value
    return val;
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/data/string.js":
/*!***************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/data/string.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringData: () => (/* binding */ StringData)
/* harmony export */ });
/* harmony import */ var _expressiondata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expressiondata */ "./node_modules/@actions/expressions/dist/data/expressiondata.js");

class StringData {
    constructor(value) {
        this.value = value;
        this.kind = _expressiondata__WEBPACK_IMPORTED_MODULE_0__.Kind.String;
        this.primitive = true;
    }
    coerceString() {
        return this.value;
    }
    number() {
        return Number(this.value);
    }
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/errors.js":
/*!**********************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ErrorType: () => (/* binding */ ErrorType),
/* harmony export */   ExpressionError: () => (/* binding */ ExpressionError),
/* harmony export */   ExpressionEvaluationError: () => (/* binding */ ExpressionEvaluationError),
/* harmony export */   MAX_EXPRESSION_LENGTH: () => (/* binding */ MAX_EXPRESSION_LENGTH),
/* harmony export */   MAX_PARSER_DEPTH: () => (/* binding */ MAX_PARSER_DEPTH)
/* harmony export */ });
/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lexer */ "./node_modules/@actions/expressions/dist/lexer.js");

const MAX_PARSER_DEPTH = 50;
const MAX_EXPRESSION_LENGTH = 21000;
var ErrorType;
(function (ErrorType) {
    ErrorType[ErrorType["ErrorUnexpectedSymbol"] = 0] = "ErrorUnexpectedSymbol";
    ErrorType[ErrorType["ErrorUnrecognizedNamedValue"] = 1] = "ErrorUnrecognizedNamedValue";
    ErrorType[ErrorType["ErrorUnexpectedEndOfExpression"] = 2] = "ErrorUnexpectedEndOfExpression";
    ErrorType[ErrorType["ErrorExceededMaxDepth"] = 3] = "ErrorExceededMaxDepth";
    ErrorType[ErrorType["ErrorExceededMaxLength"] = 4] = "ErrorExceededMaxLength";
    ErrorType[ErrorType["ErrorTooFewParameters"] = 5] = "ErrorTooFewParameters";
    ErrorType[ErrorType["ErrorTooManyParameters"] = 6] = "ErrorTooManyParameters";
    ErrorType[ErrorType["ErrorUnrecognizedContext"] = 7] = "ErrorUnrecognizedContext";
    ErrorType[ErrorType["ErrorUnrecognizedFunction"] = 8] = "ErrorUnrecognizedFunction";
})(ErrorType || (ErrorType = {}));
class ExpressionError extends Error {
    constructor(typ, tok) {
        super(`${errorDescription(typ)}: '${(0,_lexer__WEBPACK_IMPORTED_MODULE_0__.tokenString)(tok)}'`);
        this.typ = typ;
        this.tok = tok;
        this.pos = this.tok.range.start;
    }
}
function errorDescription(typ) {
    switch (typ) {
        case ErrorType.ErrorUnexpectedEndOfExpression:
            return "Unexpected end of expression";
        case ErrorType.ErrorUnexpectedSymbol:
            return "Unexpected symbol";
        case ErrorType.ErrorUnrecognizedNamedValue:
            return "Unrecognized named-value";
        case ErrorType.ErrorExceededMaxDepth:
            return `Exceeded max expression depth ${MAX_PARSER_DEPTH}`;
        case ErrorType.ErrorExceededMaxLength:
            return `Exceeded max expression length ${MAX_EXPRESSION_LENGTH}`;
        case ErrorType.ErrorTooFewParameters:
            return "Too few parameters supplied";
        case ErrorType.ErrorTooManyParameters:
            return "Too many parameters supplied";
        case ErrorType.ErrorUnrecognizedContext:
            return "Unrecognized named-value";
        case ErrorType.ErrorUnrecognizedFunction:
            return "Unrecognized function";
        default: // Should never reach here.
            return "Unknown error";
    }
}
class ExpressionEvaluationError extends Error {
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/evaluator.js":
/*!*************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/evaluator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Evaluator: () => (/* binding */ Evaluator)
/* harmony export */ });
/* harmony import */ var _ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast */ "./node_modules/@actions/expressions/dist/ast.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data */ "./node_modules/@actions/expressions/dist/data/index.js");
/* harmony import */ var _filtered_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filtered_array */ "./node_modules/@actions/expressions/dist/filtered_array.js");
/* harmony import */ var _funcs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./funcs */ "./node_modules/@actions/expressions/dist/funcs.js");
/* harmony import */ var _idxHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./idxHelper */ "./node_modules/@actions/expressions/dist/idxHelper.js");
/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lexer */ "./node_modules/@actions/expressions/dist/lexer.js");
/* harmony import */ var _result__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./result */ "./node_modules/@actions/expressions/dist/result.js");







class Evaluator {
    /**
     * Creates a new evaluator
     * @param n Parsed expression to evaluate
     * @param context Context data to use
     * @param functions Optional map of function implementations. If given, these will be preferred over the built-in functions.
     */
    constructor(n, context, functions) {
        this.n = n;
        this.context = context;
        this.functions = functions;
    }
    evaluate() {
        return this.eval(this.n);
    }
    eval(n) {
        return n.accept(this);
    }
    visitLiteral(literal) {
        return literal.literal;
    }
    visitUnary(unary) {
        const r = this.eval(unary.expr);
        if (unary.operator.type === _lexer__WEBPACK_IMPORTED_MODULE_5__.TokenType.BANG) {
            return new _data__WEBPACK_IMPORTED_MODULE_1__.BooleanData((0,_result__WEBPACK_IMPORTED_MODULE_6__.falsy)(r));
        }
        throw new Error(`unknown unary operator: ${unary.operator.lexeme}`);
    }
    visitBinary(binary) {
        const left = this.eval(binary.left);
        const right = this.eval(binary.right);
        switch (binary.operator.type) {
            case _lexer__WEBPACK_IMPORTED_MODULE_5__.TokenType.EQUAL_EQUAL:
                return new _data__WEBPACK_IMPORTED_MODULE_1__.BooleanData((0,_result__WEBPACK_IMPORTED_MODULE_6__.equals)(left, right));
            case _lexer__WEBPACK_IMPORTED_MODULE_5__.TokenType.BANG_EQUAL:
                return new _data__WEBPACK_IMPORTED_MODULE_1__.BooleanData(!(0,_result__WEBPACK_IMPORTED_MODULE_6__.equals)(left, right));
            case _lexer__WEBPACK_IMPORTED_MODULE_5__.TokenType.GREATER:
                return new _data__WEBPACK_IMPORTED_MODULE_1__.BooleanData((0,_result__WEBPACK_IMPORTED_MODULE_6__.greaterThan)(left, right));
            case _lexer__WEBPACK_IMPORTED_MODULE_5__.TokenType.GREATER_EQUAL:
                return new _data__WEBPACK_IMPORTED_MODULE_1__.BooleanData((0,_result__WEBPACK_IMPORTED_MODULE_6__.equals)(left, right) || (0,_result__WEBPACK_IMPORTED_MODULE_6__.greaterThan)(left, right));
            case _lexer__WEBPACK_IMPORTED_MODULE_5__.TokenType.LESS:
                return new _data__WEBPACK_IMPORTED_MODULE_1__.BooleanData((0,_result__WEBPACK_IMPORTED_MODULE_6__.lessThan)(left, right));
            case _lexer__WEBPACK_IMPORTED_MODULE_5__.TokenType.LESS_EQUAL:
                return new _data__WEBPACK_IMPORTED_MODULE_1__.BooleanData((0,_result__WEBPACK_IMPORTED_MODULE_6__.equals)(left, right) || (0,_result__WEBPACK_IMPORTED_MODULE_6__.lessThan)(left, right));
        }
        throw new Error(`unknown binary operator: ${binary.operator.lexeme}`);
    }
    visitLogical(logical) {
        let result;
        for (const arg of logical.args) {
            result = this.eval(arg);
            // Break?
            if ((logical.operator.type === _lexer__WEBPACK_IMPORTED_MODULE_5__.TokenType.AND && (0,_result__WEBPACK_IMPORTED_MODULE_6__.falsy)(result)) ||
                (logical.operator.type === _lexer__WEBPACK_IMPORTED_MODULE_5__.TokenType.OR && (0,_result__WEBPACK_IMPORTED_MODULE_6__.truthy)(result))) {
                break;
            }
        }
        // result is always assigned before we return here
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return result;
    }
    visitGrouping(grouping) {
        return this.eval(grouping.group);
    }
    visitContextAccess(contextAccess) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const r = this.context.get(contextAccess.name.lexeme);
        return r;
    }
    visitIndexAccess(ia) {
        let idx;
        if (ia.index instanceof _ast__WEBPACK_IMPORTED_MODULE_0__.Star) {
            idx = new _idxHelper__WEBPACK_IMPORTED_MODULE_4__.idxHelper(true, undefined);
        }
        else {
            let idxResult;
            try {
                idxResult = this.eval(ia.index);
            }
            catch (e) {
                throw new Error(`could not evaluate index for index access: ${e.message}`, { cause: e });
            }
            idx = new _idxHelper__WEBPACK_IMPORTED_MODULE_4__.idxHelper(false, idxResult);
        }
        const objResult = this.eval(ia.expr);
        let result;
        switch (objResult.kind) {
            case _data__WEBPACK_IMPORTED_MODULE_1__.Kind.Array: {
                const tobjResult = objResult;
                if (tobjResult instanceof _filtered_array__WEBPACK_IMPORTED_MODULE_2__.FilteredArray) {
                    result = filteredArrayAccess(tobjResult, idx);
                }
                else {
                    result = arrayAccess(tobjResult, idx);
                }
                break;
            }
            case _data__WEBPACK_IMPORTED_MODULE_1__.Kind.Dictionary: {
                const tobjResult = objResult;
                result = objectAccess(tobjResult, idx);
                break;
            }
            default:
                if (idx.star) {
                    result = new _filtered_array__WEBPACK_IMPORTED_MODULE_2__.FilteredArray();
                }
                else {
                    result = new _data__WEBPACK_IMPORTED_MODULE_1__.Null();
                }
        }
        return result;
    }
    visitFunctionCall(functionCall) {
        // Evaluate arguments
        const args = functionCall.args.map(arg => this.eval(arg));
        // Get function definitions
        const functionName = functionCall.functionName.lexeme.toLowerCase();
        const f = this.functions?.get(functionName) || _funcs__WEBPACK_IMPORTED_MODULE_3__.wellKnownFunctions[functionName];
        return f.call(...args);
    }
}
function filteredArrayAccess(fa, idx) {
    const result = new _filtered_array__WEBPACK_IMPORTED_MODULE_2__.FilteredArray();
    for (const item of fa.values()) {
        // Check the type of the nested item
        switch (item.kind) {
            case _data__WEBPACK_IMPORTED_MODULE_1__.Kind.Dictionary: {
                const ti = item;
                if (idx.star) {
                    for (const v of ti.values()) {
                        result.add(v);
                    }
                }
                else if (idx.str !== undefined) {
                    const v = ti.get(idx.str);
                    if (v !== undefined) {
                        result.add(v);
                    }
                }
                break;
            }
            case _data__WEBPACK_IMPORTED_MODULE_1__.Kind.Array: {
                const ti = item;
                if (idx.star) {
                    for (const v of ti.values()) {
                        result.add(v);
                    }
                }
                else if (idx.int !== undefined && idx.int < ti.values().length) {
                    result.add(ti.get(idx.int));
                }
                break;
            }
        }
    }
    return result;
}
function arrayAccess(a, idx) {
    if (idx.star) {
        const fa = new _filtered_array__WEBPACK_IMPORTED_MODULE_2__.FilteredArray();
        for (const item of a.values()) {
            fa.add(item);
        }
        return fa;
    }
    if (idx.int !== undefined && idx.int < a.values().length) {
        return a.get(idx.int);
    }
    return new _data__WEBPACK_IMPORTED_MODULE_1__.Null();
}
function objectAccess(obj, idx) {
    if (idx.star) {
        const fa = new _filtered_array__WEBPACK_IMPORTED_MODULE_2__.FilteredArray(...obj.values());
        return fa;
    }
    if (idx.str !== undefined) {
        const r = obj.get(idx.str);
        if (r !== undefined) {
            return r;
        }
    }
    return new _data__WEBPACK_IMPORTED_MODULE_1__.Null();
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/filtered_array.js":
/*!******************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/filtered_array.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FilteredArray: () => (/* binding */ FilteredArray)
/* harmony export */ });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data */ "./node_modules/@actions/expressions/dist/data/index.js");

class FilteredArray extends _data__WEBPACK_IMPORTED_MODULE_0__.Array {
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/funcs.js":
/*!*********************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/funcs.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   validateFunction: () => (/* binding */ validateFunction),
/* harmony export */   wellKnownFunctions: () => (/* binding */ wellKnownFunctions)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ "./node_modules/@actions/expressions/dist/errors.js");
/* harmony import */ var _funcs_contains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./funcs/contains */ "./node_modules/@actions/expressions/dist/funcs/contains.js");
/* harmony import */ var _funcs_endswith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./funcs/endswith */ "./node_modules/@actions/expressions/dist/funcs/endswith.js");
/* harmony import */ var _funcs_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./funcs/format */ "./node_modules/@actions/expressions/dist/funcs/format.js");
/* harmony import */ var _funcs_fromjson__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./funcs/fromjson */ "./node_modules/@actions/expressions/dist/funcs/fromjson.js");
/* harmony import */ var _funcs_join__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./funcs/join */ "./node_modules/@actions/expressions/dist/funcs/join.js");
/* harmony import */ var _funcs_startswith__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./funcs/startswith */ "./node_modules/@actions/expressions/dist/funcs/startswith.js");
/* harmony import */ var _funcs_tojson__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./funcs/tojson */ "./node_modules/@actions/expressions/dist/funcs/tojson.js");








const wellKnownFunctions = {
    contains: _funcs_contains__WEBPACK_IMPORTED_MODULE_1__.contains,
    endswith: _funcs_endswith__WEBPACK_IMPORTED_MODULE_2__.endswith,
    format: _funcs_format__WEBPACK_IMPORTED_MODULE_3__.format,
    fromjson: _funcs_fromjson__WEBPACK_IMPORTED_MODULE_4__.fromjson,
    join: _funcs_join__WEBPACK_IMPORTED_MODULE_5__.join,
    startswith: _funcs_startswith__WEBPACK_IMPORTED_MODULE_6__.startswith,
    tojson: _funcs_tojson__WEBPACK_IMPORTED_MODULE_7__.tojson
};
// validateFunction returns the function definition for the given function name.
// If the function does not exist or an incorrect number of arguments is provided,
// an error is returned.
function validateFunction(context, identifier, argCount) {
    // Expression function names are case-insensitive.
    const name = identifier.lexeme.toLowerCase();
    let f;
    f = wellKnownFunctions[name];
    if (!f) {
        f = context.extensionFunctions.get(name);
        if (!f) {
            if (!context.allowUnknownKeywords) {
                throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ExpressionError(_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorType.ErrorUnrecognizedFunction, identifier);
            }
            // Skip argument validation for unknown functions
            return;
        }
    }
    if (argCount < f.minArgs) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ExpressionError(_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorType.ErrorTooFewParameters, identifier);
    }
    if (argCount > f.maxArgs) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.ExpressionError(_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorType.ErrorTooManyParameters, identifier);
    }
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/funcs/contains.js":
/*!******************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/funcs/contains.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   contains: () => (/* binding */ contains)
/* harmony export */ });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data */ "./node_modules/@actions/expressions/dist/data/index.js");
/* harmony import */ var _result__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../result */ "./node_modules/@actions/expressions/dist/result.js");


const contains = {
    name: "contains",
    description: "`contains( search, item )`\n\nReturns `true` if `search` contains `item`. If `search` is an array, this function returns `true` if the `item` is an element in the array. If `search` is a string, this function returns `true` if the `item` is a substring of `search`. This function is not case sensitive. Casts values to a string.",
    minArgs: 2,
    maxArgs: 2,
    call: (...args) => {
        const left = args[0];
        const right = args[1];
        if (left.primitive) {
            const ls = left.coerceString();
            if (right.primitive) {
                const rs = right.coerceString();
                return new _data__WEBPACK_IMPORTED_MODULE_0__.BooleanData(ls.toLowerCase().includes(rs.toLowerCase()));
            }
        }
        else if (left.kind === _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Array) {
            const la = left;
            if (la.values().length === 0) {
                return new _data__WEBPACK_IMPORTED_MODULE_0__.BooleanData(false);
            }
            for (const v of la.values()) {
                if ((0,_result__WEBPACK_IMPORTED_MODULE_1__.equals)(right, v)) {
                    return new _data__WEBPACK_IMPORTED_MODULE_0__.BooleanData(true);
                }
            }
        }
        return new _data__WEBPACK_IMPORTED_MODULE_0__.BooleanData(false);
    }
};


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/funcs/endswith.js":
/*!******************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/funcs/endswith.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   endswith: () => (/* binding */ endswith)
/* harmony export */ });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data */ "./node_modules/@actions/expressions/dist/data/index.js");
/* harmony import */ var _result__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../result */ "./node_modules/@actions/expressions/dist/result.js");


const endswith = {
    name: "endsWith",
    description: "`endsWith( searchString, searchValue )`\n\nReturns `true` if `searchString` ends with `searchValue`. This function is not case sensitive. Casts values to a string.",
    minArgs: 2,
    maxArgs: 2,
    call: (...args) => {
        const left = args[0];
        if (!left.primitive) {
            return new _data__WEBPACK_IMPORTED_MODULE_0__.BooleanData(false);
        }
        const right = args[1];
        if (!right.primitive) {
            return new _data__WEBPACK_IMPORTED_MODULE_0__.BooleanData(false);
        }
        const ls = (0,_result__WEBPACK_IMPORTED_MODULE_1__.toUpperSpecial)(left.coerceString());
        const rs = (0,_result__WEBPACK_IMPORTED_MODULE_1__.toUpperSpecial)(right.coerceString());
        return new _data__WEBPACK_IMPORTED_MODULE_0__.BooleanData(ls.endsWith(rs));
    }
};


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/funcs/format.js":
/*!****************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/funcs/format.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   format: () => (/* binding */ format)
/* harmony export */ });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data */ "./node_modules/@actions/expressions/dist/data/index.js");

const format = {
    name: "format",
    description: "`format( string, replaceValue0, replaceValue1, ..., replaceValueN)`\n\nReplaces values in the `string`, with the variable `replaceValueN`. Variables in the `string` are specified using the `{N}` syntax, where `N` is an integer. You must specify at least one `replaceValue` and `string`. There is no maximum for the number of variables (`replaceValueN`) you can use. Escape curly braces using double braces.",
    minArgs: 1,
    maxArgs: 255 /*MAX_ARGUMENTS*/,
    call: (...args) => {
        const fs = args[0].coerceString();
        const result = [];
        let index = 0;
        while (index < fs.length) {
            const lbrace = fs.indexOf("{", index);
            const rbrace = fs.indexOf("}", index);
            // Left brace
            if (lbrace >= 0 && (rbrace < 0 || rbrace > lbrace)) {
                // Escaped left brace
                if (safeCharAt(fs, lbrace + 1) === "{") {
                    result.push(fs.substr(index, lbrace - index + 1));
                    index = lbrace + 2;
                    continue;
                }
                // Left brace, number, optional format specifiers, right brace
                if (rbrace > lbrace + 1) {
                    const argIndex = readArgIndex(fs, lbrace + 1);
                    if (argIndex.success) {
                        // Check parameter count
                        if (1 + argIndex.result > args.length - 1) {
                            throw new Error(`The following format string references more arguments than were supplied: ${fs}`);
                        }
                        // Append the portion before the left brace
                        if (lbrace > index) {
                            result.push(fs.substr(index, lbrace - index));
                        }
                        // Append the arg
                        result.push(`${args[1 + argIndex.result].coerceString()}`);
                        index = rbrace + 1;
                        continue;
                    }
                }
                throw new Error(`The following format string is invalid: ${fs}`);
            }
            // Right brace
            else if (rbrace >= 0) {
                // Escaped right brace
                if (safeCharAt(fs, rbrace + 1) === "}") {
                    result.push(fs.substr(index, rbrace - index + 1));
                    index = rbrace + 2;
                }
                else {
                    throw new Error(`The following format string is invalid: ${fs}`);
                }
            }
            // Last segment
            else {
                result.push(fs.substr(index));
                break;
            }
        }
        return new _data__WEBPACK_IMPORTED_MODULE_0__.StringData(result.join(""));
    }
};
function safeCharAt(string, index) {
    if (string.length > index) {
        return string[index];
    }
    return "\0";
}
function readArgIndex(string, startIndex) {
    // Count the number of digits
    let length = 0;
    for (;;) {
        const nextChar = safeCharAt(string, startIndex + length);
        if (nextChar >= "0" && nextChar <= "9") {
            length++;
        }
        else {
            break;
        }
    }
    // Validate at least one digit
    if (length < 1) {
        return {
            success: false
        };
    }
    // Parse the number
    const endIndex = startIndex + length - 1;
    const result = parseInt(string.substr(startIndex, length));
    return {
        success: !isNaN(result),
        result: result,
        endIndex: endIndex
    };
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/funcs/fromjson.js":
/*!******************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/funcs/fromjson.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fromjson: () => (/* binding */ fromjson)
/* harmony export */ });
/* harmony import */ var _data_reviver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/reviver */ "./node_modules/@actions/expressions/dist/data/reviver.js");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ "./node_modules/@actions/expressions/dist/errors.js");


const fromjson = {
    name: "fromJson",
    description: "`fromJSON(value)`\n\nReturns a JSON object or JSON data type for `value`. You can use this function to provide a JSON object as an evaluated expression or to convert environment variables from a string.",
    minArgs: 1,
    maxArgs: 1,
    call: (...args) => {
        const input = args[0];
        const is = input.coerceString();
        if (is.trim() === "") {
            throw new Error("empty input");
        }
        try {
            return JSON.parse(is, _data_reviver__WEBPACK_IMPORTED_MODULE_0__.reviver);
        }
        catch (e) {
            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ExpressionEvaluationError("Error parsing JSON when evaluating fromJson", { cause: e });
        }
    }
};


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/funcs/join.js":
/*!**************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/funcs/join.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   join: () => (/* binding */ join)
/* harmony export */ });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data */ "./node_modules/@actions/expressions/dist/data/index.js");

const join = {
    name: "join",
    description: "`join( array, optionalSeparator )`\n\nThe value for `array` can be an array or a string. All values in `array` are concatenated into a string. If you provide `optionalSeparator`, it is inserted between the concatenated values. Otherwise, the default separator `,` is used. Casts values to a string.",
    minArgs: 1,
    maxArgs: 2,
    call: (...args) => {
        // Primitive
        if (args[0].primitive) {
            return new _data__WEBPACK_IMPORTED_MODULE_0__.StringData(args[0].coerceString());
        }
        // Array
        if (args[0].kind === _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Array) {
            // Separator
            let separator = ",";
            if (args.length > 1 && args[1].primitive) {
                separator = args[1].coerceString();
            }
            // Convert items to strings
            return new _data__WEBPACK_IMPORTED_MODULE_0__.StringData(args[0]
                .values()
                .map(item => item.coerceString())
                .join(separator));
        }
        return new _data__WEBPACK_IMPORTED_MODULE_0__.StringData("");
    }
};


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/funcs/startswith.js":
/*!********************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/funcs/startswith.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startswith: () => (/* binding */ startswith)
/* harmony export */ });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data */ "./node_modules/@actions/expressions/dist/data/index.js");
/* harmony import */ var _result__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../result */ "./node_modules/@actions/expressions/dist/result.js");


const startswith = {
    name: "startsWith",
    description: "`startsWith( searchString, searchValue )`\n\nReturns `true` when `searchString` starts with `searchValue`. This function is not case sensitive. Casts values to a string.",
    minArgs: 2,
    maxArgs: 2,
    call: (...args) => {
        const left = args[0];
        if (!left.primitive) {
            return new _data__WEBPACK_IMPORTED_MODULE_0__.BooleanData(false);
        }
        const right = args[1];
        if (!right.primitive) {
            return new _data__WEBPACK_IMPORTED_MODULE_0__.BooleanData(false);
        }
        const ls = (0,_result__WEBPACK_IMPORTED_MODULE_1__.toUpperSpecial)(left.coerceString());
        const rs = (0,_result__WEBPACK_IMPORTED_MODULE_1__.toUpperSpecial)(right.coerceString());
        return new _data__WEBPACK_IMPORTED_MODULE_0__.BooleanData(ls.startsWith(rs));
    }
};


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/funcs/tojson.js":
/*!****************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/funcs/tojson.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tojson: () => (/* binding */ tojson)
/* harmony export */ });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data */ "./node_modules/@actions/expressions/dist/data/index.js");
/* harmony import */ var _data_replacer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/replacer */ "./node_modules/@actions/expressions/dist/data/replacer.js");


const tojson = {
    name: "toJson",
    description: "`toJSON(value)`\n\nReturns a pretty-print JSON representation of `value`. You can use this function to debug the information provided in contexts.",
    minArgs: 1,
    maxArgs: 1,
    call: (...args) => {
        return new _data__WEBPACK_IMPORTED_MODULE_0__.StringData(JSON.stringify(args[0], _data_replacer__WEBPACK_IMPORTED_MODULE_1__.replacer, "  "));
    }
};


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/idxHelper.js":
/*!*************************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/idxHelper.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   idxHelper: () => (/* binding */ idxHelper)
/* harmony export */ });
class idxHelper {
    constructor(star, idx) {
        this.star = star;
        if (!idx) {
            return;
        }
        if (!star) {
            if (idx.primitive) {
                this.str = idx.coerceString();
            }
            let f = idx.number();
            if (!isNaN(f) && isFinite(f) && f >= 0) {
                f = Math.floor(f);
                this.int = f;
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DescriptionDictionary: () => (/* reexport safe */ _completion_descriptionDictionary__WEBPACK_IMPORTED_MODULE_2__.DescriptionDictionary),
/* harmony export */   Evaluator: () => (/* reexport safe */ _evaluator__WEBPACK_IMPORTED_MODULE_5__.Evaluator),
/* harmony export */   Expr: () => (/* reexport safe */ _ast__WEBPACK_IMPORTED_MODULE_0__.Expr),
/* harmony export */   ExpressionError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_4__.ExpressionError),
/* harmony export */   ExpressionEvaluationError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_4__.ExpressionEvaluationError),
/* harmony export */   Lexer: () => (/* reexport safe */ _lexer__WEBPACK_IMPORTED_MODULE_7__.Lexer),
/* harmony export */   Parser: () => (/* reexport safe */ _parser__WEBPACK_IMPORTED_MODULE_8__.Parser),
/* harmony export */   complete: () => (/* reexport safe */ _completion__WEBPACK_IMPORTED_MODULE_1__.complete),
/* harmony export */   data: () => (/* reexport module object */ _data__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   isDescriptionDictionary: () => (/* reexport safe */ _completion_descriptionDictionary__WEBPACK_IMPORTED_MODULE_2__.isDescriptionDictionary),
/* harmony export */   wellKnownFunctions: () => (/* reexport safe */ _funcs__WEBPACK_IMPORTED_MODULE_6__.wellKnownFunctions)
/* harmony export */ });
/* harmony import */ var _ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast */ "./node_modules/@actions/expressions/dist/ast.js");
/* harmony import */ var _completion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./completion */ "./node_modules/@actions/expressions/dist/completion.js");
/* harmony import */ var _completion_descriptionDictionary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./completion/descriptionDictionary */ "./node_modules/@actions/expressions/dist/completion/descriptionDictionary.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data */ "./node_modules/@actions/expressions/dist/data/index.js");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors */ "./node_modules/@actions/expressions/dist/errors.js");
/* harmony import */ var _evaluator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./evaluator */ "./node_modules/@actions/expressions/dist/evaluator.js");
/* harmony import */ var _funcs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./funcs */ "./node_modules/@actions/expressions/dist/funcs.js");
/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lexer */ "./node_modules/@actions/expressions/dist/lexer.js");
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parser */ "./node_modules/@actions/expressions/dist/parser.js");











/***/ }),

/***/ "./node_modules/@actions/expressions/dist/lexer.js":
/*!*********************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/lexer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Lexer: () => (/* binding */ Lexer),
/* harmony export */   TokenType: () => (/* binding */ TokenType),
/* harmony export */   tokenString: () => (/* binding */ tokenString)
/* harmony export */ });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data */ "./node_modules/@actions/expressions/dist/data/index.js");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ "./node_modules/@actions/expressions/dist/errors.js");


var TokenType;
(function (TokenType) {
    TokenType[TokenType["UNKNOWN"] = 0] = "UNKNOWN";
    TokenType[TokenType["LEFT_PAREN"] = 1] = "LEFT_PAREN";
    TokenType[TokenType["RIGHT_PAREN"] = 2] = "RIGHT_PAREN";
    TokenType[TokenType["LEFT_BRACKET"] = 3] = "LEFT_BRACKET";
    TokenType[TokenType["RIGHT_BRACKET"] = 4] = "RIGHT_BRACKET";
    TokenType[TokenType["COMMA"] = 5] = "COMMA";
    TokenType[TokenType["DOT"] = 6] = "DOT";
    TokenType[TokenType["BANG"] = 7] = "BANG";
    TokenType[TokenType["BANG_EQUAL"] = 8] = "BANG_EQUAL";
    TokenType[TokenType["EQUAL_EQUAL"] = 9] = "EQUAL_EQUAL";
    TokenType[TokenType["GREATER"] = 10] = "GREATER";
    TokenType[TokenType["GREATER_EQUAL"] = 11] = "GREATER_EQUAL";
    TokenType[TokenType["LESS"] = 12] = "LESS";
    TokenType[TokenType["LESS_EQUAL"] = 13] = "LESS_EQUAL";
    TokenType[TokenType["AND"] = 14] = "AND";
    TokenType[TokenType["OR"] = 15] = "OR";
    TokenType[TokenType["STAR"] = 16] = "STAR";
    TokenType[TokenType["NUMBER"] = 17] = "NUMBER";
    TokenType[TokenType["STRING"] = 18] = "STRING";
    TokenType[TokenType["IDENTIFIER"] = 19] = "IDENTIFIER";
    TokenType[TokenType["TRUE"] = 20] = "TRUE";
    TokenType[TokenType["FALSE"] = 21] = "FALSE";
    TokenType[TokenType["NULL"] = 22] = "NULL";
    TokenType[TokenType["EOF"] = 23] = "EOF";
})(TokenType || (TokenType = {}));
function tokenString(tok) {
    switch (tok.type) {
        case TokenType.EOF:
            return "EOF";
        case TokenType.NUMBER:
            return tok.lexeme;
        case TokenType.STRING:
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return tok.value.toString();
        default:
            return tok.lexeme;
    }
}
class Lexer {
    constructor(input) {
        this.input = input;
        this.start = 0;
        this.offset = 0;
        this.line = 0;
        this.lastLineOffset = 0;
        this.tokens = [];
    }
    lex() {
        if (this.input.length > _errors__WEBPACK_IMPORTED_MODULE_1__.MAX_EXPRESSION_LENGTH) {
            throw new Error("ErrorExceededMaxLength");
        }
        while (!this.atEnd()) {
            this.start = this.offset;
            const c = this.next();
            switch (c) {
                case "(":
                    this.addToken(TokenType.LEFT_PAREN);
                    break;
                case ")":
                    this.addToken(TokenType.RIGHT_PAREN);
                    break;
                case "[":
                    this.addToken(TokenType.LEFT_BRACKET);
                    break;
                case "]":
                    this.addToken(TokenType.RIGHT_BRACKET);
                    break;
                case ",":
                    this.addToken(TokenType.COMMA);
                    break;
                case ".":
                    if (this.previous() != TokenType.IDENTIFIER &&
                        this.previous() != TokenType.RIGHT_BRACKET &&
                        this.previous() != TokenType.RIGHT_PAREN &&
                        this.previous() != TokenType.STAR) {
                        this.consumeNumber();
                    }
                    else {
                        this.addToken(TokenType.DOT);
                    }
                    break;
                case "-":
                case "+":
                    this.consumeNumber();
                    break;
                case "!":
                    this.addToken(this.match("=") ? TokenType.BANG_EQUAL : TokenType.BANG);
                    break;
                case "=":
                    if (!this.match("=")) {
                        // Illegal; continue reading until we hit a boundary character and return an error
                        this.consumeIdentifier();
                        break;
                    }
                    this.addToken(TokenType.EQUAL_EQUAL);
                    break;
                case "<":
                    this.addToken(this.match("=") ? TokenType.LESS_EQUAL : TokenType.LESS);
                    break;
                case ">":
                    this.addToken(this.match("=") ? TokenType.GREATER_EQUAL : TokenType.GREATER);
                    break;
                case "&":
                    if (!this.match("&")) {
                        // Illegal; continue reading until we hit a boundary character and return an error
                        this.consumeIdentifier();
                        break;
                    }
                    this.addToken(TokenType.AND);
                    break;
                case "|":
                    if (!this.match("|")) {
                        // Illegal; continue reading until we hit a boundary character and return an error
                        this.consumeIdentifier();
                        break;
                    }
                    this.addToken(TokenType.OR);
                    break;
                case "*":
                    this.addToken(TokenType.STAR);
                    break;
                // Ignore whitespace.
                case " ":
                case "\r":
                case "\t":
                    break;
                case "\n":
                    ++this.line;
                    this.lastLineOffset = this.offset;
                    break;
                case "'":
                    this.consumeString();
                    break;
                default:
                    switch (true) {
                        case isDigit(c):
                            this.consumeNumber();
                            break;
                        default:
                            this.consumeIdentifier();
                            break;
                    }
            }
        }
        this.tokens.push({
            type: TokenType.EOF,
            lexeme: "",
            range: this.range()
        });
        return {
            tokens: this.tokens
        };
    }
    pos() {
        return {
            line: this.line,
            column: this.start - this.lastLineOffset
        };
    }
    endPos() {
        return {
            line: this.line,
            column: this.offset - this.lastLineOffset
        };
    }
    range() {
        return {
            start: this.pos(),
            end: this.endPos()
        };
    }
    atEnd() {
        return this.offset >= this.input.length;
    }
    peek() {
        if (this.atEnd()) {
            return "\0";
        }
        return this.input[this.offset];
    }
    peekNext() {
        if (this.offset + 1 >= this.input.length) {
            return "\0";
        }
        return this.input[this.offset + 1];
    }
    previous() {
        const l = this.tokens.length;
        if (l == 0) {
            return TokenType.EOF;
        }
        return this.tokens[l - 1].type;
    }
    next() {
        return this.input[this.offset++];
    }
    match(expected) {
        if (this.atEnd()) {
            return false;
        }
        if (this.input[this.offset] !== expected) {
            return false;
        }
        this.offset++;
        return true;
    }
    addToken(type, value) {
        this.tokens.push({
            type,
            lexeme: this.input.substring(this.start, this.offset),
            range: this.range(),
            value
        });
    }
    consumeNumber() {
        while (!this.atEnd() && (!isBoundary(this.peek()) || this.peek() == ".")) {
            this.next();
        }
        const lexeme = this.input.substring(this.start, this.offset);
        const value = new _data__WEBPACK_IMPORTED_MODULE_0__.StringData(lexeme).number();
        if (isNaN(value)) {
            throw new Error(`Unexpected symbol: '${lexeme}'. Located at position ${this.start + 1} within expression: ${this.input}`);
        }
        this.addToken(TokenType.NUMBER, value);
    }
    consumeString() {
        while ((this.peek() !== "'" || this.peekNext() === "'") && !this.atEnd()) {
            if (this.peek() === "\n")
                this.line++;
            if (this.peek() === "'" && this.peekNext() === "'") {
                // Escaped "'", consume
                this.next();
            }
            this.next();
        }
        if (this.atEnd()) {
            // Unterminated string
            throw new Error(`Unexpected symbol: '${this.input.substring(this.start)}'. Located at position ${this.start + 1} within expression: ${this.input}`);
        }
        // Closing '
        this.next();
        // Trim the surrounding quotes.
        let value = this.input.substring(this.start + 1, this.offset - 1);
        value = value.replace("''", "'");
        this.addToken(TokenType.STRING, value);
    }
    consumeIdentifier() {
        while (!this.atEnd() && !isBoundary(this.peek())) {
            this.next();
        }
        let tokenType = TokenType.IDENTIFIER;
        let tokenValue = undefined;
        const lexeme = this.input.substring(this.start, this.offset);
        if (this.previous() != TokenType.DOT) {
            switch (lexeme) {
                case "true":
                    tokenType = TokenType.TRUE;
                    break;
                case "false":
                    tokenType = TokenType.FALSE;
                    break;
                case "null":
                    tokenType = TokenType.NULL;
                    break;
                case "NaN":
                    tokenType = TokenType.NUMBER;
                    tokenValue = NaN;
                    break;
                case "Infinity":
                    tokenType = TokenType.NUMBER;
                    tokenValue = Infinity;
                    break;
            }
        }
        if (!isLegalIdentifier(lexeme)) {
            throw new Error(`Unexpected symbol: '${lexeme}'. Located at position ${this.start + 1} within expression: ${this.input}`);
        }
        this.addToken(tokenType, tokenValue);
    }
}
function isDigit(c) {
    return c >= "0" && c <= "9";
}
function isBoundary(c) {
    switch (c) {
        case "(":
        case "[":
        case ")":
        case "]":
        case ",":
        case ".":
        case "!":
        case ">":
        case "<":
        case "=":
        case "&":
        case "|":
            return true;
    }
    return /\s/.test(c);
}
function isLegalIdentifier(str) {
    if (str == "") {
        return false;
    }
    const first = str[0];
    if ((first >= "a" && first <= "z") || (first >= "A" && first <= "Z") || first == "_") {
        for (const c of str.substring(1).split("")) {
            if ((c >= "a" && c <= "z") || (c >= "A" && c <= "Z") || (c >= "0" && c <= "9") || c == "_" || c == "-") {
                // OK
            }
            else {
                return false;
            }
        }
        return true;
    }
    return false;
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/parser.js":
/*!**********************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/parser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Parser: () => (/* binding */ Parser)
/* harmony export */ });
/* harmony import */ var _ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast */ "./node_modules/@actions/expressions/dist/ast.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data */ "./node_modules/@actions/expressions/dist/data/index.js");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ "./node_modules/@actions/expressions/dist/errors.js");
/* harmony import */ var _funcs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./funcs */ "./node_modules/@actions/expressions/dist/funcs.js");
/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lexer */ "./node_modules/@actions/expressions/dist/lexer.js");





class Parser {
    /**
     * Constructs a new parser for the given tokens
     *
     * @param tokens Tokens to build a parse tree from
     * @param extensionContexts Available context names
     * @param extensionFunctions Available functions (beyond the built-in ones)
     */
    constructor(tokens, extensionContexts, extensionFunctions) {
        this.tokens = tokens;
        this.offset = 0;
        this.depth = 0;
        this.extContexts = new Map();
        this.extFuncs = new Map();
        for (const contextName of extensionContexts) {
            this.extContexts.set(contextName.toLowerCase(), true);
        }
        for (const { name, func } of extensionFunctions.map(x => ({
            name: x.name,
            func: x
        }))) {
            this.extFuncs.set(name.toLowerCase(), func);
        }
        this.context = {
            allowUnknownKeywords: false,
            extensionContexts: this.extContexts,
            extensionFunctions: this.extFuncs
        };
    }
    parse() {
        // eslint-disable-next-line prefer-const
        let result;
        // No tokens
        if (this.atEnd()) {
            return result;
        }
        result = this.expression();
        if (!this.atEnd()) {
            throw this.buildError(_errors__WEBPACK_IMPORTED_MODULE_2__.ErrorType.ErrorUnexpectedSymbol, this.peek());
        }
        return result;
    }
    expression() {
        this.incrDepth();
        try {
            return this.logicalOr();
        }
        finally {
            this.decrDepth();
        }
    }
    logicalOr() {
        // && is higher precedence than ||
        let expr = this.logicalAnd();
        if (this.check(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.OR)) {
            // Track depth
            this.incrDepth();
            try {
                const logical = new _ast__WEBPACK_IMPORTED_MODULE_0__.Logical(this.peek(), [expr]);
                expr = logical;
                while (this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.OR)) {
                    const right = this.logicalAnd();
                    logical.args.push(right);
                }
            }
            finally {
                this.decrDepth();
            }
        }
        return expr;
    }
    logicalAnd() {
        // == and != are higher precedence than &&
        let expr = this.equality();
        if (this.check(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.AND)) {
            // Track depth
            this.incrDepth();
            try {
                const logical = new _ast__WEBPACK_IMPORTED_MODULE_0__.Logical(this.peek(), [expr]);
                expr = logical;
                while (this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.AND)) {
                    const right = this.equality();
                    logical.args.push(right);
                }
            }
            finally {
                this.decrDepth();
            }
        }
        return expr;
    }
    equality() {
        // >, >=, <, <= are higher precedence than == and !=
        let expr = this.comparison();
        while (this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.BANG_EQUAL, _lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.EQUAL_EQUAL)) {
            const operator = this.previous();
            const right = this.comparison();
            expr = new _ast__WEBPACK_IMPORTED_MODULE_0__.Binary(expr, operator, right);
        }
        return expr;
    }
    comparison() {
        // ! is higher precedence than >, >=, <, <=
        let expr = this.unary();
        while (this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.GREATER, _lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.GREATER_EQUAL, _lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.LESS, _lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.LESS_EQUAL)) {
            const operator = this.previous();
            const right = this.unary();
            expr = new _ast__WEBPACK_IMPORTED_MODULE_0__.Binary(expr, operator, right);
        }
        return expr;
    }
    unary() {
        if (this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.BANG)) {
            // Track depth
            this.incrDepth();
            const operator = this.previous();
            const unary = this.unary();
            try {
                return new _ast__WEBPACK_IMPORTED_MODULE_0__.Unary(operator, unary);
            }
            finally {
                this.decrDepth();
            }
        }
        return this.index();
    }
    index() {
        let expr = this.call();
        let depthIncreased = 0;
        if (expr instanceof _ast__WEBPACK_IMPORTED_MODULE_0__.Grouping || expr instanceof _ast__WEBPACK_IMPORTED_MODULE_0__.FunctionCall || expr instanceof _ast__WEBPACK_IMPORTED_MODULE_0__.ContextAccess) {
            let cont = true;
            while (cont) {
                switch (true) {
                    case this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.LEFT_BRACKET): {
                        let indexExpr;
                        if (this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.STAR)) {
                            indexExpr = new _ast__WEBPACK_IMPORTED_MODULE_0__.Star();
                        }
                        else {
                            indexExpr = this.expression();
                        }
                        this.consume(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.RIGHT_BRACKET, _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorType.ErrorUnexpectedSymbol);
                        // Track depth
                        this.incrDepth();
                        depthIncreased++;
                        expr = new _ast__WEBPACK_IMPORTED_MODULE_0__.IndexAccess(expr, indexExpr);
                        break;
                    }
                    case this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.DOT):
                        // Track depth
                        this.incrDepth();
                        depthIncreased++;
                        if (this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.IDENTIFIER)) {
                            const property = this.previous();
                            expr = new _ast__WEBPACK_IMPORTED_MODULE_0__.IndexAccess(expr, new _ast__WEBPACK_IMPORTED_MODULE_0__.Literal(new _data__WEBPACK_IMPORTED_MODULE_1__.StringData(property.lexeme), property));
                        }
                        else if (this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.STAR)) {
                            expr = new _ast__WEBPACK_IMPORTED_MODULE_0__.IndexAccess(expr, new _ast__WEBPACK_IMPORTED_MODULE_0__.Star());
                        }
                        else {
                            throw this.buildError(_errors__WEBPACK_IMPORTED_MODULE_2__.ErrorType.ErrorUnexpectedSymbol, this.peek());
                        }
                        break;
                    default:
                        cont = false;
                }
            }
        }
        for (let i = 0; i < depthIncreased; i++) {
            this.decrDepth();
        }
        return expr;
    }
    call() {
        if (!this.check(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.IDENTIFIER)) {
            return this.primary();
        }
        const identifier = this.next();
        if (!this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.LEFT_PAREN)) {
            if (!this.extContexts.has(identifier.lexeme.toLowerCase())) {
                throw this.buildError(_errors__WEBPACK_IMPORTED_MODULE_2__.ErrorType.ErrorUnrecognizedContext, identifier);
            }
            return new _ast__WEBPACK_IMPORTED_MODULE_0__.ContextAccess(identifier);
        }
        // Function call
        const args = [];
        // Arguments
        while (!this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.RIGHT_PAREN)) {
            const aexp = this.expression();
            args.push(aexp);
            if (!this.check(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.RIGHT_PAREN)) {
                this.consume(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.COMMA, _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorType.ErrorUnexpectedSymbol);
            }
        }
        (0,_funcs__WEBPACK_IMPORTED_MODULE_3__.validateFunction)(this.context, identifier, args.length);
        return new _ast__WEBPACK_IMPORTED_MODULE_0__.FunctionCall(identifier, args);
    }
    primary() {
        switch (true) {
            case this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.FALSE):
                return new _ast__WEBPACK_IMPORTED_MODULE_0__.Literal(new _data__WEBPACK_IMPORTED_MODULE_1__.BooleanData(false), this.previous());
            case this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.TRUE):
                return new _ast__WEBPACK_IMPORTED_MODULE_0__.Literal(new _data__WEBPACK_IMPORTED_MODULE_1__.BooleanData(true), this.previous());
            case this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.NULL):
                return new _ast__WEBPACK_IMPORTED_MODULE_0__.Literal(new _data__WEBPACK_IMPORTED_MODULE_1__.Null(), this.previous());
            case this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.NUMBER):
                return new _ast__WEBPACK_IMPORTED_MODULE_0__.Literal(new _data__WEBPACK_IMPORTED_MODULE_1__.NumberData(this.previous().value), this.previous());
            case this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.STRING):
                return new _ast__WEBPACK_IMPORTED_MODULE_0__.Literal(new _data__WEBPACK_IMPORTED_MODULE_1__.StringData(this.previous().value), this.previous());
            case this.match(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.LEFT_PAREN): {
                const expr = this.expression();
                if (this.atEnd()) {
                    throw this.buildError(_errors__WEBPACK_IMPORTED_MODULE_2__.ErrorType.ErrorUnexpectedEndOfExpression, this.previous()); // Back up to get the last token before the EOF
                }
                this.consume(_lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.RIGHT_PAREN, _errors__WEBPACK_IMPORTED_MODULE_2__.ErrorType.ErrorUnexpectedSymbol);
                return new _ast__WEBPACK_IMPORTED_MODULE_0__.Grouping(expr);
            }
            case this.atEnd():
                throw this.buildError(_errors__WEBPACK_IMPORTED_MODULE_2__.ErrorType.ErrorUnexpectedEndOfExpression, this.previous()); // Back up to get the last token before the EOF
        }
        throw this.buildError(_errors__WEBPACK_IMPORTED_MODULE_2__.ErrorType.ErrorUnexpectedSymbol, this.peek());
    }
    // match consumes the next token if it matches any of the given types
    match(...tokenTypes) {
        for (const tokenType of tokenTypes) {
            if (this.check(tokenType)) {
                this.next();
                return true;
            }
        }
        return false;
    }
    // check peeks whether the next token is of the given type
    check(tokenType) {
        if (this.atEnd()) {
            return false;
        }
        return this.peek().type == tokenType;
    }
    // atEnd peeks whether the next token is EOF
    atEnd() {
        return this.peek().type == _lexer__WEBPACK_IMPORTED_MODULE_4__.TokenType.EOF;
    }
    next() {
        if (!this.atEnd()) {
            this.offset++;
        }
        return this.previous();
    }
    peek() {
        return this.tokens[this.offset];
    }
    // previous returns the previous token
    previous() {
        return this.tokens[this.offset - 1];
    }
    // consume attempts to consume the next token if it matches the given type. It returns an error of
    // the given ParseErrorKind otherwise.
    consume(tokenType, errorType) {
        if (this.check(tokenType)) {
            this.next();
            return;
        }
        throw this.buildError(errorType, this.peek());
    }
    incrDepth() {
        this.depth++;
        if (this.depth > _errors__WEBPACK_IMPORTED_MODULE_2__.MAX_PARSER_DEPTH) {
            throw this.buildError(_errors__WEBPACK_IMPORTED_MODULE_2__.ErrorType.ErrorExceededMaxDepth, this.peek());
        }
    }
    decrDepth() {
        this.depth--;
    }
    buildError(errType, token) {
        return new _errors__WEBPACK_IMPORTED_MODULE_2__.ExpressionError(errType, token);
    }
}


/***/ }),

/***/ "./node_modules/@actions/expressions/dist/result.js":
/*!**********************************************************!*\
  !*** ./node_modules/@actions/expressions/dist/result.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   coerceTypes: () => (/* binding */ coerceTypes),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   falsy: () => (/* binding */ falsy),
/* harmony export */   greaterThan: () => (/* binding */ greaterThan),
/* harmony export */   lessThan: () => (/* binding */ lessThan),
/* harmony export */   toUpperSpecial: () => (/* binding */ toUpperSpecial),
/* harmony export */   truthy: () => (/* binding */ truthy)
/* harmony export */ });
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data */ "./node_modules/@actions/expressions/dist/data/index.js");

function falsy(d) {
    switch (d.kind) {
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Null:
            return true;
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Boolean:
            return !d.value;
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Number: {
            const dv = d.value;
            return dv === 0 || isNaN(dv);
        }
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.String:
            return d.value.length === 0;
    }
    return false;
}
function truthy(d) {
    return !falsy(d);
}
// Similar to the Javascript abstract equality comparison algorithm http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3.
// Except objects are not coerced to primitives.
function coerceTypes(li, ri) {
    let lv = li;
    let rv = ri;
    // Do nothing, same kind
    if (li.kind === ri.kind) {
        return [lv, rv];
    }
    switch (li.kind) {
        // Number, String
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Number:
            if (ri.kind === _data__WEBPACK_IMPORTED_MODULE_0__.Kind.String) {
                rv = new _data__WEBPACK_IMPORTED_MODULE_0__.NumberData(ri.number());
                return [lv, rv];
            }
            break;
        // String, Number
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.String:
            if (ri.kind === _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Number) {
                lv = new _data__WEBPACK_IMPORTED_MODULE_0__.NumberData(li.number());
                return [lv, rv];
            }
            break;
        // Boolean|Null, Any
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Null:
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Boolean:
            lv = new _data__WEBPACK_IMPORTED_MODULE_0__.NumberData(li.number());
            return coerceTypes(lv, rv);
    }
    // Any, Boolean|Null
    switch (ri.kind) {
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Null:
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Boolean:
            rv = new _data__WEBPACK_IMPORTED_MODULE_0__.NumberData(ri.number());
            return coerceTypes(lv, rv);
    }
    return [lv, rv];
}
// Similar to the Javascript abstract equality comparison algorithm http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3.
// Except string comparison is OrdinalIgnoreCase, and objects are not coerced to primitives.
function equals(lhs, rhs) {
    const [lv, rv] = coerceTypes(lhs, rhs);
    if (lv.kind != rv.kind) {
        return false;
    }
    switch (lv.kind) {
        // Null, Null
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Null:
            return true;
        // Number, Number
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Number: {
            const ld = lv.value;
            const rd = rv.value;
            if (isNaN(ld) || isNaN(rd)) {
                return false;
            }
            return ld == rd;
        }
        // String, String
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.String: {
            const ls = lv.value;
            const rs = rv.value;
            return toUpperSpecial(ls) === toUpperSpecial(rs);
        }
        // Boolean, Boolean
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Boolean: {
            const lb = lv.value;
            const rb = rv.value;
            return lb == rb;
        }
        // Object, Object
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Dictionary:
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Array:
            // Check reference equality
            return lv === rv;
    }
    return false;
}
// Similar to the Javascript abstract equality comparison algorithm http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3.
// Except string comparison is OrdinalIgnoreCase, and objects are not coerced to primitives.
function greaterThan(lhs, rhs) {
    const [lv, rv] = coerceTypes(lhs, rhs);
    if (lv.kind != rv.kind) {
        return false;
    }
    switch (lv.kind) {
        // Number, Number
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Number: {
            const lf = lv.value;
            const rf = rv.value;
            if (isNaN(lf) || isNaN(rf)) {
                return false;
            }
            return lf > rf;
        }
        // String, String
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.String: {
            let ls = lv.value;
            let rs = rv.value;
            ls = toUpperSpecial(ls);
            rs = toUpperSpecial(rs);
            return ls > rs;
        }
        // Boolean, Boolean
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Boolean: {
            const lb = lv.value;
            const rb = rv.value;
            return lb && !rb;
        }
    }
    return false;
}
// Similar to the Javascript abstract equality comparison algorithm http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3.
// Except string comparison is OrdinalIgnoreCase, and objects are not coerced to primitives.
function lessThan(lhs, rhs) {
    const [lv, rv] = coerceTypes(lhs, rhs);
    if (lv.kind != rv.kind) {
        return false;
    }
    switch (lv.kind) {
        // Number, Number
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Number: {
            const lf = lv.value;
            const rf = rv.value;
            if (isNaN(lf) || isNaN(rf)) {
                return false;
            }
            return lf < rf;
        }
        // String, String
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.String: {
            let ls = lv.value;
            let rs = rv.value;
            ls = toUpperSpecial(ls);
            rs = toUpperSpecial(rs);
            return ls < rs;
        }
        // Boolean, Boolean
        case _data__WEBPACK_IMPORTED_MODULE_0__.Kind.Boolean: {
            const lb = lv.value;
            const rb = rv.value;
            return !lb && rb;
        }
    }
    return false;
}
// Do not toUpper the small-dotless-ı
function toUpperSpecial(s) {
    const sb = [];
    let i = 0;
    const len = s.length;
    let found = s.indexOf("ı");
    while (i < len) {
        if (i < found) {
            sb.push(s.substring(i, found).toUpperCase()); // Append upper segment
            i = found;
        }
        else if (i == found) {
            sb.push(s.substring(i, i + 1));
            i += 1;
            found = s.indexOf("ı", i);
        }
        else {
            sb.push(s.substring(i).toUpperCase()); // Append upper remaining
            break;
        }
    }
    return sb.join("");
}


/***/ }),

/***/ "./node_modules/@actions/languageserver/dist/commands.js":
/*!***************************************************************!*\
  !*** ./node_modules/@actions/languageserver/dist/commands.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Commands: () => (/* binding */ Commands)
/* harmony export */ });
var Commands;
(function (Commands) {
    Commands["ClearCache"] = "cacheClear";
})(Commands || (Commands = {}));


/***/ }),

/***/ "./node_modules/@actions/languageserver/dist/initializationOptions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@actions/languageserver/dist/initializationOptions.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LogLevel: () => (/* reexport safe */ _actions_languageservice_log__WEBPACK_IMPORTED_MODULE_0__.LogLevel)
/* harmony export */ });
/* harmony import */ var _actions_languageservice_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actions/languageservice/log */ "./node_modules/@actions/languageservice/dist/log.js");



/***/ }),

/***/ "./node_modules/@actions/languageserver/dist/request.js":
/*!**************************************************************!*\
  !*** ./node_modules/@actions/languageserver/dist/request.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Requests: () => (/* binding */ Requests)
/* harmony export */ });
const Requests = {
    ReadFile: "actions/readFile"
};


/***/ }),

/***/ "./node_modules/@actions/languageserver/dist/utils/cache.js":
/*!******************************************************************!*\
  !*** ./node_modules/@actions/languageserver/dist/utils/cache.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TTLCache: () => (/* binding */ TTLCache)
/* harmony export */ });
class TTLCache {
    constructor(defaultTTLinMS = 10 * 60 * 1000) {
        this.defaultTTLinMS = defaultTTLinMS;
        this.cache = new Map();
    }
    /**
     *
     * @param key Key to cache value under
     * @param ttlInMS How long is the content valid. If optional, default value will be used
     * @param getter Function to retrieve content if not in cache
     */
    async get(key, ttlInMS, getter) {
        const hasEntry = this.cache.has(key);
        const e = hasEntry && this.cache.get(key);
        if (hasEntry && e && e.cachedAt > Date.now() - (ttlInMS || this.defaultTTLinMS)) {
            return e.content;
        }
        try {
            const content = await getter();
            this.cache.set(key, {
                cachedAt: Date.now(),
                content
            });
            return content;
        }
        catch (e) {
            this.cache.delete(key);
            throw e;
        }
    }
    clear() {
        this.cache.clear();
    }
}


/***/ }),

/***/ "./node_modules/@actions/languageservice/dist/log.js":
/*!***********************************************************!*\
  !*** ./node_modules/@actions/languageservice/dist/log.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LogLevel: () => (/* binding */ LogLevel),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   info: () => (/* binding */ info),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   registerLogger: () => (/* binding */ registerLogger),
/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
})(LogLevel || (LogLevel = {}));
const loggers = [];
let logLevel = LogLevel.Warn;
function registerLogger(l) {
    loggers.push(l);
}
function setLogLevel(ll) {
    logLevel = ll;
}
function log(message) {
    if (logLevel > LogLevel.Debug) {
        return;
    }
    for (const l of loggers) {
        l.log(message);
    }
}
function info(message) {
    if (logLevel > LogLevel.Info) {
        return;
    }
    for (const l of loggers) {
        l.info(message);
    }
}
function warn(message) {
    if (logLevel > LogLevel.Warn) {
        return;
    }
    for (const l of loggers) {
        l.warn(message);
    }
}
function error(message) {
    if (logLevel > LogLevel.Error) {
        return;
    }
    for (const l of loggers) {
        l.error(message);
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NoOperationTraceWriter: () => (/* reexport safe */ _templates_trace_writer__WEBPACK_IMPORTED_MODULE_2__.NoOperationTraceWriter),
/* harmony export */   convertWorkflowTemplate: () => (/* reexport safe */ _model_convert__WEBPACK_IMPORTED_MODULE_0__.convertWorkflowTemplate),
/* harmony export */   isBasicExpression: () => (/* reexport safe */ _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isBasicExpression),
/* harmony export */   isBoolean: () => (/* reexport safe */ _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isBoolean),
/* harmony export */   isLiteral: () => (/* reexport safe */ _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isLiteral),
/* harmony export */   isMapping: () => (/* reexport safe */ _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isMapping),
/* harmony export */   isNumber: () => (/* reexport safe */ _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isNumber),
/* harmony export */   isScalar: () => (/* reexport safe */ _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isScalar),
/* harmony export */   isSequence: () => (/* reexport safe */ _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isSequence),
/* harmony export */   isString: () => (/* reexport safe */ _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isString),
/* harmony export */   parseWorkflow: () => (/* reexport safe */ _workflows_workflow_parser__WEBPACK_IMPORTED_MODULE_3__.parseWorkflow)
/* harmony export */ });
/* harmony import */ var _model_convert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/convert */ "./node_modules/@actions/workflow-parser/dist/model/convert.js");
/* harmony import */ var _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./templates/tokens/type-guards */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js");
/* harmony import */ var _templates_trace_writer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./templates/trace-writer */ "./node_modules/@actions/workflow-parser/dist/templates/trace-writer.js");
/* harmony import */ var _workflows_workflow_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./workflows/workflow-parser */ "./node_modules/@actions/workflow-parser/dist/workflows/workflow-parser.js");






/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/convert.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/convert.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ErrorPolicy: () => (/* binding */ ErrorPolicy),
/* harmony export */   convertWorkflowTemplate: () => (/* binding */ convertWorkflowTemplate)
/* harmony export */ });
/* harmony import */ var _templates_tokens_template_token__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../templates/tokens/template-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/template-token.js");
/* harmony import */ var _workflows_file_reference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../workflows/file-reference */ "./node_modules/@actions/workflow-parser/dist/workflows/file-reference.js");
/* harmony import */ var _workflows_workflow_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../workflows/workflow-parser */ "./node_modules/@actions/workflow-parser/dist/workflows/workflow-parser.js");
/* harmony import */ var _converter_concurrency__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./converter/concurrency */ "./node_modules/@actions/workflow-parser/dist/model/converter/concurrency.js");
/* harmony import */ var _converter_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./converter/events */ "./node_modules/@actions/workflow-parser/dist/model/converter/events.js");
/* harmony import */ var _converter_handle_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./converter/handle-errors */ "./node_modules/@actions/workflow-parser/dist/model/converter/handle-errors.js");
/* harmony import */ var _converter_jobs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./converter/jobs */ "./node_modules/@actions/workflow-parser/dist/model/converter/jobs.js");
/* harmony import */ var _converter_referencedWorkflow__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./converter/referencedWorkflow */ "./node_modules/@actions/workflow-parser/dist/model/converter/referencedWorkflow.js");
/* harmony import */ var _type_guards__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./type-guards */ "./node_modules/@actions/workflow-parser/dist/model/type-guards.js");









var ErrorPolicy;
(function (ErrorPolicy) {
    ErrorPolicy[ErrorPolicy["ReturnErrorsOnly"] = 0] = "ReturnErrorsOnly";
    ErrorPolicy[ErrorPolicy["TryConversion"] = 1] = "TryConversion";
})(ErrorPolicy || (ErrorPolicy = {}));
const defaultOptions = {
    maxReusableWorkflowDepth: 4,
    fetchReusableWorkflowDepth: 0,
    errorPolicy: ErrorPolicy.ReturnErrorsOnly
};
async function convertWorkflowTemplate(context, root, fileProvider, options = defaultOptions) {
    const result = {};
    const opts = getOptionsWithDefaults(options);
    if (context.errors.getErrors().length > 0 && opts.errorPolicy === ErrorPolicy.ReturnErrorsOnly) {
        result.errors = context.errors.getErrors().map(x => ({
            Message: x.message
        }));
        return result;
    }
    if (fileProvider === undefined && opts.fetchReusableWorkflowDepth > 0) {
        context.error(root, new Error("A file provider is required to fetch reusable workflows"));
    }
    try {
        const rootMapping = root.assertMapping("root");
        for (const item of rootMapping) {
            const key = item.key.assertString("root key");
            switch (key.value) {
                case "on":
                    result.events = (0,_converter_handle_errors__WEBPACK_IMPORTED_MODULE_5__.handleTemplateTokenErrors)(root, context, {}, () => (0,_converter_events__WEBPACK_IMPORTED_MODULE_4__.convertOn)(context, item.value));
                    break;
                case "jobs":
                    result.jobs = (0,_converter_handle_errors__WEBPACK_IMPORTED_MODULE_5__.handleTemplateTokenErrors)(root, context, [], () => (0,_converter_jobs__WEBPACK_IMPORTED_MODULE_6__.convertJobs)(context, item.value));
                    break;
                case "concurrency":
                    (0,_converter_handle_errors__WEBPACK_IMPORTED_MODULE_5__.handleTemplateTokenErrors)(root, context, {}, () => (0,_converter_concurrency__WEBPACK_IMPORTED_MODULE_3__.convertConcurrency)(context, item.value));
                    result.concurrency = item.value;
                    break;
                case "env":
                    result.env = item.value;
                    break;
            }
        }
        // Load referenced workflows
        for (const job of result.jobs || []) {
            if ((0,_type_guards__WEBPACK_IMPORTED_MODULE_8__.isReusableWorkflowJob)(job)) {
                if (opts.maxReusableWorkflowDepth === 0) {
                    context.error(job.ref, new Error("Reusable workflows are not allowed"));
                    continue;
                }
                if (opts.fetchReusableWorkflowDepth === 0 || fileProvider === undefined) {
                    continue;
                }
                try {
                    const file = await fileProvider.getFileContent((0,_workflows_file_reference__WEBPACK_IMPORTED_MODULE_1__.parseFileReference)(job.ref.value));
                    const workflow = (0,_workflows_workflow_parser__WEBPACK_IMPORTED_MODULE_2__.parseWorkflow)(file, context);
                    if (!workflow.value) {
                        continue;
                    }
                    (0,_converter_referencedWorkflow__WEBPACK_IMPORTED_MODULE_7__.convertReferencedWorkflow)(context, workflow.value, job);
                }
                catch {
                    context.error(job.ref, new Error("Unable to find reusable workflow"));
                }
            }
        }
    }
    catch (err) {
        if (err instanceof _templates_tokens_template_token__WEBPACK_IMPORTED_MODULE_0__.TemplateTokenError) {
            context.error(err.token, err);
        }
        else {
            // Report error for the root node
            context.error(root, err);
        }
    }
    finally {
        if (context.errors.getErrors().length > 0) {
            result.errors = context.errors.getErrors().map(x => ({
                Message: x.message
            }));
        }
    }
    return result;
}
function getOptionsWithDefaults(options) {
    return {
        maxReusableWorkflowDepth: options.maxReusableWorkflowDepth !== undefined
            ? options.maxReusableWorkflowDepth
            : defaultOptions.maxReusableWorkflowDepth,
        fetchReusableWorkflowDepth: options.fetchReusableWorkflowDepth !== undefined
            ? options.fetchReusableWorkflowDepth
            : defaultOptions.fetchReusableWorkflowDepth,
        errorPolicy: options.errorPolicy !== undefined ? options.errorPolicy : defaultOptions.errorPolicy
    };
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/concurrency.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/concurrency.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertConcurrency: () => (/* binding */ convertConcurrency)
/* harmony export */ });
/* harmony import */ var _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templates/tokens/type-guards */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js");

function convertConcurrency(context, token) {
    const result = {};
    if (token.isExpression) {
        return result;
    }
    if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isString)(token)) {
        result.group = token;
        return result;
    }
    const concurrencyProperty = token.assertMapping("concurrency group");
    for (const property of concurrencyProperty) {
        const propertyName = property.key.assertString("concurrency group key");
        if (property.key.isExpression || property.value.isExpression) {
            continue;
        }
        switch (propertyName.value) {
            case "group":
                result.group = property.value.assertString("concurrency group");
                break;
            case "cancel-in-progress":
                result.cancelInProgress = property.value.assertBoolean("cancel-in-progress").value;
                break;
            default:
                context.error(propertyName, `Invalid property name: ${propertyName.value}`);
        }
    }
    return result;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/container.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/container.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertToJobContainer: () => (/* binding */ convertToJobContainer),
/* harmony export */   convertToJobServices: () => (/* binding */ convertToJobServices)
/* harmony export */ });
/* harmony import */ var _templates_tokens__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templates/tokens */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../templates/tokens/type-guards */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js");


function convertToJobContainer(context, container) {
    let image;
    let env;
    let ports;
    let volumes;
    let options;
    // Skip validation for expressions for now to match
    // behavior of the other parsers
    for (const [, token] of _templates_tokens__WEBPACK_IMPORTED_MODULE_0__.TemplateToken.traverse(container)) {
        if (token.isExpression) {
            return;
        }
    }
    if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
        // Workflow uses shorthand syntax `container: image-name`
        image = container.assertString("container item");
        return { image: image };
    }
    const mapping = container.assertMapping("container item");
    if (mapping)
        for (const item of mapping) {
            const key = item.key.assertString("container item key");
            const value = item.value;
            switch (key.value) {
                case "image":
                    image = value.assertString("container image");
                    break;
                case "credentials":
                    convertToJobCredentials(context, value);
                    break;
                case "env":
                    env = value.assertMapping("container env");
                    for (const envItem of env) {
                        envItem.key.assertString("container env value");
                    }
                    break;
                case "ports":
                    ports = value.assertSequence("container ports");
                    for (const port of ports) {
                        port.assertString("container port");
                    }
                    break;
                case "volumes":
                    volumes = value.assertSequence("container volumes");
                    for (const volume of volumes) {
                        volume.assertString("container volume");
                    }
                    break;
                case "options":
                    options = value.assertString("container options");
                    break;
                default:
                    context.error(key, `Unexpected container item key: ${key.value}`);
            }
        }
    if (!image) {
        context.error(container, "Container image cannot be empty");
    }
    else {
        return { image, env, ports, volumes, options };
    }
}
function convertToJobServices(context, services) {
    const serviceList = [];
    const mapping = services.assertMapping("services");
    for (const service of mapping) {
        service.key.assertString("service key");
        const container = convertToJobContainer(context, service.value);
        if (container) {
            serviceList.push(container);
        }
    }
    return serviceList;
}
function convertToJobCredentials(context, value) {
    const mapping = value.assertMapping("credentials");
    let username;
    let password;
    for (const item of mapping) {
        const key = item.key.assertString("credentials item");
        const value = item.value;
        switch (key.value) {
            case "username":
                username = value.assertString("credentials username");
                break;
            case "password":
                password = value.assertString("credentials password");
                break;
            default:
                context.error(key, `credentials key ${key.value}`);
        }
    }
    return { username, password };
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/cron-constants.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/cron-constants.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DOM_RANGE: () => (/* binding */ DOM_RANGE),
/* harmony export */   DOW_RANGE: () => (/* binding */ DOW_RANGE),
/* harmony export */   HOUR_RANGE: () => (/* binding */ HOUR_RANGE),
/* harmony export */   MINUTE_RANGE: () => (/* binding */ MINUTE_RANGE),
/* harmony export */   MONTH_RANGE: () => (/* binding */ MONTH_RANGE)
/* harmony export */ });
// Constants for parsing and validating cron expressions
const MONTHS = {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12
};
const DAYS = {
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6
};
const MINUTE_RANGE = { min: 0, max: 59 };
const HOUR_RANGE = { min: 0, max: 23 };
const DOM_RANGE = { min: 1, max: 31 };
const MONTH_RANGE = { min: 1, max: 12, names: MONTHS };
const DOW_RANGE = { min: 0, max: 6, names: DAYS };


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/cron.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/cron.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCronDescription: () => (/* binding */ getCronDescription),
/* harmony export */   isValidCron: () => (/* binding */ isValidCron)
/* harmony export */ });
/* harmony import */ var cronstrue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cronstrue */ "./node_modules/cronstrue/dist/cronstrue.js");
/* harmony import */ var _cron_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cron-constants */ "./node_modules/@actions/workflow-parser/dist/model/converter/cron-constants.js");


function isValidCron(cron) {
    // https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule
    const parts = cron.split(/ +/);
    if (parts.length != 5) {
        return false;
    }
    const [minutes, hours, dom, months, dow] = parts;
    return (validateCronPart(minutes, _cron_constants__WEBPACK_IMPORTED_MODULE_1__.MINUTE_RANGE) &&
        validateCronPart(hours, _cron_constants__WEBPACK_IMPORTED_MODULE_1__.HOUR_RANGE) &&
        validateCronPart(dom, _cron_constants__WEBPACK_IMPORTED_MODULE_1__.DOM_RANGE) &&
        validateCronPart(months, _cron_constants__WEBPACK_IMPORTED_MODULE_1__.MONTH_RANGE) &&
        validateCronPart(dow, _cron_constants__WEBPACK_IMPORTED_MODULE_1__.DOW_RANGE));
}
function getCronDescription(cronspec) {
    if (!isValidCron(cronspec)) {
        return;
    }
    let desc = "";
    try {
        desc = cronstrue__WEBPACK_IMPORTED_MODULE_0__.toString(cronspec, {
            dayOfWeekStartIndexZero: true,
            monthStartIndexZero: false,
            use24HourTimeFormat: true,
            // cronstrue sets the description as the error if throwExceptionOnParseError is false
            // so we need to distinguish between an error and a valid description
            throwExceptionOnParseError: true
        });
    }
    catch (err) {
        return;
    }
    // Make first character lowercase
    let result = "Runs " + desc.charAt(0).toLowerCase() + desc.slice(1);
    result +=
        "\n\nActions schedules run at most every 5 minutes." +
            " [Learn more](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#onschedule)";
    return result;
}
function validateCronPart(value, range, allowSeparators = true) {
    if (range.names && range.names[value.toLowerCase()] !== undefined) {
        return true;
    }
    if (value === "*") {
        return true;
    }
    // Operator precedence: , > / > -
    if (value.includes(",")) {
        if (!allowSeparators) {
            return false;
        }
        return value.split(",").every(v => v && validateCronPart(v, range));
    }
    if (value.includes("/")) {
        if (!allowSeparators) {
            return false;
        }
        const [start, step, ...rest] = value.split("/");
        const stepNumber = +step;
        if (rest.length > 0 || isNaN(stepNumber) || stepNumber <= 0 || !start || !step) {
            return false;
        }
        // Separators are only allowed in the part before the `/`, e.g. `1-5/2`
        return validateCronPart(start, range) && validateCronPart(step, range, false);
    }
    if (value.includes("-")) {
        if (!allowSeparators) {
            return false;
        }
        const [start, end, ...rest] = value.split("-");
        if (rest.length > 0 || !start || !end) {
            return false;
        }
        // Convert name to integers so we can make sure end >= start
        const startNumber = convertToNumber(start, range.names);
        const endNumber = convertToNumber(end, range.names);
        return validateCronPart(start, range, false) && validateCronPart(end, range, false) && endNumber >= startNumber;
    }
    const number = +value;
    return !isNaN(number) && number >= range.min && number <= range.max;
}
// Converts a string integer or a short name to a number
function convertToNumber(value, names) {
    if (names && names[value.toLowerCase()] !== undefined) {
        return +names[value.toLowerCase()];
    }
    else {
        return +value;
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/events.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/events.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertOn: () => (/* binding */ convertOn)
/* harmony export */ });
/* harmony import */ var _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templates/tokens/type-guards */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js");
/* harmony import */ var _templates_tokens_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../templates/tokens/types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");
/* harmony import */ var _cron__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cron */ "./node_modules/@actions/workflow-parser/dist/model/converter/cron.js");
/* harmony import */ var _string_list__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./string-list */ "./node_modules/@actions/workflow-parser/dist/model/converter/string-list.js");
/* harmony import */ var _workflow_call__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./workflow-call */ "./node_modules/@actions/workflow-parser/dist/model/converter/workflow-call.js");
/* harmony import */ var _workflow_dispatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./workflow-dispatch */ "./node_modules/@actions/workflow-parser/dist/model/converter/workflow-dispatch.js");






function convertOn(context, token) {
    if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isLiteral)(token)) {
        const event = token.assertString("on");
        return {
            [event.value]: {}
        };
    }
    if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isSequence)(token)) {
        const result = {};
        for (const item of token) {
            const event = item.assertString("on");
            result[event.value] = {};
        }
        return result;
    }
    if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isMapping)(token)) {
        const result = {};
        for (const item of token) {
            const eventKey = item.key.assertString("event name");
            const eventName = eventKey.value;
            if (item.value.templateTokenType === _templates_tokens_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Null) {
                result[eventName] = {};
                continue;
            }
            // Schedule is the only event that can be a sequence, handle that separately
            if (eventName === "schedule") {
                const scheduleToken = item.value.assertSequence(`event ${eventName}`);
                result.schedule = convertSchedule(context, scheduleToken);
                continue;
            }
            // All other events are defined as mappings. During schema validation we already ensure that events
            // receive only known keys, so here we can focus on the values and whether they are valid.
            const eventToken = item.value.assertMapping(`event ${eventName}`);
            if (eventName === "workflow_call") {
                result.workflow_call = (0,_workflow_call__WEBPACK_IMPORTED_MODULE_4__.convertEventWorkflowCall)(context, eventToken);
                continue;
            }
            if (eventName === "workflow_dispatch") {
                result.workflow_dispatch = (0,_workflow_dispatch__WEBPACK_IMPORTED_MODULE_5__.convertEventWorkflowDispatchInputs)(context, eventToken);
                continue;
            }
            result[eventName] = {
                ...convertPatternFilter("branches", eventToken),
                ...convertPatternFilter("tags", eventToken),
                ...convertPatternFilter("paths", eventToken),
                ...convertFilter("types", eventToken),
                ...convertFilter("workflows", eventToken)
            };
        }
        return result;
    }
    context.error(token, "Invalid format for 'on'");
    return {};
}
function convertPatternFilter(name, token) {
    const result = {};
    for (const item of token) {
        const key = item.key.assertString(`${name} filter key`);
        switch (key.value) {
            case name:
                if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isString)(item.value)) {
                    result[name] = [item.value.value];
                }
                else {
                    result[name] = (0,_string_list__WEBPACK_IMPORTED_MODULE_3__.convertStringList)(name, item.value.assertSequence(`${name} list`));
                }
                break;
            case `${name}-ignore`:
                if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isString)(item.value)) {
                    result[`${name}-ignore`] = [item.value.value];
                }
                else {
                    result[`${name}-ignore`] = (0,_string_list__WEBPACK_IMPORTED_MODULE_3__.convertStringList)(`${name}-ignore`, item.value.assertSequence(`${name}-ignore list`));
                }
                break;
        }
    }
    return result;
}
function convertFilter(name, token) {
    const result = {};
    for (const item of token) {
        const key = item.key.assertString(`${name} filter key`);
        switch (key.value) {
            case name:
                if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isString)(item.value)) {
                    result[name] = [item.value.value];
                }
                else {
                    result[name] = (0,_string_list__WEBPACK_IMPORTED_MODULE_3__.convertStringList)(name, item.value.assertSequence(`${name} list`));
                }
                break;
        }
    }
    return result;
}
function convertSchedule(context, token) {
    const result = [];
    for (const item of token) {
        const mappingToken = item.assertMapping(`event schedule`);
        if (mappingToken.count == 1) {
            const schedule = mappingToken.get(0);
            const scheduleKey = schedule.key.assertString(`schedule key`);
            if (scheduleKey.value == "cron") {
                const cron = schedule.value.assertString(`schedule cron`);
                // Validate the cron string
                if (!(0,_cron__WEBPACK_IMPORTED_MODULE_2__.isValidCron)(cron.value)) {
                    context.error(cron, "Invalid cron string");
                }
                result.push({ cron: cron.value });
            }
            else {
                context.error(scheduleKey, `Invalid schedule key`);
            }
        }
        else {
            context.error(mappingToken, "Invalid format for 'schedule'");
        }
    }
    return result;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/handle-errors.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/handle-errors.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   handleTemplateTokenErrors: () => (/* binding */ handleTemplateTokenErrors)
/* harmony export */ });
/* harmony import */ var _templates_tokens_template_token__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templates/tokens/template-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/template-token.js");

function handleTemplateTokenErrors(root, context, defaultValue, f) {
    let r = defaultValue;
    try {
        r = f();
    }
    catch (err) {
        if (err instanceof _templates_tokens_template_token__WEBPACK_IMPORTED_MODULE_0__.TemplateTokenError) {
            context.error(err.token, err);
        }
        else {
            // Report error for the root node
            context.error(root, err);
        }
    }
    return r;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/id-builder.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/id-builder.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IdBuilder: () => (/* binding */ IdBuilder)
/* harmony export */ });
const SEPARATOR = "_";
const MAX_ATTEMPTS = 1000;
const MAX_LENGTH = 100;
class IdBuilder {
    constructor() {
        this.name = [];
        this.distinctNames = new Set();
    }
    appendSegment(value) {
        if (value.length === 0) {
            return;
        }
        if (this.name.length == 0) {
            const first = value[0];
            if (this.isAlpha(first) || first == "_") {
                // Legal first char
            }
            else if (this.isNumeric(first) || first == "-") {
                // Illegal first char, but legal char.
                // Prepend "_".
                this.name.push("_");
            }
            else {
                // Illegal char
            }
        }
        else {
            // Separator
            this.name.push(SEPARATOR);
        }
        for (const c of value) {
            {
                if (this.isAlphaNumeric(c) || c == "_" || c == "-") {
                    // Legal
                    this.name.push(c);
                }
                else {
                    // Illegal
                    this.name.push(SEPARATOR);
                }
            }
        }
    }
    build() {
        const original = this.name.length > 0 ? this.name.join("") : "job";
        let suffix = "";
        for (let attempt = 1; attempt < MAX_ATTEMPTS; attempt++) {
            if (attempt === 1) {
                suffix = "";
            }
            else {
                suffix = `_${attempt}`;
            }
            const candidate = original.substring(0, Math.min(original.length, MAX_LENGTH - suffix.length)) + suffix;
            if (!this.distinctNames.has(candidate)) {
                this.distinctNames.add(candidate);
                this.name = [];
                return candidate;
            }
        }
        throw new Error("Unable to create a unique name");
    }
    /**
     * Adds a known identifier to the set of distinct ids.
     * @param value The value to add
     * @returns An error if the value is invalid, otherwise undefined
     */
    tryAddKnownId(value) {
        if (!value || !this.isValid(value) || value.length >= MAX_LENGTH) {
            return `The identifier '${value}' is invalid. IDs may only contain alphanumeric characters, '_', and '-'. IDs must start with a letter or '_' and and must be less than ${MAX_LENGTH} characters.`;
        }
        if (value.startsWith(SEPARATOR + SEPARATOR)) {
            return `The identifier '${value}' is invalid. IDs starting with '__' are reserved.`;
        }
        if (this.distinctNames.has(value)) {
            return `The identifier '${value}' may not be used more than once within the same scope.`;
        }
        this.distinctNames.add(value);
        return;
    }
    /**
     * A name is valid if it starts with a letter or underscore, and contains only
     * letters, numbers, underscores, and hyphens.
     * @param name The string name to validate
     * @returns Whether the name is valid
     */
    isValid(name) {
        let first = true;
        for (const c of name) {
            if (first) {
                first = false;
                if (!this.isAlpha(c) && c != "_") {
                    return false;
                }
                continue;
            }
            if (!this.isAlphaNumeric(c) && c != "_" && c != "-") {
                return false;
            }
        }
        return true;
    }
    isAlphaNumeric(c) {
        return this.isAlpha(c) || this.isNumeric(c);
    }
    isNumeric(c) {
        return c >= "0" && c <= "9";
    }
    isAlpha(c) {
        return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z");
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/job.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/job.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertJob: () => (/* binding */ convertJob)
/* harmony export */ });
/* harmony import */ var _templates_tokens__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templates/tokens */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../templates/tokens/type-guards */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js");
/* harmony import */ var _concurrency__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./concurrency */ "./node_modules/@actions/workflow-parser/dist/model/converter/concurrency.js");
/* harmony import */ var _container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./container */ "./node_modules/@actions/workflow-parser/dist/model/converter/container.js");
/* harmony import */ var _handle_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./handle-errors */ "./node_modules/@actions/workflow-parser/dist/model/converter/handle-errors.js");
/* harmony import */ var _id_builder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./id-builder */ "./node_modules/@actions/workflow-parser/dist/model/converter/id-builder.js");
/* harmony import */ var _job_environment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./job/environment */ "./node_modules/@actions/workflow-parser/dist/model/converter/job/environment.js");
/* harmony import */ var _job_runs_on__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./job/runs-on */ "./node_modules/@actions/workflow-parser/dist/model/converter/job/runs-on.js");
/* harmony import */ var _steps__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./steps */ "./node_modules/@actions/workflow-parser/dist/model/converter/steps.js");









function convertJob(context, jobKey, token) {
    const error = new _id_builder__WEBPACK_IMPORTED_MODULE_5__.IdBuilder().tryAddKnownId(jobKey.value);
    if (error) {
        context.error(jobKey, error);
    }
    let concurrency, container, env, environment, name, outputs, runsOn, services, strategy;
    let needs = undefined;
    let steps = [];
    let workflowJobRef;
    let workflowJobInputs;
    let inheritSecrets = false;
    let workflowJobSecrets;
    for (const item of token) {
        const propertyName = item.key.assertString("job property name");
        switch (propertyName.value) {
            case "concurrency":
                (0,_handle_errors__WEBPACK_IMPORTED_MODULE_4__.handleTemplateTokenErrors)(item.value, context, undefined, () => (0,_concurrency__WEBPACK_IMPORTED_MODULE_2__.convertConcurrency)(context, item.value));
                concurrency = item.value;
                break;
            case "container":
                (0,_container__WEBPACK_IMPORTED_MODULE_3__.convertToJobContainer)(context, item.value);
                container = item.value;
                break;
            case "env":
                (0,_handle_errors__WEBPACK_IMPORTED_MODULE_4__.handleTemplateTokenErrors)(item.value, context, undefined, () => {
                    env = item.value.assertMapping("job env");
                });
                break;
            case "environment":
                (0,_handle_errors__WEBPACK_IMPORTED_MODULE_4__.handleTemplateTokenErrors)(item.value, context, undefined, () => (0,_job_environment__WEBPACK_IMPORTED_MODULE_6__.convertToActionsEnvironmentRef)(context, item.value));
                environment = item.value;
                break;
            case "name":
                name = item.value.assertScalar("job name");
                break;
            case "needs": {
                needs = [];
                if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isString)(item.value)) {
                    const jobNeeds = item.value.assertString("job needs id");
                    needs.push(jobNeeds);
                }
                if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isSequence)(item.value)) {
                    for (const seqItem of item.value) {
                        const jobNeeds = seqItem.assertString("job needs id");
                        needs.push(jobNeeds);
                    }
                }
                break;
            }
            case "outputs":
                (0,_handle_errors__WEBPACK_IMPORTED_MODULE_4__.handleTemplateTokenErrors)(item.value, context, undefined, () => {
                    outputs = item.value.assertMapping("job outputs");
                });
                break;
            case "runs-on":
                (0,_handle_errors__WEBPACK_IMPORTED_MODULE_4__.handleTemplateTokenErrors)(item.value, context, undefined, () => (0,_job_runs_on__WEBPACK_IMPORTED_MODULE_7__.convertRunsOn)(context, item.value));
                runsOn = item.value;
                break;
            case "services":
                (0,_container__WEBPACK_IMPORTED_MODULE_3__.convertToJobServices)(context, item.value);
                services = item.value;
                break;
            case "steps":
                steps = (0,_steps__WEBPACK_IMPORTED_MODULE_8__.convertSteps)(context, item.value);
                break;
            case "strategy":
                strategy = item.value;
                break;
            case "uses":
                workflowJobRef = item.value.assertString("job uses value");
                break;
            case "with":
                (0,_handle_errors__WEBPACK_IMPORTED_MODULE_4__.handleTemplateTokenErrors)(item.value, context, undefined, () => {
                    workflowJobInputs = item.value.assertMapping("uses-with value");
                });
                break;
            case "secrets":
                if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isString)(item.value) && item.value.value === "inherit") {
                    inheritSecrets = true;
                }
                else {
                    (0,_handle_errors__WEBPACK_IMPORTED_MODULE_4__.handleTemplateTokenErrors)(item.value, context, undefined, () => {
                        workflowJobSecrets = item.value.assertMapping("uses-secrets value");
                    });
                }
                break;
        }
    }
    if (workflowJobRef !== undefined) {
        return {
            type: "reusableWorkflowJob",
            id: jobKey,
            name: jobName(name, jobKey),
            needs: needs || [],
            if: new _templates_tokens__WEBPACK_IMPORTED_MODULE_0__.BasicExpressionToken(undefined, undefined, "success()", undefined, undefined, undefined),
            ref: workflowJobRef,
            "input-definitions": undefined,
            "input-values": workflowJobInputs,
            "secret-definitions": undefined,
            "secret-values": workflowJobSecrets,
            "inherit-secrets": inheritSecrets || undefined,
            outputs: undefined,
            concurrency,
            strategy
        };
    }
    else {
        return {
            type: "job",
            id: jobKey,
            name: jobName(name, jobKey),
            needs,
            if: new _templates_tokens__WEBPACK_IMPORTED_MODULE_0__.BasicExpressionToken(undefined, undefined, "success()", undefined, undefined, undefined),
            env,
            concurrency,
            environment,
            strategy,
            "runs-on": runsOn,
            container,
            services,
            outputs,
            steps
        };
    }
}
function jobName(name, jobKey) {
    if (name === undefined) {
        return jobKey;
    }
    if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isString)(name) && name.value === "") {
        return jobKey;
    }
    return name;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/job/environment.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/job/environment.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertToActionsEnvironmentRef: () => (/* binding */ convertToActionsEnvironmentRef)
/* harmony export */ });
/* harmony import */ var _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../templates/tokens/type-guards */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js");

function convertToActionsEnvironmentRef(context, token) {
    const result = {};
    if (token.isExpression) {
        return result;
    }
    if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isScalar)(token)) {
        result.name = token;
        return result;
    }
    const environmentMapping = token.assertMapping("job environment");
    for (const property of environmentMapping) {
        const propertyName = property.key.assertString("job environment key");
        if (property.key.isExpression || property.value.isExpression) {
            continue;
        }
        switch (propertyName.value) {
            case "name":
                result.name = property.value.assertScalar("job environment name key");
                break;
            case "url":
                result.url = property.value;
                break;
        }
    }
    return result;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/job/inputs.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/job/inputs.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertWorkflowJobInputs: () => (/* binding */ convertWorkflowJobInputs),
/* harmony export */   createTokenMap: () => (/* binding */ createTokenMap)
/* harmony export */ });
function convertWorkflowJobInputs(context, job) {
    const inputDefinitions = createTokenMap(job["input-definitions"]?.assertMapping("workflow job input definitions"), "inputs");
    const inputValues = createTokenMap(job["input-values"]?.assertMapping("workflow job input values"), "with");
    if (inputDefinitions !== undefined) {
        for (const [, [name, value]] of inputDefinitions) {
            const inputSpec = createTokenMap(value.assertMapping(`input ${name}`), `input ${name} key`);
            const inputTypeToken = inputSpec?.get("type")?.[1];
            if (!inputTypeToken) {
                // This should be validated by the template reader per the schema
                continue;
            }
            const inputSet = inputValues !== undefined && inputValues.has(name.toLowerCase());
            const required = inputSpec.get("required")?.[1].assertBoolean(`input ${name} required`).value;
            if (required && !inputSet) {
                context.error(job.ref, `Input ${name} is required, but not provided while calling.`);
            }
        }
    }
    if (inputValues !== undefined) {
        for (const [, [name, value]] of inputValues) {
            if (!inputDefinitions?.has(name.toLowerCase())) {
                context.error(value, `Invalid input, ${name} is not defined in the referenced workflow.`);
            }
        }
    }
}
function createTokenMap(mapping, description) {
    if (!mapping) {
        return undefined;
    }
    const result = new Map();
    for (const item of mapping) {
        const name = item.key.assertString(`${description} key`);
        result.set(name.value.toLowerCase(), [name.value, item.value]);
    }
    return result;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/job/runs-on.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/job/runs-on.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertRunsOn: () => (/* binding */ convertRunsOn)
/* harmony export */ });
/* harmony import */ var _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../templates/tokens/type-guards */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js");

function convertRunsOn(context, token) {
    const labels = convertRunsOnLabels(token);
    if (!(0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isMapping)(token)) {
        return {
            labels,
            group: ""
        };
    }
    let group = "";
    for (const item of token) {
        const key = item.key.assertString("job runs-on property name");
        switch (key.value) {
            case "group": {
                if (item.value.isExpression) {
                    continue;
                }
                const groupName = item.value.assertString("job runs-on group name").value;
                const names = groupName.split("/");
                switch (names.length) {
                    case 1: {
                        group = groupName;
                        break;
                    }
                    case 2: {
                        if (!["org", "organization", "ent", "enterprise"].includes(names[0])) {
                            context.error(item.value, `Invalid runs-on group name '${groupName}. Please use 'organization/' or 'enterprise/' prefix to target a single runner group.'`);
                            continue;
                        }
                        if (!names[1]) {
                            context.error(item.value, `Invalid runs-on group name '${groupName}'.`);
                            continue;
                        }
                        group = groupName;
                        break;
                    }
                    default: {
                        context.error(item.value, `Invalid runs-on group name '${groupName}. Please use 'organization/' or 'enterprise/' prefix to target a single runner group.'`);
                        break;
                    }
                }
                break;
            }
            case "labels": {
                const mapLabels = convertRunsOnLabels(item.value);
                for (const label of mapLabels) {
                    labels.add(label);
                }
                break;
            }
        }
    }
    return {
        labels,
        group
    };
}
function convertRunsOnLabels(token) {
    const labels = new Set();
    if (token.isExpression) {
        return labels;
    }
    if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isString)(token)) {
        labels.add(token.value);
        return labels;
    }
    if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isSequence)(token)) {
        for (const item of token) {
            if (item.isExpression) {
                continue;
            }
            const label = item.assertString("job runs-on label sequence item");
            labels.add(label.value);
        }
    }
    return labels;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/job/secrets.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/job/secrets.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertWorkflowJobSecrets: () => (/* binding */ convertWorkflowJobSecrets)
/* harmony export */ });
/* harmony import */ var _templates_tokens__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../templates/tokens */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _inputs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inputs */ "./node_modules/@actions/workflow-parser/dist/model/converter/job/inputs.js");


function convertWorkflowJobSecrets(context, job) {
    // No validation if job passes all secrets
    if (job["inherit-secrets"]) {
        return;
    }
    const secretDefinitions = (0,_inputs__WEBPACK_IMPORTED_MODULE_1__.createTokenMap)(job["secret-definitions"]?.assertMapping("workflow job secret definitions"), "secrets");
    const secretValues = (0,_inputs__WEBPACK_IMPORTED_MODULE_1__.createTokenMap)(job["secret-values"]?.assertMapping("workflow job secret values"), "secrets");
    if (secretDefinitions !== undefined) {
        for (const [, [name, value]] of secretDefinitions) {
            if (value instanceof _templates_tokens__WEBPACK_IMPORTED_MODULE_0__.NullToken) {
                continue;
            }
            const secretSpec = (0,_inputs__WEBPACK_IMPORTED_MODULE_1__.createTokenMap)(value.assertMapping(`secret ${name}`), `secret ${name} key`);
            const required = secretSpec?.get("required")?.[1].assertBoolean(`secret ${name} required`).value;
            if (required) {
                if (secretValues == undefined || !secretValues.has(name.toLowerCase())) {
                    context.error(job.ref, `Secret ${name} is required, but not provided while calling.`);
                }
            }
        }
    }
    if (secretValues !== undefined) {
        for (const [, [name, value]] of secretValues) {
            if (!secretDefinitions?.has(name.toLowerCase())) {
                context.error(value, `Invalid secret, ${name} is not defined in the referenced workflow.`);
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/jobs.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/jobs.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertJobs: () => (/* binding */ convertJobs)
/* harmony export */ });
/* harmony import */ var _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templates/tokens/type-guards */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js");
/* harmony import */ var _handle_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./handle-errors */ "./node_modules/@actions/workflow-parser/dist/model/converter/handle-errors.js");
/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./job */ "./node_modules/@actions/workflow-parser/dist/model/converter/job.js");



function convertJobs(context, token) {
    if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isMapping)(token)) {
        const result = [];
        const jobsWithSatisfiedNeeds = [];
        const alljobsWithUnsatisfiedNeeds = [];
        for (const item of token) {
            const jobKey = item.key.assertString("job name");
            const jobDef = item.value.assertMapping(`job ${jobKey.value}`);
            const job = (0,_handle_errors__WEBPACK_IMPORTED_MODULE_1__.handleTemplateTokenErrors)(token, context, undefined, () => (0,_job__WEBPACK_IMPORTED_MODULE_2__.convertJob)(context, jobKey, jobDef));
            if (job) {
                result.push(job);
                const node = {
                    name: job.id.value,
                    needs: Object.assign([], job.needs)
                };
                if (node.needs.length > 0) {
                    alljobsWithUnsatisfiedNeeds.push(node);
                }
                else {
                    jobsWithSatisfiedNeeds.push(node);
                }
            }
        }
        //validate job needs
        validateNeeds(token, context, result, jobsWithSatisfiedNeeds, alljobsWithUnsatisfiedNeeds);
        return result;
    }
    context.error(token, "Invalid format for jobs");
    return [];
}
function validateNeeds(token, context, result, jobsWithSatisfiedNeeds, alljobsWithUnsatisfiedNeeds) {
    if (jobsWithSatisfiedNeeds.length == 0) {
        context.error(token, "The workflow must contain at least one job with no dependencies.");
        return;
    }
    // Figure out which nodes would start after current completes
    while (jobsWithSatisfiedNeeds.length > 0) {
        const currentJob = jobsWithSatisfiedNeeds.shift();
        if (currentJob == undefined) {
            break;
        }
        for (let i = alljobsWithUnsatisfiedNeeds.length - 1; i >= 0; i--) {
            const unsatisfiedJob = alljobsWithUnsatisfiedNeeds[i];
            for (let j = unsatisfiedJob.needs.length - 1; j >= 0; j--) {
                const need = unsatisfiedJob.needs[j];
                if (need.value == currentJob.name) {
                    unsatisfiedJob.needs.splice(j, 1);
                    if (unsatisfiedJob.needs.length == 0) {
                        jobsWithSatisfiedNeeds.push(unsatisfiedJob);
                        alljobsWithUnsatisfiedNeeds.splice(i, 1);
                    }
                }
            }
        }
    }
    // Check whether some jobs will never execute
    if (alljobsWithUnsatisfiedNeeds.length > 0) {
        const jobNames = result.map(x => x.id.value);
        for (const unsatisfiedJob of alljobsWithUnsatisfiedNeeds) {
            for (const need of unsatisfiedJob.needs) {
                if (jobNames.includes(need.value)) {
                    context.error(need, `Job '${unsatisfiedJob.name}' depends on job '${need.value}' which creates a cycle in the dependency graph.`);
                }
                else {
                    context.error(need, `Job '${unsatisfiedJob.name}' depends on unknown job '${need.value}'.`);
                }
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/referencedWorkflow.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/referencedWorkflow.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertReferencedWorkflow: () => (/* binding */ convertReferencedWorkflow)
/* harmony export */ });
/* harmony import */ var _templates_tokens_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templates/tokens/types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");
/* harmony import */ var _handle_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./handle-errors */ "./node_modules/@actions/workflow-parser/dist/model/converter/handle-errors.js");
/* harmony import */ var _job_inputs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./job/inputs */ "./node_modules/@actions/workflow-parser/dist/model/converter/job/inputs.js");
/* harmony import */ var _job_secrets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./job/secrets */ "./node_modules/@actions/workflow-parser/dist/model/converter/job/secrets.js");
/* harmony import */ var _jobs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jobs */ "./node_modules/@actions/workflow-parser/dist/model/converter/jobs.js");





function convertReferencedWorkflow(context, referencedWorkflow, job) {
    const mapping = referencedWorkflow.assertMapping("root");
    // The language service doesn't currently handles on other documents,
    // So use the ref in the original workflow as the error location
    const tokenForErrors = job.ref;
    for (const pair of mapping) {
        const key = pair.key.assertString("root key");
        switch (key.value) {
            case "on": {
                (0,_handle_errors__WEBPACK_IMPORTED_MODULE_1__.handleTemplateTokenErrors)(tokenForErrors, context, undefined, () => convertReferencedWorkflowOn(context, pair.value, job));
                break;
            }
            case "jobs": {
                job.jobs = (0,_handle_errors__WEBPACK_IMPORTED_MODULE_1__.handleTemplateTokenErrors)(tokenForErrors, context, [], () => (0,_jobs__WEBPACK_IMPORTED_MODULE_4__.convertJobs)(context, pair.value));
                break;
            }
        }
    }
}
function convertReferencedWorkflowOn(context, on, job) {
    const tokenForErrors = job.ref;
    switch (on.templateTokenType) {
        case _templates_tokens_types__WEBPACK_IMPORTED_MODULE_0__.TokenType.String: {
            const event = on.assertString("Reference workflow on value").value;
            if (event === "workflow_call") {
                (0,_handle_errors__WEBPACK_IMPORTED_MODULE_1__.handleTemplateTokenErrors)(tokenForErrors, context, undefined, () => (0,_job_inputs__WEBPACK_IMPORTED_MODULE_2__.convertWorkflowJobInputs)(context, job));
                (0,_handle_errors__WEBPACK_IMPORTED_MODULE_1__.handleTemplateTokenErrors)(tokenForErrors, context, undefined, () => (0,_job_secrets__WEBPACK_IMPORTED_MODULE_3__.convertWorkflowJobSecrets)(context, job));
                return;
            }
            break;
        }
        case _templates_tokens_types__WEBPACK_IMPORTED_MODULE_0__.TokenType.Sequence: {
            const events = on.assertSequence("Reference workflow on value");
            for (const eventToken of events) {
                const event = eventToken.assertString(`Reference workflow on value ${eventToken}`).value;
                if (event === "workflow_call") {
                    (0,_handle_errors__WEBPACK_IMPORTED_MODULE_1__.handleTemplateTokenErrors)(tokenForErrors, context, undefined, () => (0,_job_inputs__WEBPACK_IMPORTED_MODULE_2__.convertWorkflowJobInputs)(context, job));
                    (0,_handle_errors__WEBPACK_IMPORTED_MODULE_1__.handleTemplateTokenErrors)(tokenForErrors, context, undefined, () => (0,_job_secrets__WEBPACK_IMPORTED_MODULE_3__.convertWorkflowJobSecrets)(context, job));
                    return;
                }
            }
            break;
        }
        case _templates_tokens_types__WEBPACK_IMPORTED_MODULE_0__.TokenType.Mapping: {
            const eventMapping = on.assertMapping("Reference workflow on value");
            for (const pair of eventMapping) {
                const event = pair.key.assertString(`Reference workflow on value ${pair.key}`).value;
                if (event !== "workflow_call") {
                    continue;
                }
                if (pair.value.templateTokenType === _templates_tokens_types__WEBPACK_IMPORTED_MODULE_0__.TokenType.Null) {
                    (0,_handle_errors__WEBPACK_IMPORTED_MODULE_1__.handleTemplateTokenErrors)(tokenForErrors, context, undefined, () => (0,_job_inputs__WEBPACK_IMPORTED_MODULE_2__.convertWorkflowJobInputs)(context, job));
                    (0,_handle_errors__WEBPACK_IMPORTED_MODULE_1__.handleTemplateTokenErrors)(tokenForErrors, context, undefined, () => (0,_job_secrets__WEBPACK_IMPORTED_MODULE_3__.convertWorkflowJobSecrets)(context, job));
                    return;
                }
                const definitions = pair.value.assertMapping(`Reference workflow on value ${pair.key}`);
                for (const definition of definitions) {
                    const definitionKey = definition.key.assertString(`on-workflow_call-${definition.key}`).value;
                    switch (definitionKey) {
                        case "inputs":
                            job["input-definitions"] = definition.value.assertMapping(`on-workflow_call-${definition.key}`);
                            break;
                        case "outputs":
                            job.outputs = definition.value.assertMapping(`on-workflow_call-${definition.key}`);
                            break;
                        case "secrets":
                            job["secret-definitions"] = definition.value.assertMapping(`on-workflow_call-${definition.key}`);
                            break;
                    }
                }
                (0,_handle_errors__WEBPACK_IMPORTED_MODULE_1__.handleTemplateTokenErrors)(tokenForErrors, context, undefined, () => (0,_job_inputs__WEBPACK_IMPORTED_MODULE_2__.convertWorkflowJobInputs)(context, job));
                (0,_handle_errors__WEBPACK_IMPORTED_MODULE_1__.handleTemplateTokenErrors)(tokenForErrors, context, undefined, () => (0,_job_secrets__WEBPACK_IMPORTED_MODULE_3__.convertWorkflowJobSecrets)(context, job));
                return;
            }
            break;
        }
    }
    context.error(tokenForErrors, "workflow_call key is not defined in the referenced workflow.");
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/steps.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/steps.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertSteps: () => (/* binding */ convertSteps)
/* harmony export */ });
/* harmony import */ var _templates_tokens__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templates/tokens */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../templates/tokens/type-guards */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js");
/* harmony import */ var _type_guards__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type-guards */ "./node_modules/@actions/workflow-parser/dist/model/type-guards.js");
/* harmony import */ var _handle_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./handle-errors */ "./node_modules/@actions/workflow-parser/dist/model/converter/handle-errors.js");
/* harmony import */ var _id_builder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./id-builder */ "./node_modules/@actions/workflow-parser/dist/model/converter/id-builder.js");





function convertSteps(context, steps) {
    if (!(0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_1__.isSequence)(steps)) {
        context.error(steps, "Invalid format for steps");
        return [];
    }
    const idBuilder = new _id_builder__WEBPACK_IMPORTED_MODULE_4__.IdBuilder();
    const result = [];
    for (const item of steps) {
        const step = (0,_handle_errors__WEBPACK_IMPORTED_MODULE_3__.handleTemplateTokenErrors)(steps, context, undefined, () => convertStep(context, idBuilder, item));
        if (step) {
            result.push(step);
        }
    }
    for (const step of result) {
        if (step.id) {
            continue;
        }
        let id = "";
        if ((0,_type_guards__WEBPACK_IMPORTED_MODULE_2__.isActionStep)(step)) {
            id = createActionStepId(step);
        }
        if (!id) {
            id = "run";
        }
        idBuilder.appendSegment(`__${id}`);
        step.id = idBuilder.build();
    }
    return result;
}
function convertStep(context, idBuilder, step) {
    const mapping = step.assertMapping("steps item");
    let run;
    let id;
    let name;
    let uses;
    let continueOnError;
    let env;
    const ifCondition = new _templates_tokens__WEBPACK_IMPORTED_MODULE_0__.BasicExpressionToken(undefined, undefined, "success()", undefined, undefined, undefined);
    for (const item of mapping) {
        const key = item.key.assertString("steps item key");
        switch (key.value) {
            case "id":
                id = item.value.assertString("steps item id");
                if (id) {
                    const error = idBuilder.tryAddKnownId(id.value);
                    if (error) {
                        context.error(id, error);
                    }
                }
                break;
            case "name":
                name = item.value.assertScalar("steps item name");
                break;
            case "run":
                run = item.value.assertScalar("steps item run");
                break;
            case "uses":
                uses = item.value.assertString("steps item uses");
                break;
            case "env":
                env = item.value.assertMapping("step env");
                break;
            case "continue-on-error":
                if (!item.value.isExpression) {
                    continueOnError = item.value.assertBoolean("steps item continue-on-error").value;
                }
                else {
                    continueOnError = item.value.assertScalar("steps item continue-on-error");
                }
        }
    }
    if (run) {
        return {
            id: id?.value || "",
            name,
            if: ifCondition,
            "continue-on-error": continueOnError,
            env,
            run
        };
    }
    if (uses) {
        return {
            id: id?.value || "",
            name,
            if: ifCondition,
            "continue-on-error": continueOnError,
            env,
            uses
        };
    }
    context.error(step, "Expected uses or run to be defined");
}
function createActionStepId(step) {
    const uses = step.uses.value;
    if (uses.startsWith("docker://")) {
        return uses.substring("docker://".length);
    }
    if (uses.startsWith("./") || uses.startsWith(".\\")) {
        return "self";
    }
    const segments = uses.split("@");
    if (segments.length != 2) {
        return "";
    }
    const pathSegments = segments[0].split(/[\\/]/).filter(s => s.length > 0);
    const gitRef = segments[1];
    if (pathSegments.length >= 2 && pathSegments[0] && pathSegments[1] && gitRef) {
        return `${pathSegments[0]}/${pathSegments[1]}`;
    }
    return "";
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/string-list.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/string-list.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertStringList: () => (/* binding */ convertStringList)
/* harmony export */ });
function convertStringList(name, token) {
    const result = [];
    for (const item of token) {
        result.push(item.assertString(`${name} item`).value);
    }
    return result;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/workflow-call.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/workflow-call.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertEventWorkflowCall: () => (/* binding */ convertEventWorkflowCall),
/* harmony export */   convertWorkflowInput: () => (/* binding */ convertWorkflowInput),
/* harmony export */   convertWorkflowInputs: () => (/* binding */ convertWorkflowInputs)
/* harmony export */ });
/* harmony import */ var _templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templates/tokens/type-guards */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js");
/* harmony import */ var _workflow_template__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../workflow-template */ "./node_modules/@actions/workflow-parser/dist/model/workflow-template.js");
/* harmony import */ var _string_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./string-list */ "./node_modules/@actions/workflow-parser/dist/model/converter/string-list.js");



function convertEventWorkflowCall(context, token) {
    const result = {};
    for (const item of token) {
        const key = item.key.assertString("workflow dispatch input key");
        switch (key.value) {
            case "inputs":
                result.inputs = convertWorkflowInputs(context, item.value.assertMapping("workflow dispatch inputs"));
                break;
            case "secrets":
                result.secrets = convertWorkflowCallSecrets(context, item.value.assertMapping("workflow dispatch inputs"));
                break;
            case "outputs":
                // TODO - outputs
                break;
        }
    }
    return result;
}
function convertWorkflowInputs(context, token) {
    const result = {};
    for (const item of token) {
        const inputName = item.key.assertString("input name");
        const inputMapping = item.value.assertMapping("input configuration");
        result[inputName.value] = convertWorkflowInput(context, inputMapping);
    }
    return result;
}
function convertWorkflowInput(context, token) {
    const result = {
        type: _workflow_template__WEBPACK_IMPORTED_MODULE_1__.InputType.string // Default to string
    };
    let defaultValue;
    for (const item of token) {
        const key = item.key.assertString("workflow dispatch input key");
        switch (key.value) {
            case "description":
                result.description = item.value.assertString("input description").value;
                break;
            case "required":
                result.required = item.value.assertBoolean("input required").value;
                break;
            case "default":
                defaultValue = item.value.assertScalar("input default");
                break;
            case "type":
                result.type = _workflow_template__WEBPACK_IMPORTED_MODULE_1__.InputType[item.value.assertString("input type").value];
                break;
            case "options":
                result.options = (0,_string_list__WEBPACK_IMPORTED_MODULE_2__.convertStringList)("input options", item.value.assertSequence("input options"));
                break;
            default:
                context.error(item.key, `Invalid key '${key.value}'`);
        }
    }
    // Validate default value
    if (defaultValue !== undefined && !defaultValue.isExpression) {
        try {
            switch (result.type) {
                case _workflow_template__WEBPACK_IMPORTED_MODULE_1__.InputType.boolean:
                    result.default = defaultValue.assertBoolean("input default").value;
                    break;
                case _workflow_template__WEBPACK_IMPORTED_MODULE_1__.InputType.string:
                case _workflow_template__WEBPACK_IMPORTED_MODULE_1__.InputType.choice:
                case _workflow_template__WEBPACK_IMPORTED_MODULE_1__.InputType.environment:
                    result.default = defaultValue.assertString("input default").value;
                    break;
            }
        }
        catch (e) {
            context.error(defaultValue, e);
        }
    }
    // Validate `options` for `choice` type
    if (result.type === _workflow_template__WEBPACK_IMPORTED_MODULE_1__.InputType.choice) {
        if (result.options === undefined || result.options.length === 0) {
            context.error(token, "Missing 'options' for choice input");
        }
    }
    else {
        if (result.options !== undefined) {
            context.error(token, "Input type is not 'choice', but 'options' is defined");
        }
    }
    return result;
}
function convertWorkflowCallSecrets(context, token) {
    const result = {};
    for (const item of token) {
        const secretName = item.key.assertString("secret name");
        result[secretName.value] = convertWorkflowCallSecret(context, item.value);
    }
    return result;
}
function convertWorkflowCallSecret(context, token) {
    const result = {};
    if ((0,_templates_tokens_type_guards__WEBPACK_IMPORTED_MODULE_0__.isMapping)(token)) {
        for (const item of token) {
            const key = item.key.assertString("workflow call secret key");
            switch (key.value) {
                case "description":
                    result.description = item.value.assertString("secret description").value;
                    break;
                case "required":
                    result.required = item.value.assertBoolean("secret required").value;
                    break;
            }
        }
    }
    return result;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/converter/workflow-dispatch.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/converter/workflow-dispatch.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertEventWorkflowDispatchInputs: () => (/* binding */ convertEventWorkflowDispatchInputs),
/* harmony export */   convertWorkflowDispatchInput: () => (/* binding */ convertWorkflowDispatchInput),
/* harmony export */   convertWorkflowDispatchInputs: () => (/* binding */ convertWorkflowDispatchInputs)
/* harmony export */ });
/* harmony import */ var _workflow_template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../workflow-template */ "./node_modules/@actions/workflow-parser/dist/model/workflow-template.js");
/* harmony import */ var _string_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string-list */ "./node_modules/@actions/workflow-parser/dist/model/converter/string-list.js");


function convertEventWorkflowDispatchInputs(context, token) {
    const result = {};
    for (const item of token) {
        const key = item.key.assertString("workflow dispatch input key");
        switch (key.value) {
            case "inputs":
                result.inputs = convertWorkflowDispatchInputs(context, item.value.assertMapping("workflow dispatch inputs"));
                break;
        }
    }
    return result;
}
function convertWorkflowDispatchInputs(context, token) {
    const result = {};
    for (const item of token) {
        const inputName = item.key.assertString("input name");
        const inputMapping = item.value.assertMapping("input configuration");
        result[inputName.value] = convertWorkflowDispatchInput(context, inputMapping);
    }
    return result;
}
function convertWorkflowDispatchInput(context, token) {
    const result = {
        type: _workflow_template__WEBPACK_IMPORTED_MODULE_0__.InputType.string // Default to string
    };
    let defaultValue;
    for (const item of token) {
        const key = item.key.assertString("workflow dispatch input key");
        switch (key.value) {
            case "description":
                result.description = item.value.assertString("input description").value;
                break;
            case "required":
                result.required = item.value.assertBoolean("input required").value;
                break;
            case "default":
                defaultValue = item.value.assertScalar("input default");
                break;
            case "type":
                result.type = _workflow_template__WEBPACK_IMPORTED_MODULE_0__.InputType[item.value.assertString("input type").value];
                break;
            case "options":
                result.options = (0,_string_list__WEBPACK_IMPORTED_MODULE_1__.convertStringList)("input options", item.value.assertSequence("input options"));
                break;
            default:
                context.error(item.key, `Invalid key '${key.value}'`);
        }
    }
    // Validate default value
    if (defaultValue !== undefined) {
        try {
            switch (result.type) {
                case _workflow_template__WEBPACK_IMPORTED_MODULE_0__.InputType.boolean:
                    result.default = defaultValue.assertBoolean("input default").value;
                    break;
                case _workflow_template__WEBPACK_IMPORTED_MODULE_0__.InputType.string:
                case _workflow_template__WEBPACK_IMPORTED_MODULE_0__.InputType.choice:
                case _workflow_template__WEBPACK_IMPORTED_MODULE_0__.InputType.environment:
                    result.default = defaultValue.assertString("input default").value;
                    break;
            }
        }
        catch (e) {
            context.error(defaultValue, e);
        }
    }
    // Validate `options` for `choice` type
    if (result.type === _workflow_template__WEBPACK_IMPORTED_MODULE_0__.InputType.choice) {
        if (result.options === undefined || result.options.length === 0) {
            context.error(token, "Missing 'options' for choice input");
        }
    }
    else {
        if (result.options !== undefined) {
            context.error(token, "Input type is not 'choice', but 'options' is defined");
        }
    }
    return result;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/type-guards.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/type-guards.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isActionStep: () => (/* binding */ isActionStep),
/* harmony export */   isJob: () => (/* binding */ isJob),
/* harmony export */   isReusableWorkflowJob: () => (/* binding */ isReusableWorkflowJob),
/* harmony export */   isRunStep: () => (/* binding */ isRunStep)
/* harmony export */ });
function isRunStep(step) {
    return step.run !== undefined;
}
function isActionStep(step) {
    return step.uses !== undefined;
}
function isJob(job) {
    return job.type === "job";
}
function isReusableWorkflowJob(job) {
    return job.type === "reusableWorkflowJob";
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/model/workflow-template.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/model/workflow-template.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InputType: () => (/* binding */ InputType)
/* harmony export */ });
var InputType;
(function (InputType) {
    InputType["string"] = "string";
    InputType["choice"] = "choice";
    InputType["boolean"] = "boolean";
    InputType["environment"] = "environment";
})(InputType || (InputType = {}));


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/allowed-context.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/allowed-context.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   splitAllowedContext: () => (/* binding */ splitAllowedContext)
/* harmony export */ });
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");

function splitAllowedContext(allowedContext) {
    const FUNCTION_REGEXP = /^([a-zA-Z0-9_]+)\(([0-9]+),([0-9]+|MAX)\)$/;
    const namedContexts = [];
    const functions = [];
    if (allowedContext.length > 0) {
        for (const contextItem of allowedContext) {
            const match = contextItem.match(FUNCTION_REGEXP);
            if (match) {
                const functionName = match[1];
                const minParameters = Number.parseInt(match[2]);
                const maxParametersRaw = match[3];
                const maxParameters = maxParametersRaw === _template_constants__WEBPACK_IMPORTED_MODULE_0__.MAX_CONSTANT ? Number.MAX_SAFE_INTEGER : Number.parseInt(maxParametersRaw);
                functions.push({
                    name: functionName,
                    minArgs: minParameters,
                    maxArgs: maxParameters
                });
            }
            else {
                namedContexts.push(contextItem);
            }
        }
    }
    return {
        namedContexts: namedContexts,
        functions: functions
    };
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/json-object-reader.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/json-object-reader.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JSONObjectReader: () => (/* binding */ JSONObjectReader)
/* harmony export */ });
/* harmony import */ var _parse_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-event */ "./node_modules/@actions/workflow-parser/dist/templates/parse-event.js");
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokens */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");


class JSONObjectReader {
    constructor(fileId, input) {
        this._fileId = fileId;
        const value = JSON.parse(input);
        this._generator = this.getParseEvents(value, true);
        this._current = this._generator.next();
    }
    allowLiteral() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.Literal) {
                this._current = this._generator.next();
                return parseEvent.token;
            }
        }
        return undefined;
    }
    allowSequenceStart() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.SequenceStart) {
                this._current = this._generator.next();
                return parseEvent.token;
            }
        }
        return undefined;
    }
    allowSequenceEnd() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.SequenceEnd) {
                this._current = this._generator.next();
                return true;
            }
        }
        return false;
    }
    allowMappingStart() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.MappingStart) {
                this._current = this._generator.next();
                return parseEvent.token;
            }
        }
        return undefined;
    }
    allowMappingEnd() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.MappingEnd) {
                this._current = this._generator.next();
                return true;
            }
        }
        return false;
    }
    validateEnd() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.DocumentEnd) {
                this._current = this._generator.next();
                return;
            }
        }
        throw new Error("Expected end of reader");
    }
    validateStart() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.DocumentStart) {
                this._current = this._generator.next();
                return;
            }
        }
        throw new Error("Expected start of reader");
    }
    /**
     * Returns all tokens (depth first)
     */
    *getParseEvents(value, root) {
        if (root) {
            yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.DocumentStart, undefined);
        }
        switch (typeof value) {
            case "undefined":
                yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.Literal, new _tokens__WEBPACK_IMPORTED_MODULE_1__.NullToken(this._fileId, undefined, undefined));
                break;
            case "boolean":
                yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.Literal, new _tokens__WEBPACK_IMPORTED_MODULE_1__.BooleanToken(this._fileId, undefined, value, undefined));
                break;
            case "number":
                yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.Literal, new _tokens__WEBPACK_IMPORTED_MODULE_1__.NumberToken(this._fileId, undefined, value, undefined));
                break;
            case "string":
                yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.Literal, new _tokens__WEBPACK_IMPORTED_MODULE_1__.StringToken(this._fileId, undefined, value, undefined));
                break;
            case "object":
                // null
                if (value === null) {
                    yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.Literal, new _tokens__WEBPACK_IMPORTED_MODULE_1__.NullToken(this._fileId, undefined, undefined));
                }
                // array
                else if (Array.isArray(value)) {
                    yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.SequenceStart, new _tokens__WEBPACK_IMPORTED_MODULE_1__.SequenceToken(this._fileId, undefined, undefined));
                    for (const item of value) {
                        for (const e of this.getParseEvents(item)) {
                            yield e;
                        }
                    }
                    yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.SequenceEnd, undefined);
                }
                // object
                else {
                    yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.MappingStart, new _tokens__WEBPACK_IMPORTED_MODULE_1__.MappingToken(this._fileId, undefined, undefined));
                    for (const key of Object.keys(value)) {
                        yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.Literal, new _tokens__WEBPACK_IMPORTED_MODULE_1__.StringToken(this._fileId, undefined, key, undefined));
                        for (const e of this.getParseEvents(value[key])) {
                            yield e;
                        }
                    }
                    yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.MappingEnd, undefined);
                }
                break;
            default:
                throw new Error(`Unexpected value type '${typeof value}' when reading object`);
        }
        if (root) {
            yield new _parse_event__WEBPACK_IMPORTED_MODULE_0__.ParseEvent(_parse_event__WEBPACK_IMPORTED_MODULE_0__.EventType.DocumentEnd, undefined);
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/parse-event.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/parse-event.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventType: () => (/* binding */ EventType),
/* harmony export */   ParseEvent: () => (/* binding */ ParseEvent)
/* harmony export */ });
class ParseEvent {
    constructor(type, token) {
        this.type = type;
        this.token = token;
    }
}
var EventType;
(function (EventType) {
    EventType[EventType["Literal"] = 0] = "Literal";
    EventType[EventType["SequenceStart"] = 1] = "SequenceStart";
    EventType[EventType["SequenceEnd"] = 2] = "SequenceEnd";
    EventType[EventType["MappingStart"] = 3] = "MappingStart";
    EventType[EventType["MappingEnd"] = 4] = "MappingEnd";
    EventType[EventType["DocumentStart"] = 5] = "DocumentStart";
    EventType[EventType["DocumentEnd"] = 6] = "DocumentEnd";
})(EventType || (EventType = {}));


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/boolean-definition.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/boolean-definition.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BooleanDefinition: () => (/* binding */ BooleanDefinition)
/* harmony export */ });
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _tokens_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tokens/types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");
/* harmony import */ var _definition_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definition-type */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-type.js");
/* harmony import */ var _scalar_definition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scalar-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/scalar-definition.js");




class BooleanDefinition extends _scalar_definition__WEBPACK_IMPORTED_MODULE_3__.ScalarDefinition {
    constructor(key, definition) {
        super(key, definition);
        if (definition) {
            for (const definitionPair of definition) {
                const definitionKey = definitionPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`);
                switch (definitionKey.value) {
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.BOOLEAN: {
                        const mapping = definitionPair.value.assertMapping(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.BOOLEAN}`);
                        for (const mappingPair of mapping) {
                            const mappingKey = mappingPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.BOOLEAN} key`);
                            switch (mappingKey.value) {
                                default:
                                    // throws
                                    mappingKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.BOOLEAN} key`);
                                    break;
                            }
                        }
                        break;
                    }
                    default:
                        definitionKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`); // throws
                }
            }
        }
    }
    get definitionType() {
        return _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.Boolean;
    }
    isMatch(literal) {
        return literal.templateTokenType === _tokens_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Boolean;
    }
    validate() {
        // no-op
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-info.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/definition-info.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefinitionInfo: () => (/* binding */ DefinitionInfo)
/* harmony export */ });
class DefinitionInfo {
    constructor(schemaOrParent, nameOrDefinition) {
        this.isDefinitionInfo = true;
        const parent = schemaOrParent?.isDefinitionInfo === true
            ? schemaOrParent
            : undefined;
        this._schema = parent === undefined ? schemaOrParent : parent._schema;
        // Lookup the definition if a key was passed in
        this.definition =
            typeof nameOrDefinition === "string" ? this._schema.getDefinition(nameOrDefinition) : nameOrDefinition;
        // Record allowed context
        if (this.definition.readerContext.length > 0) {
            this.allowedContext = [];
            // Copy parent allowed context
            const upperSeen = {};
            for (const context of parent?.allowedContext ?? []) {
                this.allowedContext.push(context);
                upperSeen[context.toUpperCase()] = true;
            }
            // Append context if unseen
            for (const context of this.definition.readerContext) {
                const upper = context.toUpperCase();
                if (!upperSeen[upper]) {
                    this.allowedContext.push(context);
                    upperSeen[upper] = true;
                }
            }
        }
        else {
            this.allowedContext = parent?.allowedContext ?? [];
        }
    }
    getScalarDefinitions() {
        return this._schema.getScalarDefinitions(this.definition);
    }
    getDefinitionsOfType(type) {
        return this._schema.getDefinitionsOfType(this.definition, type);
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-type.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/definition-type.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefinitionType: () => (/* binding */ DefinitionType)
/* harmony export */ });
var DefinitionType;
(function (DefinitionType) {
    DefinitionType[DefinitionType["Null"] = 0] = "Null";
    DefinitionType[DefinitionType["Boolean"] = 1] = "Boolean";
    DefinitionType[DefinitionType["Number"] = 2] = "Number";
    DefinitionType[DefinitionType["String"] = 3] = "String";
    DefinitionType[DefinitionType["Sequence"] = 4] = "Sequence";
    DefinitionType[DefinitionType["Mapping"] = 5] = "Mapping";
    DefinitionType[DefinitionType["OneOf"] = 6] = "OneOf";
    DefinitionType[DefinitionType["AllowedValues"] = 7] = "AllowedValues";
})(DefinitionType || (DefinitionType = {}));


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/definition.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Definition: () => (/* binding */ Definition)
/* harmony export */ });
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");

/**
 * Defines the allowable schema for a user defined type
 */
class Definition {
    constructor(key, definition) {
        /**
         * Used by the template reader to determine allowed expression values and functions.
         * Also used by the template reader to validate function min/max parameters.
         */
        this.readerContext = [];
        /**
         * Used by the template evaluator to determine allowed expression values and functions.
         * The min/max parameter info is omitted.
         */
        this.evaluatorContext = [];
        this.key = key;
        if (definition) {
            for (let i = 0; i < definition.count;) {
                const definitionKey = definition.get(i).key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`);
                switch (definitionKey.value) {
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.CONTEXT: {
                        const context = definition.get(i).value.assertSequence(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.CONTEXT}`);
                        definition.remove(i);
                        const seenReaderContext = {};
                        const seenEvaluatorContext = {};
                        for (const item of context) {
                            const itemStr = item.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.CONTEXT} item`).value;
                            const upperItemStr = itemStr.toUpperCase();
                            if (seenReaderContext[upperItemStr]) {
                                throw new Error(`Duplicate context item '${itemStr}'`);
                            }
                            seenReaderContext[upperItemStr] = true;
                            this.readerContext.push(itemStr);
                            // Remove min/max parameter info
                            const paramIndex = itemStr.indexOf("(");
                            const modifiedItemStr = paramIndex > 0 ? itemStr.substr(0, paramIndex + 1) + ")" : itemStr;
                            const upperModifiedItemStr = modifiedItemStr.toUpperCase();
                            if (seenEvaluatorContext[upperModifiedItemStr]) {
                                throw new Error(`Duplicate context item '${modifiedItemStr}'`);
                            }
                            seenEvaluatorContext[upperModifiedItemStr] = true;
                            this.evaluatorContext.push(modifiedItemStr);
                        }
                        break;
                    }
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.DESCRIPTION: {
                        const value = definition.get(i).value;
                        this.description = value.assertString(_template_constants__WEBPACK_IMPORTED_MODULE_0__.DESCRIPTION).value;
                        definition.remove(i);
                        break;
                    }
                    default: {
                        i++;
                        break;
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TemplateSchema: () => (/* reexport safe */ _template_schema__WEBPACK_IMPORTED_MODULE_0__.TemplateSchema)
/* harmony export */ });
/* harmony import */ var _template_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./template-schema */ "./node_modules/@actions/workflow-parser/dist/templates/schema/template-schema.js");



/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/mapping-definition.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/mapping-definition.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MappingDefinition: () => (/* binding */ MappingDefinition)
/* harmony export */ });
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition.js");
/* harmony import */ var _definition_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definition-type */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-type.js");
/* harmony import */ var _property_definition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./property-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/property-definition.js");




class MappingDefinition extends _definition__WEBPACK_IMPORTED_MODULE_1__.Definition {
    constructor(key, definition) {
        super(key, definition);
        this.properties = {};
        this.looseKeyType = "";
        this.looseValueType = "";
        if (definition) {
            for (const definitionPair of definition) {
                const definitionKey = definitionPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`);
                switch (definitionKey.value) {
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING: {
                        const mapping = definitionPair.value.assertMapping(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING}`);
                        for (const mappingPair of mapping) {
                            const mappingKey = mappingPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING} key`);
                            switch (mappingKey.value) {
                                case _template_constants__WEBPACK_IMPORTED_MODULE_0__.PROPERTIES: {
                                    const properties = mappingPair.value.assertMapping(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.PROPERTIES}`);
                                    for (const propertiesPair of properties) {
                                        const propertyName = propertiesPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.PROPERTIES} key`);
                                        this.properties[propertyName.value] = new _property_definition__WEBPACK_IMPORTED_MODULE_3__.PropertyDefinition(propertiesPair.value);
                                    }
                                    break;
                                }
                                case _template_constants__WEBPACK_IMPORTED_MODULE_0__.LOOSE_KEY_TYPE: {
                                    const looseKeyType = mappingPair.value.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.LOOSE_KEY_TYPE}`);
                                    this.looseKeyType = looseKeyType.value;
                                    break;
                                }
                                case _template_constants__WEBPACK_IMPORTED_MODULE_0__.LOOSE_VALUE_TYPE: {
                                    const looseValueType = mappingPair.value.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.LOOSE_VALUE_TYPE}`);
                                    this.looseValueType = looseValueType.value;
                                    break;
                                }
                                default:
                                    // throws
                                    mappingKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING} key`);
                                    break;
                            }
                        }
                        break;
                    }
                    default:
                        definitionKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`); // throws
                }
            }
        }
    }
    get definitionType() {
        return _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.Mapping;
    }
    validate(schema, name) {
        // Lookup loose key type
        if (this.looseKeyType) {
            schema.getDefinition(this.looseKeyType);
            // Lookup loose value type
            if (this.looseValueType) {
                schema.getDefinition(this.looseValueType);
            }
            else {
                throw new Error(`Property '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.LOOSE_KEY_TYPE}' is defined but '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.LOOSE_VALUE_TYPE}' is not defined on '${name}'`);
            }
        }
        // Otherwise validate loose value type not be defined
        else if (this.looseValueType) {
            throw new Error(`Property '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.LOOSE_VALUE_TYPE}' is defined but '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.LOOSE_KEY_TYPE}' is not defined on '${name}'`);
        }
        // Lookup each property
        for (const propertyName of Object.keys(this.properties)) {
            const propertyDef = this.properties[propertyName];
            if (!propertyDef.type) {
                throw new Error(`Type not specified for the property '${propertyName}' on '${name}'`);
            }
            schema.getDefinition(propertyDef.type);
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/null-definition.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/null-definition.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NullDefinition: () => (/* binding */ NullDefinition)
/* harmony export */ });
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _definition_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definition-type */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-type.js");
/* harmony import */ var _scalar_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scalar-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/scalar-definition.js");
/* harmony import */ var _tokens_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tokens/types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");




class NullDefinition extends _scalar_definition__WEBPACK_IMPORTED_MODULE_2__.ScalarDefinition {
    constructor(key, definition) {
        super(key, definition);
        if (definition) {
            for (const definitionPair of definition) {
                const definitionKey = definitionPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`);
                switch (definitionKey.value) {
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.NULL: {
                        const mapping = definitionPair.value.assertMapping(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.NULL}`);
                        for (const mappingPair of mapping) {
                            const mappingKey = mappingPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.NULL} key`);
                            switch (mappingKey.value) {
                                default:
                                    // throws
                                    mappingKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.NULL} key`);
                                    break;
                            }
                        }
                        break;
                    }
                    default:
                        definitionKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`); // throws
                }
            }
        }
    }
    get definitionType() {
        return _definition_type__WEBPACK_IMPORTED_MODULE_1__.DefinitionType.Null;
    }
    isMatch(literal) {
        return literal.templateTokenType === _tokens_types__WEBPACK_IMPORTED_MODULE_3__.TokenType.Null;
    }
    validate() {
        // no-op
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/number-definition.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/number-definition.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NumberDefinition: () => (/* binding */ NumberDefinition)
/* harmony export */ });
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _definition_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definition-type */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-type.js");
/* harmony import */ var _scalar_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scalar-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/scalar-definition.js");
/* harmony import */ var _tokens_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tokens/types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");




class NumberDefinition extends _scalar_definition__WEBPACK_IMPORTED_MODULE_2__.ScalarDefinition {
    constructor(key, definition) {
        super(key, definition);
        if (definition) {
            for (const definitionPair of definition) {
                const definitionKey = definitionPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`);
                switch (definitionKey.value) {
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.NUMBER: {
                        const mapping = definitionPair.value.assertMapping(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.NUMBER}`);
                        for (const mappingPair of mapping) {
                            const mappingKey = mappingPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.NUMBER} key`);
                            switch (mappingKey.value) {
                                default:
                                    // throws
                                    mappingKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.NUMBER} key`);
                                    break;
                            }
                        }
                        break;
                    }
                    default:
                        definitionKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`); // throws
                }
            }
        }
    }
    get definitionType() {
        return _definition_type__WEBPACK_IMPORTED_MODULE_1__.DefinitionType.Number;
    }
    isMatch(literal) {
        return literal.templateTokenType === _tokens_types__WEBPACK_IMPORTED_MODULE_3__.TokenType.Number;
    }
    validate() {
        // no-op
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/one-of-definition.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/one-of-definition.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OneOfDefinition: () => (/* binding */ OneOfDefinition)
/* harmony export */ });
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition.js");
/* harmony import */ var _definition_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definition-type */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-type.js");



/**
 * Must resolve to exactly one of the referenced definitions
 */
class OneOfDefinition extends _definition__WEBPACK_IMPORTED_MODULE_1__.Definition {
    constructor(key, definition) {
        super(key, definition);
        this.oneOf = [];
        this.oneOfPrefix = [];
        if (definition) {
            for (const definitionPair of definition) {
                const definitionKey = definitionPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`);
                switch (definitionKey.value) {
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.ONE_OF: {
                        const oneOf = definitionPair.value.assertSequence(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.ONE_OF}`);
                        for (const item of oneOf) {
                            const oneOfItem = item.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.ONE_OF} item`);
                            this.oneOf.push(oneOfItem.value);
                        }
                        break;
                    }
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.ALLOWED_VALUES: {
                        const oneOf = definitionPair.value.assertSequence(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.ALLOWED_VALUES}`);
                        for (const item of oneOf) {
                            const oneOfItem = item.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.ONE_OF} item`);
                            this.oneOf.push(this.key + "-" + oneOfItem.value);
                        }
                        break;
                    }
                    default:
                        // throws
                        definitionKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`);
                        break;
                }
            }
        }
    }
    get definitionType() {
        return _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.OneOf;
    }
    validate(schema, name) {
        if (this.oneOf.length === 0) {
            throw new Error(`'${name}' does not contain any references`);
        }
        let foundLooseKeyType = false;
        const mappingDefinitions = [];
        let allowedValuesDefinition;
        let sequenceDefinition;
        let nullDefinition;
        let booleanDefinition;
        let numberDefinition;
        const stringDefinitions = [];
        const seenNestedTypes = {};
        for (const nestedType of this.oneOf) {
            if (seenNestedTypes[nestedType]) {
                throw new Error(`'${name}' contains duplicate nested type '${nestedType}'`);
            }
            seenNestedTypes[nestedType] = true;
            const nestedDefinition = schema.getDefinition(nestedType);
            if (nestedDefinition.readerContext.length > 0) {
                throw new Error(`'${name}' is a one-of definition and references another definition that defines context. This is currently not supported.`);
            }
            switch (nestedDefinition.definitionType) {
                case _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.Mapping: {
                    const mappingDefinition = nestedDefinition;
                    mappingDefinitions.push(mappingDefinition);
                    if (mappingDefinition.looseKeyType) {
                        foundLooseKeyType = true;
                    }
                    break;
                }
                case _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.Sequence: {
                    // Multiple sequence definitions not allowed
                    if (sequenceDefinition) {
                        throw new Error(`'${name}' refers to more than one definition of type '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.SEQUENCE}'`);
                    }
                    sequenceDefinition = nestedDefinition;
                    break;
                }
                case _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.Null: {
                    // Multiple null definitions not allowed
                    if (nullDefinition) {
                        throw new Error(`'${name}' refers to more than one definition of type '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.NULL}'`);
                    }
                    nullDefinition = nestedDefinition;
                    break;
                }
                case _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.Boolean: {
                    // Multiple boolean definitions not allowed
                    if (booleanDefinition) {
                        throw new Error(`'${name}' refers to more than one definition of type '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.BOOLEAN}'`);
                    }
                    booleanDefinition = nestedDefinition;
                    break;
                }
                case _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.Number: {
                    // Multiple number definitions not allowed
                    if (numberDefinition) {
                        throw new Error(`'${name}' refers to more than one definition of type '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.NUMBER}'`);
                    }
                    numberDefinition = nestedDefinition;
                    break;
                }
                case _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.String: {
                    const stringDefinition = nestedDefinition;
                    // Multiple string definitions
                    if (stringDefinitions.length > 0 && (!stringDefinitions[0].constant || !stringDefinition.constant)) {
                        throw new Error(`'${name}' refers to more than one '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.SCALAR}', but some do not set '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANT}'`);
                    }
                    stringDefinitions.push(stringDefinition);
                    break;
                }
                case _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.OneOf: {
                    // Multiple allowed-values definitions not allowed
                    if (allowedValuesDefinition) {
                        throw new Error(`'${name}' contains multiple allowed-values definitions`);
                    }
                    allowedValuesDefinition = nestedDefinition;
                    break;
                }
                default:
                    throw new Error(`'${name}' refers to a definition with type '${nestedDefinition.definitionType}'`);
            }
        }
        if (mappingDefinitions.length > 1) {
            if (foundLooseKeyType) {
                throw new Error(`'${name}' refers to two mappings and at least one sets '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.LOOSE_KEY_TYPE}'. This is not currently supported.`);
            }
            const seenProperties = {};
            for (const mappingDefinition of mappingDefinitions) {
                for (const propertyName of Object.keys(mappingDefinition.properties)) {
                    const newPropertyDef = mappingDefinition.properties[propertyName];
                    // Already seen
                    const existingPropertyDef = seenProperties[propertyName];
                    if (existingPropertyDef) {
                        // Types match
                        if (existingPropertyDef.type === newPropertyDef.type) {
                            continue;
                        }
                        // Collision
                        throw new Error(`'${name}' contains two mappings with the same property, but each refers to a different type. All matching properties must refer to the same type.`);
                    }
                    // New
                    else {
                        seenProperties[propertyName] = newPropertyDef;
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/property-definition.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/property-definition.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PropertyDefinition: () => (/* binding */ PropertyDefinition)
/* harmony export */ });
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _tokens_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tokens/types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");


class PropertyDefinition {
    constructor(token) {
        this.type = "";
        this.required = false;
        if (token.templateTokenType === _tokens_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.String) {
            this.type = token.value;
        }
        else {
            const mapping = token.assertMapping(_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING_PROPERTY_VALUE);
            for (const mappingPair of mapping) {
                const mappingKey = mappingPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING_PROPERTY_VALUE} key`);
                switch (mappingKey.value) {
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.TYPE:
                        this.type = mappingPair.value.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING_PROPERTY_VALUE} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.TYPE}`).value;
                        break;
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.REQUIRED:
                        this.required = mappingPair.value.assertBoolean(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING_PROPERTY_VALUE} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.REQUIRED}`).value;
                        break;
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.DESCRIPTION:
                        this.description = mappingPair.value.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING_PROPERTY_VALUE} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DESCRIPTION}`).value;
                        break;
                    default:
                        mappingKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.MAPPING_PROPERTY_VALUE} key`); // throws
                }
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/scalar-definition.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/scalar-definition.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScalarDefinition: () => (/* binding */ ScalarDefinition)
/* harmony export */ });
/* harmony import */ var _definition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition.js");

class ScalarDefinition extends _definition__WEBPACK_IMPORTED_MODULE_0__.Definition {
    constructor(key, definition) {
        super(key, definition);
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/sequence-definition.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/sequence-definition.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SequenceDefinition: () => (/* binding */ SequenceDefinition)
/* harmony export */ });
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition.js");
/* harmony import */ var _definition_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definition-type */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-type.js");



class SequenceDefinition extends _definition__WEBPACK_IMPORTED_MODULE_1__.Definition {
    constructor(key, definition) {
        super(key, definition);
        this.itemType = "";
        if (definition) {
            for (const definitionPair of definition) {
                const definitionKey = definitionPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`);
                switch (definitionKey.value) {
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.SEQUENCE: {
                        const mapping = definitionPair.value.assertMapping(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.SEQUENCE}`);
                        for (const mappingPair of mapping) {
                            const mappingKey = mappingPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.SEQUENCE} key`);
                            switch (mappingKey.value) {
                                case _template_constants__WEBPACK_IMPORTED_MODULE_0__.ITEM_TYPE: {
                                    const itemType = mappingPair.value.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.SEQUENCE} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.ITEM_TYPE}`);
                                    this.itemType = itemType.value;
                                    break;
                                }
                                default:
                                    // throws
                                    mappingKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.SEQUENCE} key`);
                                    break;
                            }
                        }
                        break;
                    }
                    default:
                        definitionKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`); // throws
                }
            }
        }
    }
    get definitionType() {
        return _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.Sequence;
    }
    validate(schema, name) {
        if (!this.itemType) {
            throw new Error(`'${name}' does not defined '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.ITEM_TYPE}'`);
        }
        // Lookup item type
        schema.getDefinition(this.itemType);
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/string-definition.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/string-definition.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringDefinition: () => (/* binding */ StringDefinition)
/* harmony export */ });
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _tokens_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tokens/types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");
/* harmony import */ var _definition_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./definition-type */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-type.js");
/* harmony import */ var _scalar_definition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scalar-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/scalar-definition.js");




class StringDefinition extends _scalar_definition__WEBPACK_IMPORTED_MODULE_3__.ScalarDefinition {
    constructor(key, definition) {
        super(key, definition);
        this.constant = "";
        this.ignoreCase = false;
        this.requireNonEmpty = false;
        this.isExpression = false;
        if (definition) {
            for (const definitionPair of definition) {
                const definitionKey = definitionPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`);
                switch (definitionKey.value) {
                    case _template_constants__WEBPACK_IMPORTED_MODULE_0__.STRING: {
                        const mapping = definitionPair.value.assertMapping(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.STRING}`);
                        for (const mappingPair of mapping) {
                            const mappingKey = mappingPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.STRING} key`);
                            switch (mappingKey.value) {
                                case _template_constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANT: {
                                    const constantStringToken = mappingPair.value.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.STRING} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANT}`);
                                    this.constant = constantStringToken.value;
                                    break;
                                }
                                case _template_constants__WEBPACK_IMPORTED_MODULE_0__.IGNORE_CASE: {
                                    const ignoreCaseBooleanToken = mappingPair.value.assertBoolean(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.STRING} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.IGNORE_CASE}`);
                                    this.ignoreCase = ignoreCaseBooleanToken.value;
                                    break;
                                }
                                case _template_constants__WEBPACK_IMPORTED_MODULE_0__.REQUIRE_NON_EMPTY: {
                                    const requireNonEmptyBooleanToken = mappingPair.value.assertBoolean(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.STRING} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.REQUIRE_NON_EMPTY}`);
                                    this.requireNonEmpty = requireNonEmptyBooleanToken.value;
                                    break;
                                }
                                case _template_constants__WEBPACK_IMPORTED_MODULE_0__.IS_EXPRESSION: {
                                    const isExpressionToken = mappingPair.value.assertBoolean(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.STRING} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.IS_EXPRESSION}`);
                                    this.isExpression = isExpressionToken.value;
                                    break;
                                }
                                default:
                                    // throws
                                    mappingKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.STRING} key`);
                                    break;
                            }
                        }
                        break;
                    }
                    default:
                        definitionKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_0__.DEFINITION} key`); // throws
                }
            }
        }
    }
    get definitionType() {
        return _definition_type__WEBPACK_IMPORTED_MODULE_2__.DefinitionType.String;
    }
    isMatch(literal) {
        if (literal.templateTokenType === _tokens_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.String) {
            const value = literal.value;
            if (this.constant) {
                return this.ignoreCase ? this.constant.toUpperCase() === value.toUpperCase() : this.constant === value;
            }
            else if (this.requireNonEmpty) {
                return !!value;
            }
            else {
                return true;
            }
        }
        return false;
    }
    validate() {
        if (this.constant && this.requireNonEmpty) {
            throw new Error(`Properties '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANT}' and '${_template_constants__WEBPACK_IMPORTED_MODULE_0__.REQUIRE_NON_EMPTY}' cannot both be set`);
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/schema/template-schema.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/schema/template-schema.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TemplateSchema: () => (/* binding */ TemplateSchema)
/* harmony export */ });
/* harmony import */ var _templates_tokens_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templates/tokens/types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _template_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../template-context */ "./node_modules/@actions/workflow-parser/dist/templates/template-context.js");
/* harmony import */ var _template_reader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../template-reader */ "./node_modules/@actions/workflow-parser/dist/templates/template-reader.js");
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tokens */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _trace_writer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../trace-writer */ "./node_modules/@actions/workflow-parser/dist/templates/trace-writer.js");
/* harmony import */ var _boolean_definition__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./boolean-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/boolean-definition.js");
/* harmony import */ var _definition_type__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./definition-type */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-type.js");
/* harmony import */ var _mapping_definition__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mapping-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/mapping-definition.js");
/* harmony import */ var _null_definition__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./null-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/null-definition.js");
/* harmony import */ var _number_definition__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./number-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/number-definition.js");
/* harmony import */ var _one_of_definition__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./one-of-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/one-of-definition.js");
/* harmony import */ var _property_definition__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./property-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/property-definition.js");
/* harmony import */ var _sequence_definition__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sequence-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/sequence-definition.js");
/* harmony import */ var _string_definition__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./string-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/string-definition.js");















/**
 * This models the root schema object and contains definitions
 */
class TemplateSchema {
    constructor(mapping) {
        this.definitions = {};
        this.version = "";
        // Add built-in type: null
        this.definitions[_template_constants__WEBPACK_IMPORTED_MODULE_1__.NULL] = new _null_definition__WEBPACK_IMPORTED_MODULE_9__.NullDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NULL);
        // Add built-in type: boolean
        this.definitions[_template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN] = new _boolean_definition__WEBPACK_IMPORTED_MODULE_6__.BooleanDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN);
        // Add built-in type: number
        this.definitions[_template_constants__WEBPACK_IMPORTED_MODULE_1__.NUMBER] = new _number_definition__WEBPACK_IMPORTED_MODULE_10__.NumberDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NUMBER);
        // Add built-in type: string
        this.definitions[_template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING] = new _string_definition__WEBPACK_IMPORTED_MODULE_14__.StringDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING);
        // Add built-in type: sequence
        const sequenceDefinition = new _sequence_definition__WEBPACK_IMPORTED_MODULE_13__.SequenceDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE);
        sequenceDefinition.itemType = _template_constants__WEBPACK_IMPORTED_MODULE_1__.ANY;
        this.definitions[sequenceDefinition.key] = sequenceDefinition;
        // Add built-in type: mapping
        const mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.MAPPING);
        mappingDefinition.looseKeyType = _template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING;
        mappingDefinition.looseValueType = _template_constants__WEBPACK_IMPORTED_MODULE_1__.ANY;
        this.definitions[mappingDefinition.key] = mappingDefinition;
        // Add built-in type: any
        const anyDefinition = new _one_of_definition__WEBPACK_IMPORTED_MODULE_11__.OneOfDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.ANY);
        anyDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NULL);
        anyDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN);
        anyDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NUMBER);
        anyDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING);
        anyDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE);
        anyDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.MAPPING);
        this.definitions[anyDefinition.key] = anyDefinition;
        if (mapping) {
            for (const pair of mapping) {
                const key = pair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_1__.TEMPLATE_SCHEMA} key`);
                switch (key.value) {
                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.VERSION: {
                        this.version = pair.value.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_1__.TEMPLATE_SCHEMA} ${_template_constants__WEBPACK_IMPORTED_MODULE_1__.VERSION}`).value;
                        break;
                    }
                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.DEFINITIONS: {
                        const definitions = pair.value.assertMapping(`${_template_constants__WEBPACK_IMPORTED_MODULE_1__.TEMPLATE_SCHEMA} ${_template_constants__WEBPACK_IMPORTED_MODULE_1__.DEFINITIONS}`);
                        for (const definitionsPair of definitions) {
                            const definitionsKey = definitionsPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_1__.TEMPLATE_SCHEMA} ${_template_constants__WEBPACK_IMPORTED_MODULE_1__.DEFINITIONS} key`);
                            const definitionsValue = definitionsPair.value.assertMapping(`${_template_constants__WEBPACK_IMPORTED_MODULE_1__.TEMPLATE_SCHEMA} ${_template_constants__WEBPACK_IMPORTED_MODULE_1__.DEFINITIONS} value`);
                            let definition;
                            for (const definitionPair of definitionsValue) {
                                const definitionKey = definitionPair.key.assertString(`${_template_constants__WEBPACK_IMPORTED_MODULE_1__.DEFINITION} key`);
                                const mappingToken = definitionsPair.value;
                                switch (definitionKey.value) {
                                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.NULL:
                                        definition = new _null_definition__WEBPACK_IMPORTED_MODULE_9__.NullDefinition(definitionsKey.value, definitionsValue);
                                        break;
                                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN:
                                        definition = new _boolean_definition__WEBPACK_IMPORTED_MODULE_6__.BooleanDefinition(definitionsKey.value, definitionsValue);
                                        break;
                                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.NUMBER:
                                        definition = new _number_definition__WEBPACK_IMPORTED_MODULE_10__.NumberDefinition(definitionsKey.value, definitionsValue);
                                        break;
                                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING:
                                        definition = new _string_definition__WEBPACK_IMPORTED_MODULE_14__.StringDefinition(definitionsKey.value, definitionsValue);
                                        break;
                                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE:
                                        definition = new _sequence_definition__WEBPACK_IMPORTED_MODULE_13__.SequenceDefinition(definitionsKey.value, definitionsValue);
                                        break;
                                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.MAPPING:
                                        definition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(definitionsKey.value, definitionsValue);
                                        break;
                                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.ONE_OF:
                                        definition = new _one_of_definition__WEBPACK_IMPORTED_MODULE_11__.OneOfDefinition(definitionsKey.value, definitionsValue);
                                        break;
                                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.ALLOWED_VALUES:
                                        // Change the allowed-values definition into a one-of definition and its corresponding string definitions
                                        for (const item of mappingToken) {
                                            if (item.value.templateTokenType === _templates_tokens_types__WEBPACK_IMPORTED_MODULE_0__.TokenType.Sequence) {
                                                // Create a new string definition for each StringToken in the sequence
                                                const sequenceToken = item.value;
                                                for (const activity of sequenceToken) {
                                                    if (activity.templateTokenType === _templates_tokens_types__WEBPACK_IMPORTED_MODULE_0__.TokenType.String) {
                                                        const stringToken = activity;
                                                        const allowedValuesKey = definitionsKey.value + "-" + stringToken.value;
                                                        const allowedValuesDef = new _string_definition__WEBPACK_IMPORTED_MODULE_14__.StringDefinition(allowedValuesKey);
                                                        allowedValuesDef.constant = stringToken.toDisplayString();
                                                        this.definitions[allowedValuesKey] = allowedValuesDef;
                                                    }
                                                }
                                            }
                                        }
                                        definition = new _one_of_definition__WEBPACK_IMPORTED_MODULE_11__.OneOfDefinition(definitionsKey.value, definitionsValue);
                                        break;
                                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.CONTEXT:
                                    case _template_constants__WEBPACK_IMPORTED_MODULE_1__.DESCRIPTION:
                                        continue;
                                    default:
                                        // throws
                                        definitionKey.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_1__.DEFINITION} mapping key`);
                                        break;
                                }
                                break;
                            }
                            if (!definition) {
                                throw new Error(`Not enough information to construct definition '${definitionsKey.value}'`);
                            }
                            this.definitions[definitionsKey.value] = definition;
                        }
                        break;
                    }
                    default:
                        // throws
                        key.assertUnexpectedValue(`${_template_constants__WEBPACK_IMPORTED_MODULE_1__.TEMPLATE_SCHEMA} key`);
                        break;
                }
            }
        }
    }
    /**
     * Looks up a definition by name
     */
    getDefinition(name) {
        const result = this.definitions[name];
        if (result) {
            return result;
        }
        throw new Error(`Schema definition '${name}' not found`);
    }
    /**
     * Expands one-of definitions and returns all scalar definitions
     */
    getScalarDefinitions(definition) {
        const result = [];
        switch (definition.definitionType) {
            case _definition_type__WEBPACK_IMPORTED_MODULE_7__.DefinitionType.Null:
            case _definition_type__WEBPACK_IMPORTED_MODULE_7__.DefinitionType.Boolean:
            case _definition_type__WEBPACK_IMPORTED_MODULE_7__.DefinitionType.Number:
            case _definition_type__WEBPACK_IMPORTED_MODULE_7__.DefinitionType.String:
                result.push(definition);
                break;
            case _definition_type__WEBPACK_IMPORTED_MODULE_7__.DefinitionType.OneOf: {
                const oneOf = definition;
                // Expand nested one-of definitions
                for (const nestedName of oneOf.oneOf) {
                    const nestedDefinition = this.getDefinition(nestedName);
                    result.push(...this.getScalarDefinitions(nestedDefinition));
                }
                break;
            }
        }
        return result;
    }
    /**
     * Expands one-of definitions and returns all matching definitions by type
     */
    getDefinitionsOfType(definition, type) {
        const result = [];
        if (definition.definitionType === type) {
            result.push(definition);
        }
        else if (definition.definitionType === _definition_type__WEBPACK_IMPORTED_MODULE_7__.DefinitionType.OneOf) {
            const oneOf = definition;
            for (const nestedName of oneOf.oneOf) {
                const nestedDefinition = this.getDefinition(nestedName);
                if (nestedDefinition.definitionType === type) {
                    result.push(nestedDefinition);
                }
            }
        }
        return result;
    }
    /**
     * Attempts match the property name to a property defined by any of the specified definitions.
     * If matched, any unmatching definitions are filtered from the definitions array.
     * Returns the type information for the matched property.
     */
    matchPropertyAndFilter(definitions, propertyName) {
        let result;
        // Check for a matching well-known property
        let notFoundInSome = false;
        for (const definition of definitions) {
            const propertyDef = definition.properties[propertyName];
            if (propertyDef) {
                result = propertyDef;
            }
            else {
                notFoundInSome = true;
            }
        }
        // Filter the matched definitions if needed
        if (result && notFoundInSome) {
            for (let i = 0; i < definitions.length;) {
                if (definitions[i].properties[propertyName]) {
                    i++;
                }
                else {
                    definitions.splice(i, 1);
                }
            }
        }
        return result;
    }
    validate() {
        const oneOfDefinitions = {};
        for (const name of Object.keys(this.definitions)) {
            if (!name.match(TemplateSchema._definitionNamePattern)) {
                throw new Error(`Invalid definition name '${name}'`);
            }
            const definition = this.definitions[name];
            // Delay validation for 'one-of' definitions
            if (definition.definitionType === _definition_type__WEBPACK_IMPORTED_MODULE_7__.DefinitionType.OneOf) {
                oneOfDefinitions[name] = definition;
            }
            // Otherwise validate now
            else {
                definition.validate(this, name);
            }
        }
        // Validate 'one-of' definitions
        for (const name of Object.keys(oneOfDefinitions)) {
            const oneOf = oneOfDefinitions[name];
            oneOf.validate(this, name);
        }
    }
    /**
     * Loads a user-defined schema file
     */
    static load(objectReader) {
        const context = new _template_context__WEBPACK_IMPORTED_MODULE_2__.TemplateContext(new _template_context__WEBPACK_IMPORTED_MODULE_2__.TemplateValidationErrors(10, 500), TemplateSchema.getInternalSchema(), new _trace_writer__WEBPACK_IMPORTED_MODULE_5__.NoOperationTraceWriter());
        const template = (0,_template_reader__WEBPACK_IMPORTED_MODULE_3__.readTemplate)(context, _template_constants__WEBPACK_IMPORTED_MODULE_1__.TEMPLATE_SCHEMA, objectReader, undefined);
        context.errors.check();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const mapping = template.assertMapping(_template_constants__WEBPACK_IMPORTED_MODULE_1__.TEMPLATE_SCHEMA);
        const schema = new TemplateSchema(mapping);
        schema.validate();
        return schema;
    }
    /**
     * Gets the internal schema used for reading user-defined schema files
     */
    static getInternalSchema() {
        if (TemplateSchema._internalSchema === undefined) {
            const schema = new TemplateSchema();
            // template-schema
            let mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.TEMPLATE_SCHEMA);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.VERSION] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.DEFINITIONS] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.DEFINITIONS, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // definitions
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.DEFINITIONS);
            mappingDefinition.looseKeyType = _template_constants__WEBPACK_IMPORTED_MODULE_1__.NON_EMPTY_STRING;
            mappingDefinition.looseValueType = _template_constants__WEBPACK_IMPORTED_MODULE_1__.DEFINITION;
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // definition
            let oneOfDefinition = new _one_of_definition__WEBPACK_IMPORTED_MODULE_11__.OneOfDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.DEFINITION);
            oneOfDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NULL_DEFINITION);
            oneOfDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN_DEFINITION);
            oneOfDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NUMBER_DEFINITION);
            oneOfDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING_DEFINITION);
            oneOfDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_DEFINITION);
            oneOfDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.MAPPING_DEFINITION);
            oneOfDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.ONE_OF_DEFINITION);
            schema.definitions[oneOfDefinition.key] = oneOfDefinition;
            // null-definition
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NULL_DEFINITION);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.DESCRIPTION] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_OF_NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.NULL] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.NULL_DEFINITION_PROPERTIES, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // null-definition-properties
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NULL_DEFINITION_PROPERTIES);
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // boolean-definition
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN_DEFINITION);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.DESCRIPTION] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_OF_NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN_DEFINITION_PROPERTIES, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // boolean-definition-properties
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN_DEFINITION_PROPERTIES);
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // number-definition
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NUMBER_DEFINITION);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.DESCRIPTION] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_OF_NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.NUMBER] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.NUMBER_DEFINITION_PROPERTIES, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // number-definition-properties
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NUMBER_DEFINITION_PROPERTIES);
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // string-definition
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING_DEFINITION);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.DESCRIPTION] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_OF_NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING_DEFINITION_PROPERTIES, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // string-definition-properties
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING_DEFINITION_PROPERTIES);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANT] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.IGNORE_CASE] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.REQUIRE_NON_EMPTY] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.IS_EXPRESSION] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // sequence-definition
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_DEFINITION);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.DESCRIPTION] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_OF_NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_DEFINITION_PROPERTIES, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // sequence-definition-properties
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_DEFINITION_PROPERTIES);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.ITEM_TYPE] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.NON_EMPTY_STRING, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // mapping-definition
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.MAPPING_DEFINITION);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.DESCRIPTION] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_OF_NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.MAPPING] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.MAPPING_DEFINITION_PROPERTIES, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // mapping-definition-properties
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.MAPPING_DEFINITION_PROPERTIES);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.PROPERTIES] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.PROPERTIES, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.LOOSE_KEY_TYPE] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.LOOSE_VALUE_TYPE] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.NON_EMPTY_STRING, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // properties
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.PROPERTIES);
            mappingDefinition.looseKeyType = _template_constants__WEBPACK_IMPORTED_MODULE_1__.NON_EMPTY_STRING;
            mappingDefinition.looseValueType = _template_constants__WEBPACK_IMPORTED_MODULE_1__.PROPERTY_VALUE;
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // property-value
            oneOfDefinition = new _one_of_definition__WEBPACK_IMPORTED_MODULE_11__.OneOfDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.PROPERTY_VALUE);
            oneOfDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NON_EMPTY_STRING);
            oneOfDefinition.oneOf.push(_template_constants__WEBPACK_IMPORTED_MODULE_1__.MAPPING_PROPERTY_VALUE);
            schema.definitions[oneOfDefinition.key] = oneOfDefinition;
            // mapping-property-value
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.MAPPING_PROPERTY_VALUE);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.TYPE] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.REQUIRED] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.BOOLEAN, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.DESCRIPTION] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // one-of-definition
            mappingDefinition = new _mapping_definition__WEBPACK_IMPORTED_MODULE_8__.MappingDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.ONE_OF_DEFINITION);
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.DESCRIPTION] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_OF_NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.ONE_OF] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_OF_NON_EMPTY_STRING, undefined));
            mappingDefinition.properties[_template_constants__WEBPACK_IMPORTED_MODULE_1__.ALLOWED_VALUES] = new _property_definition__WEBPACK_IMPORTED_MODULE_12__.PropertyDefinition(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(undefined, undefined, _template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_OF_NON_EMPTY_STRING, undefined));
            schema.definitions[mappingDefinition.key] = mappingDefinition;
            // non-empty-string
            const stringDefinition = new _string_definition__WEBPACK_IMPORTED_MODULE_14__.StringDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.NON_EMPTY_STRING);
            stringDefinition.requireNonEmpty = true;
            schema.definitions[stringDefinition.key] = stringDefinition;
            // sequence-of-non-empty-string
            const sequenceDefinition = new _sequence_definition__WEBPACK_IMPORTED_MODULE_13__.SequenceDefinition(_template_constants__WEBPACK_IMPORTED_MODULE_1__.SEQUENCE_OF_NON_EMPTY_STRING);
            sequenceDefinition.itemType = _template_constants__WEBPACK_IMPORTED_MODULE_1__.NON_EMPTY_STRING;
            schema.definitions[sequenceDefinition.key] = sequenceDefinition;
            schema.validate();
            TemplateSchema._internalSchema = schema;
        }
        return TemplateSchema._internalSchema;
    }
}
TemplateSchema._definitionNamePattern = /^[a-zA-Z_][a-zA-Z0-9_-]*$/;


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/template-constants.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ALLOWED_VALUES: () => (/* binding */ ALLOWED_VALUES),
/* harmony export */   ANY: () => (/* binding */ ANY),
/* harmony export */   BOOLEAN: () => (/* binding */ BOOLEAN),
/* harmony export */   BOOLEAN_DEFINITION: () => (/* binding */ BOOLEAN_DEFINITION),
/* harmony export */   BOOLEAN_DEFINITION_PROPERTIES: () => (/* binding */ BOOLEAN_DEFINITION_PROPERTIES),
/* harmony export */   CLOSE_EXPRESSION: () => (/* binding */ CLOSE_EXPRESSION),
/* harmony export */   CONSTANT: () => (/* binding */ CONSTANT),
/* harmony export */   CONTEXT: () => (/* binding */ CONTEXT),
/* harmony export */   DEFINITION: () => (/* binding */ DEFINITION),
/* harmony export */   DEFINITIONS: () => (/* binding */ DEFINITIONS),
/* harmony export */   DESCRIPTION: () => (/* binding */ DESCRIPTION),
/* harmony export */   IGNORE_CASE: () => (/* binding */ IGNORE_CASE),
/* harmony export */   INSERT_DIRECTIVE: () => (/* binding */ INSERT_DIRECTIVE),
/* harmony export */   IS_EXPRESSION: () => (/* binding */ IS_EXPRESSION),
/* harmony export */   ITEM_TYPE: () => (/* binding */ ITEM_TYPE),
/* harmony export */   LOOSE_KEY_TYPE: () => (/* binding */ LOOSE_KEY_TYPE),
/* harmony export */   LOOSE_VALUE_TYPE: () => (/* binding */ LOOSE_VALUE_TYPE),
/* harmony export */   MAPPING: () => (/* binding */ MAPPING),
/* harmony export */   MAPPING_DEFINITION: () => (/* binding */ MAPPING_DEFINITION),
/* harmony export */   MAPPING_DEFINITION_PROPERTIES: () => (/* binding */ MAPPING_DEFINITION_PROPERTIES),
/* harmony export */   MAPPING_PROPERTY_VALUE: () => (/* binding */ MAPPING_PROPERTY_VALUE),
/* harmony export */   MAX_CONSTANT: () => (/* binding */ MAX_CONSTANT),
/* harmony export */   NON_EMPTY_STRING: () => (/* binding */ NON_EMPTY_STRING),
/* harmony export */   NULL: () => (/* binding */ NULL),
/* harmony export */   NULL_DEFINITION: () => (/* binding */ NULL_DEFINITION),
/* harmony export */   NULL_DEFINITION_PROPERTIES: () => (/* binding */ NULL_DEFINITION_PROPERTIES),
/* harmony export */   NUMBER: () => (/* binding */ NUMBER),
/* harmony export */   NUMBER_DEFINITION: () => (/* binding */ NUMBER_DEFINITION),
/* harmony export */   NUMBER_DEFINITION_PROPERTIES: () => (/* binding */ NUMBER_DEFINITION_PROPERTIES),
/* harmony export */   ONE_OF: () => (/* binding */ ONE_OF),
/* harmony export */   ONE_OF_DEFINITION: () => (/* binding */ ONE_OF_DEFINITION),
/* harmony export */   OPEN_EXPRESSION: () => (/* binding */ OPEN_EXPRESSION),
/* harmony export */   PROPERTIES: () => (/* binding */ PROPERTIES),
/* harmony export */   PROPERTY_VALUE: () => (/* binding */ PROPERTY_VALUE),
/* harmony export */   REQUIRED: () => (/* binding */ REQUIRED),
/* harmony export */   REQUIRE_NON_EMPTY: () => (/* binding */ REQUIRE_NON_EMPTY),
/* harmony export */   SCALAR: () => (/* binding */ SCALAR),
/* harmony export */   SEQUENCE: () => (/* binding */ SEQUENCE),
/* harmony export */   SEQUENCE_DEFINITION: () => (/* binding */ SEQUENCE_DEFINITION),
/* harmony export */   SEQUENCE_DEFINITION_PROPERTIES: () => (/* binding */ SEQUENCE_DEFINITION_PROPERTIES),
/* harmony export */   SEQUENCE_OF_NON_EMPTY_STRING: () => (/* binding */ SEQUENCE_OF_NON_EMPTY_STRING),
/* harmony export */   STRING: () => (/* binding */ STRING),
/* harmony export */   STRING_DEFINITION: () => (/* binding */ STRING_DEFINITION),
/* harmony export */   STRING_DEFINITION_PROPERTIES: () => (/* binding */ STRING_DEFINITION_PROPERTIES),
/* harmony export */   STRUCTURE: () => (/* binding */ STRUCTURE),
/* harmony export */   TEMPLATE_SCHEMA: () => (/* binding */ TEMPLATE_SCHEMA),
/* harmony export */   TYPE: () => (/* binding */ TYPE),
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
const ALLOWED_VALUES = "allowed-values";
const ANY = "any";
const BOOLEAN = "boolean";
const BOOLEAN_DEFINITION = "boolean-definition";
const BOOLEAN_DEFINITION_PROPERTIES = "boolean-definition-properties";
const CLOSE_EXPRESSION = "}}";
const CONSTANT = "constant";
const CONTEXT = "context";
const DEFINITION = "definition";
const DEFINITIONS = "definitions";
const DESCRIPTION = "description";
const IGNORE_CASE = "ignore-case";
const INSERT_DIRECTIVE = "insert";
const IS_EXPRESSION = "is-expression";
const ITEM_TYPE = "item-type";
const LOOSE_KEY_TYPE = "loose-key-type";
const LOOSE_VALUE_TYPE = "loose-value-type";
const MAX_CONSTANT = "MAX";
const MAPPING = "mapping";
const MAPPING_DEFINITION = "mapping-definition";
const MAPPING_DEFINITION_PROPERTIES = "mapping-definition-properties";
const MAPPING_PROPERTY_VALUE = "mapping-property-value";
const NON_EMPTY_STRING = "non-empty-string";
const NULL = "null";
const NULL_DEFINITION = "null-definition";
const NULL_DEFINITION_PROPERTIES = "null-definition-properties";
const NUMBER = "number";
const NUMBER_DEFINITION = "number-definition";
const NUMBER_DEFINITION_PROPERTIES = "number-definition-properties";
const ONE_OF = "one-of";
const ONE_OF_DEFINITION = "one-of-definition";
const OPEN_EXPRESSION = "${{";
const PROPERTY_VALUE = "property-value";
const PROPERTIES = "properties";
const REQUIRED = "required";
const REQUIRE_NON_EMPTY = "require-non-empty";
const SCALAR = "scalar";
const SEQUENCE = "sequence";
const SEQUENCE_DEFINITION = "sequence-definition";
const SEQUENCE_DEFINITION_PROPERTIES = "sequence-definition-properties";
const TYPE = "type";
const SEQUENCE_OF_NON_EMPTY_STRING = "sequence-of-non-empty-string";
const STRING = "string";
const STRING_DEFINITION = "string-definition";
const STRING_DEFINITION_PROPERTIES = "string-definition-properties";
const STRUCTURE = "structure";
const TEMPLATE_SCHEMA = "template-schema";
const VERSION = "version";


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/template-context.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TemplateContext: () => (/* binding */ TemplateContext),
/* harmony export */   TemplateValidationErrors: () => (/* binding */ TemplateValidationErrors)
/* harmony export */ });
/* harmony import */ var _template_validation_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./template-validation-error */ "./node_modules/@actions/workflow-parser/dist/templates/template-validation-error.js");

/**
 * Context object that is flowed through while loading and evaluating object templates
 */
class TemplateContext {
    constructor(errors, schema, trace) {
        this._fileIds = {};
        this._fileNames = [];
        /**
         * Available functions within expression contexts
         */
        this.expressionFunctions = [];
        /**
         * Available values within expression contexts
         */
        this.expressionNamedContexts = [];
        this.state = {};
        this.errors = errors;
        this.schema = schema;
        this.trace = trace;
    }
    error(tokenOrFileId, err, tokenRange) {
        const token = tokenOrFileId;
        const range = tokenRange || token?.range;
        const prefix = this.getErrorPrefix(token?.file ?? tokenOrFileId, token?.line, token?.col);
        const message = err?.message ?? String(err);
        const e = new _template_validation_error__WEBPACK_IMPORTED_MODULE_0__.TemplateValidationError(message, prefix, undefined, range);
        this.errors.add(e);
        this.trace.error(e.message);
    }
    /**
     * Gets or adds the file ID
     */
    getFileId(file) {
        const key = file.toUpperCase();
        let id = this._fileIds[key];
        if (id === undefined) {
            id = this._fileNames.length + 1;
            this._fileIds[key] = id;
            this._fileNames.push(file);
        }
        return id;
    }
    /**
     * Looks up a file name by ID. Returns undefined if not found.
     */
    getFileName(fileId) {
        return this._fileNames.length >= fileId ? this._fileNames[fileId - 1] : undefined;
    }
    /**
     * Gets a copy of the file table
     */
    getFileTable() {
        return this._fileNames.slice();
    }
    getErrorPrefix(fileId, line, column) {
        const fileName = fileId !== undefined ? this.getFileName(fileId) : undefined;
        if (fileName) {
            if (line !== undefined && column !== undefined) {
                return `${fileName} (Line: ${line}, Col: ${column})`;
            }
            else {
                return fileName;
            }
        }
        else if (line !== undefined && column !== undefined) {
            return `(Line: ${line}, Col: ${column})`;
        }
        else {
            return "";
        }
    }
}
/**
 * Provides information about errors which occurred during validation
 */
class TemplateValidationErrors {
    constructor(maxErrors, maxMessageLength) {
        this._errors = [];
        this._maxErrors = maxErrors ?? 0;
        this._maxMessageLength = maxMessageLength ?? 0;
    }
    get count() {
        return this._errors.length;
    }
    add(err) {
        for (let e of Array.isArray(err) ? err : [err]) {
            // Check max errors
            if (this._maxErrors <= 0 || this._errors.length < this._maxErrors) {
                // Check max message length
                if (this._maxMessageLength > 0 && e.message.length > this._maxMessageLength) {
                    e = new _template_validation_error__WEBPACK_IMPORTED_MODULE_0__.TemplateValidationError(e.message.substring(0, this._maxMessageLength) + "[...]", e.prefix, e.code, e.range);
                }
                this._errors.push(e);
            }
        }
    }
    /**
     * Throws if any errors
     * @param prefix The error message prefix
     */
    check(prefix) {
        if (this._errors.length <= 0) {
            return;
        }
        if (!prefix) {
            prefix = "The template is not valid.";
        }
        throw new Error(`${prefix} ${this._errors.map(x => x.message).join(",")}`);
    }
    clear() {
        this._errors = [];
    }
    getErrors() {
        return this._errors.slice();
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/template-reader.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/template-reader.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readTemplate: () => (/* binding */ readTemplate)
/* harmony export */ });
/* harmony import */ var _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema/definition-info */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-info.js");
/* harmony import */ var _schema_definition_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schema/definition-type */ "./node_modules/@actions/workflow-parser/dist/templates/schema/definition-type.js");
/* harmony import */ var _schema_string_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema/string-definition */ "./node_modules/@actions/workflow-parser/dist/templates/schema/string-definition.js");
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tokens */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _tokens_type_guards__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tokens/type-guards */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js");
/* harmony import */ var _tokens_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tokens/types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");
// template-reader *just* does schema validation
/* eslint-disable @typescript-eslint/no-non-null-assertion */







const WHITESPACE_PATTERN = /\s/;
function readTemplate(context, type, objectReader, fileId) {
    const reader = new TemplateReader(context, objectReader, fileId);
    let value;
    try {
        objectReader.validateStart();
        const definition = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(context.schema, type);
        value = reader.readValue(definition);
        objectReader.validateEnd();
    }
    catch (err) {
        context.error(fileId, err);
    }
    return value;
}
class TemplateReader {
    constructor(context, objectReader, fileId) {
        this._context = context;
        this._schema = context.schema;
        this._objectReader = objectReader;
        this._fileId = fileId;
    }
    readValue(definition) {
        // Scalar
        const literal = this._objectReader.allowLiteral();
        if (literal) {
            let scalar = this.parseScalar(literal, definition);
            scalar = this.validate(scalar, definition);
            return scalar;
        }
        // Sequence
        const sequence = this._objectReader.allowSequenceStart();
        if (sequence) {
            const sequenceDefinition = definition.getDefinitionsOfType(_schema_definition_type__WEBPACK_IMPORTED_MODULE_1__.DefinitionType.Sequence)[0];
            // Legal
            if (sequenceDefinition) {
                const itemDefinition = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, sequenceDefinition.itemType);
                // Add each item
                while (!this._objectReader.allowSequenceEnd()) {
                    const item = this.readValue(itemDefinition);
                    sequence.add(item);
                }
            }
            // Illegal
            else {
                // Error
                this._context.error(sequence, "A sequence was not expected");
                // Skip each item
                while (!this._objectReader.allowSequenceEnd()) {
                    this.skipValue();
                }
            }
            sequence.definitionInfo = definition;
            return sequence;
        }
        // Mapping
        const mapping = this._objectReader.allowMappingStart();
        if (mapping) {
            const mappingDefinitions = definition.getDefinitionsOfType(_schema_definition_type__WEBPACK_IMPORTED_MODULE_1__.DefinitionType.Mapping);
            // Legal
            if (mappingDefinitions.length > 0) {
                if (mappingDefinitions.length > 1 ||
                    Object.keys(mappingDefinitions[0].properties).length > 0 ||
                    !mappingDefinitions[0].looseKeyType) {
                    this.handleMappingWithWellKnownProperties(definition, mappingDefinitions, mapping);
                }
                else {
                    const keyDefinition = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, mappingDefinitions[0].looseKeyType);
                    const valueDefinition = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, mappingDefinitions[0].looseValueType);
                    this.handleMappingWithAllLooseProperties(definition, keyDefinition, valueDefinition, mappingDefinitions[0], mapping);
                }
            }
            // Illegal
            else {
                this._context.error(mapping, "A mapping was not expected");
                while (!this._objectReader.allowMappingEnd()) {
                    this.skipValue();
                    this.skipValue();
                }
            }
            // handleMappingWithWellKnownProperties will only set a definition
            // if it can identify a single matching definition
            if (!mapping.definitionInfo) {
                mapping.definitionInfo = definition;
            }
            return mapping;
        }
        throw new Error("Expected a scalar value, a sequence, or a mapping");
    }
    handleMappingWithWellKnownProperties(definition, mappingDefinitions, mapping) {
        // Check if loose properties are allowed
        let looseKeyType;
        let looseValueType;
        let looseKeyDefinition;
        let looseValueDefinition;
        if (mappingDefinitions[0].looseKeyType) {
            looseKeyType = mappingDefinitions[0].looseKeyType;
            looseValueType = mappingDefinitions[0].looseValueType;
        }
        const upperKeys = {};
        let hasExpressionKey = false;
        let rawLiteral;
        while ((rawLiteral = this._objectReader.allowLiteral())) {
            const nextKeyScalar = this.parseScalar(rawLiteral, definition);
            // Expression
            if (nextKeyScalar.isExpression) {
                hasExpressionKey = true;
                // Legal
                if (definition.allowedContext.length > 0) {
                    const anyDefinition = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, _template_constants__WEBPACK_IMPORTED_MODULE_3__.ANY);
                    mapping.add(nextKeyScalar, this.readValue(anyDefinition));
                }
                // Illegal
                else {
                    this._context.error(nextKeyScalar, "A template expression is not allowed in this context");
                    this.skipValue();
                }
                continue;
            }
            // Convert to StringToken if required
            const nextKey = nextKeyScalar.templateTokenType === _tokens_types__WEBPACK_IMPORTED_MODULE_6__.TokenType.String
                ? nextKeyScalar
                : new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(nextKeyScalar.file, nextKeyScalar.range, nextKeyScalar.toString(), nextKeyScalar.definitionInfo);
            // Duplicate
            if (nextKey.value) {
                const upperKey = nextKey.value.toUpperCase();
                if (upperKeys[upperKey]) {
                    this._context.error(nextKey, `'${nextKey.value}' is already defined`);
                    this.skipValue();
                    continue;
                }
                upperKeys[upperKey] = true;
            }
            // Well known
            const nextPropertyDef = this._schema.matchPropertyAndFilter(mappingDefinitions, nextKey.value);
            if (nextPropertyDef) {
                const nextDefinition = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, nextPropertyDef.type);
                // Store the definition on the key, the value may have its own definition
                nextKey.definitionInfo = nextDefinition;
                // If the property has a description, it's a parameter that uses a shared type
                // and we need to make sure its description is set if there is one
                if (nextPropertyDef.description) {
                    nextKey.description = nextPropertyDef.description;
                }
                const nextValue = this.readValue(nextDefinition);
                mapping.add(nextKey, nextValue);
                continue;
            }
            // Loose
            if (looseKeyType) {
                if (!looseKeyDefinition) {
                    looseKeyDefinition = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, looseKeyType);
                    looseValueDefinition = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, looseValueType);
                }
                this.validate(nextKey, looseKeyDefinition);
                // Store the definition on the key, the value may have its own definition
                const nextDefinition = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, mappingDefinitions[0].looseValueType);
                nextKey.definitionInfo = nextDefinition;
                const nextValue = this.readValue(looseValueDefinition);
                mapping.add(nextKey, nextValue);
                continue;
            }
            // Error
            this._context.error(nextKey, `Unexpected value '${nextKey.value}'`);
            this.skipValue();
        }
        // If we matched a single definition from multiple,
        // update the token's definition to enable more specific editor
        // completion and validation
        if (mappingDefinitions.length === 1) {
            mapping.definitionInfo = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, mappingDefinitions[0]);
        }
        // Unable to filter to one definition
        if (mappingDefinitions.length > 1) {
            const hitCount = {};
            for (const mappingDefinition of mappingDefinitions) {
                for (const key of Object.keys(mappingDefinition.properties)) {
                    hitCount[key] = (hitCount[key] ?? 0) + 1;
                }
            }
            const nonDuplicates = [];
            for (const key of Object.keys(hitCount)) {
                if (hitCount[key] === 1) {
                    nonDuplicates.push(key);
                }
            }
            this._context.error(mapping, `There's not enough info to determine what you meant. Add one of these properties: ${nonDuplicates
                .sort()
                .join(", ")}`);
        }
        // Check required properties
        else if (mappingDefinitions.length === 1 && !hasExpressionKey) {
            for (const propertyName of Object.keys(mappingDefinitions[0].properties)) {
                const propertyDef = mappingDefinitions[0].properties[propertyName];
                if (propertyDef.required && !upperKeys[propertyName.toUpperCase()]) {
                    this._context.error(mapping, `Required property is missing: ${propertyName}`);
                }
            }
        }
        this.expectMappingEnd();
    }
    handleMappingWithAllLooseProperties(definition, keyDefinition, valueDefinition, mappingDefinition, mapping) {
        let nextValue;
        const upperKeys = {};
        let rawLiteral;
        while ((rawLiteral = this._objectReader.allowLiteral())) {
            const nextKeyScalar = this.parseScalar(rawLiteral, definition);
            nextKeyScalar.definitionInfo = keyDefinition;
            // Expression
            if (nextKeyScalar.isExpression) {
                // Legal
                if (definition.allowedContext.length > 0) {
                    nextValue = this.readValue(valueDefinition);
                    mapping.add(nextKeyScalar, nextValue);
                }
                // Illegal
                else {
                    this._context.error(nextKeyScalar, "A template expression is not allowed in this context");
                    this.skipValue();
                }
                continue;
            }
            // Convert to StringToken if required
            const nextKey = nextKeyScalar.templateTokenType === _tokens_types__WEBPACK_IMPORTED_MODULE_6__.TokenType.String
                ? nextKeyScalar
                : new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(nextKeyScalar.file, nextKeyScalar.range, nextKeyScalar.toString(), nextKeyScalar.definitionInfo);
            // Duplicate
            if (nextKey.value) {
                const upperKey = nextKey.value.toUpperCase();
                if (upperKeys[upperKey]) {
                    this._context.error(nextKey, `'${nextKey.value}' is already defined`);
                    this.skipValue();
                    continue;
                }
                upperKeys[upperKey] = true;
            }
            // Validate
            this.validate(nextKey, keyDefinition);
            // Store the definition on the key, the value may have its own definition
            const nextDefinition = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, mappingDefinition.looseValueType);
            nextKey.definitionInfo = nextDefinition;
            // Add the pair
            nextValue = this.readValue(valueDefinition);
            mapping.add(nextKey, nextValue);
        }
        this.expectMappingEnd();
    }
    expectMappingEnd() {
        if (!this._objectReader.allowMappingEnd()) {
            throw new Error("Expected mapping end"); // Should never happen
        }
    }
    skipValue() {
        // Scalar
        if (this._objectReader.allowLiteral()) {
            // Intentionally empty
        }
        // Sequence
        else if (this._objectReader.allowSequenceStart()) {
            while (!this._objectReader.allowSequenceEnd()) {
                this.skipValue();
            }
        }
        // Mapping
        else if (this._objectReader.allowMappingStart()) {
            while (!this._objectReader.allowMappingEnd()) {
                this.skipValue();
                this.skipValue();
            }
        }
        // Unexpected
        else {
            throw new Error("Expected a scalar value, a sequence, or a mapping");
        }
    }
    validate(scalar, definition) {
        switch (scalar.templateTokenType) {
            case _tokens_types__WEBPACK_IMPORTED_MODULE_6__.TokenType.Null:
            case _tokens_types__WEBPACK_IMPORTED_MODULE_6__.TokenType.Boolean:
            case _tokens_types__WEBPACK_IMPORTED_MODULE_6__.TokenType.Number:
            case _tokens_types__WEBPACK_IMPORTED_MODULE_6__.TokenType.String: {
                const literal = scalar;
                // Legal
                const scalarDefinitions = definition.getScalarDefinitions();
                let relevantDefinition;
                if ((relevantDefinition = scalarDefinitions.find(x => x.isMatch(literal)))) {
                    scalar.definitionInfo = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, relevantDefinition);
                    return scalar;
                }
                // Not a string, convert
                if (literal.templateTokenType !== _tokens_types__WEBPACK_IMPORTED_MODULE_6__.TokenType.String) {
                    const stringLiteral = new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(literal.file, literal.range, literal.toString(), literal.definitionInfo);
                    // Legal
                    if ((relevantDefinition = scalarDefinitions.find(x => x.isMatch(stringLiteral)))) {
                        stringLiteral.definitionInfo = new _schema_definition_info__WEBPACK_IMPORTED_MODULE_0__.DefinitionInfo(definition, relevantDefinition);
                        return stringLiteral;
                    }
                }
                // Illegal
                this._context.error(literal, `Unexpected value '${literal.toString()}'`);
                return scalar;
            }
            case _tokens_types__WEBPACK_IMPORTED_MODULE_6__.TokenType.BasicExpression:
                // Illegal
                if (definition.allowedContext.length === 0) {
                    this._context.error(scalar, "A template expression is not allowed in this context");
                }
                return scalar;
            default:
                this._context.error(scalar, `Unexpected value '${scalar.toString()}'`);
                return scalar;
        }
    }
    parseScalar(token, definitionInfo) {
        // Not a string
        if (!(0,_tokens_type_guards__WEBPACK_IMPORTED_MODULE_5__.isString)(token) || !token.value) {
            return token;
        }
        const allowedContext = definitionInfo.allowedContext;
        const raw = token.source || token.value;
        let startExpression = raw.indexOf(_template_constants__WEBPACK_IMPORTED_MODULE_3__.OPEN_EXPRESSION);
        if (startExpression < 0) {
            // Doesn't contain "${{"
            // Check if value should still be evaluated as an expression
            if (definitionInfo.definition instanceof _schema_string_definition__WEBPACK_IMPORTED_MODULE_2__.StringDefinition && definitionInfo.definition.isExpression) {
                const expression = this.parseIntoExpressionToken(token.range, raw, allowedContext, token, definitionInfo);
                if (expression) {
                    return expression;
                }
            }
            return token;
        }
        // Break the value into segments of LiteralToken and ExpressionToken
        let encounteredError = false;
        const segments = [];
        let i = 0;
        while (i < raw.length) {
            // An expression starts here
            if (i === startExpression) {
                // Find the end of the expression - i.e. "}}"
                startExpression = i;
                let endExpression = -1;
                let inString = false;
                for (i += _template_constants__WEBPACK_IMPORTED_MODULE_3__.OPEN_EXPRESSION.length; i < raw.length; i++) {
                    if (raw[i] === "'") {
                        inString = !inString; // Note, this handles escaped single quotes gracefully. E.x. 'foo''bar'
                    }
                    else if (!inString && raw[i] === "}" && raw[i - 1] === "}") {
                        endExpression = i;
                        i++;
                        break;
                    }
                }
                // Check if not closed
                if (endExpression < startExpression) {
                    this._context.error(token, "The expression is not closed. An unescaped ${{ sequence was found, but the closing }} sequence was not found.");
                    return token;
                }
                // Parse the expression
                const rawExpression = raw.substr(startExpression + _template_constants__WEBPACK_IMPORTED_MODULE_3__.OPEN_EXPRESSION.length, endExpression - startExpression + 1 - _template_constants__WEBPACK_IMPORTED_MODULE_3__.OPEN_EXPRESSION.length - _template_constants__WEBPACK_IMPORTED_MODULE_3__.CLOSE_EXPRESSION.length);
                let tr = token.range;
                if (tr.start.line === tr.end.line) {
                    // If it's a single line expression, adjust the range to only cover the sub-expression
                    tr = {
                        start: { line: tr.start.line, column: tr.start.column + startExpression },
                        end: { line: tr.end.line, column: tr.start.column + endExpression + 1 }
                    };
                }
                else {
                    // Adjust the range to only cover the expression for multi-line strings
                    const startRaw = raw.substring(0, startExpression);
                    const adjustedStartLine = startRaw.split("\n").length;
                    const beginningOfLine = startRaw.lastIndexOf("\n");
                    const adjustedStart = startExpression - beginningOfLine;
                    const adjustedEnd = endExpression - beginningOfLine + 1;
                    tr = {
                        start: { line: tr.start.line + adjustedStartLine, column: adjustedStart },
                        end: { line: tr.start.line + adjustedStartLine, column: adjustedEnd }
                    };
                }
                const expression = this.parseIntoExpressionToken(tr, rawExpression, allowedContext, token, definitionInfo);
                if (!expression) {
                    // Record that we've hit an error but continue to validate any other expressions
                    // that might be in the string
                    encounteredError = true;
                }
                else {
                    // Check if a directive was used when not allowed
                    if (expression.directive && (startExpression !== 0 || i < raw.length)) {
                        this._context.error(token, `The directive '${expression.directive}' is not allowed in this context. Directives are not supported for expressions that are embedded within a string. Directives are only supported when the entire value is an expression.`);
                        return token;
                    }
                    // Add the segment
                    segments.push(expression);
                }
                // Look for the next expression
                startExpression = raw.indexOf(_template_constants__WEBPACK_IMPORTED_MODULE_3__.OPEN_EXPRESSION, i);
            }
            // The next expression is further ahead
            else if (i < startExpression) {
                // Append the segment
                this.addString(segments, token.range, raw.substr(i, startExpression - i), token.definitionInfo);
                // Adjust the position
                i = startExpression;
            }
            // No remaining expressions
            else {
                this.addString(segments, token.range, raw.substr(i), token.definitionInfo);
                break;
            }
        }
        // If we've hit any error during parsing, return the original token
        if (encounteredError) {
            return token;
        }
        // Check if can convert to a literal
        // For example, the escaped expression: ${{ '{{ this is a literal }}' }}
        if (segments.length === 1 && segments[0].templateTokenType === _tokens_types__WEBPACK_IMPORTED_MODULE_6__.TokenType.BasicExpression) {
            const basicExpression = segments[0];
            const str = this.getExpressionString(basicExpression.expression);
            if (str !== undefined) {
                return new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(this._fileId, token.range, str, token.definitionInfo);
            }
        }
        // Check if only one segment
        if (segments.length === 1) {
            return segments[0];
        }
        // Build the new expression, using the format function
        const format = [];
        const args = [];
        const expressionTokens = [];
        let argIndex = 0;
        for (const segment of segments) {
            if ((0,_tokens_type_guards__WEBPACK_IMPORTED_MODULE_5__.isString)(segment)) {
                const text = segment.value
                    .replace(/'/g, "''") // Escape quotes
                    .replace(/\{/g, "{{") // Escape braces
                    .replace(/\}/g, "}}");
                format.push(text);
            }
            else {
                format.push(`{${argIndex}}`); // Append format arg
                argIndex++;
                const expression = segment;
                args.push(", ");
                args.push(expression.expression);
                expressionTokens.push(expression);
            }
        }
        return new _tokens__WEBPACK_IMPORTED_MODULE_4__.BasicExpressionToken(this._fileId, token.range, `format('${format.join("")}'${args.join("")})`, definitionInfo, expressionTokens, raw);
    }
    parseIntoExpressionToken(tr, rawExpression, allowedContext, token, definitionInfo) {
        const parseExpressionResult = this.parseExpression(tr, token, rawExpression, allowedContext, definitionInfo);
        // Check for error
        if (parseExpressionResult.error) {
            this._context.error(token, parseExpressionResult.error, tr);
            return undefined;
        }
        return parseExpressionResult.expression;
    }
    parseExpression(range, token, value, allowedContext, definitionInfo) {
        const trimmed = value.trim();
        // Check if the value is empty
        if (!trimmed) {
            return {
                error: new Error("An expression was expected")
            };
        }
        // Try to find a matching directive
        const matchDirectiveResult = this.matchDirective(trimmed, _template_constants__WEBPACK_IMPORTED_MODULE_3__.INSERT_DIRECTIVE, 0);
        if (matchDirectiveResult.isMatch) {
            return {
                expression: new _tokens__WEBPACK_IMPORTED_MODULE_4__.InsertExpressionToken(this._fileId, range, definitionInfo)
            };
        }
        else if (matchDirectiveResult.error) {
            return {
                error: matchDirectiveResult.error
            };
        }
        // Check if valid expression
        try {
            _tokens__WEBPACK_IMPORTED_MODULE_4__.ExpressionToken.validateExpression(trimmed, allowedContext);
        }
        catch (err) {
            return {
                error: err
            };
        }
        const startTrim = value.length - value.trimStart().length;
        const endTrim = value.length - value.trimEnd().length;
        const expressionRange = {
            start: {
                ...range.start,
                column: range.start.column + _template_constants__WEBPACK_IMPORTED_MODULE_3__.OPEN_EXPRESSION.length + startTrim
            },
            end: {
                ...range.end,
                column: range.end.column - _template_constants__WEBPACK_IMPORTED_MODULE_3__.CLOSE_EXPRESSION.length - endTrim
            }
        };
        // Return the expression
        return {
            expression: new _tokens__WEBPACK_IMPORTED_MODULE_4__.BasicExpressionToken(this._fileId, range, trimmed, definitionInfo, undefined, token.source, expressionRange),
            error: undefined
        };
    }
    addString(segments, range, value, definition) {
        // If the last segment was a LiteralToken, then append to the last segment
        if (segments.length > 0 && segments[segments.length - 1].templateTokenType === _tokens_types__WEBPACK_IMPORTED_MODULE_6__.TokenType.String) {
            const lastSegment = segments[segments.length - 1];
            segments[segments.length - 1] = new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(this._fileId, range, `${lastSegment.value}${value}`, definition);
        }
        // Otherwise add a new LiteralToken
        else {
            segments.push(new _tokens__WEBPACK_IMPORTED_MODULE_4__.StringToken(this._fileId, range, value, definition));
        }
    }
    matchDirective(trimmed, directive, expectedParameters) {
        const parameters = [];
        if (trimmed.startsWith(directive) &&
            (trimmed.length === directive.length || WHITESPACE_PATTERN.test(trimmed[directive.length]))) {
            let startIndex = directive.length;
            let inString = false;
            let parens = 0;
            for (let i = startIndex; i < trimmed.length; i++) {
                const c = trimmed[i];
                if (WHITESPACE_PATTERN.test(c) && !inString && parens == 0) {
                    if (startIndex < 1) {
                        parameters.push(trimmed.substr(startIndex, i - startIndex));
                    }
                    startIndex = i + 1;
                }
                else if (c === "'") {
                    inString = !inString;
                }
                else if (c === "(" && !inString) {
                    parens++;
                }
                else if (c === ")" && !inString) {
                    parens--;
                }
            }
            if (startIndex < trimmed.length) {
                parameters.push(trimmed.substr(startIndex));
            }
            if (expectedParameters != parameters.length) {
                return {
                    isMatch: false,
                    parameters: [],
                    error: new Error(`Exactly ${expectedParameters} parameter(s) were expected following the directive '${directive}'. Actual parameter count: ${parameters.length}`)
                };
            }
            return {
                isMatch: true,
                parameters: parameters
            };
        }
        return {
            isMatch: false,
            parameters: parameters
        };
    }
    getExpressionString(trimmed) {
        const result = [];
        let inString = false;
        for (let i = 0; i < trimmed.length; i++) {
            const c = trimmed[i];
            if (c === "'") {
                inString = !inString;
                if (inString && i !== 0) {
                    result.push(c);
                }
            }
            else if (!inString) {
                return undefined;
            }
            else {
                result.push(c);
            }
        }
        return result.join("");
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/template-validation-error.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/template-validation-error.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TemplateValidationError: () => (/* binding */ TemplateValidationError)
/* harmony export */ });
/**
 * Provides information about an error which occurred during validation
 */
class TemplateValidationError {
    constructor(rawMessage, prefix, code, range) {
        this.rawMessage = rawMessage;
        this.prefix = prefix;
        this.code = code;
        this.range = range;
    }
    get message() {
        if (this.prefix) {
            return `${this.prefix}: ${this.rawMessage}`;
        }
        return this.rawMessage;
    }
    toString() {
        return this.message;
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/basic-expression-token.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/basic-expression-token.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicExpressionToken: () => (/* binding */ BasicExpressionToken)
/* harmony export */ });
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _expression_token__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./expression-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/expression-token.js");
/* harmony import */ var _scalar_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scalar-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/scalar-token.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");




class BasicExpressionToken extends _expression_token__WEBPACK_IMPORTED_MODULE_1__.ExpressionToken {
    /**
     * @param originalExpressions If the basic expression was transformed from individual expressions, these will be the original ones
     */
    constructor(file, range, expression, definitionInfo, originalExpressions, source, expressionRange) {
        super(_types__WEBPACK_IMPORTED_MODULE_3__.TokenType.BasicExpression, file, range, undefined, definitionInfo);
        this.expr = expression;
        this.source = source;
        this.originalExpressions = originalExpressions;
        this.expressionRange = expressionRange;
    }
    get expression() {
        return this.expr;
    }
    clone(omitSource) {
        return omitSource
            ? new BasicExpressionToken(undefined, undefined, this.expr, this.definitionInfo, this.originalExpressions, this.source, this.expressionRange)
            : new BasicExpressionToken(this.file, this.range, this.expr, this.definitionInfo, this.originalExpressions, this.source, this.expressionRange);
    }
    toString() {
        return `${_template_constants__WEBPACK_IMPORTED_MODULE_0__.OPEN_EXPRESSION} ${this.expr} ${_template_constants__WEBPACK_IMPORTED_MODULE_0__.CLOSE_EXPRESSION}`;
    }
    toDisplayString() {
        // TODO: Implement expression display string to match `BasicExpressionToken#ToDisplayString()` in the C# parser
        return _scalar_token__WEBPACK_IMPORTED_MODULE_2__.ScalarToken.trimDisplayString(this.toString());
    }
    toJSON() {
        return {
            type: _types__WEBPACK_IMPORTED_MODULE_3__.TokenType.BasicExpression,
            expr: this.expr
        };
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/boolean-token.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/boolean-token.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BooleanToken: () => (/* binding */ BooleanToken)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");


class BooleanToken extends ___WEBPACK_IMPORTED_MODULE_0__.LiteralToken {
    constructor(file, range, value, definitionInfo) {
        super(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Boolean, file, range, definitionInfo);
        this.bool = value;
    }
    get value() {
        return this.bool;
    }
    clone(omitSource) {
        return omitSource
            ? new BooleanToken(undefined, undefined, this.bool, this.definitionInfo)
            : new BooleanToken(this.file, this.range, this.bool, this.definitionInfo);
    }
    toString() {
        return this.bool ? "true" : "false";
    }
    toJSON() {
        return this.bool;
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/expression-token.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/expression-token.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExpressionToken: () => (/* binding */ ExpressionToken)
/* harmony export */ });
/* harmony import */ var _actions_expressions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @actions/expressions */ "./node_modules/@actions/expressions/dist/index.js");
/* harmony import */ var _allowed_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../allowed-context */ "./node_modules/@actions/workflow-parser/dist/templates/allowed-context.js");
/* harmony import */ var _scalar_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scalar-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/scalar-token.js");



class ExpressionToken extends _scalar_token__WEBPACK_IMPORTED_MODULE_2__.ScalarToken {
    constructor(type, file, range, directive, definitionInfo) {
        super(type, file, range, definitionInfo);
        this.directive = directive;
    }
    get isLiteral() {
        return false;
    }
    get isExpression() {
        return true;
    }
    static validateExpression(expression, allowedContext) {
        const { namedContexts, functions } = (0,_allowed_context__WEBPACK_IMPORTED_MODULE_1__.splitAllowedContext)(allowedContext);
        // Parse
        const lexer = new _actions_expressions__WEBPACK_IMPORTED_MODULE_0__.Lexer(expression);
        const result = lexer.lex();
        const p = new _actions_expressions__WEBPACK_IMPORTED_MODULE_0__.Parser(result.tokens, namedContexts, functions);
        p.parse();
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicExpressionToken: () => (/* reexport safe */ _basic_expression_token__WEBPACK_IMPORTED_MODULE_11__.BasicExpressionToken),
/* harmony export */   BooleanToken: () => (/* reexport safe */ _boolean_token__WEBPACK_IMPORTED_MODULE_5__.BooleanToken),
/* harmony export */   ExpressionToken: () => (/* reexport safe */ _expression_token__WEBPACK_IMPORTED_MODULE_10__.ExpressionToken),
/* harmony export */   InsertExpressionToken: () => (/* reexport safe */ _insert_expression_token__WEBPACK_IMPORTED_MODULE_12__.InsertExpressionToken),
/* harmony export */   KeyValuePair: () => (/* reexport safe */ _key_value_pair__WEBPACK_IMPORTED_MODULE_7__.KeyValuePair),
/* harmony export */   LiteralToken: () => (/* reexport safe */ _literal_token__WEBPACK_IMPORTED_MODULE_2__.LiteralToken),
/* harmony export */   MappingToken: () => (/* reexport safe */ _mapping_token__WEBPACK_IMPORTED_MODULE_9__.MappingToken),
/* harmony export */   NullToken: () => (/* reexport safe */ _null_token__WEBPACK_IMPORTED_MODULE_6__.NullToken),
/* harmony export */   NumberToken: () => (/* reexport safe */ _number_token__WEBPACK_IMPORTED_MODULE_4__.NumberToken),
/* harmony export */   ScalarToken: () => (/* reexport safe */ _scalar_token__WEBPACK_IMPORTED_MODULE_1__.ScalarToken),
/* harmony export */   SequenceToken: () => (/* reexport safe */ _sequence_token__WEBPACK_IMPORTED_MODULE_8__.SequenceToken),
/* harmony export */   StringToken: () => (/* reexport safe */ _string_token__WEBPACK_IMPORTED_MODULE_3__.StringToken),
/* harmony export */   TemplateToken: () => (/* reexport safe */ _template_token__WEBPACK_IMPORTED_MODULE_0__.TemplateToken)
/* harmony export */ });
/* harmony import */ var _template_token__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./template-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/template-token.js");
/* harmony import */ var _scalar_token__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/scalar-token.js");
/* harmony import */ var _literal_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./literal-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/literal-token.js");
/* harmony import */ var _string_token__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./string-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/string-token.js");
/* harmony import */ var _number_token__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/number-token.js");
/* harmony import */ var _boolean_token__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./boolean-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/boolean-token.js");
/* harmony import */ var _null_token__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./null-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/null-token.js");
/* harmony import */ var _key_value_pair__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./key-value-pair */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/key-value-pair.js");
/* harmony import */ var _sequence_token__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sequence-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/sequence-token.js");
/* harmony import */ var _mapping_token__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mapping-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/mapping-token.js");
/* harmony import */ var _expression_token__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./expression-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/expression-token.js");
/* harmony import */ var _basic_expression_token__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./basic-expression-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/basic-expression-token.js");
/* harmony import */ var _insert_expression_token__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./insert-expression-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/insert-expression-token.js");















/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/insert-expression-token.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/insert-expression-token.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InsertExpressionToken: () => (/* binding */ InsertExpressionToken)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _template_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../template-constants */ "./node_modules/@actions/workflow-parser/dist/templates/template-constants.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");



class InsertExpressionToken extends ___WEBPACK_IMPORTED_MODULE_0__.ExpressionToken {
    constructor(file, range, definitionInfo) {
        super(_types__WEBPACK_IMPORTED_MODULE_2__.TokenType.InsertExpression, file, range, _template_constants__WEBPACK_IMPORTED_MODULE_1__.INSERT_DIRECTIVE, definitionInfo);
    }
    clone(omitSource) {
        return omitSource
            ? new InsertExpressionToken(undefined, undefined, this.definitionInfo)
            : new InsertExpressionToken(this.file, this.range, this.definitionInfo);
    }
    toString() {
        return `${_template_constants__WEBPACK_IMPORTED_MODULE_1__.OPEN_EXPRESSION} ${_template_constants__WEBPACK_IMPORTED_MODULE_1__.INSERT_DIRECTIVE} ${_template_constants__WEBPACK_IMPORTED_MODULE_1__.CLOSE_EXPRESSION}`;
    }
    toDisplayString() {
        return ___WEBPACK_IMPORTED_MODULE_0__.ScalarToken.trimDisplayString(this.toString());
    }
    toJSON() {
        return {
            type: _types__WEBPACK_IMPORTED_MODULE_2__.TokenType.InsertExpression,
            expr: "insert"
        };
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/key-value-pair.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/key-value-pair.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyValuePair: () => (/* binding */ KeyValuePair)
/* harmony export */ });
class KeyValuePair {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/literal-token.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/literal-token.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LiteralToken: () => (/* binding */ LiteralToken)
/* harmony export */ });
/* harmony import */ var _scalar_token__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/scalar-token.js");

class LiteralToken extends _scalar_token__WEBPACK_IMPORTED_MODULE_0__.ScalarToken {
    constructor(type, file, range, definitionInfo) {
        super(type, file, range, definitionInfo);
    }
    get isLiteral() {
        return true;
    }
    get isExpression() {
        return false;
    }
    toDisplayString() {
        return _scalar_token__WEBPACK_IMPORTED_MODULE_0__.ScalarToken.trimDisplayString(this.toString());
    }
    /**
     * Throws a good debug message when an unexpected literal value is encountered
     */
    assertUnexpectedValue(objectDescription) {
        throw new Error(`Error while reading '${objectDescription}'. Unexpected value '${this.toString()}'`);
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/mapping-token.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/mapping-token.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MappingToken: () => (/* binding */ MappingToken)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");


class MappingToken extends ___WEBPACK_IMPORTED_MODULE_0__.TemplateToken {
    constructor(file, range, definitionInfo) {
        super(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Mapping, file, range, definitionInfo);
        this.map = [];
    }
    get count() {
        return this.map.length;
    }
    get isScalar() {
        return false;
    }
    get isLiteral() {
        return false;
    }
    get isExpression() {
        return false;
    }
    add(key, value) {
        this.map.push(new ___WEBPACK_IMPORTED_MODULE_0__.KeyValuePair(key, value));
    }
    get(index) {
        return this.map[index];
    }
    find(key) {
        const pair = this.map.find(pair => pair.key.toString() === key);
        return pair?.value;
    }
    remove(index) {
        this.map.splice(index, 1);
    }
    clone(omitSource) {
        const result = omitSource
            ? new MappingToken(undefined, undefined, this.definitionInfo)
            : new MappingToken(this.file, this.range, this.definitionInfo);
        for (const item of this.map) {
            result.add(item.key.clone(omitSource), item.value.clone(omitSource));
        }
        return result;
    }
    toJSON() {
        const items = [];
        for (const item of this.map) {
            items.push({ Key: item.key, Value: item.value });
        }
        return {
            type: _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Mapping,
            map: items
        };
    }
    *[Symbol.iterator]() {
        for (const item of this.map) {
            yield item;
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/null-token.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/null-token.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NullToken: () => (/* binding */ NullToken)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");


class NullToken extends ___WEBPACK_IMPORTED_MODULE_0__.LiteralToken {
    constructor(file, range, definitionInfo) {
        super(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Null, file, range, definitionInfo);
    }
    clone(omitSource) {
        return omitSource
            ? new NullToken(undefined, undefined, this.definitionInfo)
            : new NullToken(this.file, this.range, this.definitionInfo);
    }
    toString() {
        return "";
    }
    toJSON() {
        return null;
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/number-token.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/number-token.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NumberToken: () => (/* binding */ NumberToken)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");


class NumberToken extends ___WEBPACK_IMPORTED_MODULE_0__.LiteralToken {
    constructor(file, range, value, definitionInfo) {
        super(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Number, file, range, definitionInfo);
        this.num = value;
    }
    get value() {
        return this.num;
    }
    clone(omitSource) {
        return omitSource
            ? new NumberToken(undefined, undefined, this.num, this.definitionInfo)
            : new NumberToken(this.file, this.range, this.num, this.definitionInfo);
    }
    toString() {
        return `${this.num}`;
    }
    toJSON() {
        return this.num;
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/scalar-token.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/scalar-token.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScalarToken: () => (/* binding */ ScalarToken)
/* harmony export */ });
/* harmony import */ var _template_token__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./template-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/template-token.js");

/**
 * Base class for everything that is not a mapping or sequence
 */
class ScalarToken extends _template_token__WEBPACK_IMPORTED_MODULE_0__.TemplateToken {
    constructor(type, file, range, definitionInfo) {
        super(type, file, range, definitionInfo);
    }
    get isScalar() {
        return true;
    }
    static trimDisplayString(displayString) {
        let firstLine = displayString.trimStart();
        const firstNewLine = firstLine.indexOf("\n");
        const firstCarriageReturn = firstLine.indexOf("\r");
        if (firstNewLine >= 0 || firstCarriageReturn >= 0) {
            firstLine = firstLine.substr(0, Math.min(firstNewLine >= 0 ? firstNewLine : Number.MAX_VALUE, firstCarriageReturn >= 0 ? firstCarriageReturn : Number.MAX_VALUE));
        }
        return firstLine;
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/sequence-token.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/sequence-token.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SequenceToken: () => (/* binding */ SequenceToken)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");


class SequenceToken extends ___WEBPACK_IMPORTED_MODULE_0__.TemplateToken {
    constructor(file, range, definitionInfo) {
        super(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Sequence, file, range, definitionInfo);
        this.seq = [];
    }
    get count() {
        return this.seq.length;
    }
    get isScalar() {
        return false;
    }
    get isLiteral() {
        return false;
    }
    get isExpression() {
        return false;
    }
    add(value) {
        this.seq.push(value);
    }
    get(index) {
        return this.seq[index];
    }
    clone(omitSource) {
        const result = omitSource
            ? new SequenceToken(undefined, undefined, this.definitionInfo)
            : new SequenceToken(this.file, this.range, this.definitionInfo);
        for (const item of this.seq) {
            result.add(item.clone(omitSource));
        }
        return result;
    }
    toJSON() {
        return {
            type: _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Sequence,
            seq: this.seq
        };
    }
    *[Symbol.iterator]() {
        for (const item of this.seq) {
            yield item;
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/string-token.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/string-token.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringToken: () => (/* binding */ StringToken)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");


class StringToken extends ___WEBPACK_IMPORTED_MODULE_0__.LiteralToken {
    constructor(file, range, value, definitionInfo, source) {
        super(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.String, file, range, definitionInfo);
        this.value = value;
        this.source = source;
    }
    clone(omitSource) {
        return omitSource
            ? new StringToken(undefined, undefined, this.value, this.definitionInfo, this.source)
            : new StringToken(this.file, this.range, this.value, this.definitionInfo, this.source);
    }
    toString() {
        return this.value;
    }
    toJSON() {
        return this.value;
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/template-token.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/template-token.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TemplateToken: () => (/* binding */ TemplateToken),
/* harmony export */   TemplateTokenError: () => (/* binding */ TemplateTokenError)
/* harmony export */ });
/* harmony import */ var _traversal_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./traversal-state */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/traversal-state.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");


class TemplateTokenError extends Error {
    constructor(message, token) {
        super(message);
        this.token = token;
    }
}
class TemplateToken {
    /**
     * Base class for all template tokens
     */
    constructor(type, file, range, definitionInfo) {
        this.type = type;
        this.file = file;
        this.range = range;
        this.definitionInfo = definitionInfo;
    }
    get templateTokenType() {
        return this.type;
    }
    get line() {
        return this.range?.start.line;
    }
    get col() {
        return this.range?.start.column;
    }
    get definition() {
        return this.definitionInfo?.definition;
    }
    get description() {
        return this._description || this.propertyDefinition?.description || this.definition?.description;
    }
    set description(description) {
        this._description = description;
    }
    typeName() {
        return (0,_types__WEBPACK_IMPORTED_MODULE_1__.tokenTypeName)(this.type);
    }
    /**
     * Asserts expected type and throws a good debug message if unexpected
     */
    assertNull(objectDescription) {
        if (this.type === _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Null) {
            return this;
        }
        throw new TemplateTokenError(`Unexpected type '${this.typeName()}' encountered while reading '${objectDescription}'. The type '${(0,_types__WEBPACK_IMPORTED_MODULE_1__.tokenTypeName)(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Null)}' was expected.`, this);
    }
    /**
     * Asserts expected type and throws a good debug message if unexpected
     */
    assertBoolean(objectDescription) {
        if (this.type === _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Boolean) {
            return this;
        }
        throw new TemplateTokenError(`Unexpected type '${this.typeName()}' encountered while reading '${objectDescription}'. The type '${(0,_types__WEBPACK_IMPORTED_MODULE_1__.tokenTypeName)(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Boolean)}' was expected.`, this);
    }
    /**
     * Asserts expected type and throws a good debug message if unexpected
     */
    assertNumber(objectDescription) {
        if (this.type === _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Number) {
            return this;
        }
        throw new TemplateTokenError(`Unexpected type '${this.typeName()}' encountered while reading '${objectDescription}'. The type '${(0,_types__WEBPACK_IMPORTED_MODULE_1__.tokenTypeName)(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Number)}' was expected.`, this);
    }
    /**
     * Asserts expected type and throws a good debug message if unexpected
     */
    assertString(objectDescription) {
        if (this.type === _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.String) {
            return this;
        }
        throw new TemplateTokenError(`Unexpected type '${this.typeName()}' encountered while reading '${objectDescription}'. The type '${(0,_types__WEBPACK_IMPORTED_MODULE_1__.tokenTypeName)(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.String)}' was expected.`, this);
    }
    /**
     * Asserts expected type and throws a good debug message if unexpected
     */
    assertScalar(objectDescription) {
        if (this?.isScalar === true) {
            return this;
        }
        throw new TemplateTokenError(`Unexpected type '${this.typeName()}' encountered while reading '${objectDescription}'. The type 'ScalarToken' was expected.`, this);
    }
    /**
     * Asserts expected type and throws a good debug message if unexpected
     */
    assertSequence(objectDescription) {
        if (this.type === _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Sequence) {
            return this;
        }
        throw new TemplateTokenError(`Unexpected type '${this.typeName()}' encountered while reading '${objectDescription}'. The type '${(0,_types__WEBPACK_IMPORTED_MODULE_1__.tokenTypeName)(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Sequence)}' was expected.`, this);
    }
    /**
     * Asserts expected type and throws a good debug message if unexpected
     */
    assertMapping(objectDescription) {
        if (this.type === _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Mapping) {
            return this;
        }
        throw new TemplateTokenError(`Unexpected type '${this.typeName()}' encountered while reading '${objectDescription}'. The type '${(0,_types__WEBPACK_IMPORTED_MODULE_1__.tokenTypeName)(_types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Mapping)}' was expected.`, this);
    }
    /**
     * Returns all tokens (depth first)
     * @param value The object to travese
     * @param omitKeys Whether to omit mapping keys
     */
    static *traverse(value, omitKeys) {
        yield [undefined, value, undefined];
        switch (value.templateTokenType) {
            case _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Sequence:
            case _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Mapping: {
                let state = new _traversal_state__WEBPACK_IMPORTED_MODULE_0__.TraversalState(undefined, value);
                state = new _traversal_state__WEBPACK_IMPORTED_MODULE_0__.TraversalState(state, value);
                while (state.parent) {
                    if (state.moveNext(omitKeys ?? false)) {
                        value = state.current;
                        yield [state.parent?.current, value, state.currentKey];
                        switch (value.type) {
                            case _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Sequence:
                            case _types__WEBPACK_IMPORTED_MODULE_1__.TokenType.Mapping:
                                state = new _traversal_state__WEBPACK_IMPORTED_MODULE_0__.TraversalState(state, value);
                                break;
                        }
                    }
                    else {
                        state = state.parent;
                    }
                }
                break;
            }
        }
    }
    toJSON() {
        return undefined;
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/traversal-state.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/traversal-state.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TraversalState: () => (/* binding */ TraversalState)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");

class TraversalState {
    constructor(parent, token) {
        this.index = -1;
        this.isKey = false;
        this.parent = parent;
        this._token = token;
        this.current = token;
    }
    moveNext(omitKeys) {
        switch (this._token.templateTokenType) {
            case _types__WEBPACK_IMPORTED_MODULE_0__.TokenType.Sequence: {
                const sequence = this._token;
                if (++this.index < sequence.count) {
                    this.current = sequence.get(this.index);
                    return true;
                }
                this.current = undefined;
                return false;
            }
            case _types__WEBPACK_IMPORTED_MODULE_0__.TokenType.Mapping: {
                const mapping = this._token;
                // Already returned the key, now return the value
                if (this.isKey) {
                    this.isKey = false;
                    this.currentKey = this.current;
                    this.current = mapping.get(this.index).value;
                    return true;
                }
                // Move next
                if (++this.index < mapping.count) {
                    // Skip the key, return the value
                    if (omitKeys) {
                        this.isKey = false;
                        this.currentKey = mapping.get(this.index).key;
                        this.current = mapping.get(this.index).value;
                        return true;
                    }
                    // Return the key
                    this.isKey = true;
                    this.currentKey = undefined;
                    this.current = mapping.get(this.index).key;
                    return true;
                }
                this.currentKey = undefined;
                this.current = undefined;
                return false;
            }
            default:
                throw new Error(`Unexpected token type '${this._token.templateTokenType}' when traversing state`);
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/type-guards.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isBasicExpression: () => (/* binding */ isBasicExpression),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isLiteral: () => (/* binding */ isLiteral),
/* harmony export */   isMapping: () => (/* binding */ isMapping),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isScalar: () => (/* binding */ isScalar),
/* harmony export */   isSequence: () => (/* binding */ isSequence),
/* harmony export */   isString: () => (/* binding */ isString)
/* harmony export */ });
/* harmony import */ var _mapping_token__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mapping-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/mapping-token.js");
/* harmony import */ var _sequence_token__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sequence-token */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/sequence-token.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js");



function isLiteral(t) {
    return t.isLiteral;
}
function isScalar(t) {
    return t.isScalar;
}
function isString(t) {
    return isLiteral(t) && t.templateTokenType === _types__WEBPACK_IMPORTED_MODULE_2__.TokenType.String;
}
function isNumber(t) {
    return isLiteral(t) && t.templateTokenType === _types__WEBPACK_IMPORTED_MODULE_2__.TokenType.Number;
}
function isBoolean(t) {
    return isLiteral(t) && t.templateTokenType === _types__WEBPACK_IMPORTED_MODULE_2__.TokenType.Boolean;
}
function isBasicExpression(t) {
    return isScalar(t) && t.templateTokenType === _types__WEBPACK_IMPORTED_MODULE_2__.TokenType.BasicExpression;
}
function isSequence(t) {
    return t instanceof _sequence_token__WEBPACK_IMPORTED_MODULE_1__.SequenceToken;
}
function isMapping(t) {
    return t instanceof _mapping_token__WEBPACK_IMPORTED_MODULE_0__.MappingToken;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/tokens/types.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TokenType: () => (/* binding */ TokenType),
/* harmony export */   tokenTypeName: () => (/* binding */ tokenTypeName)
/* harmony export */ });
var TokenType;
(function (TokenType) {
    TokenType[TokenType["String"] = 0] = "String";
    TokenType[TokenType["Sequence"] = 1] = "Sequence";
    TokenType[TokenType["Mapping"] = 2] = "Mapping";
    TokenType[TokenType["BasicExpression"] = 3] = "BasicExpression";
    TokenType[TokenType["InsertExpression"] = 4] = "InsertExpression";
    TokenType[TokenType["Boolean"] = 5] = "Boolean";
    TokenType[TokenType["Number"] = 6] = "Number";
    TokenType[TokenType["Null"] = 7] = "Null";
})(TokenType || (TokenType = {}));
function tokenTypeName(type) {
    switch (type) {
        case TokenType.String:
            return "StringToken";
        case TokenType.Sequence:
            return "SequenceToken";
        case TokenType.Mapping:
            return "MappingToken";
        case TokenType.BasicExpression:
            return "BasicExpressionToken";
        case TokenType.InsertExpression:
            return "InsertExpressionToken";
        case TokenType.Boolean:
            return "BooleanToken";
        case TokenType.Number:
            return "NumberToken";
        case TokenType.Null:
            return "NullToken";
        default: {
            // Use never to ensure exhaustiveness
            const exhaustiveCheck = type;
            throw new Error(`Unhandled token type: ${type} ${exhaustiveCheck}}`);
        }
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/templates/trace-writer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/templates/trace-writer.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NoOperationTraceWriter: () => (/* binding */ NoOperationTraceWriter)
/* harmony export */ });
class NoOperationTraceWriter {
    error() {
        // do nothing
    }
    info() {
        // do nothing
    }
    verbose() {
        // do nothing
    }
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/workflows/file-reference.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/workflows/file-reference.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fileIdentifier: () => (/* binding */ fileIdentifier),
/* harmony export */   parseFileReference: () => (/* binding */ parseFileReference)
/* harmony export */ });
function parseFileReference(ref) {
    if (ref.startsWith("./")) {
        return {
            path: ref.substring(2)
        };
    }
    const [remotePath, version] = ref.split("@");
    const [owner, repository, ...pathSegments] = remotePath.split("/").filter(s => s.length > 0);
    if (!owner || !repository || !version) {
        throw new Error(`Invalid file reference: ${ref}`);
    }
    return {
        repository,
        owner,
        path: pathSegments.join("/"),
        version
    };
}
function fileIdentifier(ref) {
    if (!("repository" in ref)) {
        return "./" + ref.path;
    }
    return `${ref.owner}/${ref.repository}/${ref.path}@${ref.version}`;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/workflows/workflow-constants.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/workflows/workflow-constants.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WORKFLOW_ROOT: () => (/* binding */ WORKFLOW_ROOT)
/* harmony export */ });
const WORKFLOW_ROOT = "workflow-root-strict";


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/workflows/workflow-parser.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/workflows/workflow-parser.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseWorkflow: () => (/* binding */ parseWorkflow)
/* harmony export */ });
/* harmony import */ var _templates_template_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../templates/template-context */ "./node_modules/@actions/workflow-parser/dist/templates/template-context.js");
/* harmony import */ var _templates_template_reader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../templates/template-reader */ "./node_modules/@actions/workflow-parser/dist/templates/template-reader.js");
/* harmony import */ var _workflow_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./workflow-constants */ "./node_modules/@actions/workflow-parser/dist/workflows/workflow-constants.js");
/* harmony import */ var _workflow_schema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./workflow-schema */ "./node_modules/@actions/workflow-parser/dist/workflows/workflow-schema.js");
/* harmony import */ var _yaml_object_reader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./yaml-object-reader */ "./node_modules/@actions/workflow-parser/dist/workflows/yaml-object-reader.js");





function parseWorkflow(entryFile, contextOrTrace) {
    const context = contextOrTrace instanceof _templates_template_context__WEBPACK_IMPORTED_MODULE_0__.TemplateContext
        ? contextOrTrace
        : new _templates_template_context__WEBPACK_IMPORTED_MODULE_0__.TemplateContext(new _templates_template_context__WEBPACK_IMPORTED_MODULE_0__.TemplateValidationErrors(), (0,_workflow_schema__WEBPACK_IMPORTED_MODULE_3__.getWorkflowSchema)(), contextOrTrace);
    const fileId = context.getFileId(entryFile.name);
    const reader = new _yaml_object_reader__WEBPACK_IMPORTED_MODULE_4__.YamlObjectReader(fileId, entryFile.content);
    if (reader.errors.length > 0) {
        // The file is not valid YAML, template errors could be misleading
        for (const err of reader.errors) {
            context.error(fileId, err.message, err.range);
        }
        return {
            context,
            value: undefined
        };
    }
    const result = _templates_template_reader__WEBPACK_IMPORTED_MODULE_1__.readTemplate(context, _workflow_constants__WEBPACK_IMPORTED_MODULE_2__.WORKFLOW_ROOT, reader, fileId);
    return {
        context,
        value: result
    };
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/workflows/workflow-schema.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/workflows/workflow-schema.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getWorkflowSchema: () => (/* binding */ getWorkflowSchema)
/* harmony export */ });
/* harmony import */ var _templates_json_object_reader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../templates/json-object-reader */ "./node_modules/@actions/workflow-parser/dist/templates/json-object-reader.js");
/* harmony import */ var _templates_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../templates/schema */ "./node_modules/@actions/workflow-parser/dist/templates/schema/index.js");
/* harmony import */ var _workflow_v1_0_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../workflow-v1.0.json */ "./node_modules/@actions/workflow-parser/dist/workflow-v1.0.json");



let schema;
function getWorkflowSchema() {
    if (schema === undefined) {
        const json = JSON.stringify(_workflow_v1_0_json__WEBPACK_IMPORTED_MODULE_2__);
        schema = _templates_schema__WEBPACK_IMPORTED_MODULE_1__.TemplateSchema.load(new _templates_json_object_reader__WEBPACK_IMPORTED_MODULE_0__.JSONObjectReader(undefined, json));
    }
    return schema;
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/workflows/yaml-object-reader.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/workflows/yaml-object-reader.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YamlObjectReader: () => (/* binding */ YamlObjectReader)
/* harmony export */ });
/* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yaml */ "./node_modules/yaml/dist/index.js");
/* harmony import */ var _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../templates/parse-event */ "./node_modules/@actions/workflow-parser/dist/templates/parse-event.js");
/* harmony import */ var _templates_tokens_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../templates/tokens/index */ "./node_modules/@actions/workflow-parser/dist/templates/tokens/index.js");



class YamlObjectReader {
    constructor(fileId, content) {
        this.lineCounter = new yaml__WEBPACK_IMPORTED_MODULE_0__.LineCounter();
        this.errors = [];
        const doc = (0,yaml__WEBPACK_IMPORTED_MODULE_0__.parseDocument)(content, {
            lineCounter: this.lineCounter,
            keepSourceTokens: true,
            uniqueKeys: false // Uniqueness is validated by the template reader
        });
        for (const err of doc.errors) {
            this.errors.push({ message: err.message, range: rangeFromLinePos(err.linePos) });
        }
        this._generator = this.getNodes(doc);
        this.fileId = fileId;
    }
    *getNodes(node) {
        let range = this.getRange(node);
        if ((0,yaml__WEBPACK_IMPORTED_MODULE_0__.isDocument)(node)) {
            yield new _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.ParseEvent(_templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.DocumentStart);
            for (const item of this.getNodes(node.contents)) {
                yield item;
            }
            yield new _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.ParseEvent(_templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.DocumentEnd);
        }
        if ((0,yaml__WEBPACK_IMPORTED_MODULE_0__.isCollection)(node)) {
            if ((0,yaml__WEBPACK_IMPORTED_MODULE_0__.isSeq)(node)) {
                yield new _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.ParseEvent(_templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.SequenceStart, new _templates_tokens_index__WEBPACK_IMPORTED_MODULE_2__.SequenceToken(this.fileId, range, undefined));
            }
            else if ((0,yaml__WEBPACK_IMPORTED_MODULE_0__.isMap)(node)) {
                yield new _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.ParseEvent(_templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.MappingStart, new _templates_tokens_index__WEBPACK_IMPORTED_MODULE_2__.MappingToken(this.fileId, range, undefined));
            }
            for (const item of node.items) {
                for (const child of this.getNodes(item)) {
                    yield child;
                }
            }
            if ((0,yaml__WEBPACK_IMPORTED_MODULE_0__.isSeq)(node)) {
                yield new _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.ParseEvent(_templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.SequenceEnd);
            }
            else if ((0,yaml__WEBPACK_IMPORTED_MODULE_0__.isMap)(node)) {
                yield new _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.ParseEvent(_templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.MappingEnd);
            }
        }
        if ((0,yaml__WEBPACK_IMPORTED_MODULE_0__.isScalar)(node)) {
            yield new _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.ParseEvent(_templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.Literal, YamlObjectReader.getLiteralToken(this.fileId, range, node));
        }
        if ((0,yaml__WEBPACK_IMPORTED_MODULE_0__.isPair)(node)) {
            const scalarKey = node.key;
            range = this.getRange(scalarKey);
            const key = scalarKey.value;
            yield new _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.ParseEvent(_templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.Literal, new _templates_tokens_index__WEBPACK_IMPORTED_MODULE_2__.StringToken(this.fileId, range, key, undefined));
            for (const child of this.getNodes(node.value)) {
                yield child;
            }
        }
    }
    getRange(node) {
        const range = node?.range ?? [];
        const startPos = range[0];
        const endPos = range[1];
        if (startPos !== undefined && endPos !== undefined) {
            const slp = this.lineCounter.linePos(startPos);
            const elp = this.lineCounter.linePos(endPos);
            return {
                start: { line: slp.line, column: slp.col },
                end: { line: elp.line, column: elp.col }
            };
        }
        return undefined;
    }
    static getLiteralToken(fileId, range, token) {
        const value = token.value;
        if (value === null || value === undefined) {
            return new _templates_tokens_index__WEBPACK_IMPORTED_MODULE_2__.NullToken(fileId, range, undefined);
        }
        switch (typeof value) {
            case "number":
                return new _templates_tokens_index__WEBPACK_IMPORTED_MODULE_2__.NumberToken(fileId, range, value, undefined);
            case "boolean":
                return new _templates_tokens_index__WEBPACK_IMPORTED_MODULE_2__.BooleanToken(fileId, range, value, undefined);
            case "string": {
                let source;
                if (token.srcToken && "source" in token.srcToken) {
                    source = token.srcToken.source;
                }
                return new _templates_tokens_index__WEBPACK_IMPORTED_MODULE_2__.StringToken(fileId, range, value, undefined, source);
            }
            default:
                throw new Error(`Unexpected value type '${typeof value}' when reading object`);
        }
    }
    allowLiteral() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.Literal) {
                this._current = this._generator.next();
                return parseEvent.token;
            }
        }
        return undefined;
    }
    allowSequenceStart() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.SequenceStart) {
                this._current = this._generator.next();
                return parseEvent.token;
            }
        }
        return undefined;
    }
    allowSequenceEnd() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.SequenceEnd) {
                this._current = this._generator.next();
                return true;
            }
        }
        return false;
    }
    allowMappingStart() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.MappingStart) {
                this._current = this._generator.next();
                return parseEvent.token;
            }
        }
        return undefined;
    }
    allowMappingEnd() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.MappingEnd) {
                this._current = this._generator.next();
                return true;
            }
        }
        return false;
    }
    validateEnd() {
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.DocumentEnd) {
                this._current = this._generator.next();
                return;
            }
        }
        throw new Error("Expected end of reader");
    }
    validateStart() {
        if (!this._current) {
            this._current = this._generator.next();
        }
        if (!this._current.done) {
            const parseEvent = this._current.value;
            if (parseEvent.type === _templates_parse_event__WEBPACK_IMPORTED_MODULE_1__.EventType.DocumentStart) {
                this._current = this._generator.next();
                return;
            }
        }
        throw new Error("Expected start of reader");
    }
}
function rangeFromLinePos(linePos) {
    if (linePos === undefined) {
        return;
    }
    // TokenRange and linePos are both 1-based
    const start = { line: linePos[0].line, column: linePos[0].col };
    const end = linePos.length == 2 ? { line: linePos[1].line, column: linePos[1].col } : start;
    return { start, end };
}


/***/ }),

/***/ "./node_modules/@actions/workflow-parser/dist/workflow-v1.0.json":
/*!***********************************************************************!*\
  !*** ./node_modules/@actions/workflow-parser/dist/workflow-v1.0.json ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"version":"workflow-v1.0","definitions":{"workflow-root":{"description":"A workflow file.","mapping":{"properties":{"on":"on","name":"workflow-name","run-name":"run-name","defaults":"workflow-defaults","env":"workflow-env","permissions":"permissions","concurrency":"workflow-concurrency","jobs":{"type":"jobs","required":true}}}},"workflow-root-strict":{"description":"Workflow file with strict validation","mapping":{"properties":{"on":{"type":"on-strict","required":true},"name":"workflow-name","run-name":"run-name","defaults":"workflow-defaults","env":"workflow-env","permissions":"permissions","concurrency":"workflow-concurrency","jobs":{"type":"jobs","required":true}}}},"workflow-name":{"description":"The name of the workflow that GitHub displays on your repository\'s \'Actions\' tab.\\n\\n[Documentation](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#name)","string":{}},"run-name":{"context":["github","inputs","vars"],"string":{},"description":"The name for workflow runs generated from the workflow. GitHub displays the workflow run name in the list of workflow runs on your repository\'s \'Actions\' tab.\\n\\n[Documentation](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#run-name)"},"on":{"description":"The GitHub event that triggers the workflow. Events can be a single string, array of events, array of event types, or an event configuration map that schedules a workflow or restricts the execution of a workflow to specific files, tags, or branch changes. View a full list of [events that trigger workflows](https://docs.github.com/actions/using-workflows/events-that-trigger-workflows).\\n\\n[Documentation](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#on)","one-of":["string","sequence","on-mapping"]},"on-mapping":{"mapping":{"properties":{"workflow_call":"workflow-call"},"loose-key-type":"non-empty-string","loose-value-type":"any"}},"on-strict":{"description":"The GitHub event that triggers the workflow.  Events can be a single string, array of events, array of event types, or an event configuration map that schedules a workflow or restricts the execution of a workflow to specific files, tags, or branch changes. View a full list of [events that trigger workflows](https://docs.github.com/actions/using-workflows/events-that-trigger-workflows).\\n\\n[Documentation](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#on)","one-of":["on-string-strict","on-sequence-strict","on-mapping-strict"]},"on-mapping-strict":{"description":"The GitHub event that triggers the workflow.  Events can be a single string, array of events, array of event types, or an event configuration map that schedules a workflow or restricts the execution of a workflow to specific files, tags, or branch changes. View a full list of [events that trigger workflows](https://docs.github.com/actions/using-workflows/events-that-trigger-workflows).\\n\\n[Documentation](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#on)","mapping":{"properties":{"branch_protection_rule":"branch-protection-rule","check_run":"check-run","check_suite":"check-suite","create":"create","delete":"delete","deployment":"deployment","deployment_status":"deployment-status","discussion":"discussion","discussion_comment":"discussion-comment","fork":"fork","gollum":"gollum","issue_comment":"issue-comment","issues":"issues","label":"label","merge_group":"merge-group","milestone":"milestone","page_build":"page-build","project":"project","project_card":"project-card","project_column":"project-column","public":"public","pull_request":"pull-request","pull_request_comment":"pull-request-comment","pull_request_review":"pull-request-review","pull_request_review_comment":"pull-request-review-comment","pull_request_target":"pull-request-target","push":"push","registry_package":"registry-package","release":"release","repository_dispatch":"repository-dispatch","schedule":"schedule","status":"status","watch":"watch","workflow_call":"workflow-call","workflow_dispatch":"workflow-dispatch","workflow_run":"workflow-run"}}},"on-string-strict":{"one-of":["branch-protection-rule-string","check-run-string","check-suite-string","create-string","delete-string","deployment-string","deployment-status-string","discussion-string","discussion-comment-string","fork-string","gollum-string","issue-comment-string","issues-string","label-string","merge-group-string","milestone-string","page-build-string","project-string","project-card-string","project-column-string","public-string","pull-request-string","pull-request-comment-string","pull-request-review-string","pull-request-review-comment-string","pull-request-target-string","push-string","registry-package-string","release-string","repository-dispatch-string","schedule-string","status-string","watch-string","workflow-call-string","workflow-dispatch-string","workflow-run-string"]},"on-sequence-strict":{"sequence":{"item-type":"on-string-strict"}},"branch-protection-rule-string":{"description":"Runs your workflow when branch protection rules in the workflow repository are changed.","string":{"constant":"branch_protection_rule"}},"branch-protection-rule":{"description":"Runs your workflow when branch protection rules in the workflow repository are changed.","one-of":["null","branch-protection-rule-mapping"]},"branch-protection-rule-mapping":{"mapping":{"properties":{"types":"branch-protection-rule-activity"}}},"branch-protection-rule-activity":{"description":"The types of branch protection rule activity that trigger the workflow. Supported activity types: `created`, `edited`, `deleted`.","one-of":["branch-protection-rule-activity-type","branch-protection-rule-activity-types"]},"branch-protection-rule-activity-types":{"sequence":{"item-type":"branch-protection-rule-activity-type"}},"branch-protection-rule-activity-type":{"allowed-values":["created","edited","deleted"]},"check-run-string":{"description":"Runs your workflow when activity related to a check run occurs. A check run is an individual test that is part of a check suite.","string":{"constant":"check_run"}},"check-run":{"description":"Runs your workflow when activity related to a check run occurs. A check run is an individual test that is part of a check suite.","one-of":["null","check-run-mapping"]},"check-run-mapping":{"mapping":{"properties":{"types":"check-run-activity"}}},"check-run-activity":{"description":"The types of check run activity that trigger the workflow. Supported activity types: `created`, `rerequested`, `completed`, `requested_action`.","one-of":["check-run-activity-type","check-run-activity-types"]},"check-run-activity-types":{"sequence":{"item-type":"check-run-activity-type"}},"check-run-activity-type":{"allowed-values":["completed","created","rerequested","requested_action"]},"check-suite-string":{"description":"Runs your workflow when check suite activity occurs. A check suite is a collection of the check runs created for a specific commit. Check suites summarize the status and conclusion of the check runs that are in the suite.","string":{"constant":"check_suite"}},"check-suite":{"description":"Runs your workflow when check suite activity occurs. A check suite is a collection of the check runs created for a specific commit. Check suites summarize the status and conclusion of the check runs that are in the suite.","one-of":["null","check-suite-mapping"]},"check-suite-mapping":{"mapping":{"properties":{"types":"check-suite-activity"}}},"check-suite-activity":{"description":"The types of check suite activity that trigger the workflow. Supported activity types: `completed`.","one-of":["check-suite-activity-type","check-suite-activity-types"]},"check-suite-activity-types":{"sequence":{"item-type":"check-suite-activity-type"}},"check-suite-activity-type":{"allowed-values":["completed"]},"create-string":{"description":"Runs your workflow when someone creates a Git reference (Git branch or tag) in the workflow\'s repository.","string":{"constant":"create"}},"create":{"description":"Runs your workflow when someone creates a Git reference (Git branch or tag) in the workflow\'s repository.","null":{}},"delete-string":{"description":"Runs your workflow when someone deletes a Git reference (Git branch or tag) in the workflow\'s repository.","string":{"constant":"delete"}},"delete":{"description":"Runs your workflow when someone deletes a Git reference (Git branch or tag) in the workflow\'s repository.","null":{}},"deployment-string":{"description":"Runs your workflow when someone creates a deployment in the workflow\'s repository. Deployments created with a commit SHA may not have a Git ref.","string":{"constant":"deployment"}},"deployment":{"description":"Runs your workflow when someone creates a deployment in the workflow\'s repository. Deployments created with a commit SHA may not have a Git ref.","null":{}},"deployment-status-string":{"description":"Runs your workflow when a third party provides a deployment status. Deployments created with a commit SHA may not have a Git ref.","string":{"constant":"deployment_status"}},"deployment-status":{"description":"Runs your workflow when a third party provides a deployment status. Deployments created with a commit SHA may not have a Git ref.","null":{}},"discussion-string":{"description":"Runs your workflow when a discussion in the workflow\'s repository is created or modified. For activity related to comments on a discussion, use the `discussion_comment` event.","string":{"constant":"discussion"}},"discussion":{"description":"Runs your workflow when a discussion in the workflow\'s repository is created or modified. For activity related to comments on a discussion, use the `discussion_comment` event.","one-of":["null","discussion-mapping"]},"discussion-mapping":{"mapping":{"properties":{"types":"discussion-activity"}}},"discussion-activity":{"description":"The types of discussion activity that trigger the workflow. Supported activity types: `created`, `edited`, `deleted`, `transferred`, `pinned`, `unpinned`, `labeled`, `unlabeled`, `locked`, `unlocked`, `category_changed`, `answered`, `unanswered`.","one-of":["discussion-activity-type","discussion-activity-types"]},"discussion-activity-types":{"sequence":{"item-type":"discussion-activity-type"}},"discussion-activity-type":{"allowed-values":["created","edited","deleted","transferred","pinned","unpinned","labeled","unlabeled","locked","unlocked","category_changed","answered","unanswered"]},"discussion-comment-string":{"description":"Runs your workflow when a comment on a discussion in the workflow\'s repository is created or modified. For activity related to a discussion as opposed to comments on the discussion, use the `discussion` event.","string":{"constant":"discussion_comment"}},"discussion-comment":{"description":"Runs your workflow when a comment on a discussion in the workflow\'s repository is created or modified. For activity related to a discussion as opposed to comments on the discussion, use the `discussion` event.","one-of":["null","discussion-comment-mapping"]},"discussion-comment-mapping":{"mapping":{"properties":{"types":"discussion-comment-activity"}}},"discussion-comment-activity":{"description":"The types of discussion comment activity that trigger the workflow. Supported activity types: `created`, `edited`, `deleted`.","one-of":["discussion-comment-activity-type","discussion-comment-activity-types"]},"discussion-comment-activity-types":{"sequence":{"item-type":"discussion-comment-activity-type"}},"discussion-comment-activity-type":{"allowed-values":["created","edited","deleted"]},"fork-string":{"description":"Runs your workflow when someone forks a repository.","string":{"constant":"fork"}},"fork":{"description":"Runs your workflow when someone forks a repository.","null":{}},"gollum-string":{"description":"Runs your workflow when someone creates or updates a Wiki page.","string":{"constant":"gollum"}},"gollum":{"description":"Runs your workflow when someone creates or updates a Wiki page.","null":{}},"issue-comment-string":{"description":"Runs your workflow when an issue or pull request comment is created, edited, or deleted.","string":{"constant":"issue_comment"}},"issue-comment":{"description":"Runs your workflow when an issue or pull request comment is created, edited, or deleted.","one-of":["null","issue-comment-mapping"]},"issue-comment-mapping":{"mapping":{"properties":{"types":"issue-comment-activity"}}},"issue-comment-activity":{"description":"The types of issue comment activity that trigger the workflow. Supported activity types: `created`, `edited`, `deleted`.","one-of":["issue-comment-activity-type","issue-comment-activity-types"]},"issue-comment-activity-types":{"sequence":{"item-type":"issue-comment-activity-type"}},"issue-comment-activity-type":{"allowed-values":["created","edited","deleted"]},"issues-string":{"description":"Runs your workflow when an issue in the workflow\'s repository is created or modified. For activity related to comments in an issue, use the `issue_comment` event.","string":{"constant":"issues"}},"issues":{"description":"Runs your workflow when an issue in the workflow\'s repository is created or modified. For activity related to comments in an issue, use the `issue_comment` event.","one-of":["null","issues-mapping"]},"issues-mapping":{"mapping":{"properties":{"types":"issues-activity"}}},"issues-activity":{"description":"The types of issue activity that trigger the workflow. Supported activity types: `opened`, `edited`, `deleted`, `transferred`, `pinned`, `unpinned`, `closed`, `reopened`, `assigned`, `unassigned`, `labeled`, `unlabeled`, `locked`, `unlocked`, `milestoned`, `demilestoned`.","one-of":["issues-activity-type","issues-activity-types"]},"issues-activity-types":{"sequence":{"item-type":"issues-activity-type"}},"issues-activity-type":{"allowed-values":["opened","edited","deleted","transferred","pinned","unpinned","closed","reopened","assigned","unassigned","labeled","unlabeled","locked","unlocked","milestoned","demilestoned"]},"label-string":{"description":"Runs your workflow when a label in your workflow\'s repository is created or modified.","string":{"constant":"label"}},"label":{"description":"Runs your workflow when a label in your workflow\'s repository is created or modified.","one-of":["null","label-mapping"]},"label-mapping":{"mapping":{"properties":{"types":"label-activity"}}},"label-activity":{"description":"The types of label activity that trigger the workflow. Supported activity types: `created`, `edited`, `deleted`.","one-of":["label-activity-type","label-activity-types"]},"label-activity-types":{"sequence":{"item-type":"label-activity-type"}},"label-activity-type":{"allowed-values":["created","edited","deleted"]},"merge-group-string":{"description":"Runs your workflow when a pull request is added to a merge queue, which adds the pull request to a merge group.","string":{"constant":"merge_group"}},"merge-group":{"description":"Runs your workflow when a pull request is added to a merge queue, which adds the pull request to a merge group.","one-of":["null","merge-group-mapping"]},"merge-group-mapping":{"mapping":{"properties":{"types":"merge-group-activity","branches":"event-branches","branches-ignore":"event-branches-ignore"}}},"merge-group-activity":{"description":"The types of merge group activity that trigger the workflow. Supported activity types: `checks_requested`.","one-of":["merge-group-activity-type","merge-group-activity-types"]},"merge-group-activity-types":{"sequence":{"item-type":"merge-group-activity-type"}},"merge-group-activity-type":{"allowed-values":["checks_requested"]},"milestone-string":{"description":"Runs your workflow when a milestone in the workflow\'s repository is created or modified.","string":{"constant":"milestone"}},"milestone":{"description":"Runs your workflow when a milestone in the workflow\'s repository is created or modified.","one-of":["null","milestone-mapping"]},"milestone-mapping":{"mapping":{"properties":{"types":"milestone-activity"}}},"milestone-activity":{"description":"The types of milestone activity that trigger the workflow. Supported activity types: `created`, `closed`, `opened`, `edited`, `deleted`.","one-of":["milestone-activity-type","milestone-activity-types"]},"milestone-activity-types":{"sequence":{"item-type":"milestone-activity-type"}},"milestone-activity-type":{"allowed-values":["created","closed","opened","edited","deleted"]},"page-build-string":{"description":"Runs your workflow when someone pushes to a branch that is the publishing source for GitHub Pages, if GitHub Pages is enabled for the repository.","string":{"constant":"page_build"}},"page-build":{"description":"Runs your workflow when someone pushes to a branch that is the publishing source for GitHub Pages, if GitHub Pages is enabled for the repository.","null":{}},"project-string":{"description":"Runs your workflow when a project board is created or modified. For activity related to cards or columns in a project board, use the `project_card` or `project_column` events instead.","string":{"constant":"project"}},"project":{"description":"Runs your workflow when a project board is created or modified. For activity related to cards or columns in a project board, use the `project_card` or `project_column` events instead.","one-of":["null","project-mapping"]},"project-mapping":{"mapping":{"properties":{"types":"project-activity"}}},"project-activity":{"description":"The types of project activity that trigger the workflow. Supported activity types: `created`, `closed`, `reopened`, `edited`, `deleted`.","one-of":["project-activity-type","project-activity-types"]},"project-activity-types":{"sequence":{"item-type":"project-activity-type"}},"project-activity-type":{"allowed-values":["created","closed","reopened","edited","deleted"]},"project-card-string":{"description":"Runs your workflow when a card on a project board is created or modified. For activity related to project boards or columns in a project board, use the `project` or `project_column` event instead.","string":{"constant":"project_card"}},"project-card":{"description":"Runs your workflow when a card on a project board is created or modified. For activity related to project boards or columns in a project board, use the `project` or `project_column` event instead.","one-of":["null","project-card-mapping"]},"project-card-mapping":{"mapping":{"properties":{"types":"project-card-activity"}}},"project-card-activity":{"description":"The types of project card activity that trigger the workflow. Supported activity types: `created`, `moved`, `converted`, `edited`, `deleted`.","one-of":["project-card-activity-type","project-card-activity-types"]},"project-card-activity-types":{"sequence":{"item-type":"project-card-activity-type"}},"project-card-activity-type":{"allowed-values":["created","moved","converted","edited","deleted"]},"project-column-string":{"description":"Runs your workflow when a column on a project board is created or modified. For activity related to project boards or cards in a project board, use the `project` or `project_card` event instead.","string":{"constant":"project_column"}},"project-column":{"description":"Runs your workflow when a column on a project board is created or modified. For activity related to project boards or cards in a project board, use the `project` or `project_card` event instead.","one-of":["null","project-column-mapping"]},"project-column-mapping":{"mapping":{"properties":{"types":"project-column-activity"}}},"project-column-activity":{"description":"The types of project column activity that trigger the workflow. Supported activity types: `created`, `updated`, `moved`, `deleted`.","one-of":["project-column-activity-type","project-column-activity-types"]},"project-column-activity-types":{"sequence":{"item-type":"project-column-activity-type"}},"project-column-activity-type":{"allowed-values":["created","updated","moved","deleted"]},"public-string":{"description":"Runs your workflow when your workflow\'s repository changes from private to public.","string":{"constant":"public"}},"public":{"description":"Runs your workflow when your workflow\'s repository changes from private to public.","null":{}},"pull-request-string":{"description":"Runs your workflow when activity on a pull request in the workflow\'s repository occurs. If no activity types are specified, the workflow runs when a pull request is opened, reopened, or when the head branch of the pull request is updated.","string":{"constant":"pull_request"}},"pull-request":{"description":"Runs your workflow when activity on a pull request in the workflow\'s repository occurs. If no activity types are specified, the workflow runs when a pull request is opened, reopened, or when the head branch of the pull request is updated.","one-of":["null","pull-request-mapping"]},"pull-request-mapping":{"mapping":{"properties":{"types":"pull-request-activity","branches":"event-branches","branches-ignore":"event-branches-ignore","paths":"event-paths","paths-ignore":"event-paths-ignore"}}},"pull-request-activity":{"description":"The types of pull request activity that trigger the workflow. Supported activity types: `assigned`, `unassigned`, `labeled`, `unlabeled`, `opened`, `edited`, `closed`, `reopened`, `synchronize`, `converted_to_draft`, `ready_for_review`, `locked`, `unlocked`, `review_requested`, `review_request_removed`, `auto_merge_enabled`, `auto_merge_disabled`.","one-of":["pull-request-activity-type","pull-request-activity-types"]},"pull-request-activity-types":{"sequence":{"item-type":"pull-request-activity-type"}},"pull-request-activity-type":{"allowed-values":["assigned","unassigned","labeled","unlabeled","opened","edited","closed","reopened","synchronize","converted_to_draft","ready_for_review","locked","unlocked","review_requested","review_request_removed","auto_merge_enabled","auto_merge_disabled"]},"pull-request-comment-string":{"description":"Please use the `issue_comment` event instead.","string":{"constant":"pull_request_comment"}},"pull-request-comment":{"description":"Please use the `issue_comment` event instead.","one-of":["null","issue-comment-mapping"]},"pull-request-review-string":{"description":"Runs your workflow when a pull request review is submitted, edited, or dismissed. A pull request review is a group of pull request review comments in addition to a body comment and a state. For activity related to pull request review comments or pull request comments, use the `pull_request_review_comment` or `issue_comment` events instead.","string":{"constant":"pull_request_review"}},"pull-request-review":{"description":"Runs your workflow when a pull request review is submitted, edited, or dismissed. A pull request review is a group of pull request review comments in addition to a body comment and a state. For activity related to pull request review comments or pull request comments, use the `pull_request_review_comment` or `issue_comment` events instead.","one-of":["null","pull-request-review-mapping"]},"pull-request-review-mapping":{"mapping":{"properties":{"types":"pull-request-review-activity"}}},"pull-request-review-activity":{"description":"The types of pull request review activity that trigger the workflow. Supported activity types: `submitted`, `edited`, `dismissed`.","one-of":["pull-request-review-activity-type","pull-request-review-activity-types"]},"pull-request-review-activity-types":{"sequence":{"item-type":"pull-request-review-activity-type"}},"pull-request-review-activity-type":{"allowed-values":["submitted","edited","dismissed"]},"pull-request-review-comment-string":{"description":"","string":{"constant":"pull_request_review_comment"}},"pull-request-review-comment":{"description":"","one-of":["null","pull-request-review-comment-mapping"]},"pull-request-review-comment-mapping":{"mapping":{"properties":{"types":"pull-request-review-comment-activity"}}},"pull-request-review-comment-activity":{"description":"The types of pull request review comment activity that trigger the workflow. Supported activity types: `created`, `edited`, `deleted`.","one-of":["pull-request-review-comment-activity-type","pull-request-review-comment-activity-types"]},"pull-request-review-comment-activity-types":{"sequence":{"item-type":"pull-request-review-comment-activity-type"}},"pull-request-review-comment-activity-type":{"allowed-values":["created","edited","deleted"]},"pull-request-target-string":{"description":"Runs your workflow when activity on a pull request in the workflow\'s repository occurs. If no activity types are specified, the workflow runs when a pull request is opened, reopened, or when the head branch of the pull request is updated.\\n\\nThis event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the `pull_request` event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request.","string":{"constant":"pull_request_target"}},"pull-request-target":{"description":"Runs your workflow when activity on a pull request in the workflow\'s repository occurs. If no activity types are specified, the workflow runs when a pull request is opened, reopened, or when the head branch of the pull request is updated.\\n\\nThis event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the `pull_request` event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request.","one-of":["null","pull-request-target-mapping"]},"pull-request-target-mapping":{"mapping":{"properties":{"types":"pull-request-target-activity","branches":"event-branches","branches-ignore":"event-branches-ignore","paths":"event-paths","paths-ignore":"event-paths-ignore"}}},"pull-request-target-activity":{"description":"The types of pull request activity that trigger the workflow. Supported activity types: `assigned`, `unassigned`, `labeled`, `unlabeled`, `opened`, `edited`, `closed`, `reopened`, `synchronize`, `converted_to_draft`, `ready_for_review`, `locked`, `unlocked`, `review_requested`, `review_request_removed`, `auto_merge_enabled`, `auto_merge_disabled`.","one-of":["pull-request-target-activity-type","pull-request-target-activity-types"]},"pull-request-target-activity-types":{"sequence":{"item-type":"pull-request-target-activity-type"}},"pull-request-target-activity-type":{"allowed-values":["assigned","unassigned","labeled","unlabeled","opened","edited","closed","reopened","synchronize","converted_to_draft","ready_for_review","locked","unlocked","review_requested","review_request_removed","auto_merge_enabled","auto_merge_disabled"]},"push-string":{"description":"Runs your workflow when you push a commit or tag.","string":{"constant":"push"}},"push":{"description":"Runs your workflow when you push a commit or tag.","one-of":["null","push-mapping"]},"push-mapping":{"mapping":{"properties":{"branches":"event-branches","branches-ignore":"event-branches-ignore","tags":"event-tags","tags-ignore":"event-tags-ignore","paths":"event-paths","paths-ignore":"event-paths-ignore"}}},"registry-package-string":{"description":"Runs your workflow when activity related to GitHub Packages occurs in your repository.","string":{"constant":"registry_package"}},"registry-package":{"description":"Runs your workflow when activity related to GitHub Packages occurs in your repository.","one-of":["null","registry-package-mapping"]},"registry-package-mapping":{"mapping":{"properties":{"types":"registry-package-activity"}}},"registry-package-activity":{"description":"The types of registry package activity that trigger the workflow. Supported activity types: `published`, `updated`.","one-of":["registry-package-activity-type","registry-package-activity-types"]},"registry-package-activity-types":{"sequence":{"item-type":"registry-package-activity-type"}},"registry-package-activity-type":{"allowed-values":["published","updated"]},"release-string":{"description":"Runs your workflow when release activity in your repository occurs.","string":{"constant":"release"}},"release":{"description":"Runs your workflow when release activity in your repository occurs.","one-of":["null","release-mapping"]},"release-mapping":{"mapping":{"properties":{"types":"release-activity"}}},"release-activity":{"description":"The types of release activity that trigger the workflow. Supported activity types: `published`, `unpublished`, `created`, `edited`, `deleted`, `prereleased`, `released`.","one-of":["release-activity-type","release-activity-types"]},"release-activity-types":{"sequence":{"item-type":"release-activity-type"}},"release-activity-type":{"allowed-values":["published","unpublished","created","edited","deleted","prereleased","released"]},"schedule-string":{"description":"The `schedule` event allows you to trigger a workflow at a scheduled time.\\n\\nYou can schedule a workflow to run at specific UTC times using POSIX cron syntax. Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes. GitHub Actions does not support the non-standard syntax `@yearly`, `@monthly`, `@weekly`, `@daily`, `@hourly`, and `@reboot`.","string":{"constant":"schedule"}},"schedule":{"description":"The `schedule` event allows you to trigger a workflow at a scheduled time.\\n\\nYou can schedule a workflow to run at specific UTC times using POSIX cron syntax. Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes. GitHub Actions does not support the non-standard syntax `@yearly`, `@monthly`, `@weekly`, `@daily`, `@hourly`, and `@reboot`.","sequence":{"item-type":"cron-mapping"}},"status-string":{"description":"Runs your workflow when the status of a Git commit changes. For example, commits can be marked as `error`, `failure`, `pending`, or `success`. If you want to provide more details about the status change, you may want to use the `check_run` event.","string":{"constant":"status"}},"status":{"description":"Runs your workflow when the status of a Git commit changes. For example, commits can be marked as `error`, `failure`, `pending`, or `success`. If you want to provide more details about the status change, you may want to use the `check_run` event.","null":{}},"watch-string":{"description":"Runs your workflow when the workflow\'s repository is starred.","string":{"constant":"watch"}},"watch":{"description":"Runs your workflow when the workflow\'s repository is starred.","one-of":["null","watch-mapping"]},"watch-mapping":{"mapping":{"properties":{"types":"watch-activity"}}},"watch-activity":{"description":"The types of watch activity that trigger the workflow. Supported activity types: `started`.","one-of":["watch-activity-type","watch-activity-types"]},"watch-activity-types":{"sequence":{"item-type":"watch-activity-type"}},"watch-activity-type":{"allowed-values":["started"]},"workflow-run-string":{"description":"This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the `workflow_run` event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow.","string":{"constant":"workflow_run"}},"workflow-run":{"description":"This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the `workflow_run` event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow.","one-of":["null","workflow-run-mapping"]},"workflow-run-mapping":{"mapping":{"properties":{"types":"workflow-run-activity","workflows":"workflow-run-workflows","branches":"event-branches","branches-ignore":"event-branches-ignore"}}},"workflow-run-workflows":{"description":"The name of the workflow that triggers the `workflow_run` event. The workflow must be in the same repository as the workflow that uses the `workflow_run` event.","one-of":["non-empty-string","sequence-of-non-empty-string"]},"workflow-run-activity":{"description":"The types of workflow run activity that trigger the workflow. Supported activity types: `completed`, `requested`, `in_progress`.","one-of":["workflow-run-activity-type","workflow-run-activity-types"]},"workflow-run-activity-types":{"sequence":{"item-type":"workflow-run-activity-type"}},"workflow-run-activity-type":{"allowed-values":["requested","completed","in_progress"]},"event-branches":{"description":"Use the `branches` filter when you want to include branch name patterns or when you want to both include and exclude branch name patterns. You cannot use both the `branches` and `branches-ignore` filters for the same event in a workflow.","one-of":["non-empty-string","sequence-of-non-empty-string"]},"event-branches-ignore":{"description":"Use the `branches-ignore` filter when you only want to exclude branch name patterns. You cannot use both the `branches` and `branches-ignore` filters for the same event in a workflow.","one-of":["non-empty-string","sequence-of-non-empty-string"]},"event-tags":{"description":"Use the `tags` filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. You cannot use both the `tags` and `tags-ignore` filters for the same event in a workflow.","one-of":["non-empty-string","sequence-of-non-empty-string"]},"event-tags-ignore":{"description":"Use the `tags-ignore` filter when you only want to exclude tag name patterns. You cannot use both the `tags` and `tags-ignore` filters for the same event in a workflow.","one-of":["non-empty-string","sequence-of-non-empty-string"]},"event-paths":{"description":"Use the `paths` filter when you want to include file path patterns or when you want to both include and exclude file path patterns. You cannot use both the `paths` and `paths-ignore` filters for the same event in a workflow.","one-of":["non-empty-string","sequence-of-non-empty-string"]},"event-paths-ignore":{"description":"Use the `paths-ignore` filter when you only want to exclude file path patterns. You cannot use both the `paths` and `paths-ignore` filters for the same event in a workflow.","one-of":["non-empty-string","sequence-of-non-empty-string"]},"repository-dispatch-string":{"description":"You can use the GitHub API to trigger a webhook event called `repository_dispatch` when you want to trigger a workflow for activity that happens outside of GitHub.","string":{"constant":"branch_protection_rule"}},"repository-dispatch":{"description":"You can use the GitHub API to trigger a webhook event called `repository_dispatch` when you want to trigger a workflow for activity that happens outside of GitHub.","one-of":["null","repository-dispatch-mapping"]},"repository-dispatch-mapping":{"mapping":{"properties":{"types":"sequence-of-non-empty-string"}}},"workflow-call-string":{"description":"The `workflow_call` event is used to indicate that a workflow can be called by another workflow. When a workflow is triggered with the `workflow_call` event, the event payload in the called workflow is the same event payload from the calling workflow.","string":{"constant":"workflow_call"}},"workflow-call":{"description":"The `workflow_call` event is used to indicate that a workflow can be called by another workflow. When a workflow is triggered with the `workflow_call` event, the event payload in the called workflow is the same event payload from the calling workflow.","one-of":["null","workflow-call-mapping"]},"workflow-call-mapping":{"mapping":{"properties":{"inputs":"workflow-call-inputs","secrets":"workflow-call-secrets","outputs":"workflow-call-outputs"}}},"workflow-call-inputs":{"description":"Inputs that are passed to the called workflow from the caller workflow.","mapping":{"loose-key-type":"non-empty-string","loose-value-type":"workflow-call-input-definition"}},"workflow-call-input-definition":{"mapping":{"properties":{"description":{"type":"string","description":"A string description of the input parameter."},"type":{"type":"workflow-call-input-type","required":true},"required":{"type":"boolean","description":"A boolean to indicate whether the action requires the input parameter. Set to `true` when the parameter is required."},"default":"workflow-call-input-default"}}},"workflow-call-input-type":{"description":"Required if input is defined for the `on.workflow_call` keyword. The value of this parameter is a string specifying the data type of the input. This must be one of: `boolean`, `number`, or `string`.","one-of":["input-type-string","input-type-boolean","input-type-number"]},"input-type-string":{"string":{"constant":"string"}},"input-type-boolean":{"string":{"constant":"boolean"}},"input-type-number":{"string":{"constant":"number"}},"input-type-choice":{"string":{"constant":"choice"}},"input-type-environment":{"string":{"constant":"environment"}},"workflow-call-input-default":{"description":"If a `default` parameter is not set, the default value of the input is `false` for boolean, `0` for a number, and `\\"\\"` for a string.","context":["github","inputs","vars"],"one-of":["string","boolean","number"]},"workflow-call-secrets":{"description":"A map of the secrets that can be used in the called workflow. Within the called workflow, you can use the `secrets` context to refer to a secret.","mapping":{"loose-key-type":"workflow-call-secret-name","loose-value-type":"workflow-call-secret-definition"}},"workflow-call-secret-name":{"string":{"require-non-empty":true},"description":"A string identifier to associate with the secret."},"workflow-call-secret-definition":{"one-of":["null","workflow-call-secret-mapping-definition"]},"workflow-call-secret-mapping-definition":{"mapping":{"properties":{"description":{"type":"string","description":"A string description of the secret parameter."},"required":{"type":"boolean","description":"A boolean specifying whether the secret must be supplied."}}}},"workflow-call-outputs":{"description":"A reusable workflow may generate data that you want to use in the caller workflow. To use these outputs, you must specify them as the outputs of the reusable workflow.","mapping":{"loose-key-type":"workflow-call-output-name","loose-value-type":"workflow-call-output-definition"}},"workflow-call-output-name":{"string":{"require-non-empty":true},"description":"A string identifier to associate with the output. The value of `<output_id>` is a map of the input\'s metadata. The `<output_id>` must be a unique identifier within the outputs object and must start with a letter or _ and contain only alphanumeric characters, -, or _."},"workflow-call-output-definition":{"mapping":{"properties":{"description":{"type":"string","description":"A string description of the output parameter."},"value":{"type":"workflow-output-context","required":true}}}},"workflow-output-context":{"description":"The value to assign to the output parameter.","context":["github","inputs","vars","jobs"],"string":{}},"workflow-dispatch-string":{"description":"The `workflow_dispatch` event allows you to manually trigger a workflow run. A workflow can be manually triggered using the GitHub API, GitHub CLI, or GitHub browser interface.","string":{"constant":"workflow_dispatch"}},"workflow-dispatch":{"description":"The `workflow_dispatch` event allows you to manually trigger a workflow run. A workflow can be manually triggered using the GitHub API, GitHub CLI, or GitHub browser interface.","one-of":["null","workflow-dispatch-mapping"]},"workflow-dispatch-mapping":{"mapping":{"properties":{"inputs":"workflow-dispatch-inputs"}}},"workflow-dispatch-inputs":{"description":"You can configure custom-defined input properties, default input values, and required inputs for the event directly in your workflow. When you trigger the event, you can provide the `ref` and any `inputs`. When the workflow runs, you can access the input values in the `inputs` context.","mapping":{"loose-key-type":"workflow-dispatch-input-name","loose-value-type":"workflow-dispatch-input"}},"workflow-dispatch-input-name":{"string":{"require-non-empty":true},"description":"A string identifier to associate with the input. The value of <input_id> is a map of the input\'s metadata. The <input_id> must be a unique identifier within the inputs object. The <input_id> must start with a letter or _ and contain only alphanumeric characters, -, or _."},"workflow-dispatch-input":{"mapping":{"properties":{"description":{"type":"string","description":"A string description of the input parameter."},"type":{"type":"workflow-dispatch-input-type"},"required":{"type":"boolean","description":"A boolean to indicate whether the workflow requires the input parameter. Set to true when the parameter is required."},"default":"workflow-dispatch-input-default","options":{"type":"sequence-of-non-empty-string","description":"The options of the dropdown list, if the type is a choice."}}}},"workflow-dispatch-input-type":{"description":"A string representing the type of the input. This must be one of: `boolean`, `number`, `string`, `choice`, or `environment`.","one-of":["input-type-string","input-type-boolean","input-type-number","input-type-environment","input-type-choice"]},"workflow-dispatch-input-default":{"description":"The default value is used when an input parameter isn\'t specified in a workflow file.","one-of":["string","boolean","number"]},"permissions":{"description":"You can use `permissions` to modify the default permissions granted to the `GITHUB_TOKEN`, adding or removing access as required, so that you only allow the minimum required access.\\n\\n[Documentation](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#permissions)","one-of":["permissions-mapping","permission-level-shorthand-read-all","permission-level-shorthand-write-all"]},"permissions-mapping":{"mapping":{"properties":{"actions":{"type":"permission-level-any","description":"Actions workflows, workflow runs, and artifacts."},"checks":{"type":"permission-level-any","description":"Check runs and check suites."},"contents":{"type":"permission-level-any","description":"Repository contents, commits, branches, downloads, releases, and merges."},"deployments":{"type":"permission-level-any","description":"Deployments and deployment statuses."},"discussions":{"type":"permission-level-any","description":"Discussions and related comments and labels."},"id-token":{"type":"permission-level-write-or-no-access","description":"Token to request an OpenID Connect token."},"issues":{"type":"permission-level-any","description":"Issues and related comments, assignees, labels, and milestones."},"packages":{"type":"permission-level-any","description":"Packages published to the GitHub Package Platform."},"pages":{"type":"permission-level-any","description":"Retrieve Pages statuses, configuration, and builds, as well as create new builds."},"pull-requests":{"type":"permission-level-any","description":"Pull requests and related comments, assignees, labels, milestones, and merges."},"repository-projects":{"type":"permission-level-any","description":"Classic projects within a repository."},"security-events":{"type":"permission-level-any","description":"Code scanning and Dependabot alerts."},"statuses":{"type":"permission-level-any","description":"Commit statuses."}}}},"permission-level-any":{"description":"The permission level for the `GITHUB_TOKEN`.","one-of":["permission-level-read","permission-level-write","permission-level-no-access"]},"permission-level-read-or-no-access":{"one-of":["permission-level-read","permission-level-no-access"]},"permission-level-write-or-no-access":{"one-of":["permission-level-write","permission-level-no-access"]},"permission-level-read":{"description":"The permission level for the `GITHUB_TOKEN`. Grants `read` permission for the specified scope.","string":{"constant":"read"}},"permission-level-write":{"description":"The permission level for the `GITHUB_TOKEN`. Grants `write` permission for the specified scope.","string":{"constant":"write"}},"permission-level-no-access":{"description":"The permission level for the `GITHUB_TOKEN`. Restricts all access for the specified scope.","string":{"constant":"none"}},"permission-level-shorthand-read-all":{"description":"The permission level for the `GITHUB_TOKEN`. Grants `read` access for all scopes.","string":{"constant":"read-all"}},"permission-level-shorthand-write-all":{"description":"The permission level for the `GITHUB_TOKEN`. Grants `write` access for all scopes.","string":{"constant":"write-all"}},"workflow-defaults":{"description":"Use `defaults` to create a map of default settings that will apply to all jobs in the workflow. You can also set default settings that are only available to a job.\\n\\n[Documentation](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#defaults)","mapping":{"properties":{"run":"workflow-defaults-run"}}},"workflow-defaults-run":{"mapping":{"properties":{"shell":"shell","working-directory":"working-directory"}}},"workflow-env":{"description":"A map of environment variables that are available to the steps of all jobs in the workflow. You can also set environment variables that are only available to the steps of a single job or to a single step.\\n\\n[Documentation](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#env)","context":["github","inputs","vars","secrets"],"mapping":{"loose-key-type":"non-empty-string","loose-value-type":"string"}},"jobs":{"description":"A workflow run is made up of one or more `jobs`, which run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the `jobs.<job_id>.needs` keyword. Each job runs in a runner environment specified by `runs-on`.\\n\\n[Documentation](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#jobs)","mapping":{"loose-key-type":"job-id","loose-value-type":"job"}},"job-id":{"string":{"require-non-empty":true},"description":"A unique identifier for the job. The identifier must start with a letter or _ and contain only alphanumeric characters, -, or _."},"job":{"description":"Each job must have an id to associate with the job. The key `job_id` is a string and its value is a map of the job\'s configuration data. You must replace `<job_id>` with a string that is unique to the jobs object. The `<job_id>` must start with a letter or _ and contain only alphanumeric characters, -, or _.","one-of":["job-factory","workflow-job"]},"job-factory":{"mapping":{"properties":{"needs":"needs","if":"job-if","strategy":"strategy","name":{"type":"string-strategy-context","description":"The name of the job displayed on GitHub."},"runs-on":{"type":"runs-on","required":true},"timeout-minutes":{"type":"number-strategy-context","description":"The maximum number of minutes to let a workflow run before GitHub automatically cancels it. Default: 360"},"cancel-timeout-minutes":"number-strategy-context","continue-on-error":{"type":"boolean-strategy-context","description":"Prevents a workflow run from failing when a job fails. Set to true to allow a workflow run to pass when this job fails."},"container":"container","services":"services","env":"job-env","environment":"job-environment","permissions":"permissions","concurrency":"job-concurrency","outputs":"job-outputs","defaults":"job-defaults","steps":"steps"}}},"workflow-job":{"mapping":{"properties":{"name":{"type":"string-strategy-context","description":"The name of the job displayed on GitHub."},"uses":{"description":"The location and version of a reusable workflow file to run as a job. Use one of the following formats:\\n\\n* `{owner}/{repo}/.github/workflows/{filename}@{ref}` for reusable workflows in public and private repositories.\\n* `./.github/workflows/{filename}` for reusable workflows in the same repository.\\n\\n{ref} can be a SHA, a release tag, or a branch name. Using the commit SHA is the safest for stability and security.","type":"non-empty-string","required":true},"with":"workflow-job-with","secrets":"workflow-job-secrets","needs":"needs","if":"job-if","permissions":"permissions","concurrency":"job-concurrency","strategy":"strategy"}}},"workflow-job-with":{"description":"When a job is used to call a reusable workflow, you can use `with` to provide a map of inputs that are passed to the called workflow.\\n\\nAny inputs that you pass must match the input specifications defined in the called workflow.","mapping":{"loose-key-type":"non-empty-string","loose-value-type":"scalar-needs-context"}},"workflow-job-secrets":{"description":"When a job is used to call a reusable workflow, you can use `secrets` to provide a map of secrets that are passed to the called workflow.\\n\\nAny secrets that you pass must match the names defined in the called workflow.","one-of":["workflow-job-secrets-mapping","workflow-job-secrets-inherit"]},"workflow-job-secrets-mapping":{"mapping":{"loose-key-type":"non-empty-string","loose-value-type":"scalar-needs-context-with-secrets"}},"workflow-job-secrets-inherit":{"string":{"constant":"inherit"}},"needs":{"description":"Use `needs` to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure applies to all jobs in the dependency chain from the point of failure onwards.","one-of":["sequence-of-non-empty-string","non-empty-string"]},"job-if":{"description":"You can use the `if` conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional.","context":["github","inputs","vars","needs","always(0,0)","failure(0,MAX)","cancelled(0,0)","success(0,MAX)"],"string":{"is-expression":true}},"job-if-result":{"context":["github","inputs","vars","needs","always(0,0)","failure(0,MAX)","cancelled(0,0)","success(0,MAX)"],"one-of":["null","boolean","number","string","sequence","mapping"]},"strategy":{"description":"Use `strategy` to use a matrix strategy for your jobs. A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. ","context":["github","inputs","vars","needs"],"mapping":{"properties":{"fail-fast":{"type":"boolean","description":"Setting `fail-fast` to `false` prevents GitHub from canceling all in-progress jobs if any matrix job fails. Default: `true`"},"max-parallel":{"type":"number","description":"The maximum number of jobs that can run simultaneously when using a matrix job strategy. By default, GitHub will maximize the number of jobs run in parallel depending on runner availability."},"matrix":"matrix"}}},"matrix":{"description":"Use `matrix` to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values.","mapping":{"properties":{"include":{"type":"matrix-filter","description":"Use `include` to expand existing matrix configurations or to add new configurations. The value of `include` is a list of objects.\\n\\nFor each object in the `include` list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten."},"exclude":{"type":"matrix-filter","description":"To remove specific configurations defined in the matrix, use `exclude`. An excluded configuration only has to be a partial match for it to be excluded."}},"loose-key-type":"non-empty-string","loose-value-type":"sequence"}},"matrix-filter":{"sequence":{"item-type":"matrix-filter-item"}},"matrix-filter-item":{"mapping":{"loose-key-type":"non-empty-string","loose-value-type":"any"}},"runs-on":{"description":"Use `runs-on` to define the type of machine to run the job on.\\n* The destination machine can be either a GitHub-hosted runner, larger runner, or a self-hosted runner.\\n* You can target runners based on the labels assigned to them, or their group membership, or a combination of these.\\n* You can provide `runs-on` as a single string or as an array of strings.\\n* If you specify an array of strings, your workflow will execute on any runner that matches all of the specified `runs-on` values.\\n* If you would like to run your workflow on multiple machines, use `jobs.<job_id>.strategy`.","context":["github","inputs","vars","needs","strategy","matrix"],"one-of":["non-empty-string","sequence-of-non-empty-string","runs-on-mapping"]},"runs-on-mapping":{"mapping":{"properties":{"group":{"description":"The group from which to select a runner.","type":"non-empty-string"},"labels":"runs-on-labels"}}},"runs-on-labels":{"description":"The label by which to filter for available runners.","one-of":["non-empty-string","sequence-of-non-empty-string"]},"job-env":{"description":"A map of variables that are available to all steps in the job.","context":["github","inputs","vars","needs","strategy","matrix","secrets"],"mapping":{"loose-key-type":"non-empty-string","loose-value-type":"string"}},"workflow-concurrency":{"description":"Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression.\\n\\nYou can also specify `concurrency` at the job level.\\n\\n[Documentation](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#concurrency)","context":["github","inputs","vars"],"one-of":["string","concurrency-mapping"]},"job-concurrency":{"description":"Concurrency ensures that only a single job using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can use any context except for the `secrets` context.\\n\\nYou can also specify `concurrency` at the workflow level.","context":["github","inputs","vars","needs","strategy","matrix"],"one-of":["non-empty-string","concurrency-mapping"]},"concurrency-mapping":{"description":"Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression.\\n\\nYou can also specify `concurrency` at the job level.\\n\\n[Documentation](https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions#concurrency)","mapping":{"properties":{"group":{"type":"non-empty-string","required":true,"description":"When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be `pending`. Any previously pending job or workflow in the concurrency group will be canceled. To also cancel any currently running job or workflow in the same concurrency group, specify `cancel-in-progress: true`."},"cancel-in-progress":{"type":"boolean","description":"To cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true."}}}},"job-environment":{"description":"The environment that the job references. All environment protection rules must pass before a job referencing the environment is sent to a runner.","context":["github","inputs","vars","needs","strategy","matrix"],"one-of":["string","job-environment-mapping"]},"job-environment-mapping":{"mapping":{"properties":{"name":{"type":"job-environment-name","required":true},"url":{"type":"string-runner-context-no-secrets","description":"The environment URL, which maps to `environment_url` in the deployments API."}}}},"job-environment-name":{"description":"The name of the environment used by the job.","context":["github","inputs","vars","needs","strategy","matrix"],"string":{}},"job-defaults":{"description":"A map of default settings that will apply to all steps in the job. You can also set default settings for the entire workflow.","mapping":{"properties":{"run":"job-defaults-run"}}},"job-defaults-run":{"context":["github","inputs","vars","strategy","matrix","needs","env"],"mapping":{"properties":{"shell":"shell","working-directory":"working-directory"}}},"job-outputs":{"description":"A map of outputs for a called workflow. Called workflow outputs are available to all downstream jobs in the caller workflow. Each output has an identifier, an optional `description,` and a `value`. The `value` must be set to the value of an output from a job within the called workflow.","mapping":{"loose-key-type":"non-empty-string","loose-value-type":"string-runner-context"}},"steps":{"description":"A job contains a sequence of tasks called `steps`. Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step. Each step runs in its own process in the runner environment and has access to the workspace and filesystem. Because steps run in their own process, changes to environment variables are not preserved between steps. GitHub provides built-in steps to set up and complete a job. Must contain either `uses` or `run`.","sequence":{"item-type":"steps-item"}},"steps-item":{"one-of":["run-step","regular-step"]},"run-step":{"mapping":{"properties":{"name":"step-name","id":"step-id","if":"step-if","timeout-minutes":"step-timeout-minutes","run":{"type":"string-steps-context","description":"Runs command-line programs using the operating system\'s shell. If you do not provide a `name`, the step name will default to the text specified in the `run` command. Commands run using non-login shells by default. You can choose a different shell and customize the shell used to run commands. Each `run` keyword represents a new process and shell in the virtual environment. When you provide multi-line commands, each line runs in the same shell.","required":true},"continue-on-error":"step-continue-on-error","env":"step-env","working-directory":"string-steps-context","shell":"shell"}}},"regular-step":{"mapping":{"properties":{"name":"step-name","id":"step-id","if":"step-if","continue-on-error":"step-continue-on-error","timeout-minutes":"step-timeout-minutes","uses":{"type":"step-uses","required":true},"with":"step-with","env":"step-env"}}},"step-uses":{"description":"Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image.","string":{"require-non-empty":true}},"step-continue-on-error":{"context":["github","inputs","vars","needs","strategy","matrix","secrets","steps","job","runner","env","hashFiles(1,255)"],"boolean":{},"description":"Prevents a job from failing when a step fails. Set to `true` to allow a job to pass when this step fails."},"step-id":{"string":{"require-non-empty":true},"description":"A unique identifier for the step. You can use the `id` to reference the step in contexts."},"step-if":{"context":["github","inputs","vars","needs","strategy","matrix","steps","job","runner","env","always(0,0)","failure(0,0)","cancelled(0,0)","success(0,0)","hashFiles(1,255)"],"description":"Use the `if` conditional to prevent a step from running unless a condition is met. Any supported context and expression can be used to create a conditional. Expressions in an `if` conditional do not require the bracketed expression syntax. When you use expressions in an `if` conditional, you may omit the expression syntax because GitHub automatically evaluates the `if` conditional as an expression.","string":{"is-expression":true}},"step-if-result":{"context":["github","inputs","vars","strategy","matrix","steps","job","runner","env","always(0,0)","failure(0,0)","cancelled(0,0)","success(0,0)","hashFiles(1,255)"],"one-of":["null","boolean","number","string","sequence","mapping"]},"step-env":{"description":"Sets variables for steps to use in the runner environment. You can also set variables for the entire workflow or a job.","context":["github","inputs","vars","needs","strategy","matrix","secrets","steps","job","runner","env","hashFiles(1,255)"],"mapping":{"loose-key-type":"non-empty-string","loose-value-type":"string"}},"step-name":{"context":["github","inputs","vars","needs","strategy","matrix","secrets","steps","job","runner","env","hashFiles(1,255)"],"string":{},"description":"A name for your step to display on GitHub."},"step-timeout-minutes":{"context":["github","inputs","vars","needs","strategy","matrix","secrets","steps","job","runner","env","hashFiles(1,255)"],"number":{},"description":"The maximum number of minutes to run the step before killing the process."},"step-with":{"description":"A map of the input parameters defined by the action. Each input parameter is a key/value pair. Input parameters are set as variables. When you specify an input in a workflow file or use a default input value, GitHub creates a variable for the input with the name `INPUT_<VARIABLE_NAME>`. The variable created converts input names to uppercase letters and replaces spaces with `_`.","context":["github","inputs","vars","needs","strategy","matrix","secrets","steps","job","runner","env","hashFiles(1,255)"],"mapping":{"loose-key-type":"non-empty-string","loose-value-type":"string"}},"container":{"description":"A container to run any steps in a job that don\'t already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts.\\n\\nIf you do not set a container, all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container.","context":["github","inputs","vars","needs","strategy","matrix"],"one-of":["string","container-mapping"]},"container-mapping":{"mapping":{"properties":{"image":{"type":"non-empty-string","description":"Use `jobs.<job_id>.container.image` to define the Docker image to use as the container to run the action. The value can be the Docker Hub image or a registry name."},"options":{"type":"non-empty-string","description":"Use `jobs.<job_id>.container.options` to configure additional Docker container resource options."},"env":"container-env","ports":{"type":"sequence-of-non-empty-string","description":"Use `jobs.<job_id>.container.ports` to set an array of ports to expose on the container."},"volumes":{"type":"sequence-of-non-empty-string","description":"Use `jobs.<job_id>.container.volumes` to set an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host."},"credentials":"container-registry-credentials"}}},"services":{"description":"Additional containers to host services for a job in a workflow. These are useful for creating databases or cache services like redis. The runner on the virtual machine will automatically create a network and manage the life cycle of the service containers. When you use a service container for a job or your step uses container actions, you don\'t need to set port information to access the service. Docker automatically exposes all ports between containers on the same network. When both the job and the action run in a container, you can directly reference the container by its hostname. The hostname is automatically mapped to the service name. When a step does not use a container action, you must access the service using localhost and bind the ports.","context":["github","inputs","vars","needs","strategy","matrix"],"mapping":{"loose-key-type":"non-empty-string","loose-value-type":"services-container"}},"services-container":{"context":["github","inputs","vars","needs","strategy","matrix"],"one-of":["non-empty-string","container-mapping"]},"container-registry-credentials":{"description":"If the image\'s container registry requires authentication to pull the image, you can use `jobs.<job_id>.container.credentials` to set a map of the username and password. The credentials are the same values that you would provide to the `docker login` command.","context":["github","inputs","vars","secrets","env"],"mapping":{"properties":{"username":"non-empty-string","password":"non-empty-string"}}},"container-env":{"description":"Use `jobs.<job_id>.container.env` to set a map of variables in the container.","mapping":{"loose-key-type":"non-empty-string","loose-value-type":"string-runner-context"}},"non-empty-string":{"string":{"require-non-empty":true}},"sequence-of-non-empty-string":{"sequence":{"item-type":"non-empty-string"}},"boolean-needs-context":{"context":["github","inputs","vars","needs"],"boolean":{}},"number-needs-context":{"context":["github","inputs","vars","needs"],"number":{}},"string-needs-context":{"context":["github","inputs","vars","needs"],"string":{}},"scalar-needs-context":{"context":["github","inputs","vars","needs","strategy","matrix"],"one-of":["string","boolean","number"]},"scalar-needs-context-with-secrets":{"context":["github","inputs","vars","needs","secrets","strategy","matrix"],"one-of":["string","boolean","number"]},"boolean-strategy-context":{"context":["github","inputs","vars","needs","strategy","matrix"],"boolean":{}},"number-strategy-context":{"context":["github","inputs","vars","needs","strategy","matrix"],"number":{}},"string-strategy-context":{"context":["github","inputs","vars","needs","strategy","matrix"],"string":{}},"boolean-steps-context":{"context":["github","inputs","vars","needs","strategy","matrix","secrets","steps","job","runner","env","hashFiles(1,255)"],"boolean":{}},"number-steps-context":{"context":["github","inputs","vars","needs","strategy","matrix","secrets","steps","job","runner","env","hashFiles(1,255)"],"number":{}},"string-runner-context":{"context":["github","inputs","vars","needs","strategy","matrix","secrets","steps","job","runner","env"],"string":{}},"string-runner-context-no-secrets":{"context":["github","inputs","vars","needs","strategy","matrix","steps","job","runner","env"],"string":{}},"string-steps-context":{"context":["github","inputs","vars","needs","strategy","matrix","secrets","steps","job","runner","env","hashFiles(1,255)"],"string":{}},"shell":{"string":{"require-non-empty":true},"description":"Use `shell` to override the default shell settings in the runner\'s operating system. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in `run`."},"working-directory":{"string":{"require-non-empty":true},"description":"The `working-directory` keyword specifies the working directory where the command is run."},"cron-mapping":{"mapping":{"properties":{"cron":"cron-pattern"}}},"cron-pattern":{"string":{"require-non-empty":true}}}}');

/***/ }),

/***/ "./node_modules/tr46/lib/mappingTable.json":
/*!*************************************************!*\
  !*** ./node_modules/tr46/lib/mappingTable.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[[[0,44],"disallowed_STD3_valid"],[[45,46],"valid"],[[47,47],"disallowed_STD3_valid"],[[48,57],"valid"],[[58,64],"disallowed_STD3_valid"],[[65,65],"mapped",[97]],[[66,66],"mapped",[98]],[[67,67],"mapped",[99]],[[68,68],"mapped",[100]],[[69,69],"mapped",[101]],[[70,70],"mapped",[102]],[[71,71],"mapped",[103]],[[72,72],"mapped",[104]],[[73,73],"mapped",[105]],[[74,74],"mapped",[106]],[[75,75],"mapped",[107]],[[76,76],"mapped",[108]],[[77,77],"mapped",[109]],[[78,78],"mapped",[110]],[[79,79],"mapped",[111]],[[80,80],"mapped",[112]],[[81,81],"mapped",[113]],[[82,82],"mapped",[114]],[[83,83],"mapped",[115]],[[84,84],"mapped",[116]],[[85,85],"mapped",[117]],[[86,86],"mapped",[118]],[[87,87],"mapped",[119]],[[88,88],"mapped",[120]],[[89,89],"mapped",[121]],[[90,90],"mapped",[122]],[[91,96],"disallowed_STD3_valid"],[[97,122],"valid"],[[123,127],"disallowed_STD3_valid"],[[128,159],"disallowed"],[[160,160],"disallowed_STD3_mapped",[32]],[[161,167],"valid",[],"NV8"],[[168,168],"disallowed_STD3_mapped",[32,776]],[[169,169],"valid",[],"NV8"],[[170,170],"mapped",[97]],[[171,172],"valid",[],"NV8"],[[173,173],"ignored"],[[174,174],"valid",[],"NV8"],[[175,175],"disallowed_STD3_mapped",[32,772]],[[176,177],"valid",[],"NV8"],[[178,178],"mapped",[50]],[[179,179],"mapped",[51]],[[180,180],"disallowed_STD3_mapped",[32,769]],[[181,181],"mapped",[956]],[[182,182],"valid",[],"NV8"],[[183,183],"valid"],[[184,184],"disallowed_STD3_mapped",[32,807]],[[185,185],"mapped",[49]],[[186,186],"mapped",[111]],[[187,187],"valid",[],"NV8"],[[188,188],"mapped",[49,8260,52]],[[189,189],"mapped",[49,8260,50]],[[190,190],"mapped",[51,8260,52]],[[191,191],"valid",[],"NV8"],[[192,192],"mapped",[224]],[[193,193],"mapped",[225]],[[194,194],"mapped",[226]],[[195,195],"mapped",[227]],[[196,196],"mapped",[228]],[[197,197],"mapped",[229]],[[198,198],"mapped",[230]],[[199,199],"mapped",[231]],[[200,200],"mapped",[232]],[[201,201],"mapped",[233]],[[202,202],"mapped",[234]],[[203,203],"mapped",[235]],[[204,204],"mapped",[236]],[[205,205],"mapped",[237]],[[206,206],"mapped",[238]],[[207,207],"mapped",[239]],[[208,208],"mapped",[240]],[[209,209],"mapped",[241]],[[210,210],"mapped",[242]],[[211,211],"mapped",[243]],[[212,212],"mapped",[244]],[[213,213],"mapped",[245]],[[214,214],"mapped",[246]],[[215,215],"valid",[],"NV8"],[[216,216],"mapped",[248]],[[217,217],"mapped",[249]],[[218,218],"mapped",[250]],[[219,219],"mapped",[251]],[[220,220],"mapped",[252]],[[221,221],"mapped",[253]],[[222,222],"mapped",[254]],[[223,223],"deviation",[115,115]],[[224,246],"valid"],[[247,247],"valid",[],"NV8"],[[248,255],"valid"],[[256,256],"mapped",[257]],[[257,257],"valid"],[[258,258],"mapped",[259]],[[259,259],"valid"],[[260,260],"mapped",[261]],[[261,261],"valid"],[[262,262],"mapped",[263]],[[263,263],"valid"],[[264,264],"mapped",[265]],[[265,265],"valid"],[[266,266],"mapped",[267]],[[267,267],"valid"],[[268,268],"mapped",[269]],[[269,269],"valid"],[[270,270],"mapped",[271]],[[271,271],"valid"],[[272,272],"mapped",[273]],[[273,273],"valid"],[[274,274],"mapped",[275]],[[275,275],"valid"],[[276,276],"mapped",[277]],[[277,277],"valid"],[[278,278],"mapped",[279]],[[279,279],"valid"],[[280,280],"mapped",[281]],[[281,281],"valid"],[[282,282],"mapped",[283]],[[283,283],"valid"],[[284,284],"mapped",[285]],[[285,285],"valid"],[[286,286],"mapped",[287]],[[287,287],"valid"],[[288,288],"mapped",[289]],[[289,289],"valid"],[[290,290],"mapped",[291]],[[291,291],"valid"],[[292,292],"mapped",[293]],[[293,293],"valid"],[[294,294],"mapped",[295]],[[295,295],"valid"],[[296,296],"mapped",[297]],[[297,297],"valid"],[[298,298],"mapped",[299]],[[299,299],"valid"],[[300,300],"mapped",[301]],[[301,301],"valid"],[[302,302],"mapped",[303]],[[303,303],"valid"],[[304,304],"mapped",[105,775]],[[305,305],"valid"],[[306,307],"mapped",[105,106]],[[308,308],"mapped",[309]],[[309,309],"valid"],[[310,310],"mapped",[311]],[[311,312],"valid"],[[313,313],"mapped",[314]],[[314,314],"valid"],[[315,315],"mapped",[316]],[[316,316],"valid"],[[317,317],"mapped",[318]],[[318,318],"valid"],[[319,320],"mapped",[108,183]],[[321,321],"mapped",[322]],[[322,322],"valid"],[[323,323],"mapped",[324]],[[324,324],"valid"],[[325,325],"mapped",[326]],[[326,326],"valid"],[[327,327],"mapped",[328]],[[328,328],"valid"],[[329,329],"mapped",[700,110]],[[330,330],"mapped",[331]],[[331,331],"valid"],[[332,332],"mapped",[333]],[[333,333],"valid"],[[334,334],"mapped",[335]],[[335,335],"valid"],[[336,336],"mapped",[337]],[[337,337],"valid"],[[338,338],"mapped",[339]],[[339,339],"valid"],[[340,340],"mapped",[341]],[[341,341],"valid"],[[342,342],"mapped",[343]],[[343,343],"valid"],[[344,344],"mapped",[345]],[[345,345],"valid"],[[346,346],"mapped",[347]],[[347,347],"valid"],[[348,348],"mapped",[349]],[[349,349],"valid"],[[350,350],"mapped",[351]],[[351,351],"valid"],[[352,352],"mapped",[353]],[[353,353],"valid"],[[354,354],"mapped",[355]],[[355,355],"valid"],[[356,356],"mapped",[357]],[[357,357],"valid"],[[358,358],"mapped",[359]],[[359,359],"valid"],[[360,360],"mapped",[361]],[[361,361],"valid"],[[362,362],"mapped",[363]],[[363,363],"valid"],[[364,364],"mapped",[365]],[[365,365],"valid"],[[366,366],"mapped",[367]],[[367,367],"valid"],[[368,368],"mapped",[369]],[[369,369],"valid"],[[370,370],"mapped",[371]],[[371,371],"valid"],[[372,372],"mapped",[373]],[[373,373],"valid"],[[374,374],"mapped",[375]],[[375,375],"valid"],[[376,376],"mapped",[255]],[[377,377],"mapped",[378]],[[378,378],"valid"],[[379,379],"mapped",[380]],[[380,380],"valid"],[[381,381],"mapped",[382]],[[382,382],"valid"],[[383,383],"mapped",[115]],[[384,384],"valid"],[[385,385],"mapped",[595]],[[386,386],"mapped",[387]],[[387,387],"valid"],[[388,388],"mapped",[389]],[[389,389],"valid"],[[390,390],"mapped",[596]],[[391,391],"mapped",[392]],[[392,392],"valid"],[[393,393],"mapped",[598]],[[394,394],"mapped",[599]],[[395,395],"mapped",[396]],[[396,397],"valid"],[[398,398],"mapped",[477]],[[399,399],"mapped",[601]],[[400,400],"mapped",[603]],[[401,401],"mapped",[402]],[[402,402],"valid"],[[403,403],"mapped",[608]],[[404,404],"mapped",[611]],[[405,405],"valid"],[[406,406],"mapped",[617]],[[407,407],"mapped",[616]],[[408,408],"mapped",[409]],[[409,411],"valid"],[[412,412],"mapped",[623]],[[413,413],"mapped",[626]],[[414,414],"valid"],[[415,415],"mapped",[629]],[[416,416],"mapped",[417]],[[417,417],"valid"],[[418,418],"mapped",[419]],[[419,419],"valid"],[[420,420],"mapped",[421]],[[421,421],"valid"],[[422,422],"mapped",[640]],[[423,423],"mapped",[424]],[[424,424],"valid"],[[425,425],"mapped",[643]],[[426,427],"valid"],[[428,428],"mapped",[429]],[[429,429],"valid"],[[430,430],"mapped",[648]],[[431,431],"mapped",[432]],[[432,432],"valid"],[[433,433],"mapped",[650]],[[434,434],"mapped",[651]],[[435,435],"mapped",[436]],[[436,436],"valid"],[[437,437],"mapped",[438]],[[438,438],"valid"],[[439,439],"mapped",[658]],[[440,440],"mapped",[441]],[[441,443],"valid"],[[444,444],"mapped",[445]],[[445,451],"valid"],[[452,454],"mapped",[100,382]],[[455,457],"mapped",[108,106]],[[458,460],"mapped",[110,106]],[[461,461],"mapped",[462]],[[462,462],"valid"],[[463,463],"mapped",[464]],[[464,464],"valid"],[[465,465],"mapped",[466]],[[466,466],"valid"],[[467,467],"mapped",[468]],[[468,468],"valid"],[[469,469],"mapped",[470]],[[470,470],"valid"],[[471,471],"mapped",[472]],[[472,472],"valid"],[[473,473],"mapped",[474]],[[474,474],"valid"],[[475,475],"mapped",[476]],[[476,477],"valid"],[[478,478],"mapped",[479]],[[479,479],"valid"],[[480,480],"mapped",[481]],[[481,481],"valid"],[[482,482],"mapped",[483]],[[483,483],"valid"],[[484,484],"mapped",[485]],[[485,485],"valid"],[[486,486],"mapped",[487]],[[487,487],"valid"],[[488,488],"mapped",[489]],[[489,489],"valid"],[[490,490],"mapped",[491]],[[491,491],"valid"],[[492,492],"mapped",[493]],[[493,493],"valid"],[[494,494],"mapped",[495]],[[495,496],"valid"],[[497,499],"mapped",[100,122]],[[500,500],"mapped",[501]],[[501,501],"valid"],[[502,502],"mapped",[405]],[[503,503],"mapped",[447]],[[504,504],"mapped",[505]],[[505,505],"valid"],[[506,506],"mapped",[507]],[[507,507],"valid"],[[508,508],"mapped",[509]],[[509,509],"valid"],[[510,510],"mapped",[511]],[[511,511],"valid"],[[512,512],"mapped",[513]],[[513,513],"valid"],[[514,514],"mapped",[515]],[[515,515],"valid"],[[516,516],"mapped",[517]],[[517,517],"valid"],[[518,518],"mapped",[519]],[[519,519],"valid"],[[520,520],"mapped",[521]],[[521,521],"valid"],[[522,522],"mapped",[523]],[[523,523],"valid"],[[524,524],"mapped",[525]],[[525,525],"valid"],[[526,526],"mapped",[527]],[[527,527],"valid"],[[528,528],"mapped",[529]],[[529,529],"valid"],[[530,530],"mapped",[531]],[[531,531],"valid"],[[532,532],"mapped",[533]],[[533,533],"valid"],[[534,534],"mapped",[535]],[[535,535],"valid"],[[536,536],"mapped",[537]],[[537,537],"valid"],[[538,538],"mapped",[539]],[[539,539],"valid"],[[540,540],"mapped",[541]],[[541,541],"valid"],[[542,542],"mapped",[543]],[[543,543],"valid"],[[544,544],"mapped",[414]],[[545,545],"valid"],[[546,546],"mapped",[547]],[[547,547],"valid"],[[548,548],"mapped",[549]],[[549,549],"valid"],[[550,550],"mapped",[551]],[[551,551],"valid"],[[552,552],"mapped",[553]],[[553,553],"valid"],[[554,554],"mapped",[555]],[[555,555],"valid"],[[556,556],"mapped",[557]],[[557,557],"valid"],[[558,558],"mapped",[559]],[[559,559],"valid"],[[560,560],"mapped",[561]],[[561,561],"valid"],[[562,562],"mapped",[563]],[[563,563],"valid"],[[564,566],"valid"],[[567,569],"valid"],[[570,570],"mapped",[11365]],[[571,571],"mapped",[572]],[[572,572],"valid"],[[573,573],"mapped",[410]],[[574,574],"mapped",[11366]],[[575,576],"valid"],[[577,577],"mapped",[578]],[[578,578],"valid"],[[579,579],"mapped",[384]],[[580,580],"mapped",[649]],[[581,581],"mapped",[652]],[[582,582],"mapped",[583]],[[583,583],"valid"],[[584,584],"mapped",[585]],[[585,585],"valid"],[[586,586],"mapped",[587]],[[587,587],"valid"],[[588,588],"mapped",[589]],[[589,589],"valid"],[[590,590],"mapped",[591]],[[591,591],"valid"],[[592,680],"valid"],[[681,685],"valid"],[[686,687],"valid"],[[688,688],"mapped",[104]],[[689,689],"mapped",[614]],[[690,690],"mapped",[106]],[[691,691],"mapped",[114]],[[692,692],"mapped",[633]],[[693,693],"mapped",[635]],[[694,694],"mapped",[641]],[[695,695],"mapped",[119]],[[696,696],"mapped",[121]],[[697,705],"valid"],[[706,709],"valid",[],"NV8"],[[710,721],"valid"],[[722,727],"valid",[],"NV8"],[[728,728],"disallowed_STD3_mapped",[32,774]],[[729,729],"disallowed_STD3_mapped",[32,775]],[[730,730],"disallowed_STD3_mapped",[32,778]],[[731,731],"disallowed_STD3_mapped",[32,808]],[[732,732],"disallowed_STD3_mapped",[32,771]],[[733,733],"disallowed_STD3_mapped",[32,779]],[[734,734],"valid",[],"NV8"],[[735,735],"valid",[],"NV8"],[[736,736],"mapped",[611]],[[737,737],"mapped",[108]],[[738,738],"mapped",[115]],[[739,739],"mapped",[120]],[[740,740],"mapped",[661]],[[741,745],"valid",[],"NV8"],[[746,747],"valid",[],"NV8"],[[748,748],"valid"],[[749,749],"valid",[],"NV8"],[[750,750],"valid"],[[751,767],"valid",[],"NV8"],[[768,831],"valid"],[[832,832],"mapped",[768]],[[833,833],"mapped",[769]],[[834,834],"valid"],[[835,835],"mapped",[787]],[[836,836],"mapped",[776,769]],[[837,837],"mapped",[953]],[[838,846],"valid"],[[847,847],"ignored"],[[848,855],"valid"],[[856,860],"valid"],[[861,863],"valid"],[[864,865],"valid"],[[866,866],"valid"],[[867,879],"valid"],[[880,880],"mapped",[881]],[[881,881],"valid"],[[882,882],"mapped",[883]],[[883,883],"valid"],[[884,884],"mapped",[697]],[[885,885],"valid"],[[886,886],"mapped",[887]],[[887,887],"valid"],[[888,889],"disallowed"],[[890,890],"disallowed_STD3_mapped",[32,953]],[[891,893],"valid"],[[894,894],"disallowed_STD3_mapped",[59]],[[895,895],"mapped",[1011]],[[896,899],"disallowed"],[[900,900],"disallowed_STD3_mapped",[32,769]],[[901,901],"disallowed_STD3_mapped",[32,776,769]],[[902,902],"mapped",[940]],[[903,903],"mapped",[183]],[[904,904],"mapped",[941]],[[905,905],"mapped",[942]],[[906,906],"mapped",[943]],[[907,907],"disallowed"],[[908,908],"mapped",[972]],[[909,909],"disallowed"],[[910,910],"mapped",[973]],[[911,911],"mapped",[974]],[[912,912],"valid"],[[913,913],"mapped",[945]],[[914,914],"mapped",[946]],[[915,915],"mapped",[947]],[[916,916],"mapped",[948]],[[917,917],"mapped",[949]],[[918,918],"mapped",[950]],[[919,919],"mapped",[951]],[[920,920],"mapped",[952]],[[921,921],"mapped",[953]],[[922,922],"mapped",[954]],[[923,923],"mapped",[955]],[[924,924],"mapped",[956]],[[925,925],"mapped",[957]],[[926,926],"mapped",[958]],[[927,927],"mapped",[959]],[[928,928],"mapped",[960]],[[929,929],"mapped",[961]],[[930,930],"disallowed"],[[931,931],"mapped",[963]],[[932,932],"mapped",[964]],[[933,933],"mapped",[965]],[[934,934],"mapped",[966]],[[935,935],"mapped",[967]],[[936,936],"mapped",[968]],[[937,937],"mapped",[969]],[[938,938],"mapped",[970]],[[939,939],"mapped",[971]],[[940,961],"valid"],[[962,962],"deviation",[963]],[[963,974],"valid"],[[975,975],"mapped",[983]],[[976,976],"mapped",[946]],[[977,977],"mapped",[952]],[[978,978],"mapped",[965]],[[979,979],"mapped",[973]],[[980,980],"mapped",[971]],[[981,981],"mapped",[966]],[[982,982],"mapped",[960]],[[983,983],"valid"],[[984,984],"mapped",[985]],[[985,985],"valid"],[[986,986],"mapped",[987]],[[987,987],"valid"],[[988,988],"mapped",[989]],[[989,989],"valid"],[[990,990],"mapped",[991]],[[991,991],"valid"],[[992,992],"mapped",[993]],[[993,993],"valid"],[[994,994],"mapped",[995]],[[995,995],"valid"],[[996,996],"mapped",[997]],[[997,997],"valid"],[[998,998],"mapped",[999]],[[999,999],"valid"],[[1000,1000],"mapped",[1001]],[[1001,1001],"valid"],[[1002,1002],"mapped",[1003]],[[1003,1003],"valid"],[[1004,1004],"mapped",[1005]],[[1005,1005],"valid"],[[1006,1006],"mapped",[1007]],[[1007,1007],"valid"],[[1008,1008],"mapped",[954]],[[1009,1009],"mapped",[961]],[[1010,1010],"mapped",[963]],[[1011,1011],"valid"],[[1012,1012],"mapped",[952]],[[1013,1013],"mapped",[949]],[[1014,1014],"valid",[],"NV8"],[[1015,1015],"mapped",[1016]],[[1016,1016],"valid"],[[1017,1017],"mapped",[963]],[[1018,1018],"mapped",[1019]],[[1019,1019],"valid"],[[1020,1020],"valid"],[[1021,1021],"mapped",[891]],[[1022,1022],"mapped",[892]],[[1023,1023],"mapped",[893]],[[1024,1024],"mapped",[1104]],[[1025,1025],"mapped",[1105]],[[1026,1026],"mapped",[1106]],[[1027,1027],"mapped",[1107]],[[1028,1028],"mapped",[1108]],[[1029,1029],"mapped",[1109]],[[1030,1030],"mapped",[1110]],[[1031,1031],"mapped",[1111]],[[1032,1032],"mapped",[1112]],[[1033,1033],"mapped",[1113]],[[1034,1034],"mapped",[1114]],[[1035,1035],"mapped",[1115]],[[1036,1036],"mapped",[1116]],[[1037,1037],"mapped",[1117]],[[1038,1038],"mapped",[1118]],[[1039,1039],"mapped",[1119]],[[1040,1040],"mapped",[1072]],[[1041,1041],"mapped",[1073]],[[1042,1042],"mapped",[1074]],[[1043,1043],"mapped",[1075]],[[1044,1044],"mapped",[1076]],[[1045,1045],"mapped",[1077]],[[1046,1046],"mapped",[1078]],[[1047,1047],"mapped",[1079]],[[1048,1048],"mapped",[1080]],[[1049,1049],"mapped",[1081]],[[1050,1050],"mapped",[1082]],[[1051,1051],"mapped",[1083]],[[1052,1052],"mapped",[1084]],[[1053,1053],"mapped",[1085]],[[1054,1054],"mapped",[1086]],[[1055,1055],"mapped",[1087]],[[1056,1056],"mapped",[1088]],[[1057,1057],"mapped",[1089]],[[1058,1058],"mapped",[1090]],[[1059,1059],"mapped",[1091]],[[1060,1060],"mapped",[1092]],[[1061,1061],"mapped",[1093]],[[1062,1062],"mapped",[1094]],[[1063,1063],"mapped",[1095]],[[1064,1064],"mapped",[1096]],[[1065,1065],"mapped",[1097]],[[1066,1066],"mapped",[1098]],[[1067,1067],"mapped",[1099]],[[1068,1068],"mapped",[1100]],[[1069,1069],"mapped",[1101]],[[1070,1070],"mapped",[1102]],[[1071,1071],"mapped",[1103]],[[1072,1103],"valid"],[[1104,1104],"valid"],[[1105,1116],"valid"],[[1117,1117],"valid"],[[1118,1119],"valid"],[[1120,1120],"mapped",[1121]],[[1121,1121],"valid"],[[1122,1122],"mapped",[1123]],[[1123,1123],"valid"],[[1124,1124],"mapped",[1125]],[[1125,1125],"valid"],[[1126,1126],"mapped",[1127]],[[1127,1127],"valid"],[[1128,1128],"mapped",[1129]],[[1129,1129],"valid"],[[1130,1130],"mapped",[1131]],[[1131,1131],"valid"],[[1132,1132],"mapped",[1133]],[[1133,1133],"valid"],[[1134,1134],"mapped",[1135]],[[1135,1135],"valid"],[[1136,1136],"mapped",[1137]],[[1137,1137],"valid"],[[1138,1138],"mapped",[1139]],[[1139,1139],"valid"],[[1140,1140],"mapped",[1141]],[[1141,1141],"valid"],[[1142,1142],"mapped",[1143]],[[1143,1143],"valid"],[[1144,1144],"mapped",[1145]],[[1145,1145],"valid"],[[1146,1146],"mapped",[1147]],[[1147,1147],"valid"],[[1148,1148],"mapped",[1149]],[[1149,1149],"valid"],[[1150,1150],"mapped",[1151]],[[1151,1151],"valid"],[[1152,1152],"mapped",[1153]],[[1153,1153],"valid"],[[1154,1154],"valid",[],"NV8"],[[1155,1158],"valid"],[[1159,1159],"valid"],[[1160,1161],"valid",[],"NV8"],[[1162,1162],"mapped",[1163]],[[1163,1163],"valid"],[[1164,1164],"mapped",[1165]],[[1165,1165],"valid"],[[1166,1166],"mapped",[1167]],[[1167,1167],"valid"],[[1168,1168],"mapped",[1169]],[[1169,1169],"valid"],[[1170,1170],"mapped",[1171]],[[1171,1171],"valid"],[[1172,1172],"mapped",[1173]],[[1173,1173],"valid"],[[1174,1174],"mapped",[1175]],[[1175,1175],"valid"],[[1176,1176],"mapped",[1177]],[[1177,1177],"valid"],[[1178,1178],"mapped",[1179]],[[1179,1179],"valid"],[[1180,1180],"mapped",[1181]],[[1181,1181],"valid"],[[1182,1182],"mapped",[1183]],[[1183,1183],"valid"],[[1184,1184],"mapped",[1185]],[[1185,1185],"valid"],[[1186,1186],"mapped",[1187]],[[1187,1187],"valid"],[[1188,1188],"mapped",[1189]],[[1189,1189],"valid"],[[1190,1190],"mapped",[1191]],[[1191,1191],"valid"],[[1192,1192],"mapped",[1193]],[[1193,1193],"valid"],[[1194,1194],"mapped",[1195]],[[1195,1195],"valid"],[[1196,1196],"mapped",[1197]],[[1197,1197],"valid"],[[1198,1198],"mapped",[1199]],[[1199,1199],"valid"],[[1200,1200],"mapped",[1201]],[[1201,1201],"valid"],[[1202,1202],"mapped",[1203]],[[1203,1203],"valid"],[[1204,1204],"mapped",[1205]],[[1205,1205],"valid"],[[1206,1206],"mapped",[1207]],[[1207,1207],"valid"],[[1208,1208],"mapped",[1209]],[[1209,1209],"valid"],[[1210,1210],"mapped",[1211]],[[1211,1211],"valid"],[[1212,1212],"mapped",[1213]],[[1213,1213],"valid"],[[1214,1214],"mapped",[1215]],[[1215,1215],"valid"],[[1216,1216],"disallowed"],[[1217,1217],"mapped",[1218]],[[1218,1218],"valid"],[[1219,1219],"mapped",[1220]],[[1220,1220],"valid"],[[1221,1221],"mapped",[1222]],[[1222,1222],"valid"],[[1223,1223],"mapped",[1224]],[[1224,1224],"valid"],[[1225,1225],"mapped",[1226]],[[1226,1226],"valid"],[[1227,1227],"mapped",[1228]],[[1228,1228],"valid"],[[1229,1229],"mapped",[1230]],[[1230,1230],"valid"],[[1231,1231],"valid"],[[1232,1232],"mapped",[1233]],[[1233,1233],"valid"],[[1234,1234],"mapped",[1235]],[[1235,1235],"valid"],[[1236,1236],"mapped",[1237]],[[1237,1237],"valid"],[[1238,1238],"mapped",[1239]],[[1239,1239],"valid"],[[1240,1240],"mapped",[1241]],[[1241,1241],"valid"],[[1242,1242],"mapped",[1243]],[[1243,1243],"valid"],[[1244,1244],"mapped",[1245]],[[1245,1245],"valid"],[[1246,1246],"mapped",[1247]],[[1247,1247],"valid"],[[1248,1248],"mapped",[1249]],[[1249,1249],"valid"],[[1250,1250],"mapped",[1251]],[[1251,1251],"valid"],[[1252,1252],"mapped",[1253]],[[1253,1253],"valid"],[[1254,1254],"mapped",[1255]],[[1255,1255],"valid"],[[1256,1256],"mapped",[1257]],[[1257,1257],"valid"],[[1258,1258],"mapped",[1259]],[[1259,1259],"valid"],[[1260,1260],"mapped",[1261]],[[1261,1261],"valid"],[[1262,1262],"mapped",[1263]],[[1263,1263],"valid"],[[1264,1264],"mapped",[1265]],[[1265,1265],"valid"],[[1266,1266],"mapped",[1267]],[[1267,1267],"valid"],[[1268,1268],"mapped",[1269]],[[1269,1269],"valid"],[[1270,1270],"mapped",[1271]],[[1271,1271],"valid"],[[1272,1272],"mapped",[1273]],[[1273,1273],"valid"],[[1274,1274],"mapped",[1275]],[[1275,1275],"valid"],[[1276,1276],"mapped",[1277]],[[1277,1277],"valid"],[[1278,1278],"mapped",[1279]],[[1279,1279],"valid"],[[1280,1280],"mapped",[1281]],[[1281,1281],"valid"],[[1282,1282],"mapped",[1283]],[[1283,1283],"valid"],[[1284,1284],"mapped",[1285]],[[1285,1285],"valid"],[[1286,1286],"mapped",[1287]],[[1287,1287],"valid"],[[1288,1288],"mapped",[1289]],[[1289,1289],"valid"],[[1290,1290],"mapped",[1291]],[[1291,1291],"valid"],[[1292,1292],"mapped",[1293]],[[1293,1293],"valid"],[[1294,1294],"mapped",[1295]],[[1295,1295],"valid"],[[1296,1296],"mapped",[1297]],[[1297,1297],"valid"],[[1298,1298],"mapped",[1299]],[[1299,1299],"valid"],[[1300,1300],"mapped",[1301]],[[1301,1301],"valid"],[[1302,1302],"mapped",[1303]],[[1303,1303],"valid"],[[1304,1304],"mapped",[1305]],[[1305,1305],"valid"],[[1306,1306],"mapped",[1307]],[[1307,1307],"valid"],[[1308,1308],"mapped",[1309]],[[1309,1309],"valid"],[[1310,1310],"mapped",[1311]],[[1311,1311],"valid"],[[1312,1312],"mapped",[1313]],[[1313,1313],"valid"],[[1314,1314],"mapped",[1315]],[[1315,1315],"valid"],[[1316,1316],"mapped",[1317]],[[1317,1317],"valid"],[[1318,1318],"mapped",[1319]],[[1319,1319],"valid"],[[1320,1320],"mapped",[1321]],[[1321,1321],"valid"],[[1322,1322],"mapped",[1323]],[[1323,1323],"valid"],[[1324,1324],"mapped",[1325]],[[1325,1325],"valid"],[[1326,1326],"mapped",[1327]],[[1327,1327],"valid"],[[1328,1328],"disallowed"],[[1329,1329],"mapped",[1377]],[[1330,1330],"mapped",[1378]],[[1331,1331],"mapped",[1379]],[[1332,1332],"mapped",[1380]],[[1333,1333],"mapped",[1381]],[[1334,1334],"mapped",[1382]],[[1335,1335],"mapped",[1383]],[[1336,1336],"mapped",[1384]],[[1337,1337],"mapped",[1385]],[[1338,1338],"mapped",[1386]],[[1339,1339],"mapped",[1387]],[[1340,1340],"mapped",[1388]],[[1341,1341],"mapped",[1389]],[[1342,1342],"mapped",[1390]],[[1343,1343],"mapped",[1391]],[[1344,1344],"mapped",[1392]],[[1345,1345],"mapped",[1393]],[[1346,1346],"mapped",[1394]],[[1347,1347],"mapped",[1395]],[[1348,1348],"mapped",[1396]],[[1349,1349],"mapped",[1397]],[[1350,1350],"mapped",[1398]],[[1351,1351],"mapped",[1399]],[[1352,1352],"mapped",[1400]],[[1353,1353],"mapped",[1401]],[[1354,1354],"mapped",[1402]],[[1355,1355],"mapped",[1403]],[[1356,1356],"mapped",[1404]],[[1357,1357],"mapped",[1405]],[[1358,1358],"mapped",[1406]],[[1359,1359],"mapped",[1407]],[[1360,1360],"mapped",[1408]],[[1361,1361],"mapped",[1409]],[[1362,1362],"mapped",[1410]],[[1363,1363],"mapped",[1411]],[[1364,1364],"mapped",[1412]],[[1365,1365],"mapped",[1413]],[[1366,1366],"mapped",[1414]],[[1367,1368],"disallowed"],[[1369,1369],"valid"],[[1370,1375],"valid",[],"NV8"],[[1376,1376],"disallowed"],[[1377,1414],"valid"],[[1415,1415],"mapped",[1381,1410]],[[1416,1416],"disallowed"],[[1417,1417],"valid",[],"NV8"],[[1418,1418],"valid",[],"NV8"],[[1419,1420],"disallowed"],[[1421,1422],"valid",[],"NV8"],[[1423,1423],"valid",[],"NV8"],[[1424,1424],"disallowed"],[[1425,1441],"valid"],[[1442,1442],"valid"],[[1443,1455],"valid"],[[1456,1465],"valid"],[[1466,1466],"valid"],[[1467,1469],"valid"],[[1470,1470],"valid",[],"NV8"],[[1471,1471],"valid"],[[1472,1472],"valid",[],"NV8"],[[1473,1474],"valid"],[[1475,1475],"valid",[],"NV8"],[[1476,1476],"valid"],[[1477,1477],"valid"],[[1478,1478],"valid",[],"NV8"],[[1479,1479],"valid"],[[1480,1487],"disallowed"],[[1488,1514],"valid"],[[1515,1519],"disallowed"],[[1520,1524],"valid"],[[1525,1535],"disallowed"],[[1536,1539],"disallowed"],[[1540,1540],"disallowed"],[[1541,1541],"disallowed"],[[1542,1546],"valid",[],"NV8"],[[1547,1547],"valid",[],"NV8"],[[1548,1548],"valid",[],"NV8"],[[1549,1551],"valid",[],"NV8"],[[1552,1557],"valid"],[[1558,1562],"valid"],[[1563,1563],"valid",[],"NV8"],[[1564,1564],"disallowed"],[[1565,1565],"disallowed"],[[1566,1566],"valid",[],"NV8"],[[1567,1567],"valid",[],"NV8"],[[1568,1568],"valid"],[[1569,1594],"valid"],[[1595,1599],"valid"],[[1600,1600],"valid",[],"NV8"],[[1601,1618],"valid"],[[1619,1621],"valid"],[[1622,1624],"valid"],[[1625,1630],"valid"],[[1631,1631],"valid"],[[1632,1641],"valid"],[[1642,1645],"valid",[],"NV8"],[[1646,1647],"valid"],[[1648,1652],"valid"],[[1653,1653],"mapped",[1575,1652]],[[1654,1654],"mapped",[1608,1652]],[[1655,1655],"mapped",[1735,1652]],[[1656,1656],"mapped",[1610,1652]],[[1657,1719],"valid"],[[1720,1721],"valid"],[[1722,1726],"valid"],[[1727,1727],"valid"],[[1728,1742],"valid"],[[1743,1743],"valid"],[[1744,1747],"valid"],[[1748,1748],"valid",[],"NV8"],[[1749,1756],"valid"],[[1757,1757],"disallowed"],[[1758,1758],"valid",[],"NV8"],[[1759,1768],"valid"],[[1769,1769],"valid",[],"NV8"],[[1770,1773],"valid"],[[1774,1775],"valid"],[[1776,1785],"valid"],[[1786,1790],"valid"],[[1791,1791],"valid"],[[1792,1805],"valid",[],"NV8"],[[1806,1806],"disallowed"],[[1807,1807],"disallowed"],[[1808,1836],"valid"],[[1837,1839],"valid"],[[1840,1866],"valid"],[[1867,1868],"disallowed"],[[1869,1871],"valid"],[[1872,1901],"valid"],[[1902,1919],"valid"],[[1920,1968],"valid"],[[1969,1969],"valid"],[[1970,1983],"disallowed"],[[1984,2037],"valid"],[[2038,2042],"valid",[],"NV8"],[[2043,2047],"disallowed"],[[2048,2093],"valid"],[[2094,2095],"disallowed"],[[2096,2110],"valid",[],"NV8"],[[2111,2111],"disallowed"],[[2112,2139],"valid"],[[2140,2141],"disallowed"],[[2142,2142],"valid",[],"NV8"],[[2143,2207],"disallowed"],[[2208,2208],"valid"],[[2209,2209],"valid"],[[2210,2220],"valid"],[[2221,2226],"valid"],[[2227,2228],"valid"],[[2229,2274],"disallowed"],[[2275,2275],"valid"],[[2276,2302],"valid"],[[2303,2303],"valid"],[[2304,2304],"valid"],[[2305,2307],"valid"],[[2308,2308],"valid"],[[2309,2361],"valid"],[[2362,2363],"valid"],[[2364,2381],"valid"],[[2382,2382],"valid"],[[2383,2383],"valid"],[[2384,2388],"valid"],[[2389,2389],"valid"],[[2390,2391],"valid"],[[2392,2392],"mapped",[2325,2364]],[[2393,2393],"mapped",[2326,2364]],[[2394,2394],"mapped",[2327,2364]],[[2395,2395],"mapped",[2332,2364]],[[2396,2396],"mapped",[2337,2364]],[[2397,2397],"mapped",[2338,2364]],[[2398,2398],"mapped",[2347,2364]],[[2399,2399],"mapped",[2351,2364]],[[2400,2403],"valid"],[[2404,2405],"valid",[],"NV8"],[[2406,2415],"valid"],[[2416,2416],"valid",[],"NV8"],[[2417,2418],"valid"],[[2419,2423],"valid"],[[2424,2424],"valid"],[[2425,2426],"valid"],[[2427,2428],"valid"],[[2429,2429],"valid"],[[2430,2431],"valid"],[[2432,2432],"valid"],[[2433,2435],"valid"],[[2436,2436],"disallowed"],[[2437,2444],"valid"],[[2445,2446],"disallowed"],[[2447,2448],"valid"],[[2449,2450],"disallowed"],[[2451,2472],"valid"],[[2473,2473],"disallowed"],[[2474,2480],"valid"],[[2481,2481],"disallowed"],[[2482,2482],"valid"],[[2483,2485],"disallowed"],[[2486,2489],"valid"],[[2490,2491],"disallowed"],[[2492,2492],"valid"],[[2493,2493],"valid"],[[2494,2500],"valid"],[[2501,2502],"disallowed"],[[2503,2504],"valid"],[[2505,2506],"disallowed"],[[2507,2509],"valid"],[[2510,2510],"valid"],[[2511,2518],"disallowed"],[[2519,2519],"valid"],[[2520,2523],"disallowed"],[[2524,2524],"mapped",[2465,2492]],[[2525,2525],"mapped",[2466,2492]],[[2526,2526],"disallowed"],[[2527,2527],"mapped",[2479,2492]],[[2528,2531],"valid"],[[2532,2533],"disallowed"],[[2534,2545],"valid"],[[2546,2554],"valid",[],"NV8"],[[2555,2555],"valid",[],"NV8"],[[2556,2560],"disallowed"],[[2561,2561],"valid"],[[2562,2562],"valid"],[[2563,2563],"valid"],[[2564,2564],"disallowed"],[[2565,2570],"valid"],[[2571,2574],"disallowed"],[[2575,2576],"valid"],[[2577,2578],"disallowed"],[[2579,2600],"valid"],[[2601,2601],"disallowed"],[[2602,2608],"valid"],[[2609,2609],"disallowed"],[[2610,2610],"valid"],[[2611,2611],"mapped",[2610,2620]],[[2612,2612],"disallowed"],[[2613,2613],"valid"],[[2614,2614],"mapped",[2616,2620]],[[2615,2615],"disallowed"],[[2616,2617],"valid"],[[2618,2619],"disallowed"],[[2620,2620],"valid"],[[2621,2621],"disallowed"],[[2622,2626],"valid"],[[2627,2630],"disallowed"],[[2631,2632],"valid"],[[2633,2634],"disallowed"],[[2635,2637],"valid"],[[2638,2640],"disallowed"],[[2641,2641],"valid"],[[2642,2648],"disallowed"],[[2649,2649],"mapped",[2582,2620]],[[2650,2650],"mapped",[2583,2620]],[[2651,2651],"mapped",[2588,2620]],[[2652,2652],"valid"],[[2653,2653],"disallowed"],[[2654,2654],"mapped",[2603,2620]],[[2655,2661],"disallowed"],[[2662,2676],"valid"],[[2677,2677],"valid"],[[2678,2688],"disallowed"],[[2689,2691],"valid"],[[2692,2692],"disallowed"],[[2693,2699],"valid"],[[2700,2700],"valid"],[[2701,2701],"valid"],[[2702,2702],"disallowed"],[[2703,2705],"valid"],[[2706,2706],"disallowed"],[[2707,2728],"valid"],[[2729,2729],"disallowed"],[[2730,2736],"valid"],[[2737,2737],"disallowed"],[[2738,2739],"valid"],[[2740,2740],"disallowed"],[[2741,2745],"valid"],[[2746,2747],"disallowed"],[[2748,2757],"valid"],[[2758,2758],"disallowed"],[[2759,2761],"valid"],[[2762,2762],"disallowed"],[[2763,2765],"valid"],[[2766,2767],"disallowed"],[[2768,2768],"valid"],[[2769,2783],"disallowed"],[[2784,2784],"valid"],[[2785,2787],"valid"],[[2788,2789],"disallowed"],[[2790,2799],"valid"],[[2800,2800],"valid",[],"NV8"],[[2801,2801],"valid",[],"NV8"],[[2802,2808],"disallowed"],[[2809,2809],"valid"],[[2810,2816],"disallowed"],[[2817,2819],"valid"],[[2820,2820],"disallowed"],[[2821,2828],"valid"],[[2829,2830],"disallowed"],[[2831,2832],"valid"],[[2833,2834],"disallowed"],[[2835,2856],"valid"],[[2857,2857],"disallowed"],[[2858,2864],"valid"],[[2865,2865],"disallowed"],[[2866,2867],"valid"],[[2868,2868],"disallowed"],[[2869,2869],"valid"],[[2870,2873],"valid"],[[2874,2875],"disallowed"],[[2876,2883],"valid"],[[2884,2884],"valid"],[[2885,2886],"disallowed"],[[2887,2888],"valid"],[[2889,2890],"disallowed"],[[2891,2893],"valid"],[[2894,2901],"disallowed"],[[2902,2903],"valid"],[[2904,2907],"disallowed"],[[2908,2908],"mapped",[2849,2876]],[[2909,2909],"mapped",[2850,2876]],[[2910,2910],"disallowed"],[[2911,2913],"valid"],[[2914,2915],"valid"],[[2916,2917],"disallowed"],[[2918,2927],"valid"],[[2928,2928],"valid",[],"NV8"],[[2929,2929],"valid"],[[2930,2935],"valid",[],"NV8"],[[2936,2945],"disallowed"],[[2946,2947],"valid"],[[2948,2948],"disallowed"],[[2949,2954],"valid"],[[2955,2957],"disallowed"],[[2958,2960],"valid"],[[2961,2961],"disallowed"],[[2962,2965],"valid"],[[2966,2968],"disallowed"],[[2969,2970],"valid"],[[2971,2971],"disallowed"],[[2972,2972],"valid"],[[2973,2973],"disallowed"],[[2974,2975],"valid"],[[2976,2978],"disallowed"],[[2979,2980],"valid"],[[2981,2983],"disallowed"],[[2984,2986],"valid"],[[2987,2989],"disallowed"],[[2990,2997],"valid"],[[2998,2998],"valid"],[[2999,3001],"valid"],[[3002,3005],"disallowed"],[[3006,3010],"valid"],[[3011,3013],"disallowed"],[[3014,3016],"valid"],[[3017,3017],"disallowed"],[[3018,3021],"valid"],[[3022,3023],"disallowed"],[[3024,3024],"valid"],[[3025,3030],"disallowed"],[[3031,3031],"valid"],[[3032,3045],"disallowed"],[[3046,3046],"valid"],[[3047,3055],"valid"],[[3056,3058],"valid",[],"NV8"],[[3059,3066],"valid",[],"NV8"],[[3067,3071],"disallowed"],[[3072,3072],"valid"],[[3073,3075],"valid"],[[3076,3076],"disallowed"],[[3077,3084],"valid"],[[3085,3085],"disallowed"],[[3086,3088],"valid"],[[3089,3089],"disallowed"],[[3090,3112],"valid"],[[3113,3113],"disallowed"],[[3114,3123],"valid"],[[3124,3124],"valid"],[[3125,3129],"valid"],[[3130,3132],"disallowed"],[[3133,3133],"valid"],[[3134,3140],"valid"],[[3141,3141],"disallowed"],[[3142,3144],"valid"],[[3145,3145],"disallowed"],[[3146,3149],"valid"],[[3150,3156],"disallowed"],[[3157,3158],"valid"],[[3159,3159],"disallowed"],[[3160,3161],"valid"],[[3162,3162],"valid"],[[3163,3167],"disallowed"],[[3168,3169],"valid"],[[3170,3171],"valid"],[[3172,3173],"disallowed"],[[3174,3183],"valid"],[[3184,3191],"disallowed"],[[3192,3199],"valid",[],"NV8"],[[3200,3200],"disallowed"],[[3201,3201],"valid"],[[3202,3203],"valid"],[[3204,3204],"disallowed"],[[3205,3212],"valid"],[[3213,3213],"disallowed"],[[3214,3216],"valid"],[[3217,3217],"disallowed"],[[3218,3240],"valid"],[[3241,3241],"disallowed"],[[3242,3251],"valid"],[[3252,3252],"disallowed"],[[3253,3257],"valid"],[[3258,3259],"disallowed"],[[3260,3261],"valid"],[[3262,3268],"valid"],[[3269,3269],"disallowed"],[[3270,3272],"valid"],[[3273,3273],"disallowed"],[[3274,3277],"valid"],[[3278,3284],"disallowed"],[[3285,3286],"valid"],[[3287,3293],"disallowed"],[[3294,3294],"valid"],[[3295,3295],"disallowed"],[[3296,3297],"valid"],[[3298,3299],"valid"],[[3300,3301],"disallowed"],[[3302,3311],"valid"],[[3312,3312],"disallowed"],[[3313,3314],"valid"],[[3315,3328],"disallowed"],[[3329,3329],"valid"],[[3330,3331],"valid"],[[3332,3332],"disallowed"],[[3333,3340],"valid"],[[3341,3341],"disallowed"],[[3342,3344],"valid"],[[3345,3345],"disallowed"],[[3346,3368],"valid"],[[3369,3369],"valid"],[[3370,3385],"valid"],[[3386,3386],"valid"],[[3387,3388],"disallowed"],[[3389,3389],"valid"],[[3390,3395],"valid"],[[3396,3396],"valid"],[[3397,3397],"disallowed"],[[3398,3400],"valid"],[[3401,3401],"disallowed"],[[3402,3405],"valid"],[[3406,3406],"valid"],[[3407,3414],"disallowed"],[[3415,3415],"valid"],[[3416,3422],"disallowed"],[[3423,3423],"valid"],[[3424,3425],"valid"],[[3426,3427],"valid"],[[3428,3429],"disallowed"],[[3430,3439],"valid"],[[3440,3445],"valid",[],"NV8"],[[3446,3448],"disallowed"],[[3449,3449],"valid",[],"NV8"],[[3450,3455],"valid"],[[3456,3457],"disallowed"],[[3458,3459],"valid"],[[3460,3460],"disallowed"],[[3461,3478],"valid"],[[3479,3481],"disallowed"],[[3482,3505],"valid"],[[3506,3506],"disallowed"],[[3507,3515],"valid"],[[3516,3516],"disallowed"],[[3517,3517],"valid"],[[3518,3519],"disallowed"],[[3520,3526],"valid"],[[3527,3529],"disallowed"],[[3530,3530],"valid"],[[3531,3534],"disallowed"],[[3535,3540],"valid"],[[3541,3541],"disallowed"],[[3542,3542],"valid"],[[3543,3543],"disallowed"],[[3544,3551],"valid"],[[3552,3557],"disallowed"],[[3558,3567],"valid"],[[3568,3569],"disallowed"],[[3570,3571],"valid"],[[3572,3572],"valid",[],"NV8"],[[3573,3584],"disallowed"],[[3585,3634],"valid"],[[3635,3635],"mapped",[3661,3634]],[[3636,3642],"valid"],[[3643,3646],"disallowed"],[[3647,3647],"valid",[],"NV8"],[[3648,3662],"valid"],[[3663,3663],"valid",[],"NV8"],[[3664,3673],"valid"],[[3674,3675],"valid",[],"NV8"],[[3676,3712],"disallowed"],[[3713,3714],"valid"],[[3715,3715],"disallowed"],[[3716,3716],"valid"],[[3717,3718],"disallowed"],[[3719,3720],"valid"],[[3721,3721],"disallowed"],[[3722,3722],"valid"],[[3723,3724],"disallowed"],[[3725,3725],"valid"],[[3726,3731],"disallowed"],[[3732,3735],"valid"],[[3736,3736],"disallowed"],[[3737,3743],"valid"],[[3744,3744],"disallowed"],[[3745,3747],"valid"],[[3748,3748],"disallowed"],[[3749,3749],"valid"],[[3750,3750],"disallowed"],[[3751,3751],"valid"],[[3752,3753],"disallowed"],[[3754,3755],"valid"],[[3756,3756],"disallowed"],[[3757,3762],"valid"],[[3763,3763],"mapped",[3789,3762]],[[3764,3769],"valid"],[[3770,3770],"disallowed"],[[3771,3773],"valid"],[[3774,3775],"disallowed"],[[3776,3780],"valid"],[[3781,3781],"disallowed"],[[3782,3782],"valid"],[[3783,3783],"disallowed"],[[3784,3789],"valid"],[[3790,3791],"disallowed"],[[3792,3801],"valid"],[[3802,3803],"disallowed"],[[3804,3804],"mapped",[3755,3737]],[[3805,3805],"mapped",[3755,3745]],[[3806,3807],"valid"],[[3808,3839],"disallowed"],[[3840,3840],"valid"],[[3841,3850],"valid",[],"NV8"],[[3851,3851],"valid"],[[3852,3852],"mapped",[3851]],[[3853,3863],"valid",[],"NV8"],[[3864,3865],"valid"],[[3866,3871],"valid",[],"NV8"],[[3872,3881],"valid"],[[3882,3892],"valid",[],"NV8"],[[3893,3893],"valid"],[[3894,3894],"valid",[],"NV8"],[[3895,3895],"valid"],[[3896,3896],"valid",[],"NV8"],[[3897,3897],"valid"],[[3898,3901],"valid",[],"NV8"],[[3902,3906],"valid"],[[3907,3907],"mapped",[3906,4023]],[[3908,3911],"valid"],[[3912,3912],"disallowed"],[[3913,3916],"valid"],[[3917,3917],"mapped",[3916,4023]],[[3918,3921],"valid"],[[3922,3922],"mapped",[3921,4023]],[[3923,3926],"valid"],[[3927,3927],"mapped",[3926,4023]],[[3928,3931],"valid"],[[3932,3932],"mapped",[3931,4023]],[[3933,3944],"valid"],[[3945,3945],"mapped",[3904,4021]],[[3946,3946],"valid"],[[3947,3948],"valid"],[[3949,3952],"disallowed"],[[3953,3954],"valid"],[[3955,3955],"mapped",[3953,3954]],[[3956,3956],"valid"],[[3957,3957],"mapped",[3953,3956]],[[3958,3958],"mapped",[4018,3968]],[[3959,3959],"mapped",[4018,3953,3968]],[[3960,3960],"mapped",[4019,3968]],[[3961,3961],"mapped",[4019,3953,3968]],[[3962,3968],"valid"],[[3969,3969],"mapped",[3953,3968]],[[3970,3972],"valid"],[[3973,3973],"valid",[],"NV8"],[[3974,3979],"valid"],[[3980,3983],"valid"],[[3984,3986],"valid"],[[3987,3987],"mapped",[3986,4023]],[[3988,3989],"valid"],[[3990,3990],"valid"],[[3991,3991],"valid"],[[3992,3992],"disallowed"],[[3993,3996],"valid"],[[3997,3997],"mapped",[3996,4023]],[[3998,4001],"valid"],[[4002,4002],"mapped",[4001,4023]],[[4003,4006],"valid"],[[4007,4007],"mapped",[4006,4023]],[[4008,4011],"valid"],[[4012,4012],"mapped",[4011,4023]],[[4013,4013],"valid"],[[4014,4016],"valid"],[[4017,4023],"valid"],[[4024,4024],"valid"],[[4025,4025],"mapped",[3984,4021]],[[4026,4028],"valid"],[[4029,4029],"disallowed"],[[4030,4037],"valid",[],"NV8"],[[4038,4038],"valid"],[[4039,4044],"valid",[],"NV8"],[[4045,4045],"disallowed"],[[4046,4046],"valid",[],"NV8"],[[4047,4047],"valid",[],"NV8"],[[4048,4049],"valid",[],"NV8"],[[4050,4052],"valid",[],"NV8"],[[4053,4056],"valid",[],"NV8"],[[4057,4058],"valid",[],"NV8"],[[4059,4095],"disallowed"],[[4096,4129],"valid"],[[4130,4130],"valid"],[[4131,4135],"valid"],[[4136,4136],"valid"],[[4137,4138],"valid"],[[4139,4139],"valid"],[[4140,4146],"valid"],[[4147,4149],"valid"],[[4150,4153],"valid"],[[4154,4159],"valid"],[[4160,4169],"valid"],[[4170,4175],"valid",[],"NV8"],[[4176,4185],"valid"],[[4186,4249],"valid"],[[4250,4253],"valid"],[[4254,4255],"valid",[],"NV8"],[[4256,4293],"disallowed"],[[4294,4294],"disallowed"],[[4295,4295],"mapped",[11559]],[[4296,4300],"disallowed"],[[4301,4301],"mapped",[11565]],[[4302,4303],"disallowed"],[[4304,4342],"valid"],[[4343,4344],"valid"],[[4345,4346],"valid"],[[4347,4347],"valid",[],"NV8"],[[4348,4348],"mapped",[4316]],[[4349,4351],"valid"],[[4352,4441],"valid",[],"NV8"],[[4442,4446],"valid",[],"NV8"],[[4447,4448],"disallowed"],[[4449,4514],"valid",[],"NV8"],[[4515,4519],"valid",[],"NV8"],[[4520,4601],"valid",[],"NV8"],[[4602,4607],"valid",[],"NV8"],[[4608,4614],"valid"],[[4615,4615],"valid"],[[4616,4678],"valid"],[[4679,4679],"valid"],[[4680,4680],"valid"],[[4681,4681],"disallowed"],[[4682,4685],"valid"],[[4686,4687],"disallowed"],[[4688,4694],"valid"],[[4695,4695],"disallowed"],[[4696,4696],"valid"],[[4697,4697],"disallowed"],[[4698,4701],"valid"],[[4702,4703],"disallowed"],[[4704,4742],"valid"],[[4743,4743],"valid"],[[4744,4744],"valid"],[[4745,4745],"disallowed"],[[4746,4749],"valid"],[[4750,4751],"disallowed"],[[4752,4782],"valid"],[[4783,4783],"valid"],[[4784,4784],"valid"],[[4785,4785],"disallowed"],[[4786,4789],"valid"],[[4790,4791],"disallowed"],[[4792,4798],"valid"],[[4799,4799],"disallowed"],[[4800,4800],"valid"],[[4801,4801],"disallowed"],[[4802,4805],"valid"],[[4806,4807],"disallowed"],[[4808,4814],"valid"],[[4815,4815],"valid"],[[4816,4822],"valid"],[[4823,4823],"disallowed"],[[4824,4846],"valid"],[[4847,4847],"valid"],[[4848,4878],"valid"],[[4879,4879],"valid"],[[4880,4880],"valid"],[[4881,4881],"disallowed"],[[4882,4885],"valid"],[[4886,4887],"disallowed"],[[4888,4894],"valid"],[[4895,4895],"valid"],[[4896,4934],"valid"],[[4935,4935],"valid"],[[4936,4954],"valid"],[[4955,4956],"disallowed"],[[4957,4958],"valid"],[[4959,4959],"valid"],[[4960,4960],"valid",[],"NV8"],[[4961,4988],"valid",[],"NV8"],[[4989,4991],"disallowed"],[[4992,5007],"valid"],[[5008,5017],"valid",[],"NV8"],[[5018,5023],"disallowed"],[[5024,5108],"valid"],[[5109,5109],"valid"],[[5110,5111],"disallowed"],[[5112,5112],"mapped",[5104]],[[5113,5113],"mapped",[5105]],[[5114,5114],"mapped",[5106]],[[5115,5115],"mapped",[5107]],[[5116,5116],"mapped",[5108]],[[5117,5117],"mapped",[5109]],[[5118,5119],"disallowed"],[[5120,5120],"valid",[],"NV8"],[[5121,5740],"valid"],[[5741,5742],"valid",[],"NV8"],[[5743,5750],"valid"],[[5751,5759],"valid"],[[5760,5760],"disallowed"],[[5761,5786],"valid"],[[5787,5788],"valid",[],"NV8"],[[5789,5791],"disallowed"],[[5792,5866],"valid"],[[5867,5872],"valid",[],"NV8"],[[5873,5880],"valid"],[[5881,5887],"disallowed"],[[5888,5900],"valid"],[[5901,5901],"disallowed"],[[5902,5908],"valid"],[[5909,5919],"disallowed"],[[5920,5940],"valid"],[[5941,5942],"valid",[],"NV8"],[[5943,5951],"disallowed"],[[5952,5971],"valid"],[[5972,5983],"disallowed"],[[5984,5996],"valid"],[[5997,5997],"disallowed"],[[5998,6000],"valid"],[[6001,6001],"disallowed"],[[6002,6003],"valid"],[[6004,6015],"disallowed"],[[6016,6067],"valid"],[[6068,6069],"disallowed"],[[6070,6099],"valid"],[[6100,6102],"valid",[],"NV8"],[[6103,6103],"valid"],[[6104,6107],"valid",[],"NV8"],[[6108,6108],"valid"],[[6109,6109],"valid"],[[6110,6111],"disallowed"],[[6112,6121],"valid"],[[6122,6127],"disallowed"],[[6128,6137],"valid",[],"NV8"],[[6138,6143],"disallowed"],[[6144,6149],"valid",[],"NV8"],[[6150,6150],"disallowed"],[[6151,6154],"valid",[],"NV8"],[[6155,6157],"ignored"],[[6158,6158],"disallowed"],[[6159,6159],"disallowed"],[[6160,6169],"valid"],[[6170,6175],"disallowed"],[[6176,6263],"valid"],[[6264,6271],"disallowed"],[[6272,6313],"valid"],[[6314,6314],"valid"],[[6315,6319],"disallowed"],[[6320,6389],"valid"],[[6390,6399],"disallowed"],[[6400,6428],"valid"],[[6429,6430],"valid"],[[6431,6431],"disallowed"],[[6432,6443],"valid"],[[6444,6447],"disallowed"],[[6448,6459],"valid"],[[6460,6463],"disallowed"],[[6464,6464],"valid",[],"NV8"],[[6465,6467],"disallowed"],[[6468,6469],"valid",[],"NV8"],[[6470,6509],"valid"],[[6510,6511],"disallowed"],[[6512,6516],"valid"],[[6517,6527],"disallowed"],[[6528,6569],"valid"],[[6570,6571],"valid"],[[6572,6575],"disallowed"],[[6576,6601],"valid"],[[6602,6607],"disallowed"],[[6608,6617],"valid"],[[6618,6618],"valid",[],"XV8"],[[6619,6621],"disallowed"],[[6622,6623],"valid",[],"NV8"],[[6624,6655],"valid",[],"NV8"],[[6656,6683],"valid"],[[6684,6685],"disallowed"],[[6686,6687],"valid",[],"NV8"],[[6688,6750],"valid"],[[6751,6751],"disallowed"],[[6752,6780],"valid"],[[6781,6782],"disallowed"],[[6783,6793],"valid"],[[6794,6799],"disallowed"],[[6800,6809],"valid"],[[6810,6815],"disallowed"],[[6816,6822],"valid",[],"NV8"],[[6823,6823],"valid"],[[6824,6829],"valid",[],"NV8"],[[6830,6831],"disallowed"],[[6832,6845],"valid"],[[6846,6846],"valid",[],"NV8"],[[6847,6911],"disallowed"],[[6912,6987],"valid"],[[6988,6991],"disallowed"],[[6992,7001],"valid"],[[7002,7018],"valid",[],"NV8"],[[7019,7027],"valid"],[[7028,7036],"valid",[],"NV8"],[[7037,7039],"disallowed"],[[7040,7082],"valid"],[[7083,7085],"valid"],[[7086,7097],"valid"],[[7098,7103],"valid"],[[7104,7155],"valid"],[[7156,7163],"disallowed"],[[7164,7167],"valid",[],"NV8"],[[7168,7223],"valid"],[[7224,7226],"disallowed"],[[7227,7231],"valid",[],"NV8"],[[7232,7241],"valid"],[[7242,7244],"disallowed"],[[7245,7293],"valid"],[[7294,7295],"valid",[],"NV8"],[[7296,7359],"disallowed"],[[7360,7367],"valid",[],"NV8"],[[7368,7375],"disallowed"],[[7376,7378],"valid"],[[7379,7379],"valid",[],"NV8"],[[7380,7410],"valid"],[[7411,7414],"valid"],[[7415,7415],"disallowed"],[[7416,7417],"valid"],[[7418,7423],"disallowed"],[[7424,7467],"valid"],[[7468,7468],"mapped",[97]],[[7469,7469],"mapped",[230]],[[7470,7470],"mapped",[98]],[[7471,7471],"valid"],[[7472,7472],"mapped",[100]],[[7473,7473],"mapped",[101]],[[7474,7474],"mapped",[477]],[[7475,7475],"mapped",[103]],[[7476,7476],"mapped",[104]],[[7477,7477],"mapped",[105]],[[7478,7478],"mapped",[106]],[[7479,7479],"mapped",[107]],[[7480,7480],"mapped",[108]],[[7481,7481],"mapped",[109]],[[7482,7482],"mapped",[110]],[[7483,7483],"valid"],[[7484,7484],"mapped",[111]],[[7485,7485],"mapped",[547]],[[7486,7486],"mapped",[112]],[[7487,7487],"mapped",[114]],[[7488,7488],"mapped",[116]],[[7489,7489],"mapped",[117]],[[7490,7490],"mapped",[119]],[[7491,7491],"mapped",[97]],[[7492,7492],"mapped",[592]],[[7493,7493],"mapped",[593]],[[7494,7494],"mapped",[7426]],[[7495,7495],"mapped",[98]],[[7496,7496],"mapped",[100]],[[7497,7497],"mapped",[101]],[[7498,7498],"mapped",[601]],[[7499,7499],"mapped",[603]],[[7500,7500],"mapped",[604]],[[7501,7501],"mapped",[103]],[[7502,7502],"valid"],[[7503,7503],"mapped",[107]],[[7504,7504],"mapped",[109]],[[7505,7505],"mapped",[331]],[[7506,7506],"mapped",[111]],[[7507,7507],"mapped",[596]],[[7508,7508],"mapped",[7446]],[[7509,7509],"mapped",[7447]],[[7510,7510],"mapped",[112]],[[7511,7511],"mapped",[116]],[[7512,7512],"mapped",[117]],[[7513,7513],"mapped",[7453]],[[7514,7514],"mapped",[623]],[[7515,7515],"mapped",[118]],[[7516,7516],"mapped",[7461]],[[7517,7517],"mapped",[946]],[[7518,7518],"mapped",[947]],[[7519,7519],"mapped",[948]],[[7520,7520],"mapped",[966]],[[7521,7521],"mapped",[967]],[[7522,7522],"mapped",[105]],[[7523,7523],"mapped",[114]],[[7524,7524],"mapped",[117]],[[7525,7525],"mapped",[118]],[[7526,7526],"mapped",[946]],[[7527,7527],"mapped",[947]],[[7528,7528],"mapped",[961]],[[7529,7529],"mapped",[966]],[[7530,7530],"mapped",[967]],[[7531,7531],"valid"],[[7532,7543],"valid"],[[7544,7544],"mapped",[1085]],[[7545,7578],"valid"],[[7579,7579],"mapped",[594]],[[7580,7580],"mapped",[99]],[[7581,7581],"mapped",[597]],[[7582,7582],"mapped",[240]],[[7583,7583],"mapped",[604]],[[7584,7584],"mapped",[102]],[[7585,7585],"mapped",[607]],[[7586,7586],"mapped",[609]],[[7587,7587],"mapped",[613]],[[7588,7588],"mapped",[616]],[[7589,7589],"mapped",[617]],[[7590,7590],"mapped",[618]],[[7591,7591],"mapped",[7547]],[[7592,7592],"mapped",[669]],[[7593,7593],"mapped",[621]],[[7594,7594],"mapped",[7557]],[[7595,7595],"mapped",[671]],[[7596,7596],"mapped",[625]],[[7597,7597],"mapped",[624]],[[7598,7598],"mapped",[626]],[[7599,7599],"mapped",[627]],[[7600,7600],"mapped",[628]],[[7601,7601],"mapped",[629]],[[7602,7602],"mapped",[632]],[[7603,7603],"mapped",[642]],[[7604,7604],"mapped",[643]],[[7605,7605],"mapped",[427]],[[7606,7606],"mapped",[649]],[[7607,7607],"mapped",[650]],[[7608,7608],"mapped",[7452]],[[7609,7609],"mapped",[651]],[[7610,7610],"mapped",[652]],[[7611,7611],"mapped",[122]],[[7612,7612],"mapped",[656]],[[7613,7613],"mapped",[657]],[[7614,7614],"mapped",[658]],[[7615,7615],"mapped",[952]],[[7616,7619],"valid"],[[7620,7626],"valid"],[[7627,7654],"valid"],[[7655,7669],"valid"],[[7670,7675],"disallowed"],[[7676,7676],"valid"],[[7677,7677],"valid"],[[7678,7679],"valid"],[[7680,7680],"mapped",[7681]],[[7681,7681],"valid"],[[7682,7682],"mapped",[7683]],[[7683,7683],"valid"],[[7684,7684],"mapped",[7685]],[[7685,7685],"valid"],[[7686,7686],"mapped",[7687]],[[7687,7687],"valid"],[[7688,7688],"mapped",[7689]],[[7689,7689],"valid"],[[7690,7690],"mapped",[7691]],[[7691,7691],"valid"],[[7692,7692],"mapped",[7693]],[[7693,7693],"valid"],[[7694,7694],"mapped",[7695]],[[7695,7695],"valid"],[[7696,7696],"mapped",[7697]],[[7697,7697],"valid"],[[7698,7698],"mapped",[7699]],[[7699,7699],"valid"],[[7700,7700],"mapped",[7701]],[[7701,7701],"valid"],[[7702,7702],"mapped",[7703]],[[7703,7703],"valid"],[[7704,7704],"mapped",[7705]],[[7705,7705],"valid"],[[7706,7706],"mapped",[7707]],[[7707,7707],"valid"],[[7708,7708],"mapped",[7709]],[[7709,7709],"valid"],[[7710,7710],"mapped",[7711]],[[7711,7711],"valid"],[[7712,7712],"mapped",[7713]],[[7713,7713],"valid"],[[7714,7714],"mapped",[7715]],[[7715,7715],"valid"],[[7716,7716],"mapped",[7717]],[[7717,7717],"valid"],[[7718,7718],"mapped",[7719]],[[7719,7719],"valid"],[[7720,7720],"mapped",[7721]],[[7721,7721],"valid"],[[7722,7722],"mapped",[7723]],[[7723,7723],"valid"],[[7724,7724],"mapped",[7725]],[[7725,7725],"valid"],[[7726,7726],"mapped",[7727]],[[7727,7727],"valid"],[[7728,7728],"mapped",[7729]],[[7729,7729],"valid"],[[7730,7730],"mapped",[7731]],[[7731,7731],"valid"],[[7732,7732],"mapped",[7733]],[[7733,7733],"valid"],[[7734,7734],"mapped",[7735]],[[7735,7735],"valid"],[[7736,7736],"mapped",[7737]],[[7737,7737],"valid"],[[7738,7738],"mapped",[7739]],[[7739,7739],"valid"],[[7740,7740],"mapped",[7741]],[[7741,7741],"valid"],[[7742,7742],"mapped",[7743]],[[7743,7743],"valid"],[[7744,7744],"mapped",[7745]],[[7745,7745],"valid"],[[7746,7746],"mapped",[7747]],[[7747,7747],"valid"],[[7748,7748],"mapped",[7749]],[[7749,7749],"valid"],[[7750,7750],"mapped",[7751]],[[7751,7751],"valid"],[[7752,7752],"mapped",[7753]],[[7753,7753],"valid"],[[7754,7754],"mapped",[7755]],[[7755,7755],"valid"],[[7756,7756],"mapped",[7757]],[[7757,7757],"valid"],[[7758,7758],"mapped",[7759]],[[7759,7759],"valid"],[[7760,7760],"mapped",[7761]],[[7761,7761],"valid"],[[7762,7762],"mapped",[7763]],[[7763,7763],"valid"],[[7764,7764],"mapped",[7765]],[[7765,7765],"valid"],[[7766,7766],"mapped",[7767]],[[7767,7767],"valid"],[[7768,7768],"mapped",[7769]],[[7769,7769],"valid"],[[7770,7770],"mapped",[7771]],[[7771,7771],"valid"],[[7772,7772],"mapped",[7773]],[[7773,7773],"valid"],[[7774,7774],"mapped",[7775]],[[7775,7775],"valid"],[[7776,7776],"mapped",[7777]],[[7777,7777],"valid"],[[7778,7778],"mapped",[7779]],[[7779,7779],"valid"],[[7780,7780],"mapped",[7781]],[[7781,7781],"valid"],[[7782,7782],"mapped",[7783]],[[7783,7783],"valid"],[[7784,7784],"mapped",[7785]],[[7785,7785],"valid"],[[7786,7786],"mapped",[7787]],[[7787,7787],"valid"],[[7788,7788],"mapped",[7789]],[[7789,7789],"valid"],[[7790,7790],"mapped",[7791]],[[7791,7791],"valid"],[[7792,7792],"mapped",[7793]],[[7793,7793],"valid"],[[7794,7794],"mapped",[7795]],[[7795,7795],"valid"],[[7796,7796],"mapped",[7797]],[[7797,7797],"valid"],[[7798,7798],"mapped",[7799]],[[7799,7799],"valid"],[[7800,7800],"mapped",[7801]],[[7801,7801],"valid"],[[7802,7802],"mapped",[7803]],[[7803,7803],"valid"],[[7804,7804],"mapped",[7805]],[[7805,7805],"valid"],[[7806,7806],"mapped",[7807]],[[7807,7807],"valid"],[[7808,7808],"mapped",[7809]],[[7809,7809],"valid"],[[7810,7810],"mapped",[7811]],[[7811,7811],"valid"],[[7812,7812],"mapped",[7813]],[[7813,7813],"valid"],[[7814,7814],"mapped",[7815]],[[7815,7815],"valid"],[[7816,7816],"mapped",[7817]],[[7817,7817],"valid"],[[7818,7818],"mapped",[7819]],[[7819,7819],"valid"],[[7820,7820],"mapped",[7821]],[[7821,7821],"valid"],[[7822,7822],"mapped",[7823]],[[7823,7823],"valid"],[[7824,7824],"mapped",[7825]],[[7825,7825],"valid"],[[7826,7826],"mapped",[7827]],[[7827,7827],"valid"],[[7828,7828],"mapped",[7829]],[[7829,7833],"valid"],[[7834,7834],"mapped",[97,702]],[[7835,7835],"mapped",[7777]],[[7836,7837],"valid"],[[7838,7838],"mapped",[115,115]],[[7839,7839],"valid"],[[7840,7840],"mapped",[7841]],[[7841,7841],"valid"],[[7842,7842],"mapped",[7843]],[[7843,7843],"valid"],[[7844,7844],"mapped",[7845]],[[7845,7845],"valid"],[[7846,7846],"mapped",[7847]],[[7847,7847],"valid"],[[7848,7848],"mapped",[7849]],[[7849,7849],"valid"],[[7850,7850],"mapped",[7851]],[[7851,7851],"valid"],[[7852,7852],"mapped",[7853]],[[7853,7853],"valid"],[[7854,7854],"mapped",[7855]],[[7855,7855],"valid"],[[7856,7856],"mapped",[7857]],[[7857,7857],"valid"],[[7858,7858],"mapped",[7859]],[[7859,7859],"valid"],[[7860,7860],"mapped",[7861]],[[7861,7861],"valid"],[[7862,7862],"mapped",[7863]],[[7863,7863],"valid"],[[7864,7864],"mapped",[7865]],[[7865,7865],"valid"],[[7866,7866],"mapped",[7867]],[[7867,7867],"valid"],[[7868,7868],"mapped",[7869]],[[7869,7869],"valid"],[[7870,7870],"mapped",[7871]],[[7871,7871],"valid"],[[7872,7872],"mapped",[7873]],[[7873,7873],"valid"],[[7874,7874],"mapped",[7875]],[[7875,7875],"valid"],[[7876,7876],"mapped",[7877]],[[7877,7877],"valid"],[[7878,7878],"mapped",[7879]],[[7879,7879],"valid"],[[7880,7880],"mapped",[7881]],[[7881,7881],"valid"],[[7882,7882],"mapped",[7883]],[[7883,7883],"valid"],[[7884,7884],"mapped",[7885]],[[7885,7885],"valid"],[[7886,7886],"mapped",[7887]],[[7887,7887],"valid"],[[7888,7888],"mapped",[7889]],[[7889,7889],"valid"],[[7890,7890],"mapped",[7891]],[[7891,7891],"valid"],[[7892,7892],"mapped",[7893]],[[7893,7893],"valid"],[[7894,7894],"mapped",[7895]],[[7895,7895],"valid"],[[7896,7896],"mapped",[7897]],[[7897,7897],"valid"],[[7898,7898],"mapped",[7899]],[[7899,7899],"valid"],[[7900,7900],"mapped",[7901]],[[7901,7901],"valid"],[[7902,7902],"mapped",[7903]],[[7903,7903],"valid"],[[7904,7904],"mapped",[7905]],[[7905,7905],"valid"],[[7906,7906],"mapped",[7907]],[[7907,7907],"valid"],[[7908,7908],"mapped",[7909]],[[7909,7909],"valid"],[[7910,7910],"mapped",[7911]],[[7911,7911],"valid"],[[7912,7912],"mapped",[7913]],[[7913,7913],"valid"],[[7914,7914],"mapped",[7915]],[[7915,7915],"valid"],[[7916,7916],"mapped",[7917]],[[7917,7917],"valid"],[[7918,7918],"mapped",[7919]],[[7919,7919],"valid"],[[7920,7920],"mapped",[7921]],[[7921,7921],"valid"],[[7922,7922],"mapped",[7923]],[[7923,7923],"valid"],[[7924,7924],"mapped",[7925]],[[7925,7925],"valid"],[[7926,7926],"mapped",[7927]],[[7927,7927],"valid"],[[7928,7928],"mapped",[7929]],[[7929,7929],"valid"],[[7930,7930],"mapped",[7931]],[[7931,7931],"valid"],[[7932,7932],"mapped",[7933]],[[7933,7933],"valid"],[[7934,7934],"mapped",[7935]],[[7935,7935],"valid"],[[7936,7943],"valid"],[[7944,7944],"mapped",[7936]],[[7945,7945],"mapped",[7937]],[[7946,7946],"mapped",[7938]],[[7947,7947],"mapped",[7939]],[[7948,7948],"mapped",[7940]],[[7949,7949],"mapped",[7941]],[[7950,7950],"mapped",[7942]],[[7951,7951],"mapped",[7943]],[[7952,7957],"valid"],[[7958,7959],"disallowed"],[[7960,7960],"mapped",[7952]],[[7961,7961],"mapped",[7953]],[[7962,7962],"mapped",[7954]],[[7963,7963],"mapped",[7955]],[[7964,7964],"mapped",[7956]],[[7965,7965],"mapped",[7957]],[[7966,7967],"disallowed"],[[7968,7975],"valid"],[[7976,7976],"mapped",[7968]],[[7977,7977],"mapped",[7969]],[[7978,7978],"mapped",[7970]],[[7979,7979],"mapped",[7971]],[[7980,7980],"mapped",[7972]],[[7981,7981],"mapped",[7973]],[[7982,7982],"mapped",[7974]],[[7983,7983],"mapped",[7975]],[[7984,7991],"valid"],[[7992,7992],"mapped",[7984]],[[7993,7993],"mapped",[7985]],[[7994,7994],"mapped",[7986]],[[7995,7995],"mapped",[7987]],[[7996,7996],"mapped",[7988]],[[7997,7997],"mapped",[7989]],[[7998,7998],"mapped",[7990]],[[7999,7999],"mapped",[7991]],[[8000,8005],"valid"],[[8006,8007],"disallowed"],[[8008,8008],"mapped",[8000]],[[8009,8009],"mapped",[8001]],[[8010,8010],"mapped",[8002]],[[8011,8011],"mapped",[8003]],[[8012,8012],"mapped",[8004]],[[8013,8013],"mapped",[8005]],[[8014,8015],"disallowed"],[[8016,8023],"valid"],[[8024,8024],"disallowed"],[[8025,8025],"mapped",[8017]],[[8026,8026],"disallowed"],[[8027,8027],"mapped",[8019]],[[8028,8028],"disallowed"],[[8029,8029],"mapped",[8021]],[[8030,8030],"disallowed"],[[8031,8031],"mapped",[8023]],[[8032,8039],"valid"],[[8040,8040],"mapped",[8032]],[[8041,8041],"mapped",[8033]],[[8042,8042],"mapped",[8034]],[[8043,8043],"mapped",[8035]],[[8044,8044],"mapped",[8036]],[[8045,8045],"mapped",[8037]],[[8046,8046],"mapped",[8038]],[[8047,8047],"mapped",[8039]],[[8048,8048],"valid"],[[8049,8049],"mapped",[940]],[[8050,8050],"valid"],[[8051,8051],"mapped",[941]],[[8052,8052],"valid"],[[8053,8053],"mapped",[942]],[[8054,8054],"valid"],[[8055,8055],"mapped",[943]],[[8056,8056],"valid"],[[8057,8057],"mapped",[972]],[[8058,8058],"valid"],[[8059,8059],"mapped",[973]],[[8060,8060],"valid"],[[8061,8061],"mapped",[974]],[[8062,8063],"disallowed"],[[8064,8064],"mapped",[7936,953]],[[8065,8065],"mapped",[7937,953]],[[8066,8066],"mapped",[7938,953]],[[8067,8067],"mapped",[7939,953]],[[8068,8068],"mapped",[7940,953]],[[8069,8069],"mapped",[7941,953]],[[8070,8070],"mapped",[7942,953]],[[8071,8071],"mapped",[7943,953]],[[8072,8072],"mapped",[7936,953]],[[8073,8073],"mapped",[7937,953]],[[8074,8074],"mapped",[7938,953]],[[8075,8075],"mapped",[7939,953]],[[8076,8076],"mapped",[7940,953]],[[8077,8077],"mapped",[7941,953]],[[8078,8078],"mapped",[7942,953]],[[8079,8079],"mapped",[7943,953]],[[8080,8080],"mapped",[7968,953]],[[8081,8081],"mapped",[7969,953]],[[8082,8082],"mapped",[7970,953]],[[8083,8083],"mapped",[7971,953]],[[8084,8084],"mapped",[7972,953]],[[8085,8085],"mapped",[7973,953]],[[8086,8086],"mapped",[7974,953]],[[8087,8087],"mapped",[7975,953]],[[8088,8088],"mapped",[7968,953]],[[8089,8089],"mapped",[7969,953]],[[8090,8090],"mapped",[7970,953]],[[8091,8091],"mapped",[7971,953]],[[8092,8092],"mapped",[7972,953]],[[8093,8093],"mapped",[7973,953]],[[8094,8094],"mapped",[7974,953]],[[8095,8095],"mapped",[7975,953]],[[8096,8096],"mapped",[8032,953]],[[8097,8097],"mapped",[8033,953]],[[8098,8098],"mapped",[8034,953]],[[8099,8099],"mapped",[8035,953]],[[8100,8100],"mapped",[8036,953]],[[8101,8101],"mapped",[8037,953]],[[8102,8102],"mapped",[8038,953]],[[8103,8103],"mapped",[8039,953]],[[8104,8104],"mapped",[8032,953]],[[8105,8105],"mapped",[8033,953]],[[8106,8106],"mapped",[8034,953]],[[8107,8107],"mapped",[8035,953]],[[8108,8108],"mapped",[8036,953]],[[8109,8109],"mapped",[8037,953]],[[8110,8110],"mapped",[8038,953]],[[8111,8111],"mapped",[8039,953]],[[8112,8113],"valid"],[[8114,8114],"mapped",[8048,953]],[[8115,8115],"mapped",[945,953]],[[8116,8116],"mapped",[940,953]],[[8117,8117],"disallowed"],[[8118,8118],"valid"],[[8119,8119],"mapped",[8118,953]],[[8120,8120],"mapped",[8112]],[[8121,8121],"mapped",[8113]],[[8122,8122],"mapped",[8048]],[[8123,8123],"mapped",[940]],[[8124,8124],"mapped",[945,953]],[[8125,8125],"disallowed_STD3_mapped",[32,787]],[[8126,8126],"mapped",[953]],[[8127,8127],"disallowed_STD3_mapped",[32,787]],[[8128,8128],"disallowed_STD3_mapped",[32,834]],[[8129,8129],"disallowed_STD3_mapped",[32,776,834]],[[8130,8130],"mapped",[8052,953]],[[8131,8131],"mapped",[951,953]],[[8132,8132],"mapped",[942,953]],[[8133,8133],"disallowed"],[[8134,8134],"valid"],[[8135,8135],"mapped",[8134,953]],[[8136,8136],"mapped",[8050]],[[8137,8137],"mapped",[941]],[[8138,8138],"mapped",[8052]],[[8139,8139],"mapped",[942]],[[8140,8140],"mapped",[951,953]],[[8141,8141],"disallowed_STD3_mapped",[32,787,768]],[[8142,8142],"disallowed_STD3_mapped",[32,787,769]],[[8143,8143],"disallowed_STD3_mapped",[32,787,834]],[[8144,8146],"valid"],[[8147,8147],"mapped",[912]],[[8148,8149],"disallowed"],[[8150,8151],"valid"],[[8152,8152],"mapped",[8144]],[[8153,8153],"mapped",[8145]],[[8154,8154],"mapped",[8054]],[[8155,8155],"mapped",[943]],[[8156,8156],"disallowed"],[[8157,8157],"disallowed_STD3_mapped",[32,788,768]],[[8158,8158],"disallowed_STD3_mapped",[32,788,769]],[[8159,8159],"disallowed_STD3_mapped",[32,788,834]],[[8160,8162],"valid"],[[8163,8163],"mapped",[944]],[[8164,8167],"valid"],[[8168,8168],"mapped",[8160]],[[8169,8169],"mapped",[8161]],[[8170,8170],"mapped",[8058]],[[8171,8171],"mapped",[973]],[[8172,8172],"mapped",[8165]],[[8173,8173],"disallowed_STD3_mapped",[32,776,768]],[[8174,8174],"disallowed_STD3_mapped",[32,776,769]],[[8175,8175],"disallowed_STD3_mapped",[96]],[[8176,8177],"disallowed"],[[8178,8178],"mapped",[8060,953]],[[8179,8179],"mapped",[969,953]],[[8180,8180],"mapped",[974,953]],[[8181,8181],"disallowed"],[[8182,8182],"valid"],[[8183,8183],"mapped",[8182,953]],[[8184,8184],"mapped",[8056]],[[8185,8185],"mapped",[972]],[[8186,8186],"mapped",[8060]],[[8187,8187],"mapped",[974]],[[8188,8188],"mapped",[969,953]],[[8189,8189],"disallowed_STD3_mapped",[32,769]],[[8190,8190],"disallowed_STD3_mapped",[32,788]],[[8191,8191],"disallowed"],[[8192,8202],"disallowed_STD3_mapped",[32]],[[8203,8203],"ignored"],[[8204,8205],"deviation",[]],[[8206,8207],"disallowed"],[[8208,8208],"valid",[],"NV8"],[[8209,8209],"mapped",[8208]],[[8210,8214],"valid",[],"NV8"],[[8215,8215],"disallowed_STD3_mapped",[32,819]],[[8216,8227],"valid",[],"NV8"],[[8228,8230],"disallowed"],[[8231,8231],"valid",[],"NV8"],[[8232,8238],"disallowed"],[[8239,8239],"disallowed_STD3_mapped",[32]],[[8240,8242],"valid",[],"NV8"],[[8243,8243],"mapped",[8242,8242]],[[8244,8244],"mapped",[8242,8242,8242]],[[8245,8245],"valid",[],"NV8"],[[8246,8246],"mapped",[8245,8245]],[[8247,8247],"mapped",[8245,8245,8245]],[[8248,8251],"valid",[],"NV8"],[[8252,8252],"disallowed_STD3_mapped",[33,33]],[[8253,8253],"valid",[],"NV8"],[[8254,8254],"disallowed_STD3_mapped",[32,773]],[[8255,8262],"valid",[],"NV8"],[[8263,8263],"disallowed_STD3_mapped",[63,63]],[[8264,8264],"disallowed_STD3_mapped",[63,33]],[[8265,8265],"disallowed_STD3_mapped",[33,63]],[[8266,8269],"valid",[],"NV8"],[[8270,8274],"valid",[],"NV8"],[[8275,8276],"valid",[],"NV8"],[[8277,8278],"valid",[],"NV8"],[[8279,8279],"mapped",[8242,8242,8242,8242]],[[8280,8286],"valid",[],"NV8"],[[8287,8287],"disallowed_STD3_mapped",[32]],[[8288,8288],"ignored"],[[8289,8291],"disallowed"],[[8292,8292],"ignored"],[[8293,8293],"disallowed"],[[8294,8297],"disallowed"],[[8298,8303],"disallowed"],[[8304,8304],"mapped",[48]],[[8305,8305],"mapped",[105]],[[8306,8307],"disallowed"],[[8308,8308],"mapped",[52]],[[8309,8309],"mapped",[53]],[[8310,8310],"mapped",[54]],[[8311,8311],"mapped",[55]],[[8312,8312],"mapped",[56]],[[8313,8313],"mapped",[57]],[[8314,8314],"disallowed_STD3_mapped",[43]],[[8315,8315],"mapped",[8722]],[[8316,8316],"disallowed_STD3_mapped",[61]],[[8317,8317],"disallowed_STD3_mapped",[40]],[[8318,8318],"disallowed_STD3_mapped",[41]],[[8319,8319],"mapped",[110]],[[8320,8320],"mapped",[48]],[[8321,8321],"mapped",[49]],[[8322,8322],"mapped",[50]],[[8323,8323],"mapped",[51]],[[8324,8324],"mapped",[52]],[[8325,8325],"mapped",[53]],[[8326,8326],"mapped",[54]],[[8327,8327],"mapped",[55]],[[8328,8328],"mapped",[56]],[[8329,8329],"mapped",[57]],[[8330,8330],"disallowed_STD3_mapped",[43]],[[8331,8331],"mapped",[8722]],[[8332,8332],"disallowed_STD3_mapped",[61]],[[8333,8333],"disallowed_STD3_mapped",[40]],[[8334,8334],"disallowed_STD3_mapped",[41]],[[8335,8335],"disallowed"],[[8336,8336],"mapped",[97]],[[8337,8337],"mapped",[101]],[[8338,8338],"mapped",[111]],[[8339,8339],"mapped",[120]],[[8340,8340],"mapped",[601]],[[8341,8341],"mapped",[104]],[[8342,8342],"mapped",[107]],[[8343,8343],"mapped",[108]],[[8344,8344],"mapped",[109]],[[8345,8345],"mapped",[110]],[[8346,8346],"mapped",[112]],[[8347,8347],"mapped",[115]],[[8348,8348],"mapped",[116]],[[8349,8351],"disallowed"],[[8352,8359],"valid",[],"NV8"],[[8360,8360],"mapped",[114,115]],[[8361,8362],"valid",[],"NV8"],[[8363,8363],"valid",[],"NV8"],[[8364,8364],"valid",[],"NV8"],[[8365,8367],"valid",[],"NV8"],[[8368,8369],"valid",[],"NV8"],[[8370,8373],"valid",[],"NV8"],[[8374,8376],"valid",[],"NV8"],[[8377,8377],"valid",[],"NV8"],[[8378,8378],"valid",[],"NV8"],[[8379,8381],"valid",[],"NV8"],[[8382,8382],"valid",[],"NV8"],[[8383,8399],"disallowed"],[[8400,8417],"valid",[],"NV8"],[[8418,8419],"valid",[],"NV8"],[[8420,8426],"valid",[],"NV8"],[[8427,8427],"valid",[],"NV8"],[[8428,8431],"valid",[],"NV8"],[[8432,8432],"valid",[],"NV8"],[[8433,8447],"disallowed"],[[8448,8448],"disallowed_STD3_mapped",[97,47,99]],[[8449,8449],"disallowed_STD3_mapped",[97,47,115]],[[8450,8450],"mapped",[99]],[[8451,8451],"mapped",[176,99]],[[8452,8452],"valid",[],"NV8"],[[8453,8453],"disallowed_STD3_mapped",[99,47,111]],[[8454,8454],"disallowed_STD3_mapped",[99,47,117]],[[8455,8455],"mapped",[603]],[[8456,8456],"valid",[],"NV8"],[[8457,8457],"mapped",[176,102]],[[8458,8458],"mapped",[103]],[[8459,8462],"mapped",[104]],[[8463,8463],"mapped",[295]],[[8464,8465],"mapped",[105]],[[8466,8467],"mapped",[108]],[[8468,8468],"valid",[],"NV8"],[[8469,8469],"mapped",[110]],[[8470,8470],"mapped",[110,111]],[[8471,8472],"valid",[],"NV8"],[[8473,8473],"mapped",[112]],[[8474,8474],"mapped",[113]],[[8475,8477],"mapped",[114]],[[8478,8479],"valid",[],"NV8"],[[8480,8480],"mapped",[115,109]],[[8481,8481],"mapped",[116,101,108]],[[8482,8482],"mapped",[116,109]],[[8483,8483],"valid",[],"NV8"],[[8484,8484],"mapped",[122]],[[8485,8485],"valid",[],"NV8"],[[8486,8486],"mapped",[969]],[[8487,8487],"valid",[],"NV8"],[[8488,8488],"mapped",[122]],[[8489,8489],"valid",[],"NV8"],[[8490,8490],"mapped",[107]],[[8491,8491],"mapped",[229]],[[8492,8492],"mapped",[98]],[[8493,8493],"mapped",[99]],[[8494,8494],"valid",[],"NV8"],[[8495,8496],"mapped",[101]],[[8497,8497],"mapped",[102]],[[8498,8498],"disallowed"],[[8499,8499],"mapped",[109]],[[8500,8500],"mapped",[111]],[[8501,8501],"mapped",[1488]],[[8502,8502],"mapped",[1489]],[[8503,8503],"mapped",[1490]],[[8504,8504],"mapped",[1491]],[[8505,8505],"mapped",[105]],[[8506,8506],"valid",[],"NV8"],[[8507,8507],"mapped",[102,97,120]],[[8508,8508],"mapped",[960]],[[8509,8510],"mapped",[947]],[[8511,8511],"mapped",[960]],[[8512,8512],"mapped",[8721]],[[8513,8516],"valid",[],"NV8"],[[8517,8518],"mapped",[100]],[[8519,8519],"mapped",[101]],[[8520,8520],"mapped",[105]],[[8521,8521],"mapped",[106]],[[8522,8523],"valid",[],"NV8"],[[8524,8524],"valid",[],"NV8"],[[8525,8525],"valid",[],"NV8"],[[8526,8526],"valid"],[[8527,8527],"valid",[],"NV8"],[[8528,8528],"mapped",[49,8260,55]],[[8529,8529],"mapped",[49,8260,57]],[[8530,8530],"mapped",[49,8260,49,48]],[[8531,8531],"mapped",[49,8260,51]],[[8532,8532],"mapped",[50,8260,51]],[[8533,8533],"mapped",[49,8260,53]],[[8534,8534],"mapped",[50,8260,53]],[[8535,8535],"mapped",[51,8260,53]],[[8536,8536],"mapped",[52,8260,53]],[[8537,8537],"mapped",[49,8260,54]],[[8538,8538],"mapped",[53,8260,54]],[[8539,8539],"mapped",[49,8260,56]],[[8540,8540],"mapped",[51,8260,56]],[[8541,8541],"mapped",[53,8260,56]],[[8542,8542],"mapped",[55,8260,56]],[[8543,8543],"mapped",[49,8260]],[[8544,8544],"mapped",[105]],[[8545,8545],"mapped",[105,105]],[[8546,8546],"mapped",[105,105,105]],[[8547,8547],"mapped",[105,118]],[[8548,8548],"mapped",[118]],[[8549,8549],"mapped",[118,105]],[[8550,8550],"mapped",[118,105,105]],[[8551,8551],"mapped",[118,105,105,105]],[[8552,8552],"mapped",[105,120]],[[8553,8553],"mapped",[120]],[[8554,8554],"mapped",[120,105]],[[8555,8555],"mapped",[120,105,105]],[[8556,8556],"mapped",[108]],[[8557,8557],"mapped",[99]],[[8558,8558],"mapped",[100]],[[8559,8559],"mapped",[109]],[[8560,8560],"mapped",[105]],[[8561,8561],"mapped",[105,105]],[[8562,8562],"mapped",[105,105,105]],[[8563,8563],"mapped",[105,118]],[[8564,8564],"mapped",[118]],[[8565,8565],"mapped",[118,105]],[[8566,8566],"mapped",[118,105,105]],[[8567,8567],"mapped",[118,105,105,105]],[[8568,8568],"mapped",[105,120]],[[8569,8569],"mapped",[120]],[[8570,8570],"mapped",[120,105]],[[8571,8571],"mapped",[120,105,105]],[[8572,8572],"mapped",[108]],[[8573,8573],"mapped",[99]],[[8574,8574],"mapped",[100]],[[8575,8575],"mapped",[109]],[[8576,8578],"valid",[],"NV8"],[[8579,8579],"disallowed"],[[8580,8580],"valid"],[[8581,8584],"valid",[],"NV8"],[[8585,8585],"mapped",[48,8260,51]],[[8586,8587],"valid",[],"NV8"],[[8588,8591],"disallowed"],[[8592,8682],"valid",[],"NV8"],[[8683,8691],"valid",[],"NV8"],[[8692,8703],"valid",[],"NV8"],[[8704,8747],"valid",[],"NV8"],[[8748,8748],"mapped",[8747,8747]],[[8749,8749],"mapped",[8747,8747,8747]],[[8750,8750],"valid",[],"NV8"],[[8751,8751],"mapped",[8750,8750]],[[8752,8752],"mapped",[8750,8750,8750]],[[8753,8799],"valid",[],"NV8"],[[8800,8800],"disallowed_STD3_valid"],[[8801,8813],"valid",[],"NV8"],[[8814,8815],"disallowed_STD3_valid"],[[8816,8945],"valid",[],"NV8"],[[8946,8959],"valid",[],"NV8"],[[8960,8960],"valid",[],"NV8"],[[8961,8961],"valid",[],"NV8"],[[8962,9000],"valid",[],"NV8"],[[9001,9001],"mapped",[12296]],[[9002,9002],"mapped",[12297]],[[9003,9082],"valid",[],"NV8"],[[9083,9083],"valid",[],"NV8"],[[9084,9084],"valid",[],"NV8"],[[9085,9114],"valid",[],"NV8"],[[9115,9166],"valid",[],"NV8"],[[9167,9168],"valid",[],"NV8"],[[9169,9179],"valid",[],"NV8"],[[9180,9191],"valid",[],"NV8"],[[9192,9192],"valid",[],"NV8"],[[9193,9203],"valid",[],"NV8"],[[9204,9210],"valid",[],"NV8"],[[9211,9215],"disallowed"],[[9216,9252],"valid",[],"NV8"],[[9253,9254],"valid",[],"NV8"],[[9255,9279],"disallowed"],[[9280,9290],"valid",[],"NV8"],[[9291,9311],"disallowed"],[[9312,9312],"mapped",[49]],[[9313,9313],"mapped",[50]],[[9314,9314],"mapped",[51]],[[9315,9315],"mapped",[52]],[[9316,9316],"mapped",[53]],[[9317,9317],"mapped",[54]],[[9318,9318],"mapped",[55]],[[9319,9319],"mapped",[56]],[[9320,9320],"mapped",[57]],[[9321,9321],"mapped",[49,48]],[[9322,9322],"mapped",[49,49]],[[9323,9323],"mapped",[49,50]],[[9324,9324],"mapped",[49,51]],[[9325,9325],"mapped",[49,52]],[[9326,9326],"mapped",[49,53]],[[9327,9327],"mapped",[49,54]],[[9328,9328],"mapped",[49,55]],[[9329,9329],"mapped",[49,56]],[[9330,9330],"mapped",[49,57]],[[9331,9331],"mapped",[50,48]],[[9332,9332],"disallowed_STD3_mapped",[40,49,41]],[[9333,9333],"disallowed_STD3_mapped",[40,50,41]],[[9334,9334],"disallowed_STD3_mapped",[40,51,41]],[[9335,9335],"disallowed_STD3_mapped",[40,52,41]],[[9336,9336],"disallowed_STD3_mapped",[40,53,41]],[[9337,9337],"disallowed_STD3_mapped",[40,54,41]],[[9338,9338],"disallowed_STD3_mapped",[40,55,41]],[[9339,9339],"disallowed_STD3_mapped",[40,56,41]],[[9340,9340],"disallowed_STD3_mapped",[40,57,41]],[[9341,9341],"disallowed_STD3_mapped",[40,49,48,41]],[[9342,9342],"disallowed_STD3_mapped",[40,49,49,41]],[[9343,9343],"disallowed_STD3_mapped",[40,49,50,41]],[[9344,9344],"disallowed_STD3_mapped",[40,49,51,41]],[[9345,9345],"disallowed_STD3_mapped",[40,49,52,41]],[[9346,9346],"disallowed_STD3_mapped",[40,49,53,41]],[[9347,9347],"disallowed_STD3_mapped",[40,49,54,41]],[[9348,9348],"disallowed_STD3_mapped",[40,49,55,41]],[[9349,9349],"disallowed_STD3_mapped",[40,49,56,41]],[[9350,9350],"disallowed_STD3_mapped",[40,49,57,41]],[[9351,9351],"disallowed_STD3_mapped",[40,50,48,41]],[[9352,9371],"disallowed"],[[9372,9372],"disallowed_STD3_mapped",[40,97,41]],[[9373,9373],"disallowed_STD3_mapped",[40,98,41]],[[9374,9374],"disallowed_STD3_mapped",[40,99,41]],[[9375,9375],"disallowed_STD3_mapped",[40,100,41]],[[9376,9376],"disallowed_STD3_mapped",[40,101,41]],[[9377,9377],"disallowed_STD3_mapped",[40,102,41]],[[9378,9378],"disallowed_STD3_mapped",[40,103,41]],[[9379,9379],"disallowed_STD3_mapped",[40,104,41]],[[9380,9380],"disallowed_STD3_mapped",[40,105,41]],[[9381,9381],"disallowed_STD3_mapped",[40,106,41]],[[9382,9382],"disallowed_STD3_mapped",[40,107,41]],[[9383,9383],"disallowed_STD3_mapped",[40,108,41]],[[9384,9384],"disallowed_STD3_mapped",[40,109,41]],[[9385,9385],"disallowed_STD3_mapped",[40,110,41]],[[9386,9386],"disallowed_STD3_mapped",[40,111,41]],[[9387,9387],"disallowed_STD3_mapped",[40,112,41]],[[9388,9388],"disallowed_STD3_mapped",[40,113,41]],[[9389,9389],"disallowed_STD3_mapped",[40,114,41]],[[9390,9390],"disallowed_STD3_mapped",[40,115,41]],[[9391,9391],"disallowed_STD3_mapped",[40,116,41]],[[9392,9392],"disallowed_STD3_mapped",[40,117,41]],[[9393,9393],"disallowed_STD3_mapped",[40,118,41]],[[9394,9394],"disallowed_STD3_mapped",[40,119,41]],[[9395,9395],"disallowed_STD3_mapped",[40,120,41]],[[9396,9396],"disallowed_STD3_mapped",[40,121,41]],[[9397,9397],"disallowed_STD3_mapped",[40,122,41]],[[9398,9398],"mapped",[97]],[[9399,9399],"mapped",[98]],[[9400,9400],"mapped",[99]],[[9401,9401],"mapped",[100]],[[9402,9402],"mapped",[101]],[[9403,9403],"mapped",[102]],[[9404,9404],"mapped",[103]],[[9405,9405],"mapped",[104]],[[9406,9406],"mapped",[105]],[[9407,9407],"mapped",[106]],[[9408,9408],"mapped",[107]],[[9409,9409],"mapped",[108]],[[9410,9410],"mapped",[109]],[[9411,9411],"mapped",[110]],[[9412,9412],"mapped",[111]],[[9413,9413],"mapped",[112]],[[9414,9414],"mapped",[113]],[[9415,9415],"mapped",[114]],[[9416,9416],"mapped",[115]],[[9417,9417],"mapped",[116]],[[9418,9418],"mapped",[117]],[[9419,9419],"mapped",[118]],[[9420,9420],"mapped",[119]],[[9421,9421],"mapped",[120]],[[9422,9422],"mapped",[121]],[[9423,9423],"mapped",[122]],[[9424,9424],"mapped",[97]],[[9425,9425],"mapped",[98]],[[9426,9426],"mapped",[99]],[[9427,9427],"mapped",[100]],[[9428,9428],"mapped",[101]],[[9429,9429],"mapped",[102]],[[9430,9430],"mapped",[103]],[[9431,9431],"mapped",[104]],[[9432,9432],"mapped",[105]],[[9433,9433],"mapped",[106]],[[9434,9434],"mapped",[107]],[[9435,9435],"mapped",[108]],[[9436,9436],"mapped",[109]],[[9437,9437],"mapped",[110]],[[9438,9438],"mapped",[111]],[[9439,9439],"mapped",[112]],[[9440,9440],"mapped",[113]],[[9441,9441],"mapped",[114]],[[9442,9442],"mapped",[115]],[[9443,9443],"mapped",[116]],[[9444,9444],"mapped",[117]],[[9445,9445],"mapped",[118]],[[9446,9446],"mapped",[119]],[[9447,9447],"mapped",[120]],[[9448,9448],"mapped",[121]],[[9449,9449],"mapped",[122]],[[9450,9450],"mapped",[48]],[[9451,9470],"valid",[],"NV8"],[[9471,9471],"valid",[],"NV8"],[[9472,9621],"valid",[],"NV8"],[[9622,9631],"valid",[],"NV8"],[[9632,9711],"valid",[],"NV8"],[[9712,9719],"valid",[],"NV8"],[[9720,9727],"valid",[],"NV8"],[[9728,9747],"valid",[],"NV8"],[[9748,9749],"valid",[],"NV8"],[[9750,9751],"valid",[],"NV8"],[[9752,9752],"valid",[],"NV8"],[[9753,9753],"valid",[],"NV8"],[[9754,9839],"valid",[],"NV8"],[[9840,9841],"valid",[],"NV8"],[[9842,9853],"valid",[],"NV8"],[[9854,9855],"valid",[],"NV8"],[[9856,9865],"valid",[],"NV8"],[[9866,9873],"valid",[],"NV8"],[[9874,9884],"valid",[],"NV8"],[[9885,9885],"valid",[],"NV8"],[[9886,9887],"valid",[],"NV8"],[[9888,9889],"valid",[],"NV8"],[[9890,9905],"valid",[],"NV8"],[[9906,9906],"valid",[],"NV8"],[[9907,9916],"valid",[],"NV8"],[[9917,9919],"valid",[],"NV8"],[[9920,9923],"valid",[],"NV8"],[[9924,9933],"valid",[],"NV8"],[[9934,9934],"valid",[],"NV8"],[[9935,9953],"valid",[],"NV8"],[[9954,9954],"valid",[],"NV8"],[[9955,9955],"valid",[],"NV8"],[[9956,9959],"valid",[],"NV8"],[[9960,9983],"valid",[],"NV8"],[[9984,9984],"valid",[],"NV8"],[[9985,9988],"valid",[],"NV8"],[[9989,9989],"valid",[],"NV8"],[[9990,9993],"valid",[],"NV8"],[[9994,9995],"valid",[],"NV8"],[[9996,10023],"valid",[],"NV8"],[[10024,10024],"valid",[],"NV8"],[[10025,10059],"valid",[],"NV8"],[[10060,10060],"valid",[],"NV8"],[[10061,10061],"valid",[],"NV8"],[[10062,10062],"valid",[],"NV8"],[[10063,10066],"valid",[],"NV8"],[[10067,10069],"valid",[],"NV8"],[[10070,10070],"valid",[],"NV8"],[[10071,10071],"valid",[],"NV8"],[[10072,10078],"valid",[],"NV8"],[[10079,10080],"valid",[],"NV8"],[[10081,10087],"valid",[],"NV8"],[[10088,10101],"valid",[],"NV8"],[[10102,10132],"valid",[],"NV8"],[[10133,10135],"valid",[],"NV8"],[[10136,10159],"valid",[],"NV8"],[[10160,10160],"valid",[],"NV8"],[[10161,10174],"valid",[],"NV8"],[[10175,10175],"valid",[],"NV8"],[[10176,10182],"valid",[],"NV8"],[[10183,10186],"valid",[],"NV8"],[[10187,10187],"valid",[],"NV8"],[[10188,10188],"valid",[],"NV8"],[[10189,10189],"valid",[],"NV8"],[[10190,10191],"valid",[],"NV8"],[[10192,10219],"valid",[],"NV8"],[[10220,10223],"valid",[],"NV8"],[[10224,10239],"valid",[],"NV8"],[[10240,10495],"valid",[],"NV8"],[[10496,10763],"valid",[],"NV8"],[[10764,10764],"mapped",[8747,8747,8747,8747]],[[10765,10867],"valid",[],"NV8"],[[10868,10868],"disallowed_STD3_mapped",[58,58,61]],[[10869,10869],"disallowed_STD3_mapped",[61,61]],[[10870,10870],"disallowed_STD3_mapped",[61,61,61]],[[10871,10971],"valid",[],"NV8"],[[10972,10972],"mapped",[10973,824]],[[10973,11007],"valid",[],"NV8"],[[11008,11021],"valid",[],"NV8"],[[11022,11027],"valid",[],"NV8"],[[11028,11034],"valid",[],"NV8"],[[11035,11039],"valid",[],"NV8"],[[11040,11043],"valid",[],"NV8"],[[11044,11084],"valid",[],"NV8"],[[11085,11087],"valid",[],"NV8"],[[11088,11092],"valid",[],"NV8"],[[11093,11097],"valid",[],"NV8"],[[11098,11123],"valid",[],"NV8"],[[11124,11125],"disallowed"],[[11126,11157],"valid",[],"NV8"],[[11158,11159],"disallowed"],[[11160,11193],"valid",[],"NV8"],[[11194,11196],"disallowed"],[[11197,11208],"valid",[],"NV8"],[[11209,11209],"disallowed"],[[11210,11217],"valid",[],"NV8"],[[11218,11243],"disallowed"],[[11244,11247],"valid",[],"NV8"],[[11248,11263],"disallowed"],[[11264,11264],"mapped",[11312]],[[11265,11265],"mapped",[11313]],[[11266,11266],"mapped",[11314]],[[11267,11267],"mapped",[11315]],[[11268,11268],"mapped",[11316]],[[11269,11269],"mapped",[11317]],[[11270,11270],"mapped",[11318]],[[11271,11271],"mapped",[11319]],[[11272,11272],"mapped",[11320]],[[11273,11273],"mapped",[11321]],[[11274,11274],"mapped",[11322]],[[11275,11275],"mapped",[11323]],[[11276,11276],"mapped",[11324]],[[11277,11277],"mapped",[11325]],[[11278,11278],"mapped",[11326]],[[11279,11279],"mapped",[11327]],[[11280,11280],"mapped",[11328]],[[11281,11281],"mapped",[11329]],[[11282,11282],"mapped",[11330]],[[11283,11283],"mapped",[11331]],[[11284,11284],"mapped",[11332]],[[11285,11285],"mapped",[11333]],[[11286,11286],"mapped",[11334]],[[11287,11287],"mapped",[11335]],[[11288,11288],"mapped",[11336]],[[11289,11289],"mapped",[11337]],[[11290,11290],"mapped",[11338]],[[11291,11291],"mapped",[11339]],[[11292,11292],"mapped",[11340]],[[11293,11293],"mapped",[11341]],[[11294,11294],"mapped",[11342]],[[11295,11295],"mapped",[11343]],[[11296,11296],"mapped",[11344]],[[11297,11297],"mapped",[11345]],[[11298,11298],"mapped",[11346]],[[11299,11299],"mapped",[11347]],[[11300,11300],"mapped",[11348]],[[11301,11301],"mapped",[11349]],[[11302,11302],"mapped",[11350]],[[11303,11303],"mapped",[11351]],[[11304,11304],"mapped",[11352]],[[11305,11305],"mapped",[11353]],[[11306,11306],"mapped",[11354]],[[11307,11307],"mapped",[11355]],[[11308,11308],"mapped",[11356]],[[11309,11309],"mapped",[11357]],[[11310,11310],"mapped",[11358]],[[11311,11311],"disallowed"],[[11312,11358],"valid"],[[11359,11359],"disallowed"],[[11360,11360],"mapped",[11361]],[[11361,11361],"valid"],[[11362,11362],"mapped",[619]],[[11363,11363],"mapped",[7549]],[[11364,11364],"mapped",[637]],[[11365,11366],"valid"],[[11367,11367],"mapped",[11368]],[[11368,11368],"valid"],[[11369,11369],"mapped",[11370]],[[11370,11370],"valid"],[[11371,11371],"mapped",[11372]],[[11372,11372],"valid"],[[11373,11373],"mapped",[593]],[[11374,11374],"mapped",[625]],[[11375,11375],"mapped",[592]],[[11376,11376],"mapped",[594]],[[11377,11377],"valid"],[[11378,11378],"mapped",[11379]],[[11379,11379],"valid"],[[11380,11380],"valid"],[[11381,11381],"mapped",[11382]],[[11382,11383],"valid"],[[11384,11387],"valid"],[[11388,11388],"mapped",[106]],[[11389,11389],"mapped",[118]],[[11390,11390],"mapped",[575]],[[11391,11391],"mapped",[576]],[[11392,11392],"mapped",[11393]],[[11393,11393],"valid"],[[11394,11394],"mapped",[11395]],[[11395,11395],"valid"],[[11396,11396],"mapped",[11397]],[[11397,11397],"valid"],[[11398,11398],"mapped",[11399]],[[11399,11399],"valid"],[[11400,11400],"mapped",[11401]],[[11401,11401],"valid"],[[11402,11402],"mapped",[11403]],[[11403,11403],"valid"],[[11404,11404],"mapped",[11405]],[[11405,11405],"valid"],[[11406,11406],"mapped",[11407]],[[11407,11407],"valid"],[[11408,11408],"mapped",[11409]],[[11409,11409],"valid"],[[11410,11410],"mapped",[11411]],[[11411,11411],"valid"],[[11412,11412],"mapped",[11413]],[[11413,11413],"valid"],[[11414,11414],"mapped",[11415]],[[11415,11415],"valid"],[[11416,11416],"mapped",[11417]],[[11417,11417],"valid"],[[11418,11418],"mapped",[11419]],[[11419,11419],"valid"],[[11420,11420],"mapped",[11421]],[[11421,11421],"valid"],[[11422,11422],"mapped",[11423]],[[11423,11423],"valid"],[[11424,11424],"mapped",[11425]],[[11425,11425],"valid"],[[11426,11426],"mapped",[11427]],[[11427,11427],"valid"],[[11428,11428],"mapped",[11429]],[[11429,11429],"valid"],[[11430,11430],"mapped",[11431]],[[11431,11431],"valid"],[[11432,11432],"mapped",[11433]],[[11433,11433],"valid"],[[11434,11434],"mapped",[11435]],[[11435,11435],"valid"],[[11436,11436],"mapped",[11437]],[[11437,11437],"valid"],[[11438,11438],"mapped",[11439]],[[11439,11439],"valid"],[[11440,11440],"mapped",[11441]],[[11441,11441],"valid"],[[11442,11442],"mapped",[11443]],[[11443,11443],"valid"],[[11444,11444],"mapped",[11445]],[[11445,11445],"valid"],[[11446,11446],"mapped",[11447]],[[11447,11447],"valid"],[[11448,11448],"mapped",[11449]],[[11449,11449],"valid"],[[11450,11450],"mapped",[11451]],[[11451,11451],"valid"],[[11452,11452],"mapped",[11453]],[[11453,11453],"valid"],[[11454,11454],"mapped",[11455]],[[11455,11455],"valid"],[[11456,11456],"mapped",[11457]],[[11457,11457],"valid"],[[11458,11458],"mapped",[11459]],[[11459,11459],"valid"],[[11460,11460],"mapped",[11461]],[[11461,11461],"valid"],[[11462,11462],"mapped",[11463]],[[11463,11463],"valid"],[[11464,11464],"mapped",[11465]],[[11465,11465],"valid"],[[11466,11466],"mapped",[11467]],[[11467,11467],"valid"],[[11468,11468],"mapped",[11469]],[[11469,11469],"valid"],[[11470,11470],"mapped",[11471]],[[11471,11471],"valid"],[[11472,11472],"mapped",[11473]],[[11473,11473],"valid"],[[11474,11474],"mapped",[11475]],[[11475,11475],"valid"],[[11476,11476],"mapped",[11477]],[[11477,11477],"valid"],[[11478,11478],"mapped",[11479]],[[11479,11479],"valid"],[[11480,11480],"mapped",[11481]],[[11481,11481],"valid"],[[11482,11482],"mapped",[11483]],[[11483,11483],"valid"],[[11484,11484],"mapped",[11485]],[[11485,11485],"valid"],[[11486,11486],"mapped",[11487]],[[11487,11487],"valid"],[[11488,11488],"mapped",[11489]],[[11489,11489],"valid"],[[11490,11490],"mapped",[11491]],[[11491,11492],"valid"],[[11493,11498],"valid",[],"NV8"],[[11499,11499],"mapped",[11500]],[[11500,11500],"valid"],[[11501,11501],"mapped",[11502]],[[11502,11505],"valid"],[[11506,11506],"mapped",[11507]],[[11507,11507],"valid"],[[11508,11512],"disallowed"],[[11513,11519],"valid",[],"NV8"],[[11520,11557],"valid"],[[11558,11558],"disallowed"],[[11559,11559],"valid"],[[11560,11564],"disallowed"],[[11565,11565],"valid"],[[11566,11567],"disallowed"],[[11568,11621],"valid"],[[11622,11623],"valid"],[[11624,11630],"disallowed"],[[11631,11631],"mapped",[11617]],[[11632,11632],"valid",[],"NV8"],[[11633,11646],"disallowed"],[[11647,11647],"valid"],[[11648,11670],"valid"],[[11671,11679],"disallowed"],[[11680,11686],"valid"],[[11687,11687],"disallowed"],[[11688,11694],"valid"],[[11695,11695],"disallowed"],[[11696,11702],"valid"],[[11703,11703],"disallowed"],[[11704,11710],"valid"],[[11711,11711],"disallowed"],[[11712,11718],"valid"],[[11719,11719],"disallowed"],[[11720,11726],"valid"],[[11727,11727],"disallowed"],[[11728,11734],"valid"],[[11735,11735],"disallowed"],[[11736,11742],"valid"],[[11743,11743],"disallowed"],[[11744,11775],"valid"],[[11776,11799],"valid",[],"NV8"],[[11800,11803],"valid",[],"NV8"],[[11804,11805],"valid",[],"NV8"],[[11806,11822],"valid",[],"NV8"],[[11823,11823],"valid"],[[11824,11824],"valid",[],"NV8"],[[11825,11825],"valid",[],"NV8"],[[11826,11835],"valid",[],"NV8"],[[11836,11842],"valid",[],"NV8"],[[11843,11903],"disallowed"],[[11904,11929],"valid",[],"NV8"],[[11930,11930],"disallowed"],[[11931,11934],"valid",[],"NV8"],[[11935,11935],"mapped",[27597]],[[11936,12018],"valid",[],"NV8"],[[12019,12019],"mapped",[40863]],[[12020,12031],"disallowed"],[[12032,12032],"mapped",[19968]],[[12033,12033],"mapped",[20008]],[[12034,12034],"mapped",[20022]],[[12035,12035],"mapped",[20031]],[[12036,12036],"mapped",[20057]],[[12037,12037],"mapped",[20101]],[[12038,12038],"mapped",[20108]],[[12039,12039],"mapped",[20128]],[[12040,12040],"mapped",[20154]],[[12041,12041],"mapped",[20799]],[[12042,12042],"mapped",[20837]],[[12043,12043],"mapped",[20843]],[[12044,12044],"mapped",[20866]],[[12045,12045],"mapped",[20886]],[[12046,12046],"mapped",[20907]],[[12047,12047],"mapped",[20960]],[[12048,12048],"mapped",[20981]],[[12049,12049],"mapped",[20992]],[[12050,12050],"mapped",[21147]],[[12051,12051],"mapped",[21241]],[[12052,12052],"mapped",[21269]],[[12053,12053],"mapped",[21274]],[[12054,12054],"mapped",[21304]],[[12055,12055],"mapped",[21313]],[[12056,12056],"mapped",[21340]],[[12057,12057],"mapped",[21353]],[[12058,12058],"mapped",[21378]],[[12059,12059],"mapped",[21430]],[[12060,12060],"mapped",[21448]],[[12061,12061],"mapped",[21475]],[[12062,12062],"mapped",[22231]],[[12063,12063],"mapped",[22303]],[[12064,12064],"mapped",[22763]],[[12065,12065],"mapped",[22786]],[[12066,12066],"mapped",[22794]],[[12067,12067],"mapped",[22805]],[[12068,12068],"mapped",[22823]],[[12069,12069],"mapped",[22899]],[[12070,12070],"mapped",[23376]],[[12071,12071],"mapped",[23424]],[[12072,12072],"mapped",[23544]],[[12073,12073],"mapped",[23567]],[[12074,12074],"mapped",[23586]],[[12075,12075],"mapped",[23608]],[[12076,12076],"mapped",[23662]],[[12077,12077],"mapped",[23665]],[[12078,12078],"mapped",[24027]],[[12079,12079],"mapped",[24037]],[[12080,12080],"mapped",[24049]],[[12081,12081],"mapped",[24062]],[[12082,12082],"mapped",[24178]],[[12083,12083],"mapped",[24186]],[[12084,12084],"mapped",[24191]],[[12085,12085],"mapped",[24308]],[[12086,12086],"mapped",[24318]],[[12087,12087],"mapped",[24331]],[[12088,12088],"mapped",[24339]],[[12089,12089],"mapped",[24400]],[[12090,12090],"mapped",[24417]],[[12091,12091],"mapped",[24435]],[[12092,12092],"mapped",[24515]],[[12093,12093],"mapped",[25096]],[[12094,12094],"mapped",[25142]],[[12095,12095],"mapped",[25163]],[[12096,12096],"mapped",[25903]],[[12097,12097],"mapped",[25908]],[[12098,12098],"mapped",[25991]],[[12099,12099],"mapped",[26007]],[[12100,12100],"mapped",[26020]],[[12101,12101],"mapped",[26041]],[[12102,12102],"mapped",[26080]],[[12103,12103],"mapped",[26085]],[[12104,12104],"mapped",[26352]],[[12105,12105],"mapped",[26376]],[[12106,12106],"mapped",[26408]],[[12107,12107],"mapped",[27424]],[[12108,12108],"mapped",[27490]],[[12109,12109],"mapped",[27513]],[[12110,12110],"mapped",[27571]],[[12111,12111],"mapped",[27595]],[[12112,12112],"mapped",[27604]],[[12113,12113],"mapped",[27611]],[[12114,12114],"mapped",[27663]],[[12115,12115],"mapped",[27668]],[[12116,12116],"mapped",[27700]],[[12117,12117],"mapped",[28779]],[[12118,12118],"mapped",[29226]],[[12119,12119],"mapped",[29238]],[[12120,12120],"mapped",[29243]],[[12121,12121],"mapped",[29247]],[[12122,12122],"mapped",[29255]],[[12123,12123],"mapped",[29273]],[[12124,12124],"mapped",[29275]],[[12125,12125],"mapped",[29356]],[[12126,12126],"mapped",[29572]],[[12127,12127],"mapped",[29577]],[[12128,12128],"mapped",[29916]],[[12129,12129],"mapped",[29926]],[[12130,12130],"mapped",[29976]],[[12131,12131],"mapped",[29983]],[[12132,12132],"mapped",[29992]],[[12133,12133],"mapped",[30000]],[[12134,12134],"mapped",[30091]],[[12135,12135],"mapped",[30098]],[[12136,12136],"mapped",[30326]],[[12137,12137],"mapped",[30333]],[[12138,12138],"mapped",[30382]],[[12139,12139],"mapped",[30399]],[[12140,12140],"mapped",[30446]],[[12141,12141],"mapped",[30683]],[[12142,12142],"mapped",[30690]],[[12143,12143],"mapped",[30707]],[[12144,12144],"mapped",[31034]],[[12145,12145],"mapped",[31160]],[[12146,12146],"mapped",[31166]],[[12147,12147],"mapped",[31348]],[[12148,12148],"mapped",[31435]],[[12149,12149],"mapped",[31481]],[[12150,12150],"mapped",[31859]],[[12151,12151],"mapped",[31992]],[[12152,12152],"mapped",[32566]],[[12153,12153],"mapped",[32593]],[[12154,12154],"mapped",[32650]],[[12155,12155],"mapped",[32701]],[[12156,12156],"mapped",[32769]],[[12157,12157],"mapped",[32780]],[[12158,12158],"mapped",[32786]],[[12159,12159],"mapped",[32819]],[[12160,12160],"mapped",[32895]],[[12161,12161],"mapped",[32905]],[[12162,12162],"mapped",[33251]],[[12163,12163],"mapped",[33258]],[[12164,12164],"mapped",[33267]],[[12165,12165],"mapped",[33276]],[[12166,12166],"mapped",[33292]],[[12167,12167],"mapped",[33307]],[[12168,12168],"mapped",[33311]],[[12169,12169],"mapped",[33390]],[[12170,12170],"mapped",[33394]],[[12171,12171],"mapped",[33400]],[[12172,12172],"mapped",[34381]],[[12173,12173],"mapped",[34411]],[[12174,12174],"mapped",[34880]],[[12175,12175],"mapped",[34892]],[[12176,12176],"mapped",[34915]],[[12177,12177],"mapped",[35198]],[[12178,12178],"mapped",[35211]],[[12179,12179],"mapped",[35282]],[[12180,12180],"mapped",[35328]],[[12181,12181],"mapped",[35895]],[[12182,12182],"mapped",[35910]],[[12183,12183],"mapped",[35925]],[[12184,12184],"mapped",[35960]],[[12185,12185],"mapped",[35997]],[[12186,12186],"mapped",[36196]],[[12187,12187],"mapped",[36208]],[[12188,12188],"mapped",[36275]],[[12189,12189],"mapped",[36523]],[[12190,12190],"mapped",[36554]],[[12191,12191],"mapped",[36763]],[[12192,12192],"mapped",[36784]],[[12193,12193],"mapped",[36789]],[[12194,12194],"mapped",[37009]],[[12195,12195],"mapped",[37193]],[[12196,12196],"mapped",[37318]],[[12197,12197],"mapped",[37324]],[[12198,12198],"mapped",[37329]],[[12199,12199],"mapped",[38263]],[[12200,12200],"mapped",[38272]],[[12201,12201],"mapped",[38428]],[[12202,12202],"mapped",[38582]],[[12203,12203],"mapped",[38585]],[[12204,12204],"mapped",[38632]],[[12205,12205],"mapped",[38737]],[[12206,12206],"mapped",[38750]],[[12207,12207],"mapped",[38754]],[[12208,12208],"mapped",[38761]],[[12209,12209],"mapped",[38859]],[[12210,12210],"mapped",[38893]],[[12211,12211],"mapped",[38899]],[[12212,12212],"mapped",[38913]],[[12213,12213],"mapped",[39080]],[[12214,12214],"mapped",[39131]],[[12215,12215],"mapped",[39135]],[[12216,12216],"mapped",[39318]],[[12217,12217],"mapped",[39321]],[[12218,12218],"mapped",[39340]],[[12219,12219],"mapped",[39592]],[[12220,12220],"mapped",[39640]],[[12221,12221],"mapped",[39647]],[[12222,12222],"mapped",[39717]],[[12223,12223],"mapped",[39727]],[[12224,12224],"mapped",[39730]],[[12225,12225],"mapped",[39740]],[[12226,12226],"mapped",[39770]],[[12227,12227],"mapped",[40165]],[[12228,12228],"mapped",[40565]],[[12229,12229],"mapped",[40575]],[[12230,12230],"mapped",[40613]],[[12231,12231],"mapped",[40635]],[[12232,12232],"mapped",[40643]],[[12233,12233],"mapped",[40653]],[[12234,12234],"mapped",[40657]],[[12235,12235],"mapped",[40697]],[[12236,12236],"mapped",[40701]],[[12237,12237],"mapped",[40718]],[[12238,12238],"mapped",[40723]],[[12239,12239],"mapped",[40736]],[[12240,12240],"mapped",[40763]],[[12241,12241],"mapped",[40778]],[[12242,12242],"mapped",[40786]],[[12243,12243],"mapped",[40845]],[[12244,12244],"mapped",[40860]],[[12245,12245],"mapped",[40864]],[[12246,12271],"disallowed"],[[12272,12283],"disallowed"],[[12284,12287],"disallowed"],[[12288,12288],"disallowed_STD3_mapped",[32]],[[12289,12289],"valid",[],"NV8"],[[12290,12290],"mapped",[46]],[[12291,12292],"valid",[],"NV8"],[[12293,12295],"valid"],[[12296,12329],"valid",[],"NV8"],[[12330,12333],"valid"],[[12334,12341],"valid",[],"NV8"],[[12342,12342],"mapped",[12306]],[[12343,12343],"valid",[],"NV8"],[[12344,12344],"mapped",[21313]],[[12345,12345],"mapped",[21316]],[[12346,12346],"mapped",[21317]],[[12347,12347],"valid",[],"NV8"],[[12348,12348],"valid"],[[12349,12349],"valid",[],"NV8"],[[12350,12350],"valid",[],"NV8"],[[12351,12351],"valid",[],"NV8"],[[12352,12352],"disallowed"],[[12353,12436],"valid"],[[12437,12438],"valid"],[[12439,12440],"disallowed"],[[12441,12442],"valid"],[[12443,12443],"disallowed_STD3_mapped",[32,12441]],[[12444,12444],"disallowed_STD3_mapped",[32,12442]],[[12445,12446],"valid"],[[12447,12447],"mapped",[12424,12426]],[[12448,12448],"valid",[],"NV8"],[[12449,12542],"valid"],[[12543,12543],"mapped",[12467,12488]],[[12544,12548],"disallowed"],[[12549,12588],"valid"],[[12589,12589],"valid"],[[12590,12592],"disallowed"],[[12593,12593],"mapped",[4352]],[[12594,12594],"mapped",[4353]],[[12595,12595],"mapped",[4522]],[[12596,12596],"mapped",[4354]],[[12597,12597],"mapped",[4524]],[[12598,12598],"mapped",[4525]],[[12599,12599],"mapped",[4355]],[[12600,12600],"mapped",[4356]],[[12601,12601],"mapped",[4357]],[[12602,12602],"mapped",[4528]],[[12603,12603],"mapped",[4529]],[[12604,12604],"mapped",[4530]],[[12605,12605],"mapped",[4531]],[[12606,12606],"mapped",[4532]],[[12607,12607],"mapped",[4533]],[[12608,12608],"mapped",[4378]],[[12609,12609],"mapped",[4358]],[[12610,12610],"mapped",[4359]],[[12611,12611],"mapped",[4360]],[[12612,12612],"mapped",[4385]],[[12613,12613],"mapped",[4361]],[[12614,12614],"mapped",[4362]],[[12615,12615],"mapped",[4363]],[[12616,12616],"mapped",[4364]],[[12617,12617],"mapped",[4365]],[[12618,12618],"mapped",[4366]],[[12619,12619],"mapped",[4367]],[[12620,12620],"mapped",[4368]],[[12621,12621],"mapped",[4369]],[[12622,12622],"mapped",[4370]],[[12623,12623],"mapped",[4449]],[[12624,12624],"mapped",[4450]],[[12625,12625],"mapped",[4451]],[[12626,12626],"mapped",[4452]],[[12627,12627],"mapped",[4453]],[[12628,12628],"mapped",[4454]],[[12629,12629],"mapped",[4455]],[[12630,12630],"mapped",[4456]],[[12631,12631],"mapped",[4457]],[[12632,12632],"mapped",[4458]],[[12633,12633],"mapped",[4459]],[[12634,12634],"mapped",[4460]],[[12635,12635],"mapped",[4461]],[[12636,12636],"mapped",[4462]],[[12637,12637],"mapped",[4463]],[[12638,12638],"mapped",[4464]],[[12639,12639],"mapped",[4465]],[[12640,12640],"mapped",[4466]],[[12641,12641],"mapped",[4467]],[[12642,12642],"mapped",[4468]],[[12643,12643],"mapped",[4469]],[[12644,12644],"disallowed"],[[12645,12645],"mapped",[4372]],[[12646,12646],"mapped",[4373]],[[12647,12647],"mapped",[4551]],[[12648,12648],"mapped",[4552]],[[12649,12649],"mapped",[4556]],[[12650,12650],"mapped",[4558]],[[12651,12651],"mapped",[4563]],[[12652,12652],"mapped",[4567]],[[12653,12653],"mapped",[4569]],[[12654,12654],"mapped",[4380]],[[12655,12655],"mapped",[4573]],[[12656,12656],"mapped",[4575]],[[12657,12657],"mapped",[4381]],[[12658,12658],"mapped",[4382]],[[12659,12659],"mapped",[4384]],[[12660,12660],"mapped",[4386]],[[12661,12661],"mapped",[4387]],[[12662,12662],"mapped",[4391]],[[12663,12663],"mapped",[4393]],[[12664,12664],"mapped",[4395]],[[12665,12665],"mapped",[4396]],[[12666,12666],"mapped",[4397]],[[12667,12667],"mapped",[4398]],[[12668,12668],"mapped",[4399]],[[12669,12669],"mapped",[4402]],[[12670,12670],"mapped",[4406]],[[12671,12671],"mapped",[4416]],[[12672,12672],"mapped",[4423]],[[12673,12673],"mapped",[4428]],[[12674,12674],"mapped",[4593]],[[12675,12675],"mapped",[4594]],[[12676,12676],"mapped",[4439]],[[12677,12677],"mapped",[4440]],[[12678,12678],"mapped",[4441]],[[12679,12679],"mapped",[4484]],[[12680,12680],"mapped",[4485]],[[12681,12681],"mapped",[4488]],[[12682,12682],"mapped",[4497]],[[12683,12683],"mapped",[4498]],[[12684,12684],"mapped",[4500]],[[12685,12685],"mapped",[4510]],[[12686,12686],"mapped",[4513]],[[12687,12687],"disallowed"],[[12688,12689],"valid",[],"NV8"],[[12690,12690],"mapped",[19968]],[[12691,12691],"mapped",[20108]],[[12692,12692],"mapped",[19977]],[[12693,12693],"mapped",[22235]],[[12694,12694],"mapped",[19978]],[[12695,12695],"mapped",[20013]],[[12696,12696],"mapped",[19979]],[[12697,12697],"mapped",[30002]],[[12698,12698],"mapped",[20057]],[[12699,12699],"mapped",[19993]],[[12700,12700],"mapped",[19969]],[[12701,12701],"mapped",[22825]],[[12702,12702],"mapped",[22320]],[[12703,12703],"mapped",[20154]],[[12704,12727],"valid"],[[12728,12730],"valid"],[[12731,12735],"disallowed"],[[12736,12751],"valid",[],"NV8"],[[12752,12771],"valid",[],"NV8"],[[12772,12783],"disallowed"],[[12784,12799],"valid"],[[12800,12800],"disallowed_STD3_mapped",[40,4352,41]],[[12801,12801],"disallowed_STD3_mapped",[40,4354,41]],[[12802,12802],"disallowed_STD3_mapped",[40,4355,41]],[[12803,12803],"disallowed_STD3_mapped",[40,4357,41]],[[12804,12804],"disallowed_STD3_mapped",[40,4358,41]],[[12805,12805],"disallowed_STD3_mapped",[40,4359,41]],[[12806,12806],"disallowed_STD3_mapped",[40,4361,41]],[[12807,12807],"disallowed_STD3_mapped",[40,4363,41]],[[12808,12808],"disallowed_STD3_mapped",[40,4364,41]],[[12809,12809],"disallowed_STD3_mapped",[40,4366,41]],[[12810,12810],"disallowed_STD3_mapped",[40,4367,41]],[[12811,12811],"disallowed_STD3_mapped",[40,4368,41]],[[12812,12812],"disallowed_STD3_mapped",[40,4369,41]],[[12813,12813],"disallowed_STD3_mapped",[40,4370,41]],[[12814,12814],"disallowed_STD3_mapped",[40,44032,41]],[[12815,12815],"disallowed_STD3_mapped",[40,45208,41]],[[12816,12816],"disallowed_STD3_mapped",[40,45796,41]],[[12817,12817],"disallowed_STD3_mapped",[40,46972,41]],[[12818,12818],"disallowed_STD3_mapped",[40,47560,41]],[[12819,12819],"disallowed_STD3_mapped",[40,48148,41]],[[12820,12820],"disallowed_STD3_mapped",[40,49324,41]],[[12821,12821],"disallowed_STD3_mapped",[40,50500,41]],[[12822,12822],"disallowed_STD3_mapped",[40,51088,41]],[[12823,12823],"disallowed_STD3_mapped",[40,52264,41]],[[12824,12824],"disallowed_STD3_mapped",[40,52852,41]],[[12825,12825],"disallowed_STD3_mapped",[40,53440,41]],[[12826,12826],"disallowed_STD3_mapped",[40,54028,41]],[[12827,12827],"disallowed_STD3_mapped",[40,54616,41]],[[12828,12828],"disallowed_STD3_mapped",[40,51452,41]],[[12829,12829],"disallowed_STD3_mapped",[40,50724,51204,41]],[[12830,12830],"disallowed_STD3_mapped",[40,50724,54980,41]],[[12831,12831],"disallowed"],[[12832,12832],"disallowed_STD3_mapped",[40,19968,41]],[[12833,12833],"disallowed_STD3_mapped",[40,20108,41]],[[12834,12834],"disallowed_STD3_mapped",[40,19977,41]],[[12835,12835],"disallowed_STD3_mapped",[40,22235,41]],[[12836,12836],"disallowed_STD3_mapped",[40,20116,41]],[[12837,12837],"disallowed_STD3_mapped",[40,20845,41]],[[12838,12838],"disallowed_STD3_mapped",[40,19971,41]],[[12839,12839],"disallowed_STD3_mapped",[40,20843,41]],[[12840,12840],"disallowed_STD3_mapped",[40,20061,41]],[[12841,12841],"disallowed_STD3_mapped",[40,21313,41]],[[12842,12842],"disallowed_STD3_mapped",[40,26376,41]],[[12843,12843],"disallowed_STD3_mapped",[40,28779,41]],[[12844,12844],"disallowed_STD3_mapped",[40,27700,41]],[[12845,12845],"disallowed_STD3_mapped",[40,26408,41]],[[12846,12846],"disallowed_STD3_mapped",[40,37329,41]],[[12847,12847],"disallowed_STD3_mapped",[40,22303,41]],[[12848,12848],"disallowed_STD3_mapped",[40,26085,41]],[[12849,12849],"disallowed_STD3_mapped",[40,26666,41]],[[12850,12850],"disallowed_STD3_mapped",[40,26377,41]],[[12851,12851],"disallowed_STD3_mapped",[40,31038,41]],[[12852,12852],"disallowed_STD3_mapped",[40,21517,41]],[[12853,12853],"disallowed_STD3_mapped",[40,29305,41]],[[12854,12854],"disallowed_STD3_mapped",[40,36001,41]],[[12855,12855],"disallowed_STD3_mapped",[40,31069,41]],[[12856,12856],"disallowed_STD3_mapped",[40,21172,41]],[[12857,12857],"disallowed_STD3_mapped",[40,20195,41]],[[12858,12858],"disallowed_STD3_mapped",[40,21628,41]],[[12859,12859],"disallowed_STD3_mapped",[40,23398,41]],[[12860,12860],"disallowed_STD3_mapped",[40,30435,41]],[[12861,12861],"disallowed_STD3_mapped",[40,20225,41]],[[12862,12862],"disallowed_STD3_mapped",[40,36039,41]],[[12863,12863],"disallowed_STD3_mapped",[40,21332,41]],[[12864,12864],"disallowed_STD3_mapped",[40,31085,41]],[[12865,12865],"disallowed_STD3_mapped",[40,20241,41]],[[12866,12866],"disallowed_STD3_mapped",[40,33258,41]],[[12867,12867],"disallowed_STD3_mapped",[40,33267,41]],[[12868,12868],"mapped",[21839]],[[12869,12869],"mapped",[24188]],[[12870,12870],"mapped",[25991]],[[12871,12871],"mapped",[31631]],[[12872,12879],"valid",[],"NV8"],[[12880,12880],"mapped",[112,116,101]],[[12881,12881],"mapped",[50,49]],[[12882,12882],"mapped",[50,50]],[[12883,12883],"mapped",[50,51]],[[12884,12884],"mapped",[50,52]],[[12885,12885],"mapped",[50,53]],[[12886,12886],"mapped",[50,54]],[[12887,12887],"mapped",[50,55]],[[12888,12888],"mapped",[50,56]],[[12889,12889],"mapped",[50,57]],[[12890,12890],"mapped",[51,48]],[[12891,12891],"mapped",[51,49]],[[12892,12892],"mapped",[51,50]],[[12893,12893],"mapped",[51,51]],[[12894,12894],"mapped",[51,52]],[[12895,12895],"mapped",[51,53]],[[12896,12896],"mapped",[4352]],[[12897,12897],"mapped",[4354]],[[12898,12898],"mapped",[4355]],[[12899,12899],"mapped",[4357]],[[12900,12900],"mapped",[4358]],[[12901,12901],"mapped",[4359]],[[12902,12902],"mapped",[4361]],[[12903,12903],"mapped",[4363]],[[12904,12904],"mapped",[4364]],[[12905,12905],"mapped",[4366]],[[12906,12906],"mapped",[4367]],[[12907,12907],"mapped",[4368]],[[12908,12908],"mapped",[4369]],[[12909,12909],"mapped",[4370]],[[12910,12910],"mapped",[44032]],[[12911,12911],"mapped",[45208]],[[12912,12912],"mapped",[45796]],[[12913,12913],"mapped",[46972]],[[12914,12914],"mapped",[47560]],[[12915,12915],"mapped",[48148]],[[12916,12916],"mapped",[49324]],[[12917,12917],"mapped",[50500]],[[12918,12918],"mapped",[51088]],[[12919,12919],"mapped",[52264]],[[12920,12920],"mapped",[52852]],[[12921,12921],"mapped",[53440]],[[12922,12922],"mapped",[54028]],[[12923,12923],"mapped",[54616]],[[12924,12924],"mapped",[52280,44256]],[[12925,12925],"mapped",[51452,51032]],[[12926,12926],"mapped",[50864]],[[12927,12927],"valid",[],"NV8"],[[12928,12928],"mapped",[19968]],[[12929,12929],"mapped",[20108]],[[12930,12930],"mapped",[19977]],[[12931,12931],"mapped",[22235]],[[12932,12932],"mapped",[20116]],[[12933,12933],"mapped",[20845]],[[12934,12934],"mapped",[19971]],[[12935,12935],"mapped",[20843]],[[12936,12936],"mapped",[20061]],[[12937,12937],"mapped",[21313]],[[12938,12938],"mapped",[26376]],[[12939,12939],"mapped",[28779]],[[12940,12940],"mapped",[27700]],[[12941,12941],"mapped",[26408]],[[12942,12942],"mapped",[37329]],[[12943,12943],"mapped",[22303]],[[12944,12944],"mapped",[26085]],[[12945,12945],"mapped",[26666]],[[12946,12946],"mapped",[26377]],[[12947,12947],"mapped",[31038]],[[12948,12948],"mapped",[21517]],[[12949,12949],"mapped",[29305]],[[12950,12950],"mapped",[36001]],[[12951,12951],"mapped",[31069]],[[12952,12952],"mapped",[21172]],[[12953,12953],"mapped",[31192]],[[12954,12954],"mapped",[30007]],[[12955,12955],"mapped",[22899]],[[12956,12956],"mapped",[36969]],[[12957,12957],"mapped",[20778]],[[12958,12958],"mapped",[21360]],[[12959,12959],"mapped",[27880]],[[12960,12960],"mapped",[38917]],[[12961,12961],"mapped",[20241]],[[12962,12962],"mapped",[20889]],[[12963,12963],"mapped",[27491]],[[12964,12964],"mapped",[19978]],[[12965,12965],"mapped",[20013]],[[12966,12966],"mapped",[19979]],[[12967,12967],"mapped",[24038]],[[12968,12968],"mapped",[21491]],[[12969,12969],"mapped",[21307]],[[12970,12970],"mapped",[23447]],[[12971,12971],"mapped",[23398]],[[12972,12972],"mapped",[30435]],[[12973,12973],"mapped",[20225]],[[12974,12974],"mapped",[36039]],[[12975,12975],"mapped",[21332]],[[12976,12976],"mapped",[22812]],[[12977,12977],"mapped",[51,54]],[[12978,12978],"mapped",[51,55]],[[12979,12979],"mapped",[51,56]],[[12980,12980],"mapped",[51,57]],[[12981,12981],"mapped",[52,48]],[[12982,12982],"mapped",[52,49]],[[12983,12983],"mapped",[52,50]],[[12984,12984],"mapped",[52,51]],[[12985,12985],"mapped",[52,52]],[[12986,12986],"mapped",[52,53]],[[12987,12987],"mapped",[52,54]],[[12988,12988],"mapped",[52,55]],[[12989,12989],"mapped",[52,56]],[[12990,12990],"mapped",[52,57]],[[12991,12991],"mapped",[53,48]],[[12992,12992],"mapped",[49,26376]],[[12993,12993],"mapped",[50,26376]],[[12994,12994],"mapped",[51,26376]],[[12995,12995],"mapped",[52,26376]],[[12996,12996],"mapped",[53,26376]],[[12997,12997],"mapped",[54,26376]],[[12998,12998],"mapped",[55,26376]],[[12999,12999],"mapped",[56,26376]],[[13000,13000],"mapped",[57,26376]],[[13001,13001],"mapped",[49,48,26376]],[[13002,13002],"mapped",[49,49,26376]],[[13003,13003],"mapped",[49,50,26376]],[[13004,13004],"mapped",[104,103]],[[13005,13005],"mapped",[101,114,103]],[[13006,13006],"mapped",[101,118]],[[13007,13007],"mapped",[108,116,100]],[[13008,13008],"mapped",[12450]],[[13009,13009],"mapped",[12452]],[[13010,13010],"mapped",[12454]],[[13011,13011],"mapped",[12456]],[[13012,13012],"mapped",[12458]],[[13013,13013],"mapped",[12459]],[[13014,13014],"mapped",[12461]],[[13015,13015],"mapped",[12463]],[[13016,13016],"mapped",[12465]],[[13017,13017],"mapped",[12467]],[[13018,13018],"mapped",[12469]],[[13019,13019],"mapped",[12471]],[[13020,13020],"mapped",[12473]],[[13021,13021],"mapped",[12475]],[[13022,13022],"mapped",[12477]],[[13023,13023],"mapped",[12479]],[[13024,13024],"mapped",[12481]],[[13025,13025],"mapped",[12484]],[[13026,13026],"mapped",[12486]],[[13027,13027],"mapped",[12488]],[[13028,13028],"mapped",[12490]],[[13029,13029],"mapped",[12491]],[[13030,13030],"mapped",[12492]],[[13031,13031],"mapped",[12493]],[[13032,13032],"mapped",[12494]],[[13033,13033],"mapped",[12495]],[[13034,13034],"mapped",[12498]],[[13035,13035],"mapped",[12501]],[[13036,13036],"mapped",[12504]],[[13037,13037],"mapped",[12507]],[[13038,13038],"mapped",[12510]],[[13039,13039],"mapped",[12511]],[[13040,13040],"mapped",[12512]],[[13041,13041],"mapped",[12513]],[[13042,13042],"mapped",[12514]],[[13043,13043],"mapped",[12516]],[[13044,13044],"mapped",[12518]],[[13045,13045],"mapped",[12520]],[[13046,13046],"mapped",[12521]],[[13047,13047],"mapped",[12522]],[[13048,13048],"mapped",[12523]],[[13049,13049],"mapped",[12524]],[[13050,13050],"mapped",[12525]],[[13051,13051],"mapped",[12527]],[[13052,13052],"mapped",[12528]],[[13053,13053],"mapped",[12529]],[[13054,13054],"mapped",[12530]],[[13055,13055],"disallowed"],[[13056,13056],"mapped",[12450,12497,12540,12488]],[[13057,13057],"mapped",[12450,12523,12501,12449]],[[13058,13058],"mapped",[12450,12531,12506,12450]],[[13059,13059],"mapped",[12450,12540,12523]],[[13060,13060],"mapped",[12452,12491,12531,12464]],[[13061,13061],"mapped",[12452,12531,12481]],[[13062,13062],"mapped",[12454,12457,12531]],[[13063,13063],"mapped",[12456,12473,12463,12540,12489]],[[13064,13064],"mapped",[12456,12540,12459,12540]],[[13065,13065],"mapped",[12458,12531,12473]],[[13066,13066],"mapped",[12458,12540,12512]],[[13067,13067],"mapped",[12459,12452,12522]],[[13068,13068],"mapped",[12459,12521,12483,12488]],[[13069,13069],"mapped",[12459,12525,12522,12540]],[[13070,13070],"mapped",[12460,12525,12531]],[[13071,13071],"mapped",[12460,12531,12510]],[[13072,13072],"mapped",[12462,12460]],[[13073,13073],"mapped",[12462,12491,12540]],[[13074,13074],"mapped",[12461,12517,12522,12540]],[[13075,13075],"mapped",[12462,12523,12480,12540]],[[13076,13076],"mapped",[12461,12525]],[[13077,13077],"mapped",[12461,12525,12464,12521,12512]],[[13078,13078],"mapped",[12461,12525,12513,12540,12488,12523]],[[13079,13079],"mapped",[12461,12525,12527,12483,12488]],[[13080,13080],"mapped",[12464,12521,12512]],[[13081,13081],"mapped",[12464,12521,12512,12488,12531]],[[13082,13082],"mapped",[12463,12523,12476,12452,12525]],[[13083,13083],"mapped",[12463,12525,12540,12493]],[[13084,13084],"mapped",[12465,12540,12473]],[[13085,13085],"mapped",[12467,12523,12490]],[[13086,13086],"mapped",[12467,12540,12509]],[[13087,13087],"mapped",[12469,12452,12463,12523]],[[13088,13088],"mapped",[12469,12531,12481,12540,12512]],[[13089,13089],"mapped",[12471,12522,12531,12464]],[[13090,13090],"mapped",[12475,12531,12481]],[[13091,13091],"mapped",[12475,12531,12488]],[[13092,13092],"mapped",[12480,12540,12473]],[[13093,13093],"mapped",[12487,12471]],[[13094,13094],"mapped",[12489,12523]],[[13095,13095],"mapped",[12488,12531]],[[13096,13096],"mapped",[12490,12494]],[[13097,13097],"mapped",[12494,12483,12488]],[[13098,13098],"mapped",[12495,12452,12484]],[[13099,13099],"mapped",[12497,12540,12475,12531,12488]],[[13100,13100],"mapped",[12497,12540,12484]],[[13101,13101],"mapped",[12496,12540,12524,12523]],[[13102,13102],"mapped",[12500,12450,12473,12488,12523]],[[13103,13103],"mapped",[12500,12463,12523]],[[13104,13104],"mapped",[12500,12467]],[[13105,13105],"mapped",[12499,12523]],[[13106,13106],"mapped",[12501,12449,12521,12483,12489]],[[13107,13107],"mapped",[12501,12451,12540,12488]],[[13108,13108],"mapped",[12502,12483,12471,12455,12523]],[[13109,13109],"mapped",[12501,12521,12531]],[[13110,13110],"mapped",[12504,12463,12479,12540,12523]],[[13111,13111],"mapped",[12506,12477]],[[13112,13112],"mapped",[12506,12491,12498]],[[13113,13113],"mapped",[12504,12523,12484]],[[13114,13114],"mapped",[12506,12531,12473]],[[13115,13115],"mapped",[12506,12540,12472]],[[13116,13116],"mapped",[12505,12540,12479]],[[13117,13117],"mapped",[12509,12452,12531,12488]],[[13118,13118],"mapped",[12508,12523,12488]],[[13119,13119],"mapped",[12507,12531]],[[13120,13120],"mapped",[12509,12531,12489]],[[13121,13121],"mapped",[12507,12540,12523]],[[13122,13122],"mapped",[12507,12540,12531]],[[13123,13123],"mapped",[12510,12452,12463,12525]],[[13124,13124],"mapped",[12510,12452,12523]],[[13125,13125],"mapped",[12510,12483,12495]],[[13126,13126],"mapped",[12510,12523,12463]],[[13127,13127],"mapped",[12510,12531,12471,12519,12531]],[[13128,13128],"mapped",[12511,12463,12525,12531]],[[13129,13129],"mapped",[12511,12522]],[[13130,13130],"mapped",[12511,12522,12496,12540,12523]],[[13131,13131],"mapped",[12513,12460]],[[13132,13132],"mapped",[12513,12460,12488,12531]],[[13133,13133],"mapped",[12513,12540,12488,12523]],[[13134,13134],"mapped",[12516,12540,12489]],[[13135,13135],"mapped",[12516,12540,12523]],[[13136,13136],"mapped",[12518,12450,12531]],[[13137,13137],"mapped",[12522,12483,12488,12523]],[[13138,13138],"mapped",[12522,12521]],[[13139,13139],"mapped",[12523,12500,12540]],[[13140,13140],"mapped",[12523,12540,12502,12523]],[[13141,13141],"mapped",[12524,12512]],[[13142,13142],"mapped",[12524,12531,12488,12466,12531]],[[13143,13143],"mapped",[12527,12483,12488]],[[13144,13144],"mapped",[48,28857]],[[13145,13145],"mapped",[49,28857]],[[13146,13146],"mapped",[50,28857]],[[13147,13147],"mapped",[51,28857]],[[13148,13148],"mapped",[52,28857]],[[13149,13149],"mapped",[53,28857]],[[13150,13150],"mapped",[54,28857]],[[13151,13151],"mapped",[55,28857]],[[13152,13152],"mapped",[56,28857]],[[13153,13153],"mapped",[57,28857]],[[13154,13154],"mapped",[49,48,28857]],[[13155,13155],"mapped",[49,49,28857]],[[13156,13156],"mapped",[49,50,28857]],[[13157,13157],"mapped",[49,51,28857]],[[13158,13158],"mapped",[49,52,28857]],[[13159,13159],"mapped",[49,53,28857]],[[13160,13160],"mapped",[49,54,28857]],[[13161,13161],"mapped",[49,55,28857]],[[13162,13162],"mapped",[49,56,28857]],[[13163,13163],"mapped",[49,57,28857]],[[13164,13164],"mapped",[50,48,28857]],[[13165,13165],"mapped",[50,49,28857]],[[13166,13166],"mapped",[50,50,28857]],[[13167,13167],"mapped",[50,51,28857]],[[13168,13168],"mapped",[50,52,28857]],[[13169,13169],"mapped",[104,112,97]],[[13170,13170],"mapped",[100,97]],[[13171,13171],"mapped",[97,117]],[[13172,13172],"mapped",[98,97,114]],[[13173,13173],"mapped",[111,118]],[[13174,13174],"mapped",[112,99]],[[13175,13175],"mapped",[100,109]],[[13176,13176],"mapped",[100,109,50]],[[13177,13177],"mapped",[100,109,51]],[[13178,13178],"mapped",[105,117]],[[13179,13179],"mapped",[24179,25104]],[[13180,13180],"mapped",[26157,21644]],[[13181,13181],"mapped",[22823,27491]],[[13182,13182],"mapped",[26126,27835]],[[13183,13183],"mapped",[26666,24335,20250,31038]],[[13184,13184],"mapped",[112,97]],[[13185,13185],"mapped",[110,97]],[[13186,13186],"mapped",[956,97]],[[13187,13187],"mapped",[109,97]],[[13188,13188],"mapped",[107,97]],[[13189,13189],"mapped",[107,98]],[[13190,13190],"mapped",[109,98]],[[13191,13191],"mapped",[103,98]],[[13192,13192],"mapped",[99,97,108]],[[13193,13193],"mapped",[107,99,97,108]],[[13194,13194],"mapped",[112,102]],[[13195,13195],"mapped",[110,102]],[[13196,13196],"mapped",[956,102]],[[13197,13197],"mapped",[956,103]],[[13198,13198],"mapped",[109,103]],[[13199,13199],"mapped",[107,103]],[[13200,13200],"mapped",[104,122]],[[13201,13201],"mapped",[107,104,122]],[[13202,13202],"mapped",[109,104,122]],[[13203,13203],"mapped",[103,104,122]],[[13204,13204],"mapped",[116,104,122]],[[13205,13205],"mapped",[956,108]],[[13206,13206],"mapped",[109,108]],[[13207,13207],"mapped",[100,108]],[[13208,13208],"mapped",[107,108]],[[13209,13209],"mapped",[102,109]],[[13210,13210],"mapped",[110,109]],[[13211,13211],"mapped",[956,109]],[[13212,13212],"mapped",[109,109]],[[13213,13213],"mapped",[99,109]],[[13214,13214],"mapped",[107,109]],[[13215,13215],"mapped",[109,109,50]],[[13216,13216],"mapped",[99,109,50]],[[13217,13217],"mapped",[109,50]],[[13218,13218],"mapped",[107,109,50]],[[13219,13219],"mapped",[109,109,51]],[[13220,13220],"mapped",[99,109,51]],[[13221,13221],"mapped",[109,51]],[[13222,13222],"mapped",[107,109,51]],[[13223,13223],"mapped",[109,8725,115]],[[13224,13224],"mapped",[109,8725,115,50]],[[13225,13225],"mapped",[112,97]],[[13226,13226],"mapped",[107,112,97]],[[13227,13227],"mapped",[109,112,97]],[[13228,13228],"mapped",[103,112,97]],[[13229,13229],"mapped",[114,97,100]],[[13230,13230],"mapped",[114,97,100,8725,115]],[[13231,13231],"mapped",[114,97,100,8725,115,50]],[[13232,13232],"mapped",[112,115]],[[13233,13233],"mapped",[110,115]],[[13234,13234],"mapped",[956,115]],[[13235,13235],"mapped",[109,115]],[[13236,13236],"mapped",[112,118]],[[13237,13237],"mapped",[110,118]],[[13238,13238],"mapped",[956,118]],[[13239,13239],"mapped",[109,118]],[[13240,13240],"mapped",[107,118]],[[13241,13241],"mapped",[109,118]],[[13242,13242],"mapped",[112,119]],[[13243,13243],"mapped",[110,119]],[[13244,13244],"mapped",[956,119]],[[13245,13245],"mapped",[109,119]],[[13246,13246],"mapped",[107,119]],[[13247,13247],"mapped",[109,119]],[[13248,13248],"mapped",[107,969]],[[13249,13249],"mapped",[109,969]],[[13250,13250],"disallowed"],[[13251,13251],"mapped",[98,113]],[[13252,13252],"mapped",[99,99]],[[13253,13253],"mapped",[99,100]],[[13254,13254],"mapped",[99,8725,107,103]],[[13255,13255],"disallowed"],[[13256,13256],"mapped",[100,98]],[[13257,13257],"mapped",[103,121]],[[13258,13258],"mapped",[104,97]],[[13259,13259],"mapped",[104,112]],[[13260,13260],"mapped",[105,110]],[[13261,13261],"mapped",[107,107]],[[13262,13262],"mapped",[107,109]],[[13263,13263],"mapped",[107,116]],[[13264,13264],"mapped",[108,109]],[[13265,13265],"mapped",[108,110]],[[13266,13266],"mapped",[108,111,103]],[[13267,13267],"mapped",[108,120]],[[13268,13268],"mapped",[109,98]],[[13269,13269],"mapped",[109,105,108]],[[13270,13270],"mapped",[109,111,108]],[[13271,13271],"mapped",[112,104]],[[13272,13272],"disallowed"],[[13273,13273],"mapped",[112,112,109]],[[13274,13274],"mapped",[112,114]],[[13275,13275],"mapped",[115,114]],[[13276,13276],"mapped",[115,118]],[[13277,13277],"mapped",[119,98]],[[13278,13278],"mapped",[118,8725,109]],[[13279,13279],"mapped",[97,8725,109]],[[13280,13280],"mapped",[49,26085]],[[13281,13281],"mapped",[50,26085]],[[13282,13282],"mapped",[51,26085]],[[13283,13283],"mapped",[52,26085]],[[13284,13284],"mapped",[53,26085]],[[13285,13285],"mapped",[54,26085]],[[13286,13286],"mapped",[55,26085]],[[13287,13287],"mapped",[56,26085]],[[13288,13288],"mapped",[57,26085]],[[13289,13289],"mapped",[49,48,26085]],[[13290,13290],"mapped",[49,49,26085]],[[13291,13291],"mapped",[49,50,26085]],[[13292,13292],"mapped",[49,51,26085]],[[13293,13293],"mapped",[49,52,26085]],[[13294,13294],"mapped",[49,53,26085]],[[13295,13295],"mapped",[49,54,26085]],[[13296,13296],"mapped",[49,55,26085]],[[13297,13297],"mapped",[49,56,26085]],[[13298,13298],"mapped",[49,57,26085]],[[13299,13299],"mapped",[50,48,26085]],[[13300,13300],"mapped",[50,49,26085]],[[13301,13301],"mapped",[50,50,26085]],[[13302,13302],"mapped",[50,51,26085]],[[13303,13303],"mapped",[50,52,26085]],[[13304,13304],"mapped",[50,53,26085]],[[13305,13305],"mapped",[50,54,26085]],[[13306,13306],"mapped",[50,55,26085]],[[13307,13307],"mapped",[50,56,26085]],[[13308,13308],"mapped",[50,57,26085]],[[13309,13309],"mapped",[51,48,26085]],[[13310,13310],"mapped",[51,49,26085]],[[13311,13311],"mapped",[103,97,108]],[[13312,19893],"valid"],[[19894,19903],"disallowed"],[[19904,19967],"valid",[],"NV8"],[[19968,40869],"valid"],[[40870,40891],"valid"],[[40892,40899],"valid"],[[40900,40907],"valid"],[[40908,40908],"valid"],[[40909,40917],"valid"],[[40918,40959],"disallowed"],[[40960,42124],"valid"],[[42125,42127],"disallowed"],[[42128,42145],"valid",[],"NV8"],[[42146,42147],"valid",[],"NV8"],[[42148,42163],"valid",[],"NV8"],[[42164,42164],"valid",[],"NV8"],[[42165,42176],"valid",[],"NV8"],[[42177,42177],"valid",[],"NV8"],[[42178,42180],"valid",[],"NV8"],[[42181,42181],"valid",[],"NV8"],[[42182,42182],"valid",[],"NV8"],[[42183,42191],"disallowed"],[[42192,42237],"valid"],[[42238,42239],"valid",[],"NV8"],[[42240,42508],"valid"],[[42509,42511],"valid",[],"NV8"],[[42512,42539],"valid"],[[42540,42559],"disallowed"],[[42560,42560],"mapped",[42561]],[[42561,42561],"valid"],[[42562,42562],"mapped",[42563]],[[42563,42563],"valid"],[[42564,42564],"mapped",[42565]],[[42565,42565],"valid"],[[42566,42566],"mapped",[42567]],[[42567,42567],"valid"],[[42568,42568],"mapped",[42569]],[[42569,42569],"valid"],[[42570,42570],"mapped",[42571]],[[42571,42571],"valid"],[[42572,42572],"mapped",[42573]],[[42573,42573],"valid"],[[42574,42574],"mapped",[42575]],[[42575,42575],"valid"],[[42576,42576],"mapped",[42577]],[[42577,42577],"valid"],[[42578,42578],"mapped",[42579]],[[42579,42579],"valid"],[[42580,42580],"mapped",[42581]],[[42581,42581],"valid"],[[42582,42582],"mapped",[42583]],[[42583,42583],"valid"],[[42584,42584],"mapped",[42585]],[[42585,42585],"valid"],[[42586,42586],"mapped",[42587]],[[42587,42587],"valid"],[[42588,42588],"mapped",[42589]],[[42589,42589],"valid"],[[42590,42590],"mapped",[42591]],[[42591,42591],"valid"],[[42592,42592],"mapped",[42593]],[[42593,42593],"valid"],[[42594,42594],"mapped",[42595]],[[42595,42595],"valid"],[[42596,42596],"mapped",[42597]],[[42597,42597],"valid"],[[42598,42598],"mapped",[42599]],[[42599,42599],"valid"],[[42600,42600],"mapped",[42601]],[[42601,42601],"valid"],[[42602,42602],"mapped",[42603]],[[42603,42603],"valid"],[[42604,42604],"mapped",[42605]],[[42605,42607],"valid"],[[42608,42611],"valid",[],"NV8"],[[42612,42619],"valid"],[[42620,42621],"valid"],[[42622,42622],"valid",[],"NV8"],[[42623,42623],"valid"],[[42624,42624],"mapped",[42625]],[[42625,42625],"valid"],[[42626,42626],"mapped",[42627]],[[42627,42627],"valid"],[[42628,42628],"mapped",[42629]],[[42629,42629],"valid"],[[42630,42630],"mapped",[42631]],[[42631,42631],"valid"],[[42632,42632],"mapped",[42633]],[[42633,42633],"valid"],[[42634,42634],"mapped",[42635]],[[42635,42635],"valid"],[[42636,42636],"mapped",[42637]],[[42637,42637],"valid"],[[42638,42638],"mapped",[42639]],[[42639,42639],"valid"],[[42640,42640],"mapped",[42641]],[[42641,42641],"valid"],[[42642,42642],"mapped",[42643]],[[42643,42643],"valid"],[[42644,42644],"mapped",[42645]],[[42645,42645],"valid"],[[42646,42646],"mapped",[42647]],[[42647,42647],"valid"],[[42648,42648],"mapped",[42649]],[[42649,42649],"valid"],[[42650,42650],"mapped",[42651]],[[42651,42651],"valid"],[[42652,42652],"mapped",[1098]],[[42653,42653],"mapped",[1100]],[[42654,42654],"valid"],[[42655,42655],"valid"],[[42656,42725],"valid"],[[42726,42735],"valid",[],"NV8"],[[42736,42737],"valid"],[[42738,42743],"valid",[],"NV8"],[[42744,42751],"disallowed"],[[42752,42774],"valid",[],"NV8"],[[42775,42778],"valid"],[[42779,42783],"valid"],[[42784,42785],"valid",[],"NV8"],[[42786,42786],"mapped",[42787]],[[42787,42787],"valid"],[[42788,42788],"mapped",[42789]],[[42789,42789],"valid"],[[42790,42790],"mapped",[42791]],[[42791,42791],"valid"],[[42792,42792],"mapped",[42793]],[[42793,42793],"valid"],[[42794,42794],"mapped",[42795]],[[42795,42795],"valid"],[[42796,42796],"mapped",[42797]],[[42797,42797],"valid"],[[42798,42798],"mapped",[42799]],[[42799,42801],"valid"],[[42802,42802],"mapped",[42803]],[[42803,42803],"valid"],[[42804,42804],"mapped",[42805]],[[42805,42805],"valid"],[[42806,42806],"mapped",[42807]],[[42807,42807],"valid"],[[42808,42808],"mapped",[42809]],[[42809,42809],"valid"],[[42810,42810],"mapped",[42811]],[[42811,42811],"valid"],[[42812,42812],"mapped",[42813]],[[42813,42813],"valid"],[[42814,42814],"mapped",[42815]],[[42815,42815],"valid"],[[42816,42816],"mapped",[42817]],[[42817,42817],"valid"],[[42818,42818],"mapped",[42819]],[[42819,42819],"valid"],[[42820,42820],"mapped",[42821]],[[42821,42821],"valid"],[[42822,42822],"mapped",[42823]],[[42823,42823],"valid"],[[42824,42824],"mapped",[42825]],[[42825,42825],"valid"],[[42826,42826],"mapped",[42827]],[[42827,42827],"valid"],[[42828,42828],"mapped",[42829]],[[42829,42829],"valid"],[[42830,42830],"mapped",[42831]],[[42831,42831],"valid"],[[42832,42832],"mapped",[42833]],[[42833,42833],"valid"],[[42834,42834],"mapped",[42835]],[[42835,42835],"valid"],[[42836,42836],"mapped",[42837]],[[42837,42837],"valid"],[[42838,42838],"mapped",[42839]],[[42839,42839],"valid"],[[42840,42840],"mapped",[42841]],[[42841,42841],"valid"],[[42842,42842],"mapped",[42843]],[[42843,42843],"valid"],[[42844,42844],"mapped",[42845]],[[42845,42845],"valid"],[[42846,42846],"mapped",[42847]],[[42847,42847],"valid"],[[42848,42848],"mapped",[42849]],[[42849,42849],"valid"],[[42850,42850],"mapped",[42851]],[[42851,42851],"valid"],[[42852,42852],"mapped",[42853]],[[42853,42853],"valid"],[[42854,42854],"mapped",[42855]],[[42855,42855],"valid"],[[42856,42856],"mapped",[42857]],[[42857,42857],"valid"],[[42858,42858],"mapped",[42859]],[[42859,42859],"valid"],[[42860,42860],"mapped",[42861]],[[42861,42861],"valid"],[[42862,42862],"mapped",[42863]],[[42863,42863],"valid"],[[42864,42864],"mapped",[42863]],[[42865,42872],"valid"],[[42873,42873],"mapped",[42874]],[[42874,42874],"valid"],[[42875,42875],"mapped",[42876]],[[42876,42876],"valid"],[[42877,42877],"mapped",[7545]],[[42878,42878],"mapped",[42879]],[[42879,42879],"valid"],[[42880,42880],"mapped",[42881]],[[42881,42881],"valid"],[[42882,42882],"mapped",[42883]],[[42883,42883],"valid"],[[42884,42884],"mapped",[42885]],[[42885,42885],"valid"],[[42886,42886],"mapped",[42887]],[[42887,42888],"valid"],[[42889,42890],"valid",[],"NV8"],[[42891,42891],"mapped",[42892]],[[42892,42892],"valid"],[[42893,42893],"mapped",[613]],[[42894,42894],"valid"],[[42895,42895],"valid"],[[42896,42896],"mapped",[42897]],[[42897,42897],"valid"],[[42898,42898],"mapped",[42899]],[[42899,42899],"valid"],[[42900,42901],"valid"],[[42902,42902],"mapped",[42903]],[[42903,42903],"valid"],[[42904,42904],"mapped",[42905]],[[42905,42905],"valid"],[[42906,42906],"mapped",[42907]],[[42907,42907],"valid"],[[42908,42908],"mapped",[42909]],[[42909,42909],"valid"],[[42910,42910],"mapped",[42911]],[[42911,42911],"valid"],[[42912,42912],"mapped",[42913]],[[42913,42913],"valid"],[[42914,42914],"mapped",[42915]],[[42915,42915],"valid"],[[42916,42916],"mapped",[42917]],[[42917,42917],"valid"],[[42918,42918],"mapped",[42919]],[[42919,42919],"valid"],[[42920,42920],"mapped",[42921]],[[42921,42921],"valid"],[[42922,42922],"mapped",[614]],[[42923,42923],"mapped",[604]],[[42924,42924],"mapped",[609]],[[42925,42925],"mapped",[620]],[[42926,42927],"disallowed"],[[42928,42928],"mapped",[670]],[[42929,42929],"mapped",[647]],[[42930,42930],"mapped",[669]],[[42931,42931],"mapped",[43859]],[[42932,42932],"mapped",[42933]],[[42933,42933],"valid"],[[42934,42934],"mapped",[42935]],[[42935,42935],"valid"],[[42936,42998],"disallowed"],[[42999,42999],"valid"],[[43000,43000],"mapped",[295]],[[43001,43001],"mapped",[339]],[[43002,43002],"valid"],[[43003,43007],"valid"],[[43008,43047],"valid"],[[43048,43051],"valid",[],"NV8"],[[43052,43055],"disallowed"],[[43056,43065],"valid",[],"NV8"],[[43066,43071],"disallowed"],[[43072,43123],"valid"],[[43124,43127],"valid",[],"NV8"],[[43128,43135],"disallowed"],[[43136,43204],"valid"],[[43205,43213],"disallowed"],[[43214,43215],"valid",[],"NV8"],[[43216,43225],"valid"],[[43226,43231],"disallowed"],[[43232,43255],"valid"],[[43256,43258],"valid",[],"NV8"],[[43259,43259],"valid"],[[43260,43260],"valid",[],"NV8"],[[43261,43261],"valid"],[[43262,43263],"disallowed"],[[43264,43309],"valid"],[[43310,43311],"valid",[],"NV8"],[[43312,43347],"valid"],[[43348,43358],"disallowed"],[[43359,43359],"valid",[],"NV8"],[[43360,43388],"valid",[],"NV8"],[[43389,43391],"disallowed"],[[43392,43456],"valid"],[[43457,43469],"valid",[],"NV8"],[[43470,43470],"disallowed"],[[43471,43481],"valid"],[[43482,43485],"disallowed"],[[43486,43487],"valid",[],"NV8"],[[43488,43518],"valid"],[[43519,43519],"disallowed"],[[43520,43574],"valid"],[[43575,43583],"disallowed"],[[43584,43597],"valid"],[[43598,43599],"disallowed"],[[43600,43609],"valid"],[[43610,43611],"disallowed"],[[43612,43615],"valid",[],"NV8"],[[43616,43638],"valid"],[[43639,43641],"valid",[],"NV8"],[[43642,43643],"valid"],[[43644,43647],"valid"],[[43648,43714],"valid"],[[43715,43738],"disallowed"],[[43739,43741],"valid"],[[43742,43743],"valid",[],"NV8"],[[43744,43759],"valid"],[[43760,43761],"valid",[],"NV8"],[[43762,43766],"valid"],[[43767,43776],"disallowed"],[[43777,43782],"valid"],[[43783,43784],"disallowed"],[[43785,43790],"valid"],[[43791,43792],"disallowed"],[[43793,43798],"valid"],[[43799,43807],"disallowed"],[[43808,43814],"valid"],[[43815,43815],"disallowed"],[[43816,43822],"valid"],[[43823,43823],"disallowed"],[[43824,43866],"valid"],[[43867,43867],"valid",[],"NV8"],[[43868,43868],"mapped",[42791]],[[43869,43869],"mapped",[43831]],[[43870,43870],"mapped",[619]],[[43871,43871],"mapped",[43858]],[[43872,43875],"valid"],[[43876,43877],"valid"],[[43878,43887],"disallowed"],[[43888,43888],"mapped",[5024]],[[43889,43889],"mapped",[5025]],[[43890,43890],"mapped",[5026]],[[43891,43891],"mapped",[5027]],[[43892,43892],"mapped",[5028]],[[43893,43893],"mapped",[5029]],[[43894,43894],"mapped",[5030]],[[43895,43895],"mapped",[5031]],[[43896,43896],"mapped",[5032]],[[43897,43897],"mapped",[5033]],[[43898,43898],"mapped",[5034]],[[43899,43899],"mapped",[5035]],[[43900,43900],"mapped",[5036]],[[43901,43901],"mapped",[5037]],[[43902,43902],"mapped",[5038]],[[43903,43903],"mapped",[5039]],[[43904,43904],"mapped",[5040]],[[43905,43905],"mapped",[5041]],[[43906,43906],"mapped",[5042]],[[43907,43907],"mapped",[5043]],[[43908,43908],"mapped",[5044]],[[43909,43909],"mapped",[5045]],[[43910,43910],"mapped",[5046]],[[43911,43911],"mapped",[5047]],[[43912,43912],"mapped",[5048]],[[43913,43913],"mapped",[5049]],[[43914,43914],"mapped",[5050]],[[43915,43915],"mapped",[5051]],[[43916,43916],"mapped",[5052]],[[43917,43917],"mapped",[5053]],[[43918,43918],"mapped",[5054]],[[43919,43919],"mapped",[5055]],[[43920,43920],"mapped",[5056]],[[43921,43921],"mapped",[5057]],[[43922,43922],"mapped",[5058]],[[43923,43923],"mapped",[5059]],[[43924,43924],"mapped",[5060]],[[43925,43925],"mapped",[5061]],[[43926,43926],"mapped",[5062]],[[43927,43927],"mapped",[5063]],[[43928,43928],"mapped",[5064]],[[43929,43929],"mapped",[5065]],[[43930,43930],"mapped",[5066]],[[43931,43931],"mapped",[5067]],[[43932,43932],"mapped",[5068]],[[43933,43933],"mapped",[5069]],[[43934,43934],"mapped",[5070]],[[43935,43935],"mapped",[5071]],[[43936,43936],"mapped",[5072]],[[43937,43937],"mapped",[5073]],[[43938,43938],"mapped",[5074]],[[43939,43939],"mapped",[5075]],[[43940,43940],"mapped",[5076]],[[43941,43941],"mapped",[5077]],[[43942,43942],"mapped",[5078]],[[43943,43943],"mapped",[5079]],[[43944,43944],"mapped",[5080]],[[43945,43945],"mapped",[5081]],[[43946,43946],"mapped",[5082]],[[43947,43947],"mapped",[5083]],[[43948,43948],"mapped",[5084]],[[43949,43949],"mapped",[5085]],[[43950,43950],"mapped",[5086]],[[43951,43951],"mapped",[5087]],[[43952,43952],"mapped",[5088]],[[43953,43953],"mapped",[5089]],[[43954,43954],"mapped",[5090]],[[43955,43955],"mapped",[5091]],[[43956,43956],"mapped",[5092]],[[43957,43957],"mapped",[5093]],[[43958,43958],"mapped",[5094]],[[43959,43959],"mapped",[5095]],[[43960,43960],"mapped",[5096]],[[43961,43961],"mapped",[5097]],[[43962,43962],"mapped",[5098]],[[43963,43963],"mapped",[5099]],[[43964,43964],"mapped",[5100]],[[43965,43965],"mapped",[5101]],[[43966,43966],"mapped",[5102]],[[43967,43967],"mapped",[5103]],[[43968,44010],"valid"],[[44011,44011],"valid",[],"NV8"],[[44012,44013],"valid"],[[44014,44015],"disallowed"],[[44016,44025],"valid"],[[44026,44031],"disallowed"],[[44032,55203],"valid"],[[55204,55215],"disallowed"],[[55216,55238],"valid",[],"NV8"],[[55239,55242],"disallowed"],[[55243,55291],"valid",[],"NV8"],[[55292,55295],"disallowed"],[[55296,57343],"disallowed"],[[57344,63743],"disallowed"],[[63744,63744],"mapped",[35912]],[[63745,63745],"mapped",[26356]],[[63746,63746],"mapped",[36554]],[[63747,63747],"mapped",[36040]],[[63748,63748],"mapped",[28369]],[[63749,63749],"mapped",[20018]],[[63750,63750],"mapped",[21477]],[[63751,63752],"mapped",[40860]],[[63753,63753],"mapped",[22865]],[[63754,63754],"mapped",[37329]],[[63755,63755],"mapped",[21895]],[[63756,63756],"mapped",[22856]],[[63757,63757],"mapped",[25078]],[[63758,63758],"mapped",[30313]],[[63759,63759],"mapped",[32645]],[[63760,63760],"mapped",[34367]],[[63761,63761],"mapped",[34746]],[[63762,63762],"mapped",[35064]],[[63763,63763],"mapped",[37007]],[[63764,63764],"mapped",[27138]],[[63765,63765],"mapped",[27931]],[[63766,63766],"mapped",[28889]],[[63767,63767],"mapped",[29662]],[[63768,63768],"mapped",[33853]],[[63769,63769],"mapped",[37226]],[[63770,63770],"mapped",[39409]],[[63771,63771],"mapped",[20098]],[[63772,63772],"mapped",[21365]],[[63773,63773],"mapped",[27396]],[[63774,63774],"mapped",[29211]],[[63775,63775],"mapped",[34349]],[[63776,63776],"mapped",[40478]],[[63777,63777],"mapped",[23888]],[[63778,63778],"mapped",[28651]],[[63779,63779],"mapped",[34253]],[[63780,63780],"mapped",[35172]],[[63781,63781],"mapped",[25289]],[[63782,63782],"mapped",[33240]],[[63783,63783],"mapped",[34847]],[[63784,63784],"mapped",[24266]],[[63785,63785],"mapped",[26391]],[[63786,63786],"mapped",[28010]],[[63787,63787],"mapped",[29436]],[[63788,63788],"mapped",[37070]],[[63789,63789],"mapped",[20358]],[[63790,63790],"mapped",[20919]],[[63791,63791],"mapped",[21214]],[[63792,63792],"mapped",[25796]],[[63793,63793],"mapped",[27347]],[[63794,63794],"mapped",[29200]],[[63795,63795],"mapped",[30439]],[[63796,63796],"mapped",[32769]],[[63797,63797],"mapped",[34310]],[[63798,63798],"mapped",[34396]],[[63799,63799],"mapped",[36335]],[[63800,63800],"mapped",[38706]],[[63801,63801],"mapped",[39791]],[[63802,63802],"mapped",[40442]],[[63803,63803],"mapped",[30860]],[[63804,63804],"mapped",[31103]],[[63805,63805],"mapped",[32160]],[[63806,63806],"mapped",[33737]],[[63807,63807],"mapped",[37636]],[[63808,63808],"mapped",[40575]],[[63809,63809],"mapped",[35542]],[[63810,63810],"mapped",[22751]],[[63811,63811],"mapped",[24324]],[[63812,63812],"mapped",[31840]],[[63813,63813],"mapped",[32894]],[[63814,63814],"mapped",[29282]],[[63815,63815],"mapped",[30922]],[[63816,63816],"mapped",[36034]],[[63817,63817],"mapped",[38647]],[[63818,63818],"mapped",[22744]],[[63819,63819],"mapped",[23650]],[[63820,63820],"mapped",[27155]],[[63821,63821],"mapped",[28122]],[[63822,63822],"mapped",[28431]],[[63823,63823],"mapped",[32047]],[[63824,63824],"mapped",[32311]],[[63825,63825],"mapped",[38475]],[[63826,63826],"mapped",[21202]],[[63827,63827],"mapped",[32907]],[[63828,63828],"mapped",[20956]],[[63829,63829],"mapped",[20940]],[[63830,63830],"mapped",[31260]],[[63831,63831],"mapped",[32190]],[[63832,63832],"mapped",[33777]],[[63833,63833],"mapped",[38517]],[[63834,63834],"mapped",[35712]],[[63835,63835],"mapped",[25295]],[[63836,63836],"mapped",[27138]],[[63837,63837],"mapped",[35582]],[[63838,63838],"mapped",[20025]],[[63839,63839],"mapped",[23527]],[[63840,63840],"mapped",[24594]],[[63841,63841],"mapped",[29575]],[[63842,63842],"mapped",[30064]],[[63843,63843],"mapped",[21271]],[[63844,63844],"mapped",[30971]],[[63845,63845],"mapped",[20415]],[[63846,63846],"mapped",[24489]],[[63847,63847],"mapped",[19981]],[[63848,63848],"mapped",[27852]],[[63849,63849],"mapped",[25976]],[[63850,63850],"mapped",[32034]],[[63851,63851],"mapped",[21443]],[[63852,63852],"mapped",[22622]],[[63853,63853],"mapped",[30465]],[[63854,63854],"mapped",[33865]],[[63855,63855],"mapped",[35498]],[[63856,63856],"mapped",[27578]],[[63857,63857],"mapped",[36784]],[[63858,63858],"mapped",[27784]],[[63859,63859],"mapped",[25342]],[[63860,63860],"mapped",[33509]],[[63861,63861],"mapped",[25504]],[[63862,63862],"mapped",[30053]],[[63863,63863],"mapped",[20142]],[[63864,63864],"mapped",[20841]],[[63865,63865],"mapped",[20937]],[[63866,63866],"mapped",[26753]],[[63867,63867],"mapped",[31975]],[[63868,63868],"mapped",[33391]],[[63869,63869],"mapped",[35538]],[[63870,63870],"mapped",[37327]],[[63871,63871],"mapped",[21237]],[[63872,63872],"mapped",[21570]],[[63873,63873],"mapped",[22899]],[[63874,63874],"mapped",[24300]],[[63875,63875],"mapped",[26053]],[[63876,63876],"mapped",[28670]],[[63877,63877],"mapped",[31018]],[[63878,63878],"mapped",[38317]],[[63879,63879],"mapped",[39530]],[[63880,63880],"mapped",[40599]],[[63881,63881],"mapped",[40654]],[[63882,63882],"mapped",[21147]],[[63883,63883],"mapped",[26310]],[[63884,63884],"mapped",[27511]],[[63885,63885],"mapped",[36706]],[[63886,63886],"mapped",[24180]],[[63887,63887],"mapped",[24976]],[[63888,63888],"mapped",[25088]],[[63889,63889],"mapped",[25754]],[[63890,63890],"mapped",[28451]],[[63891,63891],"mapped",[29001]],[[63892,63892],"mapped",[29833]],[[63893,63893],"mapped",[31178]],[[63894,63894],"mapped",[32244]],[[63895,63895],"mapped",[32879]],[[63896,63896],"mapped",[36646]],[[63897,63897],"mapped",[34030]],[[63898,63898],"mapped",[36899]],[[63899,63899],"mapped",[37706]],[[63900,63900],"mapped",[21015]],[[63901,63901],"mapped",[21155]],[[63902,63902],"mapped",[21693]],[[63903,63903],"mapped",[28872]],[[63904,63904],"mapped",[35010]],[[63905,63905],"mapped",[35498]],[[63906,63906],"mapped",[24265]],[[63907,63907],"mapped",[24565]],[[63908,63908],"mapped",[25467]],[[63909,63909],"mapped",[27566]],[[63910,63910],"mapped",[31806]],[[63911,63911],"mapped",[29557]],[[63912,63912],"mapped",[20196]],[[63913,63913],"mapped",[22265]],[[63914,63914],"mapped",[23527]],[[63915,63915],"mapped",[23994]],[[63916,63916],"mapped",[24604]],[[63917,63917],"mapped",[29618]],[[63918,63918],"mapped",[29801]],[[63919,63919],"mapped",[32666]],[[63920,63920],"mapped",[32838]],[[63921,63921],"mapped",[37428]],[[63922,63922],"mapped",[38646]],[[63923,63923],"mapped",[38728]],[[63924,63924],"mapped",[38936]],[[63925,63925],"mapped",[20363]],[[63926,63926],"mapped",[31150]],[[63927,63927],"mapped",[37300]],[[63928,63928],"mapped",[38584]],[[63929,63929],"mapped",[24801]],[[63930,63930],"mapped",[20102]],[[63931,63931],"mapped",[20698]],[[63932,63932],"mapped",[23534]],[[63933,63933],"mapped",[23615]],[[63934,63934],"mapped",[26009]],[[63935,63935],"mapped",[27138]],[[63936,63936],"mapped",[29134]],[[63937,63937],"mapped",[30274]],[[63938,63938],"mapped",[34044]],[[63939,63939],"mapped",[36988]],[[63940,63940],"mapped",[40845]],[[63941,63941],"mapped",[26248]],[[63942,63942],"mapped",[38446]],[[63943,63943],"mapped",[21129]],[[63944,63944],"mapped",[26491]],[[63945,63945],"mapped",[26611]],[[63946,63946],"mapped",[27969]],[[63947,63947],"mapped",[28316]],[[63948,63948],"mapped",[29705]],[[63949,63949],"mapped",[30041]],[[63950,63950],"mapped",[30827]],[[63951,63951],"mapped",[32016]],[[63952,63952],"mapped",[39006]],[[63953,63953],"mapped",[20845]],[[63954,63954],"mapped",[25134]],[[63955,63955],"mapped",[38520]],[[63956,63956],"mapped",[20523]],[[63957,63957],"mapped",[23833]],[[63958,63958],"mapped",[28138]],[[63959,63959],"mapped",[36650]],[[63960,63960],"mapped",[24459]],[[63961,63961],"mapped",[24900]],[[63962,63962],"mapped",[26647]],[[63963,63963],"mapped",[29575]],[[63964,63964],"mapped",[38534]],[[63965,63965],"mapped",[21033]],[[63966,63966],"mapped",[21519]],[[63967,63967],"mapped",[23653]],[[63968,63968],"mapped",[26131]],[[63969,63969],"mapped",[26446]],[[63970,63970],"mapped",[26792]],[[63971,63971],"mapped",[27877]],[[63972,63972],"mapped",[29702]],[[63973,63973],"mapped",[30178]],[[63974,63974],"mapped",[32633]],[[63975,63975],"mapped",[35023]],[[63976,63976],"mapped",[35041]],[[63977,63977],"mapped",[37324]],[[63978,63978],"mapped",[38626]],[[63979,63979],"mapped",[21311]],[[63980,63980],"mapped",[28346]],[[63981,63981],"mapped",[21533]],[[63982,63982],"mapped",[29136]],[[63983,63983],"mapped",[29848]],[[63984,63984],"mapped",[34298]],[[63985,63985],"mapped",[38563]],[[63986,63986],"mapped",[40023]],[[63987,63987],"mapped",[40607]],[[63988,63988],"mapped",[26519]],[[63989,63989],"mapped",[28107]],[[63990,63990],"mapped",[33256]],[[63991,63991],"mapped",[31435]],[[63992,63992],"mapped",[31520]],[[63993,63993],"mapped",[31890]],[[63994,63994],"mapped",[29376]],[[63995,63995],"mapped",[28825]],[[63996,63996],"mapped",[35672]],[[63997,63997],"mapped",[20160]],[[63998,63998],"mapped",[33590]],[[63999,63999],"mapped",[21050]],[[64000,64000],"mapped",[20999]],[[64001,64001],"mapped",[24230]],[[64002,64002],"mapped",[25299]],[[64003,64003],"mapped",[31958]],[[64004,64004],"mapped",[23429]],[[64005,64005],"mapped",[27934]],[[64006,64006],"mapped",[26292]],[[64007,64007],"mapped",[36667]],[[64008,64008],"mapped",[34892]],[[64009,64009],"mapped",[38477]],[[64010,64010],"mapped",[35211]],[[64011,64011],"mapped",[24275]],[[64012,64012],"mapped",[20800]],[[64013,64013],"mapped",[21952]],[[64014,64015],"valid"],[[64016,64016],"mapped",[22618]],[[64017,64017],"valid"],[[64018,64018],"mapped",[26228]],[[64019,64020],"valid"],[[64021,64021],"mapped",[20958]],[[64022,64022],"mapped",[29482]],[[64023,64023],"mapped",[30410]],[[64024,64024],"mapped",[31036]],[[64025,64025],"mapped",[31070]],[[64026,64026],"mapped",[31077]],[[64027,64027],"mapped",[31119]],[[64028,64028],"mapped",[38742]],[[64029,64029],"mapped",[31934]],[[64030,64030],"mapped",[32701]],[[64031,64031],"valid"],[[64032,64032],"mapped",[34322]],[[64033,64033],"valid"],[[64034,64034],"mapped",[35576]],[[64035,64036],"valid"],[[64037,64037],"mapped",[36920]],[[64038,64038],"mapped",[37117]],[[64039,64041],"valid"],[[64042,64042],"mapped",[39151]],[[64043,64043],"mapped",[39164]],[[64044,64044],"mapped",[39208]],[[64045,64045],"mapped",[40372]],[[64046,64046],"mapped",[37086]],[[64047,64047],"mapped",[38583]],[[64048,64048],"mapped",[20398]],[[64049,64049],"mapped",[20711]],[[64050,64050],"mapped",[20813]],[[64051,64051],"mapped",[21193]],[[64052,64052],"mapped",[21220]],[[64053,64053],"mapped",[21329]],[[64054,64054],"mapped",[21917]],[[64055,64055],"mapped",[22022]],[[64056,64056],"mapped",[22120]],[[64057,64057],"mapped",[22592]],[[64058,64058],"mapped",[22696]],[[64059,64059],"mapped",[23652]],[[64060,64060],"mapped",[23662]],[[64061,64061],"mapped",[24724]],[[64062,64062],"mapped",[24936]],[[64063,64063],"mapped",[24974]],[[64064,64064],"mapped",[25074]],[[64065,64065],"mapped",[25935]],[[64066,64066],"mapped",[26082]],[[64067,64067],"mapped",[26257]],[[64068,64068],"mapped",[26757]],[[64069,64069],"mapped",[28023]],[[64070,64070],"mapped",[28186]],[[64071,64071],"mapped",[28450]],[[64072,64072],"mapped",[29038]],[[64073,64073],"mapped",[29227]],[[64074,64074],"mapped",[29730]],[[64075,64075],"mapped",[30865]],[[64076,64076],"mapped",[31038]],[[64077,64077],"mapped",[31049]],[[64078,64078],"mapped",[31048]],[[64079,64079],"mapped",[31056]],[[64080,64080],"mapped",[31062]],[[64081,64081],"mapped",[31069]],[[64082,64082],"mapped",[31117]],[[64083,64083],"mapped",[31118]],[[64084,64084],"mapped",[31296]],[[64085,64085],"mapped",[31361]],[[64086,64086],"mapped",[31680]],[[64087,64087],"mapped",[32244]],[[64088,64088],"mapped",[32265]],[[64089,64089],"mapped",[32321]],[[64090,64090],"mapped",[32626]],[[64091,64091],"mapped",[32773]],[[64092,64092],"mapped",[33261]],[[64093,64094],"mapped",[33401]],[[64095,64095],"mapped",[33879]],[[64096,64096],"mapped",[35088]],[[64097,64097],"mapped",[35222]],[[64098,64098],"mapped",[35585]],[[64099,64099],"mapped",[35641]],[[64100,64100],"mapped",[36051]],[[64101,64101],"mapped",[36104]],[[64102,64102],"mapped",[36790]],[[64103,64103],"mapped",[36920]],[[64104,64104],"mapped",[38627]],[[64105,64105],"mapped",[38911]],[[64106,64106],"mapped",[38971]],[[64107,64107],"mapped",[24693]],[[64108,64108],"mapped",[148206]],[[64109,64109],"mapped",[33304]],[[64110,64111],"disallowed"],[[64112,64112],"mapped",[20006]],[[64113,64113],"mapped",[20917]],[[64114,64114],"mapped",[20840]],[[64115,64115],"mapped",[20352]],[[64116,64116],"mapped",[20805]],[[64117,64117],"mapped",[20864]],[[64118,64118],"mapped",[21191]],[[64119,64119],"mapped",[21242]],[[64120,64120],"mapped",[21917]],[[64121,64121],"mapped",[21845]],[[64122,64122],"mapped",[21913]],[[64123,64123],"mapped",[21986]],[[64124,64124],"mapped",[22618]],[[64125,64125],"mapped",[22707]],[[64126,64126],"mapped",[22852]],[[64127,64127],"mapped",[22868]],[[64128,64128],"mapped",[23138]],[[64129,64129],"mapped",[23336]],[[64130,64130],"mapped",[24274]],[[64131,64131],"mapped",[24281]],[[64132,64132],"mapped",[24425]],[[64133,64133],"mapped",[24493]],[[64134,64134],"mapped",[24792]],[[64135,64135],"mapped",[24910]],[[64136,64136],"mapped",[24840]],[[64137,64137],"mapped",[24974]],[[64138,64138],"mapped",[24928]],[[64139,64139],"mapped",[25074]],[[64140,64140],"mapped",[25140]],[[64141,64141],"mapped",[25540]],[[64142,64142],"mapped",[25628]],[[64143,64143],"mapped",[25682]],[[64144,64144],"mapped",[25942]],[[64145,64145],"mapped",[26228]],[[64146,64146],"mapped",[26391]],[[64147,64147],"mapped",[26395]],[[64148,64148],"mapped",[26454]],[[64149,64149],"mapped",[27513]],[[64150,64150],"mapped",[27578]],[[64151,64151],"mapped",[27969]],[[64152,64152],"mapped",[28379]],[[64153,64153],"mapped",[28363]],[[64154,64154],"mapped",[28450]],[[64155,64155],"mapped",[28702]],[[64156,64156],"mapped",[29038]],[[64157,64157],"mapped",[30631]],[[64158,64158],"mapped",[29237]],[[64159,64159],"mapped",[29359]],[[64160,64160],"mapped",[29482]],[[64161,64161],"mapped",[29809]],[[64162,64162],"mapped",[29958]],[[64163,64163],"mapped",[30011]],[[64164,64164],"mapped",[30237]],[[64165,64165],"mapped",[30239]],[[64166,64166],"mapped",[30410]],[[64167,64167],"mapped",[30427]],[[64168,64168],"mapped",[30452]],[[64169,64169],"mapped",[30538]],[[64170,64170],"mapped",[30528]],[[64171,64171],"mapped",[30924]],[[64172,64172],"mapped",[31409]],[[64173,64173],"mapped",[31680]],[[64174,64174],"mapped",[31867]],[[64175,64175],"mapped",[32091]],[[64176,64176],"mapped",[32244]],[[64177,64177],"mapped",[32574]],[[64178,64178],"mapped",[32773]],[[64179,64179],"mapped",[33618]],[[64180,64180],"mapped",[33775]],[[64181,64181],"mapped",[34681]],[[64182,64182],"mapped",[35137]],[[64183,64183],"mapped",[35206]],[[64184,64184],"mapped",[35222]],[[64185,64185],"mapped",[35519]],[[64186,64186],"mapped",[35576]],[[64187,64187],"mapped",[35531]],[[64188,64188],"mapped",[35585]],[[64189,64189],"mapped",[35582]],[[64190,64190],"mapped",[35565]],[[64191,64191],"mapped",[35641]],[[64192,64192],"mapped",[35722]],[[64193,64193],"mapped",[36104]],[[64194,64194],"mapped",[36664]],[[64195,64195],"mapped",[36978]],[[64196,64196],"mapped",[37273]],[[64197,64197],"mapped",[37494]],[[64198,64198],"mapped",[38524]],[[64199,64199],"mapped",[38627]],[[64200,64200],"mapped",[38742]],[[64201,64201],"mapped",[38875]],[[64202,64202],"mapped",[38911]],[[64203,64203],"mapped",[38923]],[[64204,64204],"mapped",[38971]],[[64205,64205],"mapped",[39698]],[[64206,64206],"mapped",[40860]],[[64207,64207],"mapped",[141386]],[[64208,64208],"mapped",[141380]],[[64209,64209],"mapped",[144341]],[[64210,64210],"mapped",[15261]],[[64211,64211],"mapped",[16408]],[[64212,64212],"mapped",[16441]],[[64213,64213],"mapped",[152137]],[[64214,64214],"mapped",[154832]],[[64215,64215],"mapped",[163539]],[[64216,64216],"mapped",[40771]],[[64217,64217],"mapped",[40846]],[[64218,64255],"disallowed"],[[64256,64256],"mapped",[102,102]],[[64257,64257],"mapped",[102,105]],[[64258,64258],"mapped",[102,108]],[[64259,64259],"mapped",[102,102,105]],[[64260,64260],"mapped",[102,102,108]],[[64261,64262],"mapped",[115,116]],[[64263,64274],"disallowed"],[[64275,64275],"mapped",[1396,1398]],[[64276,64276],"mapped",[1396,1381]],[[64277,64277],"mapped",[1396,1387]],[[64278,64278],"mapped",[1406,1398]],[[64279,64279],"mapped",[1396,1389]],[[64280,64284],"disallowed"],[[64285,64285],"mapped",[1497,1460]],[[64286,64286],"valid"],[[64287,64287],"mapped",[1522,1463]],[[64288,64288],"mapped",[1506]],[[64289,64289],"mapped",[1488]],[[64290,64290],"mapped",[1491]],[[64291,64291],"mapped",[1492]],[[64292,64292],"mapped",[1499]],[[64293,64293],"mapped",[1500]],[[64294,64294],"mapped",[1501]],[[64295,64295],"mapped",[1512]],[[64296,64296],"mapped",[1514]],[[64297,64297],"disallowed_STD3_mapped",[43]],[[64298,64298],"mapped",[1513,1473]],[[64299,64299],"mapped",[1513,1474]],[[64300,64300],"mapped",[1513,1468,1473]],[[64301,64301],"mapped",[1513,1468,1474]],[[64302,64302],"mapped",[1488,1463]],[[64303,64303],"mapped",[1488,1464]],[[64304,64304],"mapped",[1488,1468]],[[64305,64305],"mapped",[1489,1468]],[[64306,64306],"mapped",[1490,1468]],[[64307,64307],"mapped",[1491,1468]],[[64308,64308],"mapped",[1492,1468]],[[64309,64309],"mapped",[1493,1468]],[[64310,64310],"mapped",[1494,1468]],[[64311,64311],"disallowed"],[[64312,64312],"mapped",[1496,1468]],[[64313,64313],"mapped",[1497,1468]],[[64314,64314],"mapped",[1498,1468]],[[64315,64315],"mapped",[1499,1468]],[[64316,64316],"mapped",[1500,1468]],[[64317,64317],"disallowed"],[[64318,64318],"mapped",[1502,1468]],[[64319,64319],"disallowed"],[[64320,64320],"mapped",[1504,1468]],[[64321,64321],"mapped",[1505,1468]],[[64322,64322],"disallowed"],[[64323,64323],"mapped",[1507,1468]],[[64324,64324],"mapped",[1508,1468]],[[64325,64325],"disallowed"],[[64326,64326],"mapped",[1510,1468]],[[64327,64327],"mapped",[1511,1468]],[[64328,64328],"mapped",[1512,1468]],[[64329,64329],"mapped",[1513,1468]],[[64330,64330],"mapped",[1514,1468]],[[64331,64331],"mapped",[1493,1465]],[[64332,64332],"mapped",[1489,1471]],[[64333,64333],"mapped",[1499,1471]],[[64334,64334],"mapped",[1508,1471]],[[64335,64335],"mapped",[1488,1500]],[[64336,64337],"mapped",[1649]],[[64338,64341],"mapped",[1659]],[[64342,64345],"mapped",[1662]],[[64346,64349],"mapped",[1664]],[[64350,64353],"mapped",[1658]],[[64354,64357],"mapped",[1663]],[[64358,64361],"mapped",[1657]],[[64362,64365],"mapped",[1700]],[[64366,64369],"mapped",[1702]],[[64370,64373],"mapped",[1668]],[[64374,64377],"mapped",[1667]],[[64378,64381],"mapped",[1670]],[[64382,64385],"mapped",[1671]],[[64386,64387],"mapped",[1677]],[[64388,64389],"mapped",[1676]],[[64390,64391],"mapped",[1678]],[[64392,64393],"mapped",[1672]],[[64394,64395],"mapped",[1688]],[[64396,64397],"mapped",[1681]],[[64398,64401],"mapped",[1705]],[[64402,64405],"mapped",[1711]],[[64406,64409],"mapped",[1715]],[[64410,64413],"mapped",[1713]],[[64414,64415],"mapped",[1722]],[[64416,64419],"mapped",[1723]],[[64420,64421],"mapped",[1728]],[[64422,64425],"mapped",[1729]],[[64426,64429],"mapped",[1726]],[[64430,64431],"mapped",[1746]],[[64432,64433],"mapped",[1747]],[[64434,64449],"valid",[],"NV8"],[[64450,64466],"disallowed"],[[64467,64470],"mapped",[1709]],[[64471,64472],"mapped",[1735]],[[64473,64474],"mapped",[1734]],[[64475,64476],"mapped",[1736]],[[64477,64477],"mapped",[1735,1652]],[[64478,64479],"mapped",[1739]],[[64480,64481],"mapped",[1733]],[[64482,64483],"mapped",[1737]],[[64484,64487],"mapped",[1744]],[[64488,64489],"mapped",[1609]],[[64490,64491],"mapped",[1574,1575]],[[64492,64493],"mapped",[1574,1749]],[[64494,64495],"mapped",[1574,1608]],[[64496,64497],"mapped",[1574,1735]],[[64498,64499],"mapped",[1574,1734]],[[64500,64501],"mapped",[1574,1736]],[[64502,64504],"mapped",[1574,1744]],[[64505,64507],"mapped",[1574,1609]],[[64508,64511],"mapped",[1740]],[[64512,64512],"mapped",[1574,1580]],[[64513,64513],"mapped",[1574,1581]],[[64514,64514],"mapped",[1574,1605]],[[64515,64515],"mapped",[1574,1609]],[[64516,64516],"mapped",[1574,1610]],[[64517,64517],"mapped",[1576,1580]],[[64518,64518],"mapped",[1576,1581]],[[64519,64519],"mapped",[1576,1582]],[[64520,64520],"mapped",[1576,1605]],[[64521,64521],"mapped",[1576,1609]],[[64522,64522],"mapped",[1576,1610]],[[64523,64523],"mapped",[1578,1580]],[[64524,64524],"mapped",[1578,1581]],[[64525,64525],"mapped",[1578,1582]],[[64526,64526],"mapped",[1578,1605]],[[64527,64527],"mapped",[1578,1609]],[[64528,64528],"mapped",[1578,1610]],[[64529,64529],"mapped",[1579,1580]],[[64530,64530],"mapped",[1579,1605]],[[64531,64531],"mapped",[1579,1609]],[[64532,64532],"mapped",[1579,1610]],[[64533,64533],"mapped",[1580,1581]],[[64534,64534],"mapped",[1580,1605]],[[64535,64535],"mapped",[1581,1580]],[[64536,64536],"mapped",[1581,1605]],[[64537,64537],"mapped",[1582,1580]],[[64538,64538],"mapped",[1582,1581]],[[64539,64539],"mapped",[1582,1605]],[[64540,64540],"mapped",[1587,1580]],[[64541,64541],"mapped",[1587,1581]],[[64542,64542],"mapped",[1587,1582]],[[64543,64543],"mapped",[1587,1605]],[[64544,64544],"mapped",[1589,1581]],[[64545,64545],"mapped",[1589,1605]],[[64546,64546],"mapped",[1590,1580]],[[64547,64547],"mapped",[1590,1581]],[[64548,64548],"mapped",[1590,1582]],[[64549,64549],"mapped",[1590,1605]],[[64550,64550],"mapped",[1591,1581]],[[64551,64551],"mapped",[1591,1605]],[[64552,64552],"mapped",[1592,1605]],[[64553,64553],"mapped",[1593,1580]],[[64554,64554],"mapped",[1593,1605]],[[64555,64555],"mapped",[1594,1580]],[[64556,64556],"mapped",[1594,1605]],[[64557,64557],"mapped",[1601,1580]],[[64558,64558],"mapped",[1601,1581]],[[64559,64559],"mapped",[1601,1582]],[[64560,64560],"mapped",[1601,1605]],[[64561,64561],"mapped",[1601,1609]],[[64562,64562],"mapped",[1601,1610]],[[64563,64563],"mapped",[1602,1581]],[[64564,64564],"mapped",[1602,1605]],[[64565,64565],"mapped",[1602,1609]],[[64566,64566],"mapped",[1602,1610]],[[64567,64567],"mapped",[1603,1575]],[[64568,64568],"mapped",[1603,1580]],[[64569,64569],"mapped",[1603,1581]],[[64570,64570],"mapped",[1603,1582]],[[64571,64571],"mapped",[1603,1604]],[[64572,64572],"mapped",[1603,1605]],[[64573,64573],"mapped",[1603,1609]],[[64574,64574],"mapped",[1603,1610]],[[64575,64575],"mapped",[1604,1580]],[[64576,64576],"mapped",[1604,1581]],[[64577,64577],"mapped",[1604,1582]],[[64578,64578],"mapped",[1604,1605]],[[64579,64579],"mapped",[1604,1609]],[[64580,64580],"mapped",[1604,1610]],[[64581,64581],"mapped",[1605,1580]],[[64582,64582],"mapped",[1605,1581]],[[64583,64583],"mapped",[1605,1582]],[[64584,64584],"mapped",[1605,1605]],[[64585,64585],"mapped",[1605,1609]],[[64586,64586],"mapped",[1605,1610]],[[64587,64587],"mapped",[1606,1580]],[[64588,64588],"mapped",[1606,1581]],[[64589,64589],"mapped",[1606,1582]],[[64590,64590],"mapped",[1606,1605]],[[64591,64591],"mapped",[1606,1609]],[[64592,64592],"mapped",[1606,1610]],[[64593,64593],"mapped",[1607,1580]],[[64594,64594],"mapped",[1607,1605]],[[64595,64595],"mapped",[1607,1609]],[[64596,64596],"mapped",[1607,1610]],[[64597,64597],"mapped",[1610,1580]],[[64598,64598],"mapped",[1610,1581]],[[64599,64599],"mapped",[1610,1582]],[[64600,64600],"mapped",[1610,1605]],[[64601,64601],"mapped",[1610,1609]],[[64602,64602],"mapped",[1610,1610]],[[64603,64603],"mapped",[1584,1648]],[[64604,64604],"mapped",[1585,1648]],[[64605,64605],"mapped",[1609,1648]],[[64606,64606],"disallowed_STD3_mapped",[32,1612,1617]],[[64607,64607],"disallowed_STD3_mapped",[32,1613,1617]],[[64608,64608],"disallowed_STD3_mapped",[32,1614,1617]],[[64609,64609],"disallowed_STD3_mapped",[32,1615,1617]],[[64610,64610],"disallowed_STD3_mapped",[32,1616,1617]],[[64611,64611],"disallowed_STD3_mapped",[32,1617,1648]],[[64612,64612],"mapped",[1574,1585]],[[64613,64613],"mapped",[1574,1586]],[[64614,64614],"mapped",[1574,1605]],[[64615,64615],"mapped",[1574,1606]],[[64616,64616],"mapped",[1574,1609]],[[64617,64617],"mapped",[1574,1610]],[[64618,64618],"mapped",[1576,1585]],[[64619,64619],"mapped",[1576,1586]],[[64620,64620],"mapped",[1576,1605]],[[64621,64621],"mapped",[1576,1606]],[[64622,64622],"mapped",[1576,1609]],[[64623,64623],"mapped",[1576,1610]],[[64624,64624],"mapped",[1578,1585]],[[64625,64625],"mapped",[1578,1586]],[[64626,64626],"mapped",[1578,1605]],[[64627,64627],"mapped",[1578,1606]],[[64628,64628],"mapped",[1578,1609]],[[64629,64629],"mapped",[1578,1610]],[[64630,64630],"mapped",[1579,1585]],[[64631,64631],"mapped",[1579,1586]],[[64632,64632],"mapped",[1579,1605]],[[64633,64633],"mapped",[1579,1606]],[[64634,64634],"mapped",[1579,1609]],[[64635,64635],"mapped",[1579,1610]],[[64636,64636],"mapped",[1601,1609]],[[64637,64637],"mapped",[1601,1610]],[[64638,64638],"mapped",[1602,1609]],[[64639,64639],"mapped",[1602,1610]],[[64640,64640],"mapped",[1603,1575]],[[64641,64641],"mapped",[1603,1604]],[[64642,64642],"mapped",[1603,1605]],[[64643,64643],"mapped",[1603,1609]],[[64644,64644],"mapped",[1603,1610]],[[64645,64645],"mapped",[1604,1605]],[[64646,64646],"mapped",[1604,1609]],[[64647,64647],"mapped",[1604,1610]],[[64648,64648],"mapped",[1605,1575]],[[64649,64649],"mapped",[1605,1605]],[[64650,64650],"mapped",[1606,1585]],[[64651,64651],"mapped",[1606,1586]],[[64652,64652],"mapped",[1606,1605]],[[64653,64653],"mapped",[1606,1606]],[[64654,64654],"mapped",[1606,1609]],[[64655,64655],"mapped",[1606,1610]],[[64656,64656],"mapped",[1609,1648]],[[64657,64657],"mapped",[1610,1585]],[[64658,64658],"mapped",[1610,1586]],[[64659,64659],"mapped",[1610,1605]],[[64660,64660],"mapped",[1610,1606]],[[64661,64661],"mapped",[1610,1609]],[[64662,64662],"mapped",[1610,1610]],[[64663,64663],"mapped",[1574,1580]],[[64664,64664],"mapped",[1574,1581]],[[64665,64665],"mapped",[1574,1582]],[[64666,64666],"mapped",[1574,1605]],[[64667,64667],"mapped",[1574,1607]],[[64668,64668],"mapped",[1576,1580]],[[64669,64669],"mapped",[1576,1581]],[[64670,64670],"mapped",[1576,1582]],[[64671,64671],"mapped",[1576,1605]],[[64672,64672],"mapped",[1576,1607]],[[64673,64673],"mapped",[1578,1580]],[[64674,64674],"mapped",[1578,1581]],[[64675,64675],"mapped",[1578,1582]],[[64676,64676],"mapped",[1578,1605]],[[64677,64677],"mapped",[1578,1607]],[[64678,64678],"mapped",[1579,1605]],[[64679,64679],"mapped",[1580,1581]],[[64680,64680],"mapped",[1580,1605]],[[64681,64681],"mapped",[1581,1580]],[[64682,64682],"mapped",[1581,1605]],[[64683,64683],"mapped",[1582,1580]],[[64684,64684],"mapped",[1582,1605]],[[64685,64685],"mapped",[1587,1580]],[[64686,64686],"mapped",[1587,1581]],[[64687,64687],"mapped",[1587,1582]],[[64688,64688],"mapped",[1587,1605]],[[64689,64689],"mapped",[1589,1581]],[[64690,64690],"mapped",[1589,1582]],[[64691,64691],"mapped",[1589,1605]],[[64692,64692],"mapped",[1590,1580]],[[64693,64693],"mapped",[1590,1581]],[[64694,64694],"mapped",[1590,1582]],[[64695,64695],"mapped",[1590,1605]],[[64696,64696],"mapped",[1591,1581]],[[64697,64697],"mapped",[1592,1605]],[[64698,64698],"mapped",[1593,1580]],[[64699,64699],"mapped",[1593,1605]],[[64700,64700],"mapped",[1594,1580]],[[64701,64701],"mapped",[1594,1605]],[[64702,64702],"mapped",[1601,1580]],[[64703,64703],"mapped",[1601,1581]],[[64704,64704],"mapped",[1601,1582]],[[64705,64705],"mapped",[1601,1605]],[[64706,64706],"mapped",[1602,1581]],[[64707,64707],"mapped",[1602,1605]],[[64708,64708],"mapped",[1603,1580]],[[64709,64709],"mapped",[1603,1581]],[[64710,64710],"mapped",[1603,1582]],[[64711,64711],"mapped",[1603,1604]],[[64712,64712],"mapped",[1603,1605]],[[64713,64713],"mapped",[1604,1580]],[[64714,64714],"mapped",[1604,1581]],[[64715,64715],"mapped",[1604,1582]],[[64716,64716],"mapped",[1604,1605]],[[64717,64717],"mapped",[1604,1607]],[[64718,64718],"mapped",[1605,1580]],[[64719,64719],"mapped",[1605,1581]],[[64720,64720],"mapped",[1605,1582]],[[64721,64721],"mapped",[1605,1605]],[[64722,64722],"mapped",[1606,1580]],[[64723,64723],"mapped",[1606,1581]],[[64724,64724],"mapped",[1606,1582]],[[64725,64725],"mapped",[1606,1605]],[[64726,64726],"mapped",[1606,1607]],[[64727,64727],"mapped",[1607,1580]],[[64728,64728],"mapped",[1607,1605]],[[64729,64729],"mapped",[1607,1648]],[[64730,64730],"mapped",[1610,1580]],[[64731,64731],"mapped",[1610,1581]],[[64732,64732],"mapped",[1610,1582]],[[64733,64733],"mapped",[1610,1605]],[[64734,64734],"mapped",[1610,1607]],[[64735,64735],"mapped",[1574,1605]],[[64736,64736],"mapped",[1574,1607]],[[64737,64737],"mapped",[1576,1605]],[[64738,64738],"mapped",[1576,1607]],[[64739,64739],"mapped",[1578,1605]],[[64740,64740],"mapped",[1578,1607]],[[64741,64741],"mapped",[1579,1605]],[[64742,64742],"mapped",[1579,1607]],[[64743,64743],"mapped",[1587,1605]],[[64744,64744],"mapped",[1587,1607]],[[64745,64745],"mapped",[1588,1605]],[[64746,64746],"mapped",[1588,1607]],[[64747,64747],"mapped",[1603,1604]],[[64748,64748],"mapped",[1603,1605]],[[64749,64749],"mapped",[1604,1605]],[[64750,64750],"mapped",[1606,1605]],[[64751,64751],"mapped",[1606,1607]],[[64752,64752],"mapped",[1610,1605]],[[64753,64753],"mapped",[1610,1607]],[[64754,64754],"mapped",[1600,1614,1617]],[[64755,64755],"mapped",[1600,1615,1617]],[[64756,64756],"mapped",[1600,1616,1617]],[[64757,64757],"mapped",[1591,1609]],[[64758,64758],"mapped",[1591,1610]],[[64759,64759],"mapped",[1593,1609]],[[64760,64760],"mapped",[1593,1610]],[[64761,64761],"mapped",[1594,1609]],[[64762,64762],"mapped",[1594,1610]],[[64763,64763],"mapped",[1587,1609]],[[64764,64764],"mapped",[1587,1610]],[[64765,64765],"mapped",[1588,1609]],[[64766,64766],"mapped",[1588,1610]],[[64767,64767],"mapped",[1581,1609]],[[64768,64768],"mapped",[1581,1610]],[[64769,64769],"mapped",[1580,1609]],[[64770,64770],"mapped",[1580,1610]],[[64771,64771],"mapped",[1582,1609]],[[64772,64772],"mapped",[1582,1610]],[[64773,64773],"mapped",[1589,1609]],[[64774,64774],"mapped",[1589,1610]],[[64775,64775],"mapped",[1590,1609]],[[64776,64776],"mapped",[1590,1610]],[[64777,64777],"mapped",[1588,1580]],[[64778,64778],"mapped",[1588,1581]],[[64779,64779],"mapped",[1588,1582]],[[64780,64780],"mapped",[1588,1605]],[[64781,64781],"mapped",[1588,1585]],[[64782,64782],"mapped",[1587,1585]],[[64783,64783],"mapped",[1589,1585]],[[64784,64784],"mapped",[1590,1585]],[[64785,64785],"mapped",[1591,1609]],[[64786,64786],"mapped",[1591,1610]],[[64787,64787],"mapped",[1593,1609]],[[64788,64788],"mapped",[1593,1610]],[[64789,64789],"mapped",[1594,1609]],[[64790,64790],"mapped",[1594,1610]],[[64791,64791],"mapped",[1587,1609]],[[64792,64792],"mapped",[1587,1610]],[[64793,64793],"mapped",[1588,1609]],[[64794,64794],"mapped",[1588,1610]],[[64795,64795],"mapped",[1581,1609]],[[64796,64796],"mapped",[1581,1610]],[[64797,64797],"mapped",[1580,1609]],[[64798,64798],"mapped",[1580,1610]],[[64799,64799],"mapped",[1582,1609]],[[64800,64800],"mapped",[1582,1610]],[[64801,64801],"mapped",[1589,1609]],[[64802,64802],"mapped",[1589,1610]],[[64803,64803],"mapped",[1590,1609]],[[64804,64804],"mapped",[1590,1610]],[[64805,64805],"mapped",[1588,1580]],[[64806,64806],"mapped",[1588,1581]],[[64807,64807],"mapped",[1588,1582]],[[64808,64808],"mapped",[1588,1605]],[[64809,64809],"mapped",[1588,1585]],[[64810,64810],"mapped",[1587,1585]],[[64811,64811],"mapped",[1589,1585]],[[64812,64812],"mapped",[1590,1585]],[[64813,64813],"mapped",[1588,1580]],[[64814,64814],"mapped",[1588,1581]],[[64815,64815],"mapped",[1588,1582]],[[64816,64816],"mapped",[1588,1605]],[[64817,64817],"mapped",[1587,1607]],[[64818,64818],"mapped",[1588,1607]],[[64819,64819],"mapped",[1591,1605]],[[64820,64820],"mapped",[1587,1580]],[[64821,64821],"mapped",[1587,1581]],[[64822,64822],"mapped",[1587,1582]],[[64823,64823],"mapped",[1588,1580]],[[64824,64824],"mapped",[1588,1581]],[[64825,64825],"mapped",[1588,1582]],[[64826,64826],"mapped",[1591,1605]],[[64827,64827],"mapped",[1592,1605]],[[64828,64829],"mapped",[1575,1611]],[[64830,64831],"valid",[],"NV8"],[[64832,64847],"disallowed"],[[64848,64848],"mapped",[1578,1580,1605]],[[64849,64850],"mapped",[1578,1581,1580]],[[64851,64851],"mapped",[1578,1581,1605]],[[64852,64852],"mapped",[1578,1582,1605]],[[64853,64853],"mapped",[1578,1605,1580]],[[64854,64854],"mapped",[1578,1605,1581]],[[64855,64855],"mapped",[1578,1605,1582]],[[64856,64857],"mapped",[1580,1605,1581]],[[64858,64858],"mapped",[1581,1605,1610]],[[64859,64859],"mapped",[1581,1605,1609]],[[64860,64860],"mapped",[1587,1581,1580]],[[64861,64861],"mapped",[1587,1580,1581]],[[64862,64862],"mapped",[1587,1580,1609]],[[64863,64864],"mapped",[1587,1605,1581]],[[64865,64865],"mapped",[1587,1605,1580]],[[64866,64867],"mapped",[1587,1605,1605]],[[64868,64869],"mapped",[1589,1581,1581]],[[64870,64870],"mapped",[1589,1605,1605]],[[64871,64872],"mapped",[1588,1581,1605]],[[64873,64873],"mapped",[1588,1580,1610]],[[64874,64875],"mapped",[1588,1605,1582]],[[64876,64877],"mapped",[1588,1605,1605]],[[64878,64878],"mapped",[1590,1581,1609]],[[64879,64880],"mapped",[1590,1582,1605]],[[64881,64882],"mapped",[1591,1605,1581]],[[64883,64883],"mapped",[1591,1605,1605]],[[64884,64884],"mapped",[1591,1605,1610]],[[64885,64885],"mapped",[1593,1580,1605]],[[64886,64887],"mapped",[1593,1605,1605]],[[64888,64888],"mapped",[1593,1605,1609]],[[64889,64889],"mapped",[1594,1605,1605]],[[64890,64890],"mapped",[1594,1605,1610]],[[64891,64891],"mapped",[1594,1605,1609]],[[64892,64893],"mapped",[1601,1582,1605]],[[64894,64894],"mapped",[1602,1605,1581]],[[64895,64895],"mapped",[1602,1605,1605]],[[64896,64896],"mapped",[1604,1581,1605]],[[64897,64897],"mapped",[1604,1581,1610]],[[64898,64898],"mapped",[1604,1581,1609]],[[64899,64900],"mapped",[1604,1580,1580]],[[64901,64902],"mapped",[1604,1582,1605]],[[64903,64904],"mapped",[1604,1605,1581]],[[64905,64905],"mapped",[1605,1581,1580]],[[64906,64906],"mapped",[1605,1581,1605]],[[64907,64907],"mapped",[1605,1581,1610]],[[64908,64908],"mapped",[1605,1580,1581]],[[64909,64909],"mapped",[1605,1580,1605]],[[64910,64910],"mapped",[1605,1582,1580]],[[64911,64911],"mapped",[1605,1582,1605]],[[64912,64913],"disallowed"],[[64914,64914],"mapped",[1605,1580,1582]],[[64915,64915],"mapped",[1607,1605,1580]],[[64916,64916],"mapped",[1607,1605,1605]],[[64917,64917],"mapped",[1606,1581,1605]],[[64918,64918],"mapped",[1606,1581,1609]],[[64919,64920],"mapped",[1606,1580,1605]],[[64921,64921],"mapped",[1606,1580,1609]],[[64922,64922],"mapped",[1606,1605,1610]],[[64923,64923],"mapped",[1606,1605,1609]],[[64924,64925],"mapped",[1610,1605,1605]],[[64926,64926],"mapped",[1576,1582,1610]],[[64927,64927],"mapped",[1578,1580,1610]],[[64928,64928],"mapped",[1578,1580,1609]],[[64929,64929],"mapped",[1578,1582,1610]],[[64930,64930],"mapped",[1578,1582,1609]],[[64931,64931],"mapped",[1578,1605,1610]],[[64932,64932],"mapped",[1578,1605,1609]],[[64933,64933],"mapped",[1580,1605,1610]],[[64934,64934],"mapped",[1580,1581,1609]],[[64935,64935],"mapped",[1580,1605,1609]],[[64936,64936],"mapped",[1587,1582,1609]],[[64937,64937],"mapped",[1589,1581,1610]],[[64938,64938],"mapped",[1588,1581,1610]],[[64939,64939],"mapped",[1590,1581,1610]],[[64940,64940],"mapped",[1604,1580,1610]],[[64941,64941],"mapped",[1604,1605,1610]],[[64942,64942],"mapped",[1610,1581,1610]],[[64943,64943],"mapped",[1610,1580,1610]],[[64944,64944],"mapped",[1610,1605,1610]],[[64945,64945],"mapped",[1605,1605,1610]],[[64946,64946],"mapped",[1602,1605,1610]],[[64947,64947],"mapped",[1606,1581,1610]],[[64948,64948],"mapped",[1602,1605,1581]],[[64949,64949],"mapped",[1604,1581,1605]],[[64950,64950],"mapped",[1593,1605,1610]],[[64951,64951],"mapped",[1603,1605,1610]],[[64952,64952],"mapped",[1606,1580,1581]],[[64953,64953],"mapped",[1605,1582,1610]],[[64954,64954],"mapped",[1604,1580,1605]],[[64955,64955],"mapped",[1603,1605,1605]],[[64956,64956],"mapped",[1604,1580,1605]],[[64957,64957],"mapped",[1606,1580,1581]],[[64958,64958],"mapped",[1580,1581,1610]],[[64959,64959],"mapped",[1581,1580,1610]],[[64960,64960],"mapped",[1605,1580,1610]],[[64961,64961],"mapped",[1601,1605,1610]],[[64962,64962],"mapped",[1576,1581,1610]],[[64963,64963],"mapped",[1603,1605,1605]],[[64964,64964],"mapped",[1593,1580,1605]],[[64965,64965],"mapped",[1589,1605,1605]],[[64966,64966],"mapped",[1587,1582,1610]],[[64967,64967],"mapped",[1606,1580,1610]],[[64968,64975],"disallowed"],[[64976,65007],"disallowed"],[[65008,65008],"mapped",[1589,1604,1746]],[[65009,65009],"mapped",[1602,1604,1746]],[[65010,65010],"mapped",[1575,1604,1604,1607]],[[65011,65011],"mapped",[1575,1603,1576,1585]],[[65012,65012],"mapped",[1605,1581,1605,1583]],[[65013,65013],"mapped",[1589,1604,1593,1605]],[[65014,65014],"mapped",[1585,1587,1608,1604]],[[65015,65015],"mapped",[1593,1604,1610,1607]],[[65016,65016],"mapped",[1608,1587,1604,1605]],[[65017,65017],"mapped",[1589,1604,1609]],[[65018,65018],"disallowed_STD3_mapped",[1589,1604,1609,32,1575,1604,1604,1607,32,1593,1604,1610,1607,32,1608,1587,1604,1605]],[[65019,65019],"disallowed_STD3_mapped",[1580,1604,32,1580,1604,1575,1604,1607]],[[65020,65020],"mapped",[1585,1740,1575,1604]],[[65021,65021],"valid",[],"NV8"],[[65022,65023],"disallowed"],[[65024,65039],"ignored"],[[65040,65040],"disallowed_STD3_mapped",[44]],[[65041,65041],"mapped",[12289]],[[65042,65042],"disallowed"],[[65043,65043],"disallowed_STD3_mapped",[58]],[[65044,65044],"disallowed_STD3_mapped",[59]],[[65045,65045],"disallowed_STD3_mapped",[33]],[[65046,65046],"disallowed_STD3_mapped",[63]],[[65047,65047],"mapped",[12310]],[[65048,65048],"mapped",[12311]],[[65049,65049],"disallowed"],[[65050,65055],"disallowed"],[[65056,65059],"valid"],[[65060,65062],"valid"],[[65063,65069],"valid"],[[65070,65071],"valid"],[[65072,65072],"disallowed"],[[65073,65073],"mapped",[8212]],[[65074,65074],"mapped",[8211]],[[65075,65076],"disallowed_STD3_mapped",[95]],[[65077,65077],"disallowed_STD3_mapped",[40]],[[65078,65078],"disallowed_STD3_mapped",[41]],[[65079,65079],"disallowed_STD3_mapped",[123]],[[65080,65080],"disallowed_STD3_mapped",[125]],[[65081,65081],"mapped",[12308]],[[65082,65082],"mapped",[12309]],[[65083,65083],"mapped",[12304]],[[65084,65084],"mapped",[12305]],[[65085,65085],"mapped",[12298]],[[65086,65086],"mapped",[12299]],[[65087,65087],"mapped",[12296]],[[65088,65088],"mapped",[12297]],[[65089,65089],"mapped",[12300]],[[65090,65090],"mapped",[12301]],[[65091,65091],"mapped",[12302]],[[65092,65092],"mapped",[12303]],[[65093,65094],"valid",[],"NV8"],[[65095,65095],"disallowed_STD3_mapped",[91]],[[65096,65096],"disallowed_STD3_mapped",[93]],[[65097,65100],"disallowed_STD3_mapped",[32,773]],[[65101,65103],"disallowed_STD3_mapped",[95]],[[65104,65104],"disallowed_STD3_mapped",[44]],[[65105,65105],"mapped",[12289]],[[65106,65106],"disallowed"],[[65107,65107],"disallowed"],[[65108,65108],"disallowed_STD3_mapped",[59]],[[65109,65109],"disallowed_STD3_mapped",[58]],[[65110,65110],"disallowed_STD3_mapped",[63]],[[65111,65111],"disallowed_STD3_mapped",[33]],[[65112,65112],"mapped",[8212]],[[65113,65113],"disallowed_STD3_mapped",[40]],[[65114,65114],"disallowed_STD3_mapped",[41]],[[65115,65115],"disallowed_STD3_mapped",[123]],[[65116,65116],"disallowed_STD3_mapped",[125]],[[65117,65117],"mapped",[12308]],[[65118,65118],"mapped",[12309]],[[65119,65119],"disallowed_STD3_mapped",[35]],[[65120,65120],"disallowed_STD3_mapped",[38]],[[65121,65121],"disallowed_STD3_mapped",[42]],[[65122,65122],"disallowed_STD3_mapped",[43]],[[65123,65123],"mapped",[45]],[[65124,65124],"disallowed_STD3_mapped",[60]],[[65125,65125],"disallowed_STD3_mapped",[62]],[[65126,65126],"disallowed_STD3_mapped",[61]],[[65127,65127],"disallowed"],[[65128,65128],"disallowed_STD3_mapped",[92]],[[65129,65129],"disallowed_STD3_mapped",[36]],[[65130,65130],"disallowed_STD3_mapped",[37]],[[65131,65131],"disallowed_STD3_mapped",[64]],[[65132,65135],"disallowed"],[[65136,65136],"disallowed_STD3_mapped",[32,1611]],[[65137,65137],"mapped",[1600,1611]],[[65138,65138],"disallowed_STD3_mapped",[32,1612]],[[65139,65139],"valid"],[[65140,65140],"disallowed_STD3_mapped",[32,1613]],[[65141,65141],"disallowed"],[[65142,65142],"disallowed_STD3_mapped",[32,1614]],[[65143,65143],"mapped",[1600,1614]],[[65144,65144],"disallowed_STD3_mapped",[32,1615]],[[65145,65145],"mapped",[1600,1615]],[[65146,65146],"disallowed_STD3_mapped",[32,1616]],[[65147,65147],"mapped",[1600,1616]],[[65148,65148],"disallowed_STD3_mapped",[32,1617]],[[65149,65149],"mapped",[1600,1617]],[[65150,65150],"disallowed_STD3_mapped",[32,1618]],[[65151,65151],"mapped",[1600,1618]],[[65152,65152],"mapped",[1569]],[[65153,65154],"mapped",[1570]],[[65155,65156],"mapped",[1571]],[[65157,65158],"mapped",[1572]],[[65159,65160],"mapped",[1573]],[[65161,65164],"mapped",[1574]],[[65165,65166],"mapped",[1575]],[[65167,65170],"mapped",[1576]],[[65171,65172],"mapped",[1577]],[[65173,65176],"mapped",[1578]],[[65177,65180],"mapped",[1579]],[[65181,65184],"mapped",[1580]],[[65185,65188],"mapped",[1581]],[[65189,65192],"mapped",[1582]],[[65193,65194],"mapped",[1583]],[[65195,65196],"mapped",[1584]],[[65197,65198],"mapped",[1585]],[[65199,65200],"mapped",[1586]],[[65201,65204],"mapped",[1587]],[[65205,65208],"mapped",[1588]],[[65209,65212],"mapped",[1589]],[[65213,65216],"mapped",[1590]],[[65217,65220],"mapped",[1591]],[[65221,65224],"mapped",[1592]],[[65225,65228],"mapped",[1593]],[[65229,65232],"mapped",[1594]],[[65233,65236],"mapped",[1601]],[[65237,65240],"mapped",[1602]],[[65241,65244],"mapped",[1603]],[[65245,65248],"mapped",[1604]],[[65249,65252],"mapped",[1605]],[[65253,65256],"mapped",[1606]],[[65257,65260],"mapped",[1607]],[[65261,65262],"mapped",[1608]],[[65263,65264],"mapped",[1609]],[[65265,65268],"mapped",[1610]],[[65269,65270],"mapped",[1604,1570]],[[65271,65272],"mapped",[1604,1571]],[[65273,65274],"mapped",[1604,1573]],[[65275,65276],"mapped",[1604,1575]],[[65277,65278],"disallowed"],[[65279,65279],"ignored"],[[65280,65280],"disallowed"],[[65281,65281],"disallowed_STD3_mapped",[33]],[[65282,65282],"disallowed_STD3_mapped",[34]],[[65283,65283],"disallowed_STD3_mapped",[35]],[[65284,65284],"disallowed_STD3_mapped",[36]],[[65285,65285],"disallowed_STD3_mapped",[37]],[[65286,65286],"disallowed_STD3_mapped",[38]],[[65287,65287],"disallowed_STD3_mapped",[39]],[[65288,65288],"disallowed_STD3_mapped",[40]],[[65289,65289],"disallowed_STD3_mapped",[41]],[[65290,65290],"disallowed_STD3_mapped",[42]],[[65291,65291],"disallowed_STD3_mapped",[43]],[[65292,65292],"disallowed_STD3_mapped",[44]],[[65293,65293],"mapped",[45]],[[65294,65294],"mapped",[46]],[[65295,65295],"disallowed_STD3_mapped",[47]],[[65296,65296],"mapped",[48]],[[65297,65297],"mapped",[49]],[[65298,65298],"mapped",[50]],[[65299,65299],"mapped",[51]],[[65300,65300],"mapped",[52]],[[65301,65301],"mapped",[53]],[[65302,65302],"mapped",[54]],[[65303,65303],"mapped",[55]],[[65304,65304],"mapped",[56]],[[65305,65305],"mapped",[57]],[[65306,65306],"disallowed_STD3_mapped",[58]],[[65307,65307],"disallowed_STD3_mapped",[59]],[[65308,65308],"disallowed_STD3_mapped",[60]],[[65309,65309],"disallowed_STD3_mapped",[61]],[[65310,65310],"disallowed_STD3_mapped",[62]],[[65311,65311],"disallowed_STD3_mapped",[63]],[[65312,65312],"disallowed_STD3_mapped",[64]],[[65313,65313],"mapped",[97]],[[65314,65314],"mapped",[98]],[[65315,65315],"mapped",[99]],[[65316,65316],"mapped",[100]],[[65317,65317],"mapped",[101]],[[65318,65318],"mapped",[102]],[[65319,65319],"mapped",[103]],[[65320,65320],"mapped",[104]],[[65321,65321],"mapped",[105]],[[65322,65322],"mapped",[106]],[[65323,65323],"mapped",[107]],[[65324,65324],"mapped",[108]],[[65325,65325],"mapped",[109]],[[65326,65326],"mapped",[110]],[[65327,65327],"mapped",[111]],[[65328,65328],"mapped",[112]],[[65329,65329],"mapped",[113]],[[65330,65330],"mapped",[114]],[[65331,65331],"mapped",[115]],[[65332,65332],"mapped",[116]],[[65333,65333],"mapped",[117]],[[65334,65334],"mapped",[118]],[[65335,65335],"mapped",[119]],[[65336,65336],"mapped",[120]],[[65337,65337],"mapped",[121]],[[65338,65338],"mapped",[122]],[[65339,65339],"disallowed_STD3_mapped",[91]],[[65340,65340],"disallowed_STD3_mapped",[92]],[[65341,65341],"disallowed_STD3_mapped",[93]],[[65342,65342],"disallowed_STD3_mapped",[94]],[[65343,65343],"disallowed_STD3_mapped",[95]],[[65344,65344],"disallowed_STD3_mapped",[96]],[[65345,65345],"mapped",[97]],[[65346,65346],"mapped",[98]],[[65347,65347],"mapped",[99]],[[65348,65348],"mapped",[100]],[[65349,65349],"mapped",[101]],[[65350,65350],"mapped",[102]],[[65351,65351],"mapped",[103]],[[65352,65352],"mapped",[104]],[[65353,65353],"mapped",[105]],[[65354,65354],"mapped",[106]],[[65355,65355],"mapped",[107]],[[65356,65356],"mapped",[108]],[[65357,65357],"mapped",[109]],[[65358,65358],"mapped",[110]],[[65359,65359],"mapped",[111]],[[65360,65360],"mapped",[112]],[[65361,65361],"mapped",[113]],[[65362,65362],"mapped",[114]],[[65363,65363],"mapped",[115]],[[65364,65364],"mapped",[116]],[[65365,65365],"mapped",[117]],[[65366,65366],"mapped",[118]],[[65367,65367],"mapped",[119]],[[65368,65368],"mapped",[120]],[[65369,65369],"mapped",[121]],[[65370,65370],"mapped",[122]],[[65371,65371],"disallowed_STD3_mapped",[123]],[[65372,65372],"disallowed_STD3_mapped",[124]],[[65373,65373],"disallowed_STD3_mapped",[125]],[[65374,65374],"disallowed_STD3_mapped",[126]],[[65375,65375],"mapped",[10629]],[[65376,65376],"mapped",[10630]],[[65377,65377],"mapped",[46]],[[65378,65378],"mapped",[12300]],[[65379,65379],"mapped",[12301]],[[65380,65380],"mapped",[12289]],[[65381,65381],"mapped",[12539]],[[65382,65382],"mapped",[12530]],[[65383,65383],"mapped",[12449]],[[65384,65384],"mapped",[12451]],[[65385,65385],"mapped",[12453]],[[65386,65386],"mapped",[12455]],[[65387,65387],"mapped",[12457]],[[65388,65388],"mapped",[12515]],[[65389,65389],"mapped",[12517]],[[65390,65390],"mapped",[12519]],[[65391,65391],"mapped",[12483]],[[65392,65392],"mapped",[12540]],[[65393,65393],"mapped",[12450]],[[65394,65394],"mapped",[12452]],[[65395,65395],"mapped",[12454]],[[65396,65396],"mapped",[12456]],[[65397,65397],"mapped",[12458]],[[65398,65398],"mapped",[12459]],[[65399,65399],"mapped",[12461]],[[65400,65400],"mapped",[12463]],[[65401,65401],"mapped",[12465]],[[65402,65402],"mapped",[12467]],[[65403,65403],"mapped",[12469]],[[65404,65404],"mapped",[12471]],[[65405,65405],"mapped",[12473]],[[65406,65406],"mapped",[12475]],[[65407,65407],"mapped",[12477]],[[65408,65408],"mapped",[12479]],[[65409,65409],"mapped",[12481]],[[65410,65410],"mapped",[12484]],[[65411,65411],"mapped",[12486]],[[65412,65412],"mapped",[12488]],[[65413,65413],"mapped",[12490]],[[65414,65414],"mapped",[12491]],[[65415,65415],"mapped",[12492]],[[65416,65416],"mapped",[12493]],[[65417,65417],"mapped",[12494]],[[65418,65418],"mapped",[12495]],[[65419,65419],"mapped",[12498]],[[65420,65420],"mapped",[12501]],[[65421,65421],"mapped",[12504]],[[65422,65422],"mapped",[12507]],[[65423,65423],"mapped",[12510]],[[65424,65424],"mapped",[12511]],[[65425,65425],"mapped",[12512]],[[65426,65426],"mapped",[12513]],[[65427,65427],"mapped",[12514]],[[65428,65428],"mapped",[12516]],[[65429,65429],"mapped",[12518]],[[65430,65430],"mapped",[12520]],[[65431,65431],"mapped",[12521]],[[65432,65432],"mapped",[12522]],[[65433,65433],"mapped",[12523]],[[65434,65434],"mapped",[12524]],[[65435,65435],"mapped",[12525]],[[65436,65436],"mapped",[12527]],[[65437,65437],"mapped",[12531]],[[65438,65438],"mapped",[12441]],[[65439,65439],"mapped",[12442]],[[65440,65440],"disallowed"],[[65441,65441],"mapped",[4352]],[[65442,65442],"mapped",[4353]],[[65443,65443],"mapped",[4522]],[[65444,65444],"mapped",[4354]],[[65445,65445],"mapped",[4524]],[[65446,65446],"mapped",[4525]],[[65447,65447],"mapped",[4355]],[[65448,65448],"mapped",[4356]],[[65449,65449],"mapped",[4357]],[[65450,65450],"mapped",[4528]],[[65451,65451],"mapped",[4529]],[[65452,65452],"mapped",[4530]],[[65453,65453],"mapped",[4531]],[[65454,65454],"mapped",[4532]],[[65455,65455],"mapped",[4533]],[[65456,65456],"mapped",[4378]],[[65457,65457],"mapped",[4358]],[[65458,65458],"mapped",[4359]],[[65459,65459],"mapped",[4360]],[[65460,65460],"mapped",[4385]],[[65461,65461],"mapped",[4361]],[[65462,65462],"mapped",[4362]],[[65463,65463],"mapped",[4363]],[[65464,65464],"mapped",[4364]],[[65465,65465],"mapped",[4365]],[[65466,65466],"mapped",[4366]],[[65467,65467],"mapped",[4367]],[[65468,65468],"mapped",[4368]],[[65469,65469],"mapped",[4369]],[[65470,65470],"mapped",[4370]],[[65471,65473],"disallowed"],[[65474,65474],"mapped",[4449]],[[65475,65475],"mapped",[4450]],[[65476,65476],"mapped",[4451]],[[65477,65477],"mapped",[4452]],[[65478,65478],"mapped",[4453]],[[65479,65479],"mapped",[4454]],[[65480,65481],"disallowed"],[[65482,65482],"mapped",[4455]],[[65483,65483],"mapped",[4456]],[[65484,65484],"mapped",[4457]],[[65485,65485],"mapped",[4458]],[[65486,65486],"mapped",[4459]],[[65487,65487],"mapped",[4460]],[[65488,65489],"disallowed"],[[65490,65490],"mapped",[4461]],[[65491,65491],"mapped",[4462]],[[65492,65492],"mapped",[4463]],[[65493,65493],"mapped",[4464]],[[65494,65494],"mapped",[4465]],[[65495,65495],"mapped",[4466]],[[65496,65497],"disallowed"],[[65498,65498],"mapped",[4467]],[[65499,65499],"mapped",[4468]],[[65500,65500],"mapped",[4469]],[[65501,65503],"disallowed"],[[65504,65504],"mapped",[162]],[[65505,65505],"mapped",[163]],[[65506,65506],"mapped",[172]],[[65507,65507],"disallowed_STD3_mapped",[32,772]],[[65508,65508],"mapped",[166]],[[65509,65509],"mapped",[165]],[[65510,65510],"mapped",[8361]],[[65511,65511],"disallowed"],[[65512,65512],"mapped",[9474]],[[65513,65513],"mapped",[8592]],[[65514,65514],"mapped",[8593]],[[65515,65515],"mapped",[8594]],[[65516,65516],"mapped",[8595]],[[65517,65517],"mapped",[9632]],[[65518,65518],"mapped",[9675]],[[65519,65528],"disallowed"],[[65529,65531],"disallowed"],[[65532,65532],"disallowed"],[[65533,65533],"disallowed"],[[65534,65535],"disallowed"],[[65536,65547],"valid"],[[65548,65548],"disallowed"],[[65549,65574],"valid"],[[65575,65575],"disallowed"],[[65576,65594],"valid"],[[65595,65595],"disallowed"],[[65596,65597],"valid"],[[65598,65598],"disallowed"],[[65599,65613],"valid"],[[65614,65615],"disallowed"],[[65616,65629],"valid"],[[65630,65663],"disallowed"],[[65664,65786],"valid"],[[65787,65791],"disallowed"],[[65792,65794],"valid",[],"NV8"],[[65795,65798],"disallowed"],[[65799,65843],"valid",[],"NV8"],[[65844,65846],"disallowed"],[[65847,65855],"valid",[],"NV8"],[[65856,65930],"valid",[],"NV8"],[[65931,65932],"valid",[],"NV8"],[[65933,65935],"disallowed"],[[65936,65947],"valid",[],"NV8"],[[65948,65951],"disallowed"],[[65952,65952],"valid",[],"NV8"],[[65953,65999],"disallowed"],[[66000,66044],"valid",[],"NV8"],[[66045,66045],"valid"],[[66046,66175],"disallowed"],[[66176,66204],"valid"],[[66205,66207],"disallowed"],[[66208,66256],"valid"],[[66257,66271],"disallowed"],[[66272,66272],"valid"],[[66273,66299],"valid",[],"NV8"],[[66300,66303],"disallowed"],[[66304,66334],"valid"],[[66335,66335],"valid"],[[66336,66339],"valid",[],"NV8"],[[66340,66351],"disallowed"],[[66352,66368],"valid"],[[66369,66369],"valid",[],"NV8"],[[66370,66377],"valid"],[[66378,66378],"valid",[],"NV8"],[[66379,66383],"disallowed"],[[66384,66426],"valid"],[[66427,66431],"disallowed"],[[66432,66461],"valid"],[[66462,66462],"disallowed"],[[66463,66463],"valid",[],"NV8"],[[66464,66499],"valid"],[[66500,66503],"disallowed"],[[66504,66511],"valid"],[[66512,66517],"valid",[],"NV8"],[[66518,66559],"disallowed"],[[66560,66560],"mapped",[66600]],[[66561,66561],"mapped",[66601]],[[66562,66562],"mapped",[66602]],[[66563,66563],"mapped",[66603]],[[66564,66564],"mapped",[66604]],[[66565,66565],"mapped",[66605]],[[66566,66566],"mapped",[66606]],[[66567,66567],"mapped",[66607]],[[66568,66568],"mapped",[66608]],[[66569,66569],"mapped",[66609]],[[66570,66570],"mapped",[66610]],[[66571,66571],"mapped",[66611]],[[66572,66572],"mapped",[66612]],[[66573,66573],"mapped",[66613]],[[66574,66574],"mapped",[66614]],[[66575,66575],"mapped",[66615]],[[66576,66576],"mapped",[66616]],[[66577,66577],"mapped",[66617]],[[66578,66578],"mapped",[66618]],[[66579,66579],"mapped",[66619]],[[66580,66580],"mapped",[66620]],[[66581,66581],"mapped",[66621]],[[66582,66582],"mapped",[66622]],[[66583,66583],"mapped",[66623]],[[66584,66584],"mapped",[66624]],[[66585,66585],"mapped",[66625]],[[66586,66586],"mapped",[66626]],[[66587,66587],"mapped",[66627]],[[66588,66588],"mapped",[66628]],[[66589,66589],"mapped",[66629]],[[66590,66590],"mapped",[66630]],[[66591,66591],"mapped",[66631]],[[66592,66592],"mapped",[66632]],[[66593,66593],"mapped",[66633]],[[66594,66594],"mapped",[66634]],[[66595,66595],"mapped",[66635]],[[66596,66596],"mapped",[66636]],[[66597,66597],"mapped",[66637]],[[66598,66598],"mapped",[66638]],[[66599,66599],"mapped",[66639]],[[66600,66637],"valid"],[[66638,66717],"valid"],[[66718,66719],"disallowed"],[[66720,66729],"valid"],[[66730,66815],"disallowed"],[[66816,66855],"valid"],[[66856,66863],"disallowed"],[[66864,66915],"valid"],[[66916,66926],"disallowed"],[[66927,66927],"valid",[],"NV8"],[[66928,67071],"disallowed"],[[67072,67382],"valid"],[[67383,67391],"disallowed"],[[67392,67413],"valid"],[[67414,67423],"disallowed"],[[67424,67431],"valid"],[[67432,67583],"disallowed"],[[67584,67589],"valid"],[[67590,67591],"disallowed"],[[67592,67592],"valid"],[[67593,67593],"disallowed"],[[67594,67637],"valid"],[[67638,67638],"disallowed"],[[67639,67640],"valid"],[[67641,67643],"disallowed"],[[67644,67644],"valid"],[[67645,67646],"disallowed"],[[67647,67647],"valid"],[[67648,67669],"valid"],[[67670,67670],"disallowed"],[[67671,67679],"valid",[],"NV8"],[[67680,67702],"valid"],[[67703,67711],"valid",[],"NV8"],[[67712,67742],"valid"],[[67743,67750],"disallowed"],[[67751,67759],"valid",[],"NV8"],[[67760,67807],"disallowed"],[[67808,67826],"valid"],[[67827,67827],"disallowed"],[[67828,67829],"valid"],[[67830,67834],"disallowed"],[[67835,67839],"valid",[],"NV8"],[[67840,67861],"valid"],[[67862,67865],"valid",[],"NV8"],[[67866,67867],"valid",[],"NV8"],[[67868,67870],"disallowed"],[[67871,67871],"valid",[],"NV8"],[[67872,67897],"valid"],[[67898,67902],"disallowed"],[[67903,67903],"valid",[],"NV8"],[[67904,67967],"disallowed"],[[67968,68023],"valid"],[[68024,68027],"disallowed"],[[68028,68029],"valid",[],"NV8"],[[68030,68031],"valid"],[[68032,68047],"valid",[],"NV8"],[[68048,68049],"disallowed"],[[68050,68095],"valid",[],"NV8"],[[68096,68099],"valid"],[[68100,68100],"disallowed"],[[68101,68102],"valid"],[[68103,68107],"disallowed"],[[68108,68115],"valid"],[[68116,68116],"disallowed"],[[68117,68119],"valid"],[[68120,68120],"disallowed"],[[68121,68147],"valid"],[[68148,68151],"disallowed"],[[68152,68154],"valid"],[[68155,68158],"disallowed"],[[68159,68159],"valid"],[[68160,68167],"valid",[],"NV8"],[[68168,68175],"disallowed"],[[68176,68184],"valid",[],"NV8"],[[68185,68191],"disallowed"],[[68192,68220],"valid"],[[68221,68223],"valid",[],"NV8"],[[68224,68252],"valid"],[[68253,68255],"valid",[],"NV8"],[[68256,68287],"disallowed"],[[68288,68295],"valid"],[[68296,68296],"valid",[],"NV8"],[[68297,68326],"valid"],[[68327,68330],"disallowed"],[[68331,68342],"valid",[],"NV8"],[[68343,68351],"disallowed"],[[68352,68405],"valid"],[[68406,68408],"disallowed"],[[68409,68415],"valid",[],"NV8"],[[68416,68437],"valid"],[[68438,68439],"disallowed"],[[68440,68447],"valid",[],"NV8"],[[68448,68466],"valid"],[[68467,68471],"disallowed"],[[68472,68479],"valid",[],"NV8"],[[68480,68497],"valid"],[[68498,68504],"disallowed"],[[68505,68508],"valid",[],"NV8"],[[68509,68520],"disallowed"],[[68521,68527],"valid",[],"NV8"],[[68528,68607],"disallowed"],[[68608,68680],"valid"],[[68681,68735],"disallowed"],[[68736,68736],"mapped",[68800]],[[68737,68737],"mapped",[68801]],[[68738,68738],"mapped",[68802]],[[68739,68739],"mapped",[68803]],[[68740,68740],"mapped",[68804]],[[68741,68741],"mapped",[68805]],[[68742,68742],"mapped",[68806]],[[68743,68743],"mapped",[68807]],[[68744,68744],"mapped",[68808]],[[68745,68745],"mapped",[68809]],[[68746,68746],"mapped",[68810]],[[68747,68747],"mapped",[68811]],[[68748,68748],"mapped",[68812]],[[68749,68749],"mapped",[68813]],[[68750,68750],"mapped",[68814]],[[68751,68751],"mapped",[68815]],[[68752,68752],"mapped",[68816]],[[68753,68753],"mapped",[68817]],[[68754,68754],"mapped",[68818]],[[68755,68755],"mapped",[68819]],[[68756,68756],"mapped",[68820]],[[68757,68757],"mapped",[68821]],[[68758,68758],"mapped",[68822]],[[68759,68759],"mapped",[68823]],[[68760,68760],"mapped",[68824]],[[68761,68761],"mapped",[68825]],[[68762,68762],"mapped",[68826]],[[68763,68763],"mapped",[68827]],[[68764,68764],"mapped",[68828]],[[68765,68765],"mapped",[68829]],[[68766,68766],"mapped",[68830]],[[68767,68767],"mapped",[68831]],[[68768,68768],"mapped",[68832]],[[68769,68769],"mapped",[68833]],[[68770,68770],"mapped",[68834]],[[68771,68771],"mapped",[68835]],[[68772,68772],"mapped",[68836]],[[68773,68773],"mapped",[68837]],[[68774,68774],"mapped",[68838]],[[68775,68775],"mapped",[68839]],[[68776,68776],"mapped",[68840]],[[68777,68777],"mapped",[68841]],[[68778,68778],"mapped",[68842]],[[68779,68779],"mapped",[68843]],[[68780,68780],"mapped",[68844]],[[68781,68781],"mapped",[68845]],[[68782,68782],"mapped",[68846]],[[68783,68783],"mapped",[68847]],[[68784,68784],"mapped",[68848]],[[68785,68785],"mapped",[68849]],[[68786,68786],"mapped",[68850]],[[68787,68799],"disallowed"],[[68800,68850],"valid"],[[68851,68857],"disallowed"],[[68858,68863],"valid",[],"NV8"],[[68864,69215],"disallowed"],[[69216,69246],"valid",[],"NV8"],[[69247,69631],"disallowed"],[[69632,69702],"valid"],[[69703,69709],"valid",[],"NV8"],[[69710,69713],"disallowed"],[[69714,69733],"valid",[],"NV8"],[[69734,69743],"valid"],[[69744,69758],"disallowed"],[[69759,69759],"valid"],[[69760,69818],"valid"],[[69819,69820],"valid",[],"NV8"],[[69821,69821],"disallowed"],[[69822,69825],"valid",[],"NV8"],[[69826,69839],"disallowed"],[[69840,69864],"valid"],[[69865,69871],"disallowed"],[[69872,69881],"valid"],[[69882,69887],"disallowed"],[[69888,69940],"valid"],[[69941,69941],"disallowed"],[[69942,69951],"valid"],[[69952,69955],"valid",[],"NV8"],[[69956,69967],"disallowed"],[[69968,70003],"valid"],[[70004,70005],"valid",[],"NV8"],[[70006,70006],"valid"],[[70007,70015],"disallowed"],[[70016,70084],"valid"],[[70085,70088],"valid",[],"NV8"],[[70089,70089],"valid",[],"NV8"],[[70090,70092],"valid"],[[70093,70093],"valid",[],"NV8"],[[70094,70095],"disallowed"],[[70096,70105],"valid"],[[70106,70106],"valid"],[[70107,70107],"valid",[],"NV8"],[[70108,70108],"valid"],[[70109,70111],"valid",[],"NV8"],[[70112,70112],"disallowed"],[[70113,70132],"valid",[],"NV8"],[[70133,70143],"disallowed"],[[70144,70161],"valid"],[[70162,70162],"disallowed"],[[70163,70199],"valid"],[[70200,70205],"valid",[],"NV8"],[[70206,70271],"disallowed"],[[70272,70278],"valid"],[[70279,70279],"disallowed"],[[70280,70280],"valid"],[[70281,70281],"disallowed"],[[70282,70285],"valid"],[[70286,70286],"disallowed"],[[70287,70301],"valid"],[[70302,70302],"disallowed"],[[70303,70312],"valid"],[[70313,70313],"valid",[],"NV8"],[[70314,70319],"disallowed"],[[70320,70378],"valid"],[[70379,70383],"disallowed"],[[70384,70393],"valid"],[[70394,70399],"disallowed"],[[70400,70400],"valid"],[[70401,70403],"valid"],[[70404,70404],"disallowed"],[[70405,70412],"valid"],[[70413,70414],"disallowed"],[[70415,70416],"valid"],[[70417,70418],"disallowed"],[[70419,70440],"valid"],[[70441,70441],"disallowed"],[[70442,70448],"valid"],[[70449,70449],"disallowed"],[[70450,70451],"valid"],[[70452,70452],"disallowed"],[[70453,70457],"valid"],[[70458,70459],"disallowed"],[[70460,70468],"valid"],[[70469,70470],"disallowed"],[[70471,70472],"valid"],[[70473,70474],"disallowed"],[[70475,70477],"valid"],[[70478,70479],"disallowed"],[[70480,70480],"valid"],[[70481,70486],"disallowed"],[[70487,70487],"valid"],[[70488,70492],"disallowed"],[[70493,70499],"valid"],[[70500,70501],"disallowed"],[[70502,70508],"valid"],[[70509,70511],"disallowed"],[[70512,70516],"valid"],[[70517,70783],"disallowed"],[[70784,70853],"valid"],[[70854,70854],"valid",[],"NV8"],[[70855,70855],"valid"],[[70856,70863],"disallowed"],[[70864,70873],"valid"],[[70874,71039],"disallowed"],[[71040,71093],"valid"],[[71094,71095],"disallowed"],[[71096,71104],"valid"],[[71105,71113],"valid",[],"NV8"],[[71114,71127],"valid",[],"NV8"],[[71128,71133],"valid"],[[71134,71167],"disallowed"],[[71168,71232],"valid"],[[71233,71235],"valid",[],"NV8"],[[71236,71236],"valid"],[[71237,71247],"disallowed"],[[71248,71257],"valid"],[[71258,71295],"disallowed"],[[71296,71351],"valid"],[[71352,71359],"disallowed"],[[71360,71369],"valid"],[[71370,71423],"disallowed"],[[71424,71449],"valid"],[[71450,71452],"disallowed"],[[71453,71467],"valid"],[[71468,71471],"disallowed"],[[71472,71481],"valid"],[[71482,71487],"valid",[],"NV8"],[[71488,71839],"disallowed"],[[71840,71840],"mapped",[71872]],[[71841,71841],"mapped",[71873]],[[71842,71842],"mapped",[71874]],[[71843,71843],"mapped",[71875]],[[71844,71844],"mapped",[71876]],[[71845,71845],"mapped",[71877]],[[71846,71846],"mapped",[71878]],[[71847,71847],"mapped",[71879]],[[71848,71848],"mapped",[71880]],[[71849,71849],"mapped",[71881]],[[71850,71850],"mapped",[71882]],[[71851,71851],"mapped",[71883]],[[71852,71852],"mapped",[71884]],[[71853,71853],"mapped",[71885]],[[71854,71854],"mapped",[71886]],[[71855,71855],"mapped",[71887]],[[71856,71856],"mapped",[71888]],[[71857,71857],"mapped",[71889]],[[71858,71858],"mapped",[71890]],[[71859,71859],"mapped",[71891]],[[71860,71860],"mapped",[71892]],[[71861,71861],"mapped",[71893]],[[71862,71862],"mapped",[71894]],[[71863,71863],"mapped",[71895]],[[71864,71864],"mapped",[71896]],[[71865,71865],"mapped",[71897]],[[71866,71866],"mapped",[71898]],[[71867,71867],"mapped",[71899]],[[71868,71868],"mapped",[71900]],[[71869,71869],"mapped",[71901]],[[71870,71870],"mapped",[71902]],[[71871,71871],"mapped",[71903]],[[71872,71913],"valid"],[[71914,71922],"valid",[],"NV8"],[[71923,71934],"disallowed"],[[71935,71935],"valid"],[[71936,72383],"disallowed"],[[72384,72440],"valid"],[[72441,73727],"disallowed"],[[73728,74606],"valid"],[[74607,74648],"valid"],[[74649,74649],"valid"],[[74650,74751],"disallowed"],[[74752,74850],"valid",[],"NV8"],[[74851,74862],"valid",[],"NV8"],[[74863,74863],"disallowed"],[[74864,74867],"valid",[],"NV8"],[[74868,74868],"valid",[],"NV8"],[[74869,74879],"disallowed"],[[74880,75075],"valid"],[[75076,77823],"disallowed"],[[77824,78894],"valid"],[[78895,82943],"disallowed"],[[82944,83526],"valid"],[[83527,92159],"disallowed"],[[92160,92728],"valid"],[[92729,92735],"disallowed"],[[92736,92766],"valid"],[[92767,92767],"disallowed"],[[92768,92777],"valid"],[[92778,92781],"disallowed"],[[92782,92783],"valid",[],"NV8"],[[92784,92879],"disallowed"],[[92880,92909],"valid"],[[92910,92911],"disallowed"],[[92912,92916],"valid"],[[92917,92917],"valid",[],"NV8"],[[92918,92927],"disallowed"],[[92928,92982],"valid"],[[92983,92991],"valid",[],"NV8"],[[92992,92995],"valid"],[[92996,92997],"valid",[],"NV8"],[[92998,93007],"disallowed"],[[93008,93017],"valid"],[[93018,93018],"disallowed"],[[93019,93025],"valid",[],"NV8"],[[93026,93026],"disallowed"],[[93027,93047],"valid"],[[93048,93052],"disallowed"],[[93053,93071],"valid"],[[93072,93951],"disallowed"],[[93952,94020],"valid"],[[94021,94031],"disallowed"],[[94032,94078],"valid"],[[94079,94094],"disallowed"],[[94095,94111],"valid"],[[94112,110591],"disallowed"],[[110592,110593],"valid"],[[110594,113663],"disallowed"],[[113664,113770],"valid"],[[113771,113775],"disallowed"],[[113776,113788],"valid"],[[113789,113791],"disallowed"],[[113792,113800],"valid"],[[113801,113807],"disallowed"],[[113808,113817],"valid"],[[113818,113819],"disallowed"],[[113820,113820],"valid",[],"NV8"],[[113821,113822],"valid"],[[113823,113823],"valid",[],"NV8"],[[113824,113827],"ignored"],[[113828,118783],"disallowed"],[[118784,119029],"valid",[],"NV8"],[[119030,119039],"disallowed"],[[119040,119078],"valid",[],"NV8"],[[119079,119080],"disallowed"],[[119081,119081],"valid",[],"NV8"],[[119082,119133],"valid",[],"NV8"],[[119134,119134],"mapped",[119127,119141]],[[119135,119135],"mapped",[119128,119141]],[[119136,119136],"mapped",[119128,119141,119150]],[[119137,119137],"mapped",[119128,119141,119151]],[[119138,119138],"mapped",[119128,119141,119152]],[[119139,119139],"mapped",[119128,119141,119153]],[[119140,119140],"mapped",[119128,119141,119154]],[[119141,119154],"valid",[],"NV8"],[[119155,119162],"disallowed"],[[119163,119226],"valid",[],"NV8"],[[119227,119227],"mapped",[119225,119141]],[[119228,119228],"mapped",[119226,119141]],[[119229,119229],"mapped",[119225,119141,119150]],[[119230,119230],"mapped",[119226,119141,119150]],[[119231,119231],"mapped",[119225,119141,119151]],[[119232,119232],"mapped",[119226,119141,119151]],[[119233,119261],"valid",[],"NV8"],[[119262,119272],"valid",[],"NV8"],[[119273,119295],"disallowed"],[[119296,119365],"valid",[],"NV8"],[[119366,119551],"disallowed"],[[119552,119638],"valid",[],"NV8"],[[119639,119647],"disallowed"],[[119648,119665],"valid",[],"NV8"],[[119666,119807],"disallowed"],[[119808,119808],"mapped",[97]],[[119809,119809],"mapped",[98]],[[119810,119810],"mapped",[99]],[[119811,119811],"mapped",[100]],[[119812,119812],"mapped",[101]],[[119813,119813],"mapped",[102]],[[119814,119814],"mapped",[103]],[[119815,119815],"mapped",[104]],[[119816,119816],"mapped",[105]],[[119817,119817],"mapped",[106]],[[119818,119818],"mapped",[107]],[[119819,119819],"mapped",[108]],[[119820,119820],"mapped",[109]],[[119821,119821],"mapped",[110]],[[119822,119822],"mapped",[111]],[[119823,119823],"mapped",[112]],[[119824,119824],"mapped",[113]],[[119825,119825],"mapped",[114]],[[119826,119826],"mapped",[115]],[[119827,119827],"mapped",[116]],[[119828,119828],"mapped",[117]],[[119829,119829],"mapped",[118]],[[119830,119830],"mapped",[119]],[[119831,119831],"mapped",[120]],[[119832,119832],"mapped",[121]],[[119833,119833],"mapped",[122]],[[119834,119834],"mapped",[97]],[[119835,119835],"mapped",[98]],[[119836,119836],"mapped",[99]],[[119837,119837],"mapped",[100]],[[119838,119838],"mapped",[101]],[[119839,119839],"mapped",[102]],[[119840,119840],"mapped",[103]],[[119841,119841],"mapped",[104]],[[119842,119842],"mapped",[105]],[[119843,119843],"mapped",[106]],[[119844,119844],"mapped",[107]],[[119845,119845],"mapped",[108]],[[119846,119846],"mapped",[109]],[[119847,119847],"mapped",[110]],[[119848,119848],"mapped",[111]],[[119849,119849],"mapped",[112]],[[119850,119850],"mapped",[113]],[[119851,119851],"mapped",[114]],[[119852,119852],"mapped",[115]],[[119853,119853],"mapped",[116]],[[119854,119854],"mapped",[117]],[[119855,119855],"mapped",[118]],[[119856,119856],"mapped",[119]],[[119857,119857],"mapped",[120]],[[119858,119858],"mapped",[121]],[[119859,119859],"mapped",[122]],[[119860,119860],"mapped",[97]],[[119861,119861],"mapped",[98]],[[119862,119862],"mapped",[99]],[[119863,119863],"mapped",[100]],[[119864,119864],"mapped",[101]],[[119865,119865],"mapped",[102]],[[119866,119866],"mapped",[103]],[[119867,119867],"mapped",[104]],[[119868,119868],"mapped",[105]],[[119869,119869],"mapped",[106]],[[119870,119870],"mapped",[107]],[[119871,119871],"mapped",[108]],[[119872,119872],"mapped",[109]],[[119873,119873],"mapped",[110]],[[119874,119874],"mapped",[111]],[[119875,119875],"mapped",[112]],[[119876,119876],"mapped",[113]],[[119877,119877],"mapped",[114]],[[119878,119878],"mapped",[115]],[[119879,119879],"mapped",[116]],[[119880,119880],"mapped",[117]],[[119881,119881],"mapped",[118]],[[119882,119882],"mapped",[119]],[[119883,119883],"mapped",[120]],[[119884,119884],"mapped",[121]],[[119885,119885],"mapped",[122]],[[119886,119886],"mapped",[97]],[[119887,119887],"mapped",[98]],[[119888,119888],"mapped",[99]],[[119889,119889],"mapped",[100]],[[119890,119890],"mapped",[101]],[[119891,119891],"mapped",[102]],[[119892,119892],"mapped",[103]],[[119893,119893],"disallowed"],[[119894,119894],"mapped",[105]],[[119895,119895],"mapped",[106]],[[119896,119896],"mapped",[107]],[[119897,119897],"mapped",[108]],[[119898,119898],"mapped",[109]],[[119899,119899],"mapped",[110]],[[119900,119900],"mapped",[111]],[[119901,119901],"mapped",[112]],[[119902,119902],"mapped",[113]],[[119903,119903],"mapped",[114]],[[119904,119904],"mapped",[115]],[[119905,119905],"mapped",[116]],[[119906,119906],"mapped",[117]],[[119907,119907],"mapped",[118]],[[119908,119908],"mapped",[119]],[[119909,119909],"mapped",[120]],[[119910,119910],"mapped",[121]],[[119911,119911],"mapped",[122]],[[119912,119912],"mapped",[97]],[[119913,119913],"mapped",[98]],[[119914,119914],"mapped",[99]],[[119915,119915],"mapped",[100]],[[119916,119916],"mapped",[101]],[[119917,119917],"mapped",[102]],[[119918,119918],"mapped",[103]],[[119919,119919],"mapped",[104]],[[119920,119920],"mapped",[105]],[[119921,119921],"mapped",[106]],[[119922,119922],"mapped",[107]],[[119923,119923],"mapped",[108]],[[119924,119924],"mapped",[109]],[[119925,119925],"mapped",[110]],[[119926,119926],"mapped",[111]],[[119927,119927],"mapped",[112]],[[119928,119928],"mapped",[113]],[[119929,119929],"mapped",[114]],[[119930,119930],"mapped",[115]],[[119931,119931],"mapped",[116]],[[119932,119932],"mapped",[117]],[[119933,119933],"mapped",[118]],[[119934,119934],"mapped",[119]],[[119935,119935],"mapped",[120]],[[119936,119936],"mapped",[121]],[[119937,119937],"mapped",[122]],[[119938,119938],"mapped",[97]],[[119939,119939],"mapped",[98]],[[119940,119940],"mapped",[99]],[[119941,119941],"mapped",[100]],[[119942,119942],"mapped",[101]],[[119943,119943],"mapped",[102]],[[119944,119944],"mapped",[103]],[[119945,119945],"mapped",[104]],[[119946,119946],"mapped",[105]],[[119947,119947],"mapped",[106]],[[119948,119948],"mapped",[107]],[[119949,119949],"mapped",[108]],[[119950,119950],"mapped",[109]],[[119951,119951],"mapped",[110]],[[119952,119952],"mapped",[111]],[[119953,119953],"mapped",[112]],[[119954,119954],"mapped",[113]],[[119955,119955],"mapped",[114]],[[119956,119956],"mapped",[115]],[[119957,119957],"mapped",[116]],[[119958,119958],"mapped",[117]],[[119959,119959],"mapped",[118]],[[119960,119960],"mapped",[119]],[[119961,119961],"mapped",[120]],[[119962,119962],"mapped",[121]],[[119963,119963],"mapped",[122]],[[119964,119964],"mapped",[97]],[[119965,119965],"disallowed"],[[119966,119966],"mapped",[99]],[[119967,119967],"mapped",[100]],[[119968,119969],"disallowed"],[[119970,119970],"mapped",[103]],[[119971,119972],"disallowed"],[[119973,119973],"mapped",[106]],[[119974,119974],"mapped",[107]],[[119975,119976],"disallowed"],[[119977,119977],"mapped",[110]],[[119978,119978],"mapped",[111]],[[119979,119979],"mapped",[112]],[[119980,119980],"mapped",[113]],[[119981,119981],"disallowed"],[[119982,119982],"mapped",[115]],[[119983,119983],"mapped",[116]],[[119984,119984],"mapped",[117]],[[119985,119985],"mapped",[118]],[[119986,119986],"mapped",[119]],[[119987,119987],"mapped",[120]],[[119988,119988],"mapped",[121]],[[119989,119989],"mapped",[122]],[[119990,119990],"mapped",[97]],[[119991,119991],"mapped",[98]],[[119992,119992],"mapped",[99]],[[119993,119993],"mapped",[100]],[[119994,119994],"disallowed"],[[119995,119995],"mapped",[102]],[[119996,119996],"disallowed"],[[119997,119997],"mapped",[104]],[[119998,119998],"mapped",[105]],[[119999,119999],"mapped",[106]],[[120000,120000],"mapped",[107]],[[120001,120001],"mapped",[108]],[[120002,120002],"mapped",[109]],[[120003,120003],"mapped",[110]],[[120004,120004],"disallowed"],[[120005,120005],"mapped",[112]],[[120006,120006],"mapped",[113]],[[120007,120007],"mapped",[114]],[[120008,120008],"mapped",[115]],[[120009,120009],"mapped",[116]],[[120010,120010],"mapped",[117]],[[120011,120011],"mapped",[118]],[[120012,120012],"mapped",[119]],[[120013,120013],"mapped",[120]],[[120014,120014],"mapped",[121]],[[120015,120015],"mapped",[122]],[[120016,120016],"mapped",[97]],[[120017,120017],"mapped",[98]],[[120018,120018],"mapped",[99]],[[120019,120019],"mapped",[100]],[[120020,120020],"mapped",[101]],[[120021,120021],"mapped",[102]],[[120022,120022],"mapped",[103]],[[120023,120023],"mapped",[104]],[[120024,120024],"mapped",[105]],[[120025,120025],"mapped",[106]],[[120026,120026],"mapped",[107]],[[120027,120027],"mapped",[108]],[[120028,120028],"mapped",[109]],[[120029,120029],"mapped",[110]],[[120030,120030],"mapped",[111]],[[120031,120031],"mapped",[112]],[[120032,120032],"mapped",[113]],[[120033,120033],"mapped",[114]],[[120034,120034],"mapped",[115]],[[120035,120035],"mapped",[116]],[[120036,120036],"mapped",[117]],[[120037,120037],"mapped",[118]],[[120038,120038],"mapped",[119]],[[120039,120039],"mapped",[120]],[[120040,120040],"mapped",[121]],[[120041,120041],"mapped",[122]],[[120042,120042],"mapped",[97]],[[120043,120043],"mapped",[98]],[[120044,120044],"mapped",[99]],[[120045,120045],"mapped",[100]],[[120046,120046],"mapped",[101]],[[120047,120047],"mapped",[102]],[[120048,120048],"mapped",[103]],[[120049,120049],"mapped",[104]],[[120050,120050],"mapped",[105]],[[120051,120051],"mapped",[106]],[[120052,120052],"mapped",[107]],[[120053,120053],"mapped",[108]],[[120054,120054],"mapped",[109]],[[120055,120055],"mapped",[110]],[[120056,120056],"mapped",[111]],[[120057,120057],"mapped",[112]],[[120058,120058],"mapped",[113]],[[120059,120059],"mapped",[114]],[[120060,120060],"mapped",[115]],[[120061,120061],"mapped",[116]],[[120062,120062],"mapped",[117]],[[120063,120063],"mapped",[118]],[[120064,120064],"mapped",[119]],[[120065,120065],"mapped",[120]],[[120066,120066],"mapped",[121]],[[120067,120067],"mapped",[122]],[[120068,120068],"mapped",[97]],[[120069,120069],"mapped",[98]],[[120070,120070],"disallowed"],[[120071,120071],"mapped",[100]],[[120072,120072],"mapped",[101]],[[120073,120073],"mapped",[102]],[[120074,120074],"mapped",[103]],[[120075,120076],"disallowed"],[[120077,120077],"mapped",[106]],[[120078,120078],"mapped",[107]],[[120079,120079],"mapped",[108]],[[120080,120080],"mapped",[109]],[[120081,120081],"mapped",[110]],[[120082,120082],"mapped",[111]],[[120083,120083],"mapped",[112]],[[120084,120084],"mapped",[113]],[[120085,120085],"disallowed"],[[120086,120086],"mapped",[115]],[[120087,120087],"mapped",[116]],[[120088,120088],"mapped",[117]],[[120089,120089],"mapped",[118]],[[120090,120090],"mapped",[119]],[[120091,120091],"mapped",[120]],[[120092,120092],"mapped",[121]],[[120093,120093],"disallowed"],[[120094,120094],"mapped",[97]],[[120095,120095],"mapped",[98]],[[120096,120096],"mapped",[99]],[[120097,120097],"mapped",[100]],[[120098,120098],"mapped",[101]],[[120099,120099],"mapped",[102]],[[120100,120100],"mapped",[103]],[[120101,120101],"mapped",[104]],[[120102,120102],"mapped",[105]],[[120103,120103],"mapped",[106]],[[120104,120104],"mapped",[107]],[[120105,120105],"mapped",[108]],[[120106,120106],"mapped",[109]],[[120107,120107],"mapped",[110]],[[120108,120108],"mapped",[111]],[[120109,120109],"mapped",[112]],[[120110,120110],"mapped",[113]],[[120111,120111],"mapped",[114]],[[120112,120112],"mapped",[115]],[[120113,120113],"mapped",[116]],[[120114,120114],"mapped",[117]],[[120115,120115],"mapped",[118]],[[120116,120116],"mapped",[119]],[[120117,120117],"mapped",[120]],[[120118,120118],"mapped",[121]],[[120119,120119],"mapped",[122]],[[120120,120120],"mapped",[97]],[[120121,120121],"mapped",[98]],[[120122,120122],"disallowed"],[[120123,120123],"mapped",[100]],[[120124,120124],"mapped",[101]],[[120125,120125],"mapped",[102]],[[120126,120126],"mapped",[103]],[[120127,120127],"disallowed"],[[120128,120128],"mapped",[105]],[[120129,120129],"mapped",[106]],[[120130,120130],"mapped",[107]],[[120131,120131],"mapped",[108]],[[120132,120132],"mapped",[109]],[[120133,120133],"disallowed"],[[120134,120134],"mapped",[111]],[[120135,120137],"disallowed"],[[120138,120138],"mapped",[115]],[[120139,120139],"mapped",[116]],[[120140,120140],"mapped",[117]],[[120141,120141],"mapped",[118]],[[120142,120142],"mapped",[119]],[[120143,120143],"mapped",[120]],[[120144,120144],"mapped",[121]],[[120145,120145],"disallowed"],[[120146,120146],"mapped",[97]],[[120147,120147],"mapped",[98]],[[120148,120148],"mapped",[99]],[[120149,120149],"mapped",[100]],[[120150,120150],"mapped",[101]],[[120151,120151],"mapped",[102]],[[120152,120152],"mapped",[103]],[[120153,120153],"mapped",[104]],[[120154,120154],"mapped",[105]],[[120155,120155],"mapped",[106]],[[120156,120156],"mapped",[107]],[[120157,120157],"mapped",[108]],[[120158,120158],"mapped",[109]],[[120159,120159],"mapped",[110]],[[120160,120160],"mapped",[111]],[[120161,120161],"mapped",[112]],[[120162,120162],"mapped",[113]],[[120163,120163],"mapped",[114]],[[120164,120164],"mapped",[115]],[[120165,120165],"mapped",[116]],[[120166,120166],"mapped",[117]],[[120167,120167],"mapped",[118]],[[120168,120168],"mapped",[119]],[[120169,120169],"mapped",[120]],[[120170,120170],"mapped",[121]],[[120171,120171],"mapped",[122]],[[120172,120172],"mapped",[97]],[[120173,120173],"mapped",[98]],[[120174,120174],"mapped",[99]],[[120175,120175],"mapped",[100]],[[120176,120176],"mapped",[101]],[[120177,120177],"mapped",[102]],[[120178,120178],"mapped",[103]],[[120179,120179],"mapped",[104]],[[120180,120180],"mapped",[105]],[[120181,120181],"mapped",[106]],[[120182,120182],"mapped",[107]],[[120183,120183],"mapped",[108]],[[120184,120184],"mapped",[109]],[[120185,120185],"mapped",[110]],[[120186,120186],"mapped",[111]],[[120187,120187],"mapped",[112]],[[120188,120188],"mapped",[113]],[[120189,120189],"mapped",[114]],[[120190,120190],"mapped",[115]],[[120191,120191],"mapped",[116]],[[120192,120192],"mapped",[117]],[[120193,120193],"mapped",[118]],[[120194,120194],"mapped",[119]],[[120195,120195],"mapped",[120]],[[120196,120196],"mapped",[121]],[[120197,120197],"mapped",[122]],[[120198,120198],"mapped",[97]],[[120199,120199],"mapped",[98]],[[120200,120200],"mapped",[99]],[[120201,120201],"mapped",[100]],[[120202,120202],"mapped",[101]],[[120203,120203],"mapped",[102]],[[120204,120204],"mapped",[103]],[[120205,120205],"mapped",[104]],[[120206,120206],"mapped",[105]],[[120207,120207],"mapped",[106]],[[120208,120208],"mapped",[107]],[[120209,120209],"mapped",[108]],[[120210,120210],"mapped",[109]],[[120211,120211],"mapped",[110]],[[120212,120212],"mapped",[111]],[[120213,120213],"mapped",[112]],[[120214,120214],"mapped",[113]],[[120215,120215],"mapped",[114]],[[120216,120216],"mapped",[115]],[[120217,120217],"mapped",[116]],[[120218,120218],"mapped",[117]],[[120219,120219],"mapped",[118]],[[120220,120220],"mapped",[119]],[[120221,120221],"mapped",[120]],[[120222,120222],"mapped",[121]],[[120223,120223],"mapped",[122]],[[120224,120224],"mapped",[97]],[[120225,120225],"mapped",[98]],[[120226,120226],"mapped",[99]],[[120227,120227],"mapped",[100]],[[120228,120228],"mapped",[101]],[[120229,120229],"mapped",[102]],[[120230,120230],"mapped",[103]],[[120231,120231],"mapped",[104]],[[120232,120232],"mapped",[105]],[[120233,120233],"mapped",[106]],[[120234,120234],"mapped",[107]],[[120235,120235],"mapped",[108]],[[120236,120236],"mapped",[109]],[[120237,120237],"mapped",[110]],[[120238,120238],"mapped",[111]],[[120239,120239],"mapped",[112]],[[120240,120240],"mapped",[113]],[[120241,120241],"mapped",[114]],[[120242,120242],"mapped",[115]],[[120243,120243],"mapped",[116]],[[120244,120244],"mapped",[117]],[[120245,120245],"mapped",[118]],[[120246,120246],"mapped",[119]],[[120247,120247],"mapped",[120]],[[120248,120248],"mapped",[121]],[[120249,120249],"mapped",[122]],[[120250,120250],"mapped",[97]],[[120251,120251],"mapped",[98]],[[120252,120252],"mapped",[99]],[[120253,120253],"mapped",[100]],[[120254,120254],"mapped",[101]],[[120255,120255],"mapped",[102]],[[120256,120256],"mapped",[103]],[[120257,120257],"mapped",[104]],[[120258,120258],"mapped",[105]],[[120259,120259],"mapped",[106]],[[120260,120260],"mapped",[107]],[[120261,120261],"mapped",[108]],[[120262,120262],"mapped",[109]],[[120263,120263],"mapped",[110]],[[120264,120264],"mapped",[111]],[[120265,120265],"mapped",[112]],[[120266,120266],"mapped",[113]],[[120267,120267],"mapped",[114]],[[120268,120268],"mapped",[115]],[[120269,120269],"mapped",[116]],[[120270,120270],"mapped",[117]],[[120271,120271],"mapped",[118]],[[120272,120272],"mapped",[119]],[[120273,120273],"mapped",[120]],[[120274,120274],"mapped",[121]],[[120275,120275],"mapped",[122]],[[120276,120276],"mapped",[97]],[[120277,120277],"mapped",[98]],[[120278,120278],"mapped",[99]],[[120279,120279],"mapped",[100]],[[120280,120280],"mapped",[101]],[[120281,120281],"mapped",[102]],[[120282,120282],"mapped",[103]],[[120283,120283],"mapped",[104]],[[120284,120284],"mapped",[105]],[[120285,120285],"mapped",[106]],[[120286,120286],"mapped",[107]],[[120287,120287],"mapped",[108]],[[120288,120288],"mapped",[109]],[[120289,120289],"mapped",[110]],[[120290,120290],"mapped",[111]],[[120291,120291],"mapped",[112]],[[120292,120292],"mapped",[113]],[[120293,120293],"mapped",[114]],[[120294,120294],"mapped",[115]],[[120295,120295],"mapped",[116]],[[120296,120296],"mapped",[117]],[[120297,120297],"mapped",[118]],[[120298,120298],"mapped",[119]],[[120299,120299],"mapped",[120]],[[120300,120300],"mapped",[121]],[[120301,120301],"mapped",[122]],[[120302,120302],"mapped",[97]],[[120303,120303],"mapped",[98]],[[120304,120304],"mapped",[99]],[[120305,120305],"mapped",[100]],[[120306,120306],"mapped",[101]],[[120307,120307],"mapped",[102]],[[120308,120308],"mapped",[103]],[[120309,120309],"mapped",[104]],[[120310,120310],"mapped",[105]],[[120311,120311],"mapped",[106]],[[120312,120312],"mapped",[107]],[[120313,120313],"mapped",[108]],[[120314,120314],"mapped",[109]],[[120315,120315],"mapped",[110]],[[120316,120316],"mapped",[111]],[[120317,120317],"mapped",[112]],[[120318,120318],"mapped",[113]],[[120319,120319],"mapped",[114]],[[120320,120320],"mapped",[115]],[[120321,120321],"mapped",[116]],[[120322,120322],"mapped",[117]],[[120323,120323],"mapped",[118]],[[120324,120324],"mapped",[119]],[[120325,120325],"mapped",[120]],[[120326,120326],"mapped",[121]],[[120327,120327],"mapped",[122]],[[120328,120328],"mapped",[97]],[[120329,120329],"mapped",[98]],[[120330,120330],"mapped",[99]],[[120331,120331],"mapped",[100]],[[120332,120332],"mapped",[101]],[[120333,120333],"mapped",[102]],[[120334,120334],"mapped",[103]],[[120335,120335],"mapped",[104]],[[120336,120336],"mapped",[105]],[[120337,120337],"mapped",[106]],[[120338,120338],"mapped",[107]],[[120339,120339],"mapped",[108]],[[120340,120340],"mapped",[109]],[[120341,120341],"mapped",[110]],[[120342,120342],"mapped",[111]],[[120343,120343],"mapped",[112]],[[120344,120344],"mapped",[113]],[[120345,120345],"mapped",[114]],[[120346,120346],"mapped",[115]],[[120347,120347],"mapped",[116]],[[120348,120348],"mapped",[117]],[[120349,120349],"mapped",[118]],[[120350,120350],"mapped",[119]],[[120351,120351],"mapped",[120]],[[120352,120352],"mapped",[121]],[[120353,120353],"mapped",[122]],[[120354,120354],"mapped",[97]],[[120355,120355],"mapped",[98]],[[120356,120356],"mapped",[99]],[[120357,120357],"mapped",[100]],[[120358,120358],"mapped",[101]],[[120359,120359],"mapped",[102]],[[120360,120360],"mapped",[103]],[[120361,120361],"mapped",[104]],[[120362,120362],"mapped",[105]],[[120363,120363],"mapped",[106]],[[120364,120364],"mapped",[107]],[[120365,120365],"mapped",[108]],[[120366,120366],"mapped",[109]],[[120367,120367],"mapped",[110]],[[120368,120368],"mapped",[111]],[[120369,120369],"mapped",[112]],[[120370,120370],"mapped",[113]],[[120371,120371],"mapped",[114]],[[120372,120372],"mapped",[115]],[[120373,120373],"mapped",[116]],[[120374,120374],"mapped",[117]],[[120375,120375],"mapped",[118]],[[120376,120376],"mapped",[119]],[[120377,120377],"mapped",[120]],[[120378,120378],"mapped",[121]],[[120379,120379],"mapped",[122]],[[120380,120380],"mapped",[97]],[[120381,120381],"mapped",[98]],[[120382,120382],"mapped",[99]],[[120383,120383],"mapped",[100]],[[120384,120384],"mapped",[101]],[[120385,120385],"mapped",[102]],[[120386,120386],"mapped",[103]],[[120387,120387],"mapped",[104]],[[120388,120388],"mapped",[105]],[[120389,120389],"mapped",[106]],[[120390,120390],"mapped",[107]],[[120391,120391],"mapped",[108]],[[120392,120392],"mapped",[109]],[[120393,120393],"mapped",[110]],[[120394,120394],"mapped",[111]],[[120395,120395],"mapped",[112]],[[120396,120396],"mapped",[113]],[[120397,120397],"mapped",[114]],[[120398,120398],"mapped",[115]],[[120399,120399],"mapped",[116]],[[120400,120400],"mapped",[117]],[[120401,120401],"mapped",[118]],[[120402,120402],"mapped",[119]],[[120403,120403],"mapped",[120]],[[120404,120404],"mapped",[121]],[[120405,120405],"mapped",[122]],[[120406,120406],"mapped",[97]],[[120407,120407],"mapped",[98]],[[120408,120408],"mapped",[99]],[[120409,120409],"mapped",[100]],[[120410,120410],"mapped",[101]],[[120411,120411],"mapped",[102]],[[120412,120412],"mapped",[103]],[[120413,120413],"mapped",[104]],[[120414,120414],"mapped",[105]],[[120415,120415],"mapped",[106]],[[120416,120416],"mapped",[107]],[[120417,120417],"mapped",[108]],[[120418,120418],"mapped",[109]],[[120419,120419],"mapped",[110]],[[120420,120420],"mapped",[111]],[[120421,120421],"mapped",[112]],[[120422,120422],"mapped",[113]],[[120423,120423],"mapped",[114]],[[120424,120424],"mapped",[115]],[[120425,120425],"mapped",[116]],[[120426,120426],"mapped",[117]],[[120427,120427],"mapped",[118]],[[120428,120428],"mapped",[119]],[[120429,120429],"mapped",[120]],[[120430,120430],"mapped",[121]],[[120431,120431],"mapped",[122]],[[120432,120432],"mapped",[97]],[[120433,120433],"mapped",[98]],[[120434,120434],"mapped",[99]],[[120435,120435],"mapped",[100]],[[120436,120436],"mapped",[101]],[[120437,120437],"mapped",[102]],[[120438,120438],"mapped",[103]],[[120439,120439],"mapped",[104]],[[120440,120440],"mapped",[105]],[[120441,120441],"mapped",[106]],[[120442,120442],"mapped",[107]],[[120443,120443],"mapped",[108]],[[120444,120444],"mapped",[109]],[[120445,120445],"mapped",[110]],[[120446,120446],"mapped",[111]],[[120447,120447],"mapped",[112]],[[120448,120448],"mapped",[113]],[[120449,120449],"mapped",[114]],[[120450,120450],"mapped",[115]],[[120451,120451],"mapped",[116]],[[120452,120452],"mapped",[117]],[[120453,120453],"mapped",[118]],[[120454,120454],"mapped",[119]],[[120455,120455],"mapped",[120]],[[120456,120456],"mapped",[121]],[[120457,120457],"mapped",[122]],[[120458,120458],"mapped",[97]],[[120459,120459],"mapped",[98]],[[120460,120460],"mapped",[99]],[[120461,120461],"mapped",[100]],[[120462,120462],"mapped",[101]],[[120463,120463],"mapped",[102]],[[120464,120464],"mapped",[103]],[[120465,120465],"mapped",[104]],[[120466,120466],"mapped",[105]],[[120467,120467],"mapped",[106]],[[120468,120468],"mapped",[107]],[[120469,120469],"mapped",[108]],[[120470,120470],"mapped",[109]],[[120471,120471],"mapped",[110]],[[120472,120472],"mapped",[111]],[[120473,120473],"mapped",[112]],[[120474,120474],"mapped",[113]],[[120475,120475],"mapped",[114]],[[120476,120476],"mapped",[115]],[[120477,120477],"mapped",[116]],[[120478,120478],"mapped",[117]],[[120479,120479],"mapped",[118]],[[120480,120480],"mapped",[119]],[[120481,120481],"mapped",[120]],[[120482,120482],"mapped",[121]],[[120483,120483],"mapped",[122]],[[120484,120484],"mapped",[305]],[[120485,120485],"mapped",[567]],[[120486,120487],"disallowed"],[[120488,120488],"mapped",[945]],[[120489,120489],"mapped",[946]],[[120490,120490],"mapped",[947]],[[120491,120491],"mapped",[948]],[[120492,120492],"mapped",[949]],[[120493,120493],"mapped",[950]],[[120494,120494],"mapped",[951]],[[120495,120495],"mapped",[952]],[[120496,120496],"mapped",[953]],[[120497,120497],"mapped",[954]],[[120498,120498],"mapped",[955]],[[120499,120499],"mapped",[956]],[[120500,120500],"mapped",[957]],[[120501,120501],"mapped",[958]],[[120502,120502],"mapped",[959]],[[120503,120503],"mapped",[960]],[[120504,120504],"mapped",[961]],[[120505,120505],"mapped",[952]],[[120506,120506],"mapped",[963]],[[120507,120507],"mapped",[964]],[[120508,120508],"mapped",[965]],[[120509,120509],"mapped",[966]],[[120510,120510],"mapped",[967]],[[120511,120511],"mapped",[968]],[[120512,120512],"mapped",[969]],[[120513,120513],"mapped",[8711]],[[120514,120514],"mapped",[945]],[[120515,120515],"mapped",[946]],[[120516,120516],"mapped",[947]],[[120517,120517],"mapped",[948]],[[120518,120518],"mapped",[949]],[[120519,120519],"mapped",[950]],[[120520,120520],"mapped",[951]],[[120521,120521],"mapped",[952]],[[120522,120522],"mapped",[953]],[[120523,120523],"mapped",[954]],[[120524,120524],"mapped",[955]],[[120525,120525],"mapped",[956]],[[120526,120526],"mapped",[957]],[[120527,120527],"mapped",[958]],[[120528,120528],"mapped",[959]],[[120529,120529],"mapped",[960]],[[120530,120530],"mapped",[961]],[[120531,120532],"mapped",[963]],[[120533,120533],"mapped",[964]],[[120534,120534],"mapped",[965]],[[120535,120535],"mapped",[966]],[[120536,120536],"mapped",[967]],[[120537,120537],"mapped",[968]],[[120538,120538],"mapped",[969]],[[120539,120539],"mapped",[8706]],[[120540,120540],"mapped",[949]],[[120541,120541],"mapped",[952]],[[120542,120542],"mapped",[954]],[[120543,120543],"mapped",[966]],[[120544,120544],"mapped",[961]],[[120545,120545],"mapped",[960]],[[120546,120546],"mapped",[945]],[[120547,120547],"mapped",[946]],[[120548,120548],"mapped",[947]],[[120549,120549],"mapped",[948]],[[120550,120550],"mapped",[949]],[[120551,120551],"mapped",[950]],[[120552,120552],"mapped",[951]],[[120553,120553],"mapped",[952]],[[120554,120554],"mapped",[953]],[[120555,120555],"mapped",[954]],[[120556,120556],"mapped",[955]],[[120557,120557],"mapped",[956]],[[120558,120558],"mapped",[957]],[[120559,120559],"mapped",[958]],[[120560,120560],"mapped",[959]],[[120561,120561],"mapped",[960]],[[120562,120562],"mapped",[961]],[[120563,120563],"mapped",[952]],[[120564,120564],"mapped",[963]],[[120565,120565],"mapped",[964]],[[120566,120566],"mapped",[965]],[[120567,120567],"mapped",[966]],[[120568,120568],"mapped",[967]],[[120569,120569],"mapped",[968]],[[120570,120570],"mapped",[969]],[[120571,120571],"mapped",[8711]],[[120572,120572],"mapped",[945]],[[120573,120573],"mapped",[946]],[[120574,120574],"mapped",[947]],[[120575,120575],"mapped",[948]],[[120576,120576],"mapped",[949]],[[120577,120577],"mapped",[950]],[[120578,120578],"mapped",[951]],[[120579,120579],"mapped",[952]],[[120580,120580],"mapped",[953]],[[120581,120581],"mapped",[954]],[[120582,120582],"mapped",[955]],[[120583,120583],"mapped",[956]],[[120584,120584],"mapped",[957]],[[120585,120585],"mapped",[958]],[[120586,120586],"mapped",[959]],[[120587,120587],"mapped",[960]],[[120588,120588],"mapped",[961]],[[120589,120590],"mapped",[963]],[[120591,120591],"mapped",[964]],[[120592,120592],"mapped",[965]],[[120593,120593],"mapped",[966]],[[120594,120594],"mapped",[967]],[[120595,120595],"mapped",[968]],[[120596,120596],"mapped",[969]],[[120597,120597],"mapped",[8706]],[[120598,120598],"mapped",[949]],[[120599,120599],"mapped",[952]],[[120600,120600],"mapped",[954]],[[120601,120601],"mapped",[966]],[[120602,120602],"mapped",[961]],[[120603,120603],"mapped",[960]],[[120604,120604],"mapped",[945]],[[120605,120605],"mapped",[946]],[[120606,120606],"mapped",[947]],[[120607,120607],"mapped",[948]],[[120608,120608],"mapped",[949]],[[120609,120609],"mapped",[950]],[[120610,120610],"mapped",[951]],[[120611,120611],"mapped",[952]],[[120612,120612],"mapped",[953]],[[120613,120613],"mapped",[954]],[[120614,120614],"mapped",[955]],[[120615,120615],"mapped",[956]],[[120616,120616],"mapped",[957]],[[120617,120617],"mapped",[958]],[[120618,120618],"mapped",[959]],[[120619,120619],"mapped",[960]],[[120620,120620],"mapped",[961]],[[120621,120621],"mapped",[952]],[[120622,120622],"mapped",[963]],[[120623,120623],"mapped",[964]],[[120624,120624],"mapped",[965]],[[120625,120625],"mapped",[966]],[[120626,120626],"mapped",[967]],[[120627,120627],"mapped",[968]],[[120628,120628],"mapped",[969]],[[120629,120629],"mapped",[8711]],[[120630,120630],"mapped",[945]],[[120631,120631],"mapped",[946]],[[120632,120632],"mapped",[947]],[[120633,120633],"mapped",[948]],[[120634,120634],"mapped",[949]],[[120635,120635],"mapped",[950]],[[120636,120636],"mapped",[951]],[[120637,120637],"mapped",[952]],[[120638,120638],"mapped",[953]],[[120639,120639],"mapped",[954]],[[120640,120640],"mapped",[955]],[[120641,120641],"mapped",[956]],[[120642,120642],"mapped",[957]],[[120643,120643],"mapped",[958]],[[120644,120644],"mapped",[959]],[[120645,120645],"mapped",[960]],[[120646,120646],"mapped",[961]],[[120647,120648],"mapped",[963]],[[120649,120649],"mapped",[964]],[[120650,120650],"mapped",[965]],[[120651,120651],"mapped",[966]],[[120652,120652],"mapped",[967]],[[120653,120653],"mapped",[968]],[[120654,120654],"mapped",[969]],[[120655,120655],"mapped",[8706]],[[120656,120656],"mapped",[949]],[[120657,120657],"mapped",[952]],[[120658,120658],"mapped",[954]],[[120659,120659],"mapped",[966]],[[120660,120660],"mapped",[961]],[[120661,120661],"mapped",[960]],[[120662,120662],"mapped",[945]],[[120663,120663],"mapped",[946]],[[120664,120664],"mapped",[947]],[[120665,120665],"mapped",[948]],[[120666,120666],"mapped",[949]],[[120667,120667],"mapped",[950]],[[120668,120668],"mapped",[951]],[[120669,120669],"mapped",[952]],[[120670,120670],"mapped",[953]],[[120671,120671],"mapped",[954]],[[120672,120672],"mapped",[955]],[[120673,120673],"mapped",[956]],[[120674,120674],"mapped",[957]],[[120675,120675],"mapped",[958]],[[120676,120676],"mapped",[959]],[[120677,120677],"mapped",[960]],[[120678,120678],"mapped",[961]],[[120679,120679],"mapped",[952]],[[120680,120680],"mapped",[963]],[[120681,120681],"mapped",[964]],[[120682,120682],"mapped",[965]],[[120683,120683],"mapped",[966]],[[120684,120684],"mapped",[967]],[[120685,120685],"mapped",[968]],[[120686,120686],"mapped",[969]],[[120687,120687],"mapped",[8711]],[[120688,120688],"mapped",[945]],[[120689,120689],"mapped",[946]],[[120690,120690],"mapped",[947]],[[120691,120691],"mapped",[948]],[[120692,120692],"mapped",[949]],[[120693,120693],"mapped",[950]],[[120694,120694],"mapped",[951]],[[120695,120695],"mapped",[952]],[[120696,120696],"mapped",[953]],[[120697,120697],"mapped",[954]],[[120698,120698],"mapped",[955]],[[120699,120699],"mapped",[956]],[[120700,120700],"mapped",[957]],[[120701,120701],"mapped",[958]],[[120702,120702],"mapped",[959]],[[120703,120703],"mapped",[960]],[[120704,120704],"mapped",[961]],[[120705,120706],"mapped",[963]],[[120707,120707],"mapped",[964]],[[120708,120708],"mapped",[965]],[[120709,120709],"mapped",[966]],[[120710,120710],"mapped",[967]],[[120711,120711],"mapped",[968]],[[120712,120712],"mapped",[969]],[[120713,120713],"mapped",[8706]],[[120714,120714],"mapped",[949]],[[120715,120715],"mapped",[952]],[[120716,120716],"mapped",[954]],[[120717,120717],"mapped",[966]],[[120718,120718],"mapped",[961]],[[120719,120719],"mapped",[960]],[[120720,120720],"mapped",[945]],[[120721,120721],"mapped",[946]],[[120722,120722],"mapped",[947]],[[120723,120723],"mapped",[948]],[[120724,120724],"mapped",[949]],[[120725,120725],"mapped",[950]],[[120726,120726],"mapped",[951]],[[120727,120727],"mapped",[952]],[[120728,120728],"mapped",[953]],[[120729,120729],"mapped",[954]],[[120730,120730],"mapped",[955]],[[120731,120731],"mapped",[956]],[[120732,120732],"mapped",[957]],[[120733,120733],"mapped",[958]],[[120734,120734],"mapped",[959]],[[120735,120735],"mapped",[960]],[[120736,120736],"mapped",[961]],[[120737,120737],"mapped",[952]],[[120738,120738],"mapped",[963]],[[120739,120739],"mapped",[964]],[[120740,120740],"mapped",[965]],[[120741,120741],"mapped",[966]],[[120742,120742],"mapped",[967]],[[120743,120743],"mapped",[968]],[[120744,120744],"mapped",[969]],[[120745,120745],"mapped",[8711]],[[120746,120746],"mapped",[945]],[[120747,120747],"mapped",[946]],[[120748,120748],"mapped",[947]],[[120749,120749],"mapped",[948]],[[120750,120750],"mapped",[949]],[[120751,120751],"mapped",[950]],[[120752,120752],"mapped",[951]],[[120753,120753],"mapped",[952]],[[120754,120754],"mapped",[953]],[[120755,120755],"mapped",[954]],[[120756,120756],"mapped",[955]],[[120757,120757],"mapped",[956]],[[120758,120758],"mapped",[957]],[[120759,120759],"mapped",[958]],[[120760,120760],"mapped",[959]],[[120761,120761],"mapped",[960]],[[120762,120762],"mapped",[961]],[[120763,120764],"mapped",[963]],[[120765,120765],"mapped",[964]],[[120766,120766],"mapped",[965]],[[120767,120767],"mapped",[966]],[[120768,120768],"mapped",[967]],[[120769,120769],"mapped",[968]],[[120770,120770],"mapped",[969]],[[120771,120771],"mapped",[8706]],[[120772,120772],"mapped",[949]],[[120773,120773],"mapped",[952]],[[120774,120774],"mapped",[954]],[[120775,120775],"mapped",[966]],[[120776,120776],"mapped",[961]],[[120777,120777],"mapped",[960]],[[120778,120779],"mapped",[989]],[[120780,120781],"disallowed"],[[120782,120782],"mapped",[48]],[[120783,120783],"mapped",[49]],[[120784,120784],"mapped",[50]],[[120785,120785],"mapped",[51]],[[120786,120786],"mapped",[52]],[[120787,120787],"mapped",[53]],[[120788,120788],"mapped",[54]],[[120789,120789],"mapped",[55]],[[120790,120790],"mapped",[56]],[[120791,120791],"mapped",[57]],[[120792,120792],"mapped",[48]],[[120793,120793],"mapped",[49]],[[120794,120794],"mapped",[50]],[[120795,120795],"mapped",[51]],[[120796,120796],"mapped",[52]],[[120797,120797],"mapped",[53]],[[120798,120798],"mapped",[54]],[[120799,120799],"mapped",[55]],[[120800,120800],"mapped",[56]],[[120801,120801],"mapped",[57]],[[120802,120802],"mapped",[48]],[[120803,120803],"mapped",[49]],[[120804,120804],"mapped",[50]],[[120805,120805],"mapped",[51]],[[120806,120806],"mapped",[52]],[[120807,120807],"mapped",[53]],[[120808,120808],"mapped",[54]],[[120809,120809],"mapped",[55]],[[120810,120810],"mapped",[56]],[[120811,120811],"mapped",[57]],[[120812,120812],"mapped",[48]],[[120813,120813],"mapped",[49]],[[120814,120814],"mapped",[50]],[[120815,120815],"mapped",[51]],[[120816,120816],"mapped",[52]],[[120817,120817],"mapped",[53]],[[120818,120818],"mapped",[54]],[[120819,120819],"mapped",[55]],[[120820,120820],"mapped",[56]],[[120821,120821],"mapped",[57]],[[120822,120822],"mapped",[48]],[[120823,120823],"mapped",[49]],[[120824,120824],"mapped",[50]],[[120825,120825],"mapped",[51]],[[120826,120826],"mapped",[52]],[[120827,120827],"mapped",[53]],[[120828,120828],"mapped",[54]],[[120829,120829],"mapped",[55]],[[120830,120830],"mapped",[56]],[[120831,120831],"mapped",[57]],[[120832,121343],"valid",[],"NV8"],[[121344,121398],"valid"],[[121399,121402],"valid",[],"NV8"],[[121403,121452],"valid"],[[121453,121460],"valid",[],"NV8"],[[121461,121461],"valid"],[[121462,121475],"valid",[],"NV8"],[[121476,121476],"valid"],[[121477,121483],"valid",[],"NV8"],[[121484,121498],"disallowed"],[[121499,121503],"valid"],[[121504,121504],"disallowed"],[[121505,121519],"valid"],[[121520,124927],"disallowed"],[[124928,125124],"valid"],[[125125,125126],"disallowed"],[[125127,125135],"valid",[],"NV8"],[[125136,125142],"valid"],[[125143,126463],"disallowed"],[[126464,126464],"mapped",[1575]],[[126465,126465],"mapped",[1576]],[[126466,126466],"mapped",[1580]],[[126467,126467],"mapped",[1583]],[[126468,126468],"disallowed"],[[126469,126469],"mapped",[1608]],[[126470,126470],"mapped",[1586]],[[126471,126471],"mapped",[1581]],[[126472,126472],"mapped",[1591]],[[126473,126473],"mapped",[1610]],[[126474,126474],"mapped",[1603]],[[126475,126475],"mapped",[1604]],[[126476,126476],"mapped",[1605]],[[126477,126477],"mapped",[1606]],[[126478,126478],"mapped",[1587]],[[126479,126479],"mapped",[1593]],[[126480,126480],"mapped",[1601]],[[126481,126481],"mapped",[1589]],[[126482,126482],"mapped",[1602]],[[126483,126483],"mapped",[1585]],[[126484,126484],"mapped",[1588]],[[126485,126485],"mapped",[1578]],[[126486,126486],"mapped",[1579]],[[126487,126487],"mapped",[1582]],[[126488,126488],"mapped",[1584]],[[126489,126489],"mapped",[1590]],[[126490,126490],"mapped",[1592]],[[126491,126491],"mapped",[1594]],[[126492,126492],"mapped",[1646]],[[126493,126493],"mapped",[1722]],[[126494,126494],"mapped",[1697]],[[126495,126495],"mapped",[1647]],[[126496,126496],"disallowed"],[[126497,126497],"mapped",[1576]],[[126498,126498],"mapped",[1580]],[[126499,126499],"disallowed"],[[126500,126500],"mapped",[1607]],[[126501,126502],"disallowed"],[[126503,126503],"mapped",[1581]],[[126504,126504],"disallowed"],[[126505,126505],"mapped",[1610]],[[126506,126506],"mapped",[1603]],[[126507,126507],"mapped",[1604]],[[126508,126508],"mapped",[1605]],[[126509,126509],"mapped",[1606]],[[126510,126510],"mapped",[1587]],[[126511,126511],"mapped",[1593]],[[126512,126512],"mapped",[1601]],[[126513,126513],"mapped",[1589]],[[126514,126514],"mapped",[1602]],[[126515,126515],"disallowed"],[[126516,126516],"mapped",[1588]],[[126517,126517],"mapped",[1578]],[[126518,126518],"mapped",[1579]],[[126519,126519],"mapped",[1582]],[[126520,126520],"disallowed"],[[126521,126521],"mapped",[1590]],[[126522,126522],"disallowed"],[[126523,126523],"mapped",[1594]],[[126524,126529],"disallowed"],[[126530,126530],"mapped",[1580]],[[126531,126534],"disallowed"],[[126535,126535],"mapped",[1581]],[[126536,126536],"disallowed"],[[126537,126537],"mapped",[1610]],[[126538,126538],"disallowed"],[[126539,126539],"mapped",[1604]],[[126540,126540],"disallowed"],[[126541,126541],"mapped",[1606]],[[126542,126542],"mapped",[1587]],[[126543,126543],"mapped",[1593]],[[126544,126544],"disallowed"],[[126545,126545],"mapped",[1589]],[[126546,126546],"mapped",[1602]],[[126547,126547],"disallowed"],[[126548,126548],"mapped",[1588]],[[126549,126550],"disallowed"],[[126551,126551],"mapped",[1582]],[[126552,126552],"disallowed"],[[126553,126553],"mapped",[1590]],[[126554,126554],"disallowed"],[[126555,126555],"mapped",[1594]],[[126556,126556],"disallowed"],[[126557,126557],"mapped",[1722]],[[126558,126558],"disallowed"],[[126559,126559],"mapped",[1647]],[[126560,126560],"disallowed"],[[126561,126561],"mapped",[1576]],[[126562,126562],"mapped",[1580]],[[126563,126563],"disallowed"],[[126564,126564],"mapped",[1607]],[[126565,126566],"disallowed"],[[126567,126567],"mapped",[1581]],[[126568,126568],"mapped",[1591]],[[126569,126569],"mapped",[1610]],[[126570,126570],"mapped",[1603]],[[126571,126571],"disallowed"],[[126572,126572],"mapped",[1605]],[[126573,126573],"mapped",[1606]],[[126574,126574],"mapped",[1587]],[[126575,126575],"mapped",[1593]],[[126576,126576],"mapped",[1601]],[[126577,126577],"mapped",[1589]],[[126578,126578],"mapped",[1602]],[[126579,126579],"disallowed"],[[126580,126580],"mapped",[1588]],[[126581,126581],"mapped",[1578]],[[126582,126582],"mapped",[1579]],[[126583,126583],"mapped",[1582]],[[126584,126584],"disallowed"],[[126585,126585],"mapped",[1590]],[[126586,126586],"mapped",[1592]],[[126587,126587],"mapped",[1594]],[[126588,126588],"mapped",[1646]],[[126589,126589],"disallowed"],[[126590,126590],"mapped",[1697]],[[126591,126591],"disallowed"],[[126592,126592],"mapped",[1575]],[[126593,126593],"mapped",[1576]],[[126594,126594],"mapped",[1580]],[[126595,126595],"mapped",[1583]],[[126596,126596],"mapped",[1607]],[[126597,126597],"mapped",[1608]],[[126598,126598],"mapped",[1586]],[[126599,126599],"mapped",[1581]],[[126600,126600],"mapped",[1591]],[[126601,126601],"mapped",[1610]],[[126602,126602],"disallowed"],[[126603,126603],"mapped",[1604]],[[126604,126604],"mapped",[1605]],[[126605,126605],"mapped",[1606]],[[126606,126606],"mapped",[1587]],[[126607,126607],"mapped",[1593]],[[126608,126608],"mapped",[1601]],[[126609,126609],"mapped",[1589]],[[126610,126610],"mapped",[1602]],[[126611,126611],"mapped",[1585]],[[126612,126612],"mapped",[1588]],[[126613,126613],"mapped",[1578]],[[126614,126614],"mapped",[1579]],[[126615,126615],"mapped",[1582]],[[126616,126616],"mapped",[1584]],[[126617,126617],"mapped",[1590]],[[126618,126618],"mapped",[1592]],[[126619,126619],"mapped",[1594]],[[126620,126624],"disallowed"],[[126625,126625],"mapped",[1576]],[[126626,126626],"mapped",[1580]],[[126627,126627],"mapped",[1583]],[[126628,126628],"disallowed"],[[126629,126629],"mapped",[1608]],[[126630,126630],"mapped",[1586]],[[126631,126631],"mapped",[1581]],[[126632,126632],"mapped",[1591]],[[126633,126633],"mapped",[1610]],[[126634,126634],"disallowed"],[[126635,126635],"mapped",[1604]],[[126636,126636],"mapped",[1605]],[[126637,126637],"mapped",[1606]],[[126638,126638],"mapped",[1587]],[[126639,126639],"mapped",[1593]],[[126640,126640],"mapped",[1601]],[[126641,126641],"mapped",[1589]],[[126642,126642],"mapped",[1602]],[[126643,126643],"mapped",[1585]],[[126644,126644],"mapped",[1588]],[[126645,126645],"mapped",[1578]],[[126646,126646],"mapped",[1579]],[[126647,126647],"mapped",[1582]],[[126648,126648],"mapped",[1584]],[[126649,126649],"mapped",[1590]],[[126650,126650],"mapped",[1592]],[[126651,126651],"mapped",[1594]],[[126652,126703],"disallowed"],[[126704,126705],"valid",[],"NV8"],[[126706,126975],"disallowed"],[[126976,127019],"valid",[],"NV8"],[[127020,127023],"disallowed"],[[127024,127123],"valid",[],"NV8"],[[127124,127135],"disallowed"],[[127136,127150],"valid",[],"NV8"],[[127151,127152],"disallowed"],[[127153,127166],"valid",[],"NV8"],[[127167,127167],"valid",[],"NV8"],[[127168,127168],"disallowed"],[[127169,127183],"valid",[],"NV8"],[[127184,127184],"disallowed"],[[127185,127199],"valid",[],"NV8"],[[127200,127221],"valid",[],"NV8"],[[127222,127231],"disallowed"],[[127232,127232],"disallowed"],[[127233,127233],"disallowed_STD3_mapped",[48,44]],[[127234,127234],"disallowed_STD3_mapped",[49,44]],[[127235,127235],"disallowed_STD3_mapped",[50,44]],[[127236,127236],"disallowed_STD3_mapped",[51,44]],[[127237,127237],"disallowed_STD3_mapped",[52,44]],[[127238,127238],"disallowed_STD3_mapped",[53,44]],[[127239,127239],"disallowed_STD3_mapped",[54,44]],[[127240,127240],"disallowed_STD3_mapped",[55,44]],[[127241,127241],"disallowed_STD3_mapped",[56,44]],[[127242,127242],"disallowed_STD3_mapped",[57,44]],[[127243,127244],"valid",[],"NV8"],[[127245,127247],"disallowed"],[[127248,127248],"disallowed_STD3_mapped",[40,97,41]],[[127249,127249],"disallowed_STD3_mapped",[40,98,41]],[[127250,127250],"disallowed_STD3_mapped",[40,99,41]],[[127251,127251],"disallowed_STD3_mapped",[40,100,41]],[[127252,127252],"disallowed_STD3_mapped",[40,101,41]],[[127253,127253],"disallowed_STD3_mapped",[40,102,41]],[[127254,127254],"disallowed_STD3_mapped",[40,103,41]],[[127255,127255],"disallowed_STD3_mapped",[40,104,41]],[[127256,127256],"disallowed_STD3_mapped",[40,105,41]],[[127257,127257],"disallowed_STD3_mapped",[40,106,41]],[[127258,127258],"disallowed_STD3_mapped",[40,107,41]],[[127259,127259],"disallowed_STD3_mapped",[40,108,41]],[[127260,127260],"disallowed_STD3_mapped",[40,109,41]],[[127261,127261],"disallowed_STD3_mapped",[40,110,41]],[[127262,127262],"disallowed_STD3_mapped",[40,111,41]],[[127263,127263],"disallowed_STD3_mapped",[40,112,41]],[[127264,127264],"disallowed_STD3_mapped",[40,113,41]],[[127265,127265],"disallowed_STD3_mapped",[40,114,41]],[[127266,127266],"disallowed_STD3_mapped",[40,115,41]],[[127267,127267],"disallowed_STD3_mapped",[40,116,41]],[[127268,127268],"disallowed_STD3_mapped",[40,117,41]],[[127269,127269],"disallowed_STD3_mapped",[40,118,41]],[[127270,127270],"disallowed_STD3_mapped",[40,119,41]],[[127271,127271],"disallowed_STD3_mapped",[40,120,41]],[[127272,127272],"disallowed_STD3_mapped",[40,121,41]],[[127273,127273],"disallowed_STD3_mapped",[40,122,41]],[[127274,127274],"mapped",[12308,115,12309]],[[127275,127275],"mapped",[99]],[[127276,127276],"mapped",[114]],[[127277,127277],"mapped",[99,100]],[[127278,127278],"mapped",[119,122]],[[127279,127279],"disallowed"],[[127280,127280],"mapped",[97]],[[127281,127281],"mapped",[98]],[[127282,127282],"mapped",[99]],[[127283,127283],"mapped",[100]],[[127284,127284],"mapped",[101]],[[127285,127285],"mapped",[102]],[[127286,127286],"mapped",[103]],[[127287,127287],"mapped",[104]],[[127288,127288],"mapped",[105]],[[127289,127289],"mapped",[106]],[[127290,127290],"mapped",[107]],[[127291,127291],"mapped",[108]],[[127292,127292],"mapped",[109]],[[127293,127293],"mapped",[110]],[[127294,127294],"mapped",[111]],[[127295,127295],"mapped",[112]],[[127296,127296],"mapped",[113]],[[127297,127297],"mapped",[114]],[[127298,127298],"mapped",[115]],[[127299,127299],"mapped",[116]],[[127300,127300],"mapped",[117]],[[127301,127301],"mapped",[118]],[[127302,127302],"mapped",[119]],[[127303,127303],"mapped",[120]],[[127304,127304],"mapped",[121]],[[127305,127305],"mapped",[122]],[[127306,127306],"mapped",[104,118]],[[127307,127307],"mapped",[109,118]],[[127308,127308],"mapped",[115,100]],[[127309,127309],"mapped",[115,115]],[[127310,127310],"mapped",[112,112,118]],[[127311,127311],"mapped",[119,99]],[[127312,127318],"valid",[],"NV8"],[[127319,127319],"valid",[],"NV8"],[[127320,127326],"valid",[],"NV8"],[[127327,127327],"valid",[],"NV8"],[[127328,127337],"valid",[],"NV8"],[[127338,127338],"mapped",[109,99]],[[127339,127339],"mapped",[109,100]],[[127340,127343],"disallowed"],[[127344,127352],"valid",[],"NV8"],[[127353,127353],"valid",[],"NV8"],[[127354,127354],"valid",[],"NV8"],[[127355,127356],"valid",[],"NV8"],[[127357,127358],"valid",[],"NV8"],[[127359,127359],"valid",[],"NV8"],[[127360,127369],"valid",[],"NV8"],[[127370,127373],"valid",[],"NV8"],[[127374,127375],"valid",[],"NV8"],[[127376,127376],"mapped",[100,106]],[[127377,127386],"valid",[],"NV8"],[[127387,127461],"disallowed"],[[127462,127487],"valid",[],"NV8"],[[127488,127488],"mapped",[12411,12363]],[[127489,127489],"mapped",[12467,12467]],[[127490,127490],"mapped",[12469]],[[127491,127503],"disallowed"],[[127504,127504],"mapped",[25163]],[[127505,127505],"mapped",[23383]],[[127506,127506],"mapped",[21452]],[[127507,127507],"mapped",[12487]],[[127508,127508],"mapped",[20108]],[[127509,127509],"mapped",[22810]],[[127510,127510],"mapped",[35299]],[[127511,127511],"mapped",[22825]],[[127512,127512],"mapped",[20132]],[[127513,127513],"mapped",[26144]],[[127514,127514],"mapped",[28961]],[[127515,127515],"mapped",[26009]],[[127516,127516],"mapped",[21069]],[[127517,127517],"mapped",[24460]],[[127518,127518],"mapped",[20877]],[[127519,127519],"mapped",[26032]],[[127520,127520],"mapped",[21021]],[[127521,127521],"mapped",[32066]],[[127522,127522],"mapped",[29983]],[[127523,127523],"mapped",[36009]],[[127524,127524],"mapped",[22768]],[[127525,127525],"mapped",[21561]],[[127526,127526],"mapped",[28436]],[[127527,127527],"mapped",[25237]],[[127528,127528],"mapped",[25429]],[[127529,127529],"mapped",[19968]],[[127530,127530],"mapped",[19977]],[[127531,127531],"mapped",[36938]],[[127532,127532],"mapped",[24038]],[[127533,127533],"mapped",[20013]],[[127534,127534],"mapped",[21491]],[[127535,127535],"mapped",[25351]],[[127536,127536],"mapped",[36208]],[[127537,127537],"mapped",[25171]],[[127538,127538],"mapped",[31105]],[[127539,127539],"mapped",[31354]],[[127540,127540],"mapped",[21512]],[[127541,127541],"mapped",[28288]],[[127542,127542],"mapped",[26377]],[[127543,127543],"mapped",[26376]],[[127544,127544],"mapped",[30003]],[[127545,127545],"mapped",[21106]],[[127546,127546],"mapped",[21942]],[[127547,127551],"disallowed"],[[127552,127552],"mapped",[12308,26412,12309]],[[127553,127553],"mapped",[12308,19977,12309]],[[127554,127554],"mapped",[12308,20108,12309]],[[127555,127555],"mapped",[12308,23433,12309]],[[127556,127556],"mapped",[12308,28857,12309]],[[127557,127557],"mapped",[12308,25171,12309]],[[127558,127558],"mapped",[12308,30423,12309]],[[127559,127559],"mapped",[12308,21213,12309]],[[127560,127560],"mapped",[12308,25943,12309]],[[127561,127567],"disallowed"],[[127568,127568],"mapped",[24471]],[[127569,127569],"mapped",[21487]],[[127570,127743],"disallowed"],[[127744,127776],"valid",[],"NV8"],[[127777,127788],"valid",[],"NV8"],[[127789,127791],"valid",[],"NV8"],[[127792,127797],"valid",[],"NV8"],[[127798,127798],"valid",[],"NV8"],[[127799,127868],"valid",[],"NV8"],[[127869,127869],"valid",[],"NV8"],[[127870,127871],"valid",[],"NV8"],[[127872,127891],"valid",[],"NV8"],[[127892,127903],"valid",[],"NV8"],[[127904,127940],"valid",[],"NV8"],[[127941,127941],"valid",[],"NV8"],[[127942,127946],"valid",[],"NV8"],[[127947,127950],"valid",[],"NV8"],[[127951,127955],"valid",[],"NV8"],[[127956,127967],"valid",[],"NV8"],[[127968,127984],"valid",[],"NV8"],[[127985,127991],"valid",[],"NV8"],[[127992,127999],"valid",[],"NV8"],[[128000,128062],"valid",[],"NV8"],[[128063,128063],"valid",[],"NV8"],[[128064,128064],"valid",[],"NV8"],[[128065,128065],"valid",[],"NV8"],[[128066,128247],"valid",[],"NV8"],[[128248,128248],"valid",[],"NV8"],[[128249,128252],"valid",[],"NV8"],[[128253,128254],"valid",[],"NV8"],[[128255,128255],"valid",[],"NV8"],[[128256,128317],"valid",[],"NV8"],[[128318,128319],"valid",[],"NV8"],[[128320,128323],"valid",[],"NV8"],[[128324,128330],"valid",[],"NV8"],[[128331,128335],"valid",[],"NV8"],[[128336,128359],"valid",[],"NV8"],[[128360,128377],"valid",[],"NV8"],[[128378,128378],"disallowed"],[[128379,128419],"valid",[],"NV8"],[[128420,128420],"disallowed"],[[128421,128506],"valid",[],"NV8"],[[128507,128511],"valid",[],"NV8"],[[128512,128512],"valid",[],"NV8"],[[128513,128528],"valid",[],"NV8"],[[128529,128529],"valid",[],"NV8"],[[128530,128532],"valid",[],"NV8"],[[128533,128533],"valid",[],"NV8"],[[128534,128534],"valid",[],"NV8"],[[128535,128535],"valid",[],"NV8"],[[128536,128536],"valid",[],"NV8"],[[128537,128537],"valid",[],"NV8"],[[128538,128538],"valid",[],"NV8"],[[128539,128539],"valid",[],"NV8"],[[128540,128542],"valid",[],"NV8"],[[128543,128543],"valid",[],"NV8"],[[128544,128549],"valid",[],"NV8"],[[128550,128551],"valid",[],"NV8"],[[128552,128555],"valid",[],"NV8"],[[128556,128556],"valid",[],"NV8"],[[128557,128557],"valid",[],"NV8"],[[128558,128559],"valid",[],"NV8"],[[128560,128563],"valid",[],"NV8"],[[128564,128564],"valid",[],"NV8"],[[128565,128576],"valid",[],"NV8"],[[128577,128578],"valid",[],"NV8"],[[128579,128580],"valid",[],"NV8"],[[128581,128591],"valid",[],"NV8"],[[128592,128639],"valid",[],"NV8"],[[128640,128709],"valid",[],"NV8"],[[128710,128719],"valid",[],"NV8"],[[128720,128720],"valid",[],"NV8"],[[128721,128735],"disallowed"],[[128736,128748],"valid",[],"NV8"],[[128749,128751],"disallowed"],[[128752,128755],"valid",[],"NV8"],[[128756,128767],"disallowed"],[[128768,128883],"valid",[],"NV8"],[[128884,128895],"disallowed"],[[128896,128980],"valid",[],"NV8"],[[128981,129023],"disallowed"],[[129024,129035],"valid",[],"NV8"],[[129036,129039],"disallowed"],[[129040,129095],"valid",[],"NV8"],[[129096,129103],"disallowed"],[[129104,129113],"valid",[],"NV8"],[[129114,129119],"disallowed"],[[129120,129159],"valid",[],"NV8"],[[129160,129167],"disallowed"],[[129168,129197],"valid",[],"NV8"],[[129198,129295],"disallowed"],[[129296,129304],"valid",[],"NV8"],[[129305,129407],"disallowed"],[[129408,129412],"valid",[],"NV8"],[[129413,129471],"disallowed"],[[129472,129472],"valid",[],"NV8"],[[129473,131069],"disallowed"],[[131070,131071],"disallowed"],[[131072,173782],"valid"],[[173783,173823],"disallowed"],[[173824,177972],"valid"],[[177973,177983],"disallowed"],[[177984,178205],"valid"],[[178206,178207],"disallowed"],[[178208,183969],"valid"],[[183970,194559],"disallowed"],[[194560,194560],"mapped",[20029]],[[194561,194561],"mapped",[20024]],[[194562,194562],"mapped",[20033]],[[194563,194563],"mapped",[131362]],[[194564,194564],"mapped",[20320]],[[194565,194565],"mapped",[20398]],[[194566,194566],"mapped",[20411]],[[194567,194567],"mapped",[20482]],[[194568,194568],"mapped",[20602]],[[194569,194569],"mapped",[20633]],[[194570,194570],"mapped",[20711]],[[194571,194571],"mapped",[20687]],[[194572,194572],"mapped",[13470]],[[194573,194573],"mapped",[132666]],[[194574,194574],"mapped",[20813]],[[194575,194575],"mapped",[20820]],[[194576,194576],"mapped",[20836]],[[194577,194577],"mapped",[20855]],[[194578,194578],"mapped",[132380]],[[194579,194579],"mapped",[13497]],[[194580,194580],"mapped",[20839]],[[194581,194581],"mapped",[20877]],[[194582,194582],"mapped",[132427]],[[194583,194583],"mapped",[20887]],[[194584,194584],"mapped",[20900]],[[194585,194585],"mapped",[20172]],[[194586,194586],"mapped",[20908]],[[194587,194587],"mapped",[20917]],[[194588,194588],"mapped",[168415]],[[194589,194589],"mapped",[20981]],[[194590,194590],"mapped",[20995]],[[194591,194591],"mapped",[13535]],[[194592,194592],"mapped",[21051]],[[194593,194593],"mapped",[21062]],[[194594,194594],"mapped",[21106]],[[194595,194595],"mapped",[21111]],[[194596,194596],"mapped",[13589]],[[194597,194597],"mapped",[21191]],[[194598,194598],"mapped",[21193]],[[194599,194599],"mapped",[21220]],[[194600,194600],"mapped",[21242]],[[194601,194601],"mapped",[21253]],[[194602,194602],"mapped",[21254]],[[194603,194603],"mapped",[21271]],[[194604,194604],"mapped",[21321]],[[194605,194605],"mapped",[21329]],[[194606,194606],"mapped",[21338]],[[194607,194607],"mapped",[21363]],[[194608,194608],"mapped",[21373]],[[194609,194611],"mapped",[21375]],[[194612,194612],"mapped",[133676]],[[194613,194613],"mapped",[28784]],[[194614,194614],"mapped",[21450]],[[194615,194615],"mapped",[21471]],[[194616,194616],"mapped",[133987]],[[194617,194617],"mapped",[21483]],[[194618,194618],"mapped",[21489]],[[194619,194619],"mapped",[21510]],[[194620,194620],"mapped",[21662]],[[194621,194621],"mapped",[21560]],[[194622,194622],"mapped",[21576]],[[194623,194623],"mapped",[21608]],[[194624,194624],"mapped",[21666]],[[194625,194625],"mapped",[21750]],[[194626,194626],"mapped",[21776]],[[194627,194627],"mapped",[21843]],[[194628,194628],"mapped",[21859]],[[194629,194630],"mapped",[21892]],[[194631,194631],"mapped",[21913]],[[194632,194632],"mapped",[21931]],[[194633,194633],"mapped",[21939]],[[194634,194634],"mapped",[21954]],[[194635,194635],"mapped",[22294]],[[194636,194636],"mapped",[22022]],[[194637,194637],"mapped",[22295]],[[194638,194638],"mapped",[22097]],[[194639,194639],"mapped",[22132]],[[194640,194640],"mapped",[20999]],[[194641,194641],"mapped",[22766]],[[194642,194642],"mapped",[22478]],[[194643,194643],"mapped",[22516]],[[194644,194644],"mapped",[22541]],[[194645,194645],"mapped",[22411]],[[194646,194646],"mapped",[22578]],[[194647,194647],"mapped",[22577]],[[194648,194648],"mapped",[22700]],[[194649,194649],"mapped",[136420]],[[194650,194650],"mapped",[22770]],[[194651,194651],"mapped",[22775]],[[194652,194652],"mapped",[22790]],[[194653,194653],"mapped",[22810]],[[194654,194654],"mapped",[22818]],[[194655,194655],"mapped",[22882]],[[194656,194656],"mapped",[136872]],[[194657,194657],"mapped",[136938]],[[194658,194658],"mapped",[23020]],[[194659,194659],"mapped",[23067]],[[194660,194660],"mapped",[23079]],[[194661,194661],"mapped",[23000]],[[194662,194662],"mapped",[23142]],[[194663,194663],"mapped",[14062]],[[194664,194664],"disallowed"],[[194665,194665],"mapped",[23304]],[[194666,194667],"mapped",[23358]],[[194668,194668],"mapped",[137672]],[[194669,194669],"mapped",[23491]],[[194670,194670],"mapped",[23512]],[[194671,194671],"mapped",[23527]],[[194672,194672],"mapped",[23539]],[[194673,194673],"mapped",[138008]],[[194674,194674],"mapped",[23551]],[[194675,194675],"mapped",[23558]],[[194676,194676],"disallowed"],[[194677,194677],"mapped",[23586]],[[194678,194678],"mapped",[14209]],[[194679,194679],"mapped",[23648]],[[194680,194680],"mapped",[23662]],[[194681,194681],"mapped",[23744]],[[194682,194682],"mapped",[23693]],[[194683,194683],"mapped",[138724]],[[194684,194684],"mapped",[23875]],[[194685,194685],"mapped",[138726]],[[194686,194686],"mapped",[23918]],[[194687,194687],"mapped",[23915]],[[194688,194688],"mapped",[23932]],[[194689,194689],"mapped",[24033]],[[194690,194690],"mapped",[24034]],[[194691,194691],"mapped",[14383]],[[194692,194692],"mapped",[24061]],[[194693,194693],"mapped",[24104]],[[194694,194694],"mapped",[24125]],[[194695,194695],"mapped",[24169]],[[194696,194696],"mapped",[14434]],[[194697,194697],"mapped",[139651]],[[194698,194698],"mapped",[14460]],[[194699,194699],"mapped",[24240]],[[194700,194700],"mapped",[24243]],[[194701,194701],"mapped",[24246]],[[194702,194702],"mapped",[24266]],[[194703,194703],"mapped",[172946]],[[194704,194704],"mapped",[24318]],[[194705,194706],"mapped",[140081]],[[194707,194707],"mapped",[33281]],[[194708,194709],"mapped",[24354]],[[194710,194710],"mapped",[14535]],[[194711,194711],"mapped",[144056]],[[194712,194712],"mapped",[156122]],[[194713,194713],"mapped",[24418]],[[194714,194714],"mapped",[24427]],[[194715,194715],"mapped",[14563]],[[194716,194716],"mapped",[24474]],[[194717,194717],"mapped",[24525]],[[194718,194718],"mapped",[24535]],[[194719,194719],"mapped",[24569]],[[194720,194720],"mapped",[24705]],[[194721,194721],"mapped",[14650]],[[194722,194722],"mapped",[14620]],[[194723,194723],"mapped",[24724]],[[194724,194724],"mapped",[141012]],[[194725,194725],"mapped",[24775]],[[194726,194726],"mapped",[24904]],[[194727,194727],"mapped",[24908]],[[194728,194728],"mapped",[24910]],[[194729,194729],"mapped",[24908]],[[194730,194730],"mapped",[24954]],[[194731,194731],"mapped",[24974]],[[194732,194732],"mapped",[25010]],[[194733,194733],"mapped",[24996]],[[194734,194734],"mapped",[25007]],[[194735,194735],"mapped",[25054]],[[194736,194736],"mapped",[25074]],[[194737,194737],"mapped",[25078]],[[194738,194738],"mapped",[25104]],[[194739,194739],"mapped",[25115]],[[194740,194740],"mapped",[25181]],[[194741,194741],"mapped",[25265]],[[194742,194742],"mapped",[25300]],[[194743,194743],"mapped",[25424]],[[194744,194744],"mapped",[142092]],[[194745,194745],"mapped",[25405]],[[194746,194746],"mapped",[25340]],[[194747,194747],"mapped",[25448]],[[194748,194748],"mapped",[25475]],[[194749,194749],"mapped",[25572]],[[194750,194750],"mapped",[142321]],[[194751,194751],"mapped",[25634]],[[194752,194752],"mapped",[25541]],[[194753,194753],"mapped",[25513]],[[194754,194754],"mapped",[14894]],[[194755,194755],"mapped",[25705]],[[194756,194756],"mapped",[25726]],[[194757,194757],"mapped",[25757]],[[194758,194758],"mapped",[25719]],[[194759,194759],"mapped",[14956]],[[194760,194760],"mapped",[25935]],[[194761,194761],"mapped",[25964]],[[194762,194762],"mapped",[143370]],[[194763,194763],"mapped",[26083]],[[194764,194764],"mapped",[26360]],[[194765,194765],"mapped",[26185]],[[194766,194766],"mapped",[15129]],[[194767,194767],"mapped",[26257]],[[194768,194768],"mapped",[15112]],[[194769,194769],"mapped",[15076]],[[194770,194770],"mapped",[20882]],[[194771,194771],"mapped",[20885]],[[194772,194772],"mapped",[26368]],[[194773,194773],"mapped",[26268]],[[194774,194774],"mapped",[32941]],[[194775,194775],"mapped",[17369]],[[194776,194776],"mapped",[26391]],[[194777,194777],"mapped",[26395]],[[194778,194778],"mapped",[26401]],[[194779,194779],"mapped",[26462]],[[194780,194780],"mapped",[26451]],[[194781,194781],"mapped",[144323]],[[194782,194782],"mapped",[15177]],[[194783,194783],"mapped",[26618]],[[194784,194784],"mapped",[26501]],[[194785,194785],"mapped",[26706]],[[194786,194786],"mapped",[26757]],[[194787,194787],"mapped",[144493]],[[194788,194788],"mapped",[26766]],[[194789,194789],"mapped",[26655]],[[194790,194790],"mapped",[26900]],[[194791,194791],"mapped",[15261]],[[194792,194792],"mapped",[26946]],[[194793,194793],"mapped",[27043]],[[194794,194794],"mapped",[27114]],[[194795,194795],"mapped",[27304]],[[194796,194796],"mapped",[145059]],[[194797,194797],"mapped",[27355]],[[194798,194798],"mapped",[15384]],[[194799,194799],"mapped",[27425]],[[194800,194800],"mapped",[145575]],[[194801,194801],"mapped",[27476]],[[194802,194802],"mapped",[15438]],[[194803,194803],"mapped",[27506]],[[194804,194804],"mapped",[27551]],[[194805,194805],"mapped",[27578]],[[194806,194806],"mapped",[27579]],[[194807,194807],"mapped",[146061]],[[194808,194808],"mapped",[138507]],[[194809,194809],"mapped",[146170]],[[194810,194810],"mapped",[27726]],[[194811,194811],"mapped",[146620]],[[194812,194812],"mapped",[27839]],[[194813,194813],"mapped",[27853]],[[194814,194814],"mapped",[27751]],[[194815,194815],"mapped",[27926]],[[194816,194816],"mapped",[27966]],[[194817,194817],"mapped",[28023]],[[194818,194818],"mapped",[27969]],[[194819,194819],"mapped",[28009]],[[194820,194820],"mapped",[28024]],[[194821,194821],"mapped",[28037]],[[194822,194822],"mapped",[146718]],[[194823,194823],"mapped",[27956]],[[194824,194824],"mapped",[28207]],[[194825,194825],"mapped",[28270]],[[194826,194826],"mapped",[15667]],[[194827,194827],"mapped",[28363]],[[194828,194828],"mapped",[28359]],[[194829,194829],"mapped",[147153]],[[194830,194830],"mapped",[28153]],[[194831,194831],"mapped",[28526]],[[194832,194832],"mapped",[147294]],[[194833,194833],"mapped",[147342]],[[194834,194834],"mapped",[28614]],[[194835,194835],"mapped",[28729]],[[194836,194836],"mapped",[28702]],[[194837,194837],"mapped",[28699]],[[194838,194838],"mapped",[15766]],[[194839,194839],"mapped",[28746]],[[194840,194840],"mapped",[28797]],[[194841,194841],"mapped",[28791]],[[194842,194842],"mapped",[28845]],[[194843,194843],"mapped",[132389]],[[194844,194844],"mapped",[28997]],[[194845,194845],"mapped",[148067]],[[194846,194846],"mapped",[29084]],[[194847,194847],"disallowed"],[[194848,194848],"mapped",[29224]],[[194849,194849],"mapped",[29237]],[[194850,194850],"mapped",[29264]],[[194851,194851],"mapped",[149000]],[[194852,194852],"mapped",[29312]],[[194853,194853],"mapped",[29333]],[[194854,194854],"mapped",[149301]],[[194855,194855],"mapped",[149524]],[[194856,194856],"mapped",[29562]],[[194857,194857],"mapped",[29579]],[[194858,194858],"mapped",[16044]],[[194859,194859],"mapped",[29605]],[[194860,194861],"mapped",[16056]],[[194862,194862],"mapped",[29767]],[[194863,194863],"mapped",[29788]],[[194864,194864],"mapped",[29809]],[[194865,194865],"mapped",[29829]],[[194866,194866],"mapped",[29898]],[[194867,194867],"mapped",[16155]],[[194868,194868],"mapped",[29988]],[[194869,194869],"mapped",[150582]],[[194870,194870],"mapped",[30014]],[[194871,194871],"mapped",[150674]],[[194872,194872],"mapped",[30064]],[[194873,194873],"mapped",[139679]],[[194874,194874],"mapped",[30224]],[[194875,194875],"mapped",[151457]],[[194876,194876],"mapped",[151480]],[[194877,194877],"mapped",[151620]],[[194878,194878],"mapped",[16380]],[[194879,194879],"mapped",[16392]],[[194880,194880],"mapped",[30452]],[[194881,194881],"mapped",[151795]],[[194882,194882],"mapped",[151794]],[[194883,194883],"mapped",[151833]],[[194884,194884],"mapped",[151859]],[[194885,194885],"mapped",[30494]],[[194886,194887],"mapped",[30495]],[[194888,194888],"mapped",[30538]],[[194889,194889],"mapped",[16441]],[[194890,194890],"mapped",[30603]],[[194891,194891],"mapped",[16454]],[[194892,194892],"mapped",[16534]],[[194893,194893],"mapped",[152605]],[[194894,194894],"mapped",[30798]],[[194895,194895],"mapped",[30860]],[[194896,194896],"mapped",[30924]],[[194897,194897],"mapped",[16611]],[[194898,194898],"mapped",[153126]],[[194899,194899],"mapped",[31062]],[[194900,194900],"mapped",[153242]],[[194901,194901],"mapped",[153285]],[[194902,194902],"mapped",[31119]],[[194903,194903],"mapped",[31211]],[[194904,194904],"mapped",[16687]],[[194905,194905],"mapped",[31296]],[[194906,194906],"mapped",[31306]],[[194907,194907],"mapped",[31311]],[[194908,194908],"mapped",[153980]],[[194909,194910],"mapped",[154279]],[[194911,194911],"disallowed"],[[194912,194912],"mapped",[16898]],[[194913,194913],"mapped",[154539]],[[194914,194914],"mapped",[31686]],[[194915,194915],"mapped",[31689]],[[194916,194916],"mapped",[16935]],[[194917,194917],"mapped",[154752]],[[194918,194918],"mapped",[31954]],[[194919,194919],"mapped",[17056]],[[194920,194920],"mapped",[31976]],[[194921,194921],"mapped",[31971]],[[194922,194922],"mapped",[32000]],[[194923,194923],"mapped",[155526]],[[194924,194924],"mapped",[32099]],[[194925,194925],"mapped",[17153]],[[194926,194926],"mapped",[32199]],[[194927,194927],"mapped",[32258]],[[194928,194928],"mapped",[32325]],[[194929,194929],"mapped",[17204]],[[194930,194930],"mapped",[156200]],[[194931,194931],"mapped",[156231]],[[194932,194932],"mapped",[17241]],[[194933,194933],"mapped",[156377]],[[194934,194934],"mapped",[32634]],[[194935,194935],"mapped",[156478]],[[194936,194936],"mapped",[32661]],[[194937,194937],"mapped",[32762]],[[194938,194938],"mapped",[32773]],[[194939,194939],"mapped",[156890]],[[194940,194940],"mapped",[156963]],[[194941,194941],"mapped",[32864]],[[194942,194942],"mapped",[157096]],[[194943,194943],"mapped",[32880]],[[194944,194944],"mapped",[144223]],[[194945,194945],"mapped",[17365]],[[194946,194946],"mapped",[32946]],[[194947,194947],"mapped",[33027]],[[194948,194948],"mapped",[17419]],[[194949,194949],"mapped",[33086]],[[194950,194950],"mapped",[23221]],[[194951,194951],"mapped",[157607]],[[194952,194952],"mapped",[157621]],[[194953,194953],"mapped",[144275]],[[194954,194954],"mapped",[144284]],[[194955,194955],"mapped",[33281]],[[194956,194956],"mapped",[33284]],[[194957,194957],"mapped",[36766]],[[194958,194958],"mapped",[17515]],[[194959,194959],"mapped",[33425]],[[194960,194960],"mapped",[33419]],[[194961,194961],"mapped",[33437]],[[194962,194962],"mapped",[21171]],[[194963,194963],"mapped",[33457]],[[194964,194964],"mapped",[33459]],[[194965,194965],"mapped",[33469]],[[194966,194966],"mapped",[33510]],[[194967,194967],"mapped",[158524]],[[194968,194968],"mapped",[33509]],[[194969,194969],"mapped",[33565]],[[194970,194970],"mapped",[33635]],[[194971,194971],"mapped",[33709]],[[194972,194972],"mapped",[33571]],[[194973,194973],"mapped",[33725]],[[194974,194974],"mapped",[33767]],[[194975,194975],"mapped",[33879]],[[194976,194976],"mapped",[33619]],[[194977,194977],"mapped",[33738]],[[194978,194978],"mapped",[33740]],[[194979,194979],"mapped",[33756]],[[194980,194980],"mapped",[158774]],[[194981,194981],"mapped",[159083]],[[194982,194982],"mapped",[158933]],[[194983,194983],"mapped",[17707]],[[194984,194984],"mapped",[34033]],[[194985,194985],"mapped",[34035]],[[194986,194986],"mapped",[34070]],[[194987,194987],"mapped",[160714]],[[194988,194988],"mapped",[34148]],[[194989,194989],"mapped",[159532]],[[194990,194990],"mapped",[17757]],[[194991,194991],"mapped",[17761]],[[194992,194992],"mapped",[159665]],[[194993,194993],"mapped",[159954]],[[194994,194994],"mapped",[17771]],[[194995,194995],"mapped",[34384]],[[194996,194996],"mapped",[34396]],[[194997,194997],"mapped",[34407]],[[194998,194998],"mapped",[34409]],[[194999,194999],"mapped",[34473]],[[195000,195000],"mapped",[34440]],[[195001,195001],"mapped",[34574]],[[195002,195002],"mapped",[34530]],[[195003,195003],"mapped",[34681]],[[195004,195004],"mapped",[34600]],[[195005,195005],"mapped",[34667]],[[195006,195006],"mapped",[34694]],[[195007,195007],"disallowed"],[[195008,195008],"mapped",[34785]],[[195009,195009],"mapped",[34817]],[[195010,195010],"mapped",[17913]],[[195011,195011],"mapped",[34912]],[[195012,195012],"mapped",[34915]],[[195013,195013],"mapped",[161383]],[[195014,195014],"mapped",[35031]],[[195015,195015],"mapped",[35038]],[[195016,195016],"mapped",[17973]],[[195017,195017],"mapped",[35066]],[[195018,195018],"mapped",[13499]],[[195019,195019],"mapped",[161966]],[[195020,195020],"mapped",[162150]],[[195021,195021],"mapped",[18110]],[[195022,195022],"mapped",[18119]],[[195023,195023],"mapped",[35488]],[[195024,195024],"mapped",[35565]],[[195025,195025],"mapped",[35722]],[[195026,195026],"mapped",[35925]],[[195027,195027],"mapped",[162984]],[[195028,195028],"mapped",[36011]],[[195029,195029],"mapped",[36033]],[[195030,195030],"mapped",[36123]],[[195031,195031],"mapped",[36215]],[[195032,195032],"mapped",[163631]],[[195033,195033],"mapped",[133124]],[[195034,195034],"mapped",[36299]],[[195035,195035],"mapped",[36284]],[[195036,195036],"mapped",[36336]],[[195037,195037],"mapped",[133342]],[[195038,195038],"mapped",[36564]],[[195039,195039],"mapped",[36664]],[[195040,195040],"mapped",[165330]],[[195041,195041],"mapped",[165357]],[[195042,195042],"mapped",[37012]],[[195043,195043],"mapped",[37105]],[[195044,195044],"mapped",[37137]],[[195045,195045],"mapped",[165678]],[[195046,195046],"mapped",[37147]],[[195047,195047],"mapped",[37432]],[[195048,195048],"mapped",[37591]],[[195049,195049],"mapped",[37592]],[[195050,195050],"mapped",[37500]],[[195051,195051],"mapped",[37881]],[[195052,195052],"mapped",[37909]],[[195053,195053],"mapped",[166906]],[[195054,195054],"mapped",[38283]],[[195055,195055],"mapped",[18837]],[[195056,195056],"mapped",[38327]],[[195057,195057],"mapped",[167287]],[[195058,195058],"mapped",[18918]],[[195059,195059],"mapped",[38595]],[[195060,195060],"mapped",[23986]],[[195061,195061],"mapped",[38691]],[[195062,195062],"mapped",[168261]],[[195063,195063],"mapped",[168474]],[[195064,195064],"mapped",[19054]],[[195065,195065],"mapped",[19062]],[[195066,195066],"mapped",[38880]],[[195067,195067],"mapped",[168970]],[[195068,195068],"mapped",[19122]],[[195069,195069],"mapped",[169110]],[[195070,195071],"mapped",[38923]],[[195072,195072],"mapped",[38953]],[[195073,195073],"mapped",[169398]],[[195074,195074],"mapped",[39138]],[[195075,195075],"mapped",[19251]],[[195076,195076],"mapped",[39209]],[[195077,195077],"mapped",[39335]],[[195078,195078],"mapped",[39362]],[[195079,195079],"mapped",[39422]],[[195080,195080],"mapped",[19406]],[[195081,195081],"mapped",[170800]],[[195082,195082],"mapped",[39698]],[[195083,195083],"mapped",[40000]],[[195084,195084],"mapped",[40189]],[[195085,195085],"mapped",[19662]],[[195086,195086],"mapped",[19693]],[[195087,195087],"mapped",[40295]],[[195088,195088],"mapped",[172238]],[[195089,195089],"mapped",[19704]],[[195090,195090],"mapped",[172293]],[[195091,195091],"mapped",[172558]],[[195092,195092],"mapped",[172689]],[[195093,195093],"mapped",[40635]],[[195094,195094],"mapped",[19798]],[[195095,195095],"mapped",[40697]],[[195096,195096],"mapped",[40702]],[[195097,195097],"mapped",[40709]],[[195098,195098],"mapped",[40719]],[[195099,195099],"mapped",[40726]],[[195100,195100],"mapped",[40763]],[[195101,195101],"mapped",[173568]],[[195102,196605],"disallowed"],[[196606,196607],"disallowed"],[[196608,262141],"disallowed"],[[262142,262143],"disallowed"],[[262144,327677],"disallowed"],[[327678,327679],"disallowed"],[[327680,393213],"disallowed"],[[393214,393215],"disallowed"],[[393216,458749],"disallowed"],[[458750,458751],"disallowed"],[[458752,524285],"disallowed"],[[524286,524287],"disallowed"],[[524288,589821],"disallowed"],[[589822,589823],"disallowed"],[[589824,655357],"disallowed"],[[655358,655359],"disallowed"],[[655360,720893],"disallowed"],[[720894,720895],"disallowed"],[[720896,786429],"disallowed"],[[786430,786431],"disallowed"],[[786432,851965],"disallowed"],[[851966,851967],"disallowed"],[[851968,917501],"disallowed"],[[917502,917503],"disallowed"],[[917504,917504],"disallowed"],[[917505,917505],"disallowed"],[[917506,917535],"disallowed"],[[917536,917631],"disallowed"],[[917632,917759],"disallowed"],[[917760,917999],"ignored"],[[918000,983037],"disallowed"],[[983038,983039],"disallowed"],[[983040,1048573],"disallowed"],[[1048574,1048575],"disallowed"],[[1048576,1114109],"disallowed"],[[1114110,1114111],"disallowed"]]');

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"@github/vscode-github-actions","displayName":"GitHub Actions","publisher":"github","icon":"resources/logo.png","license":"MIT","repository":{"url":"https://github.com/github/vscode-github-actions"},"description":"GitHub Actions workflows and runs for github.com hosted repositories in VS Code","version":"0.26.2","engines":{"vscode":"^1.72.0","node":">= 16"},"extensionKind":["workspace"],"capabilities":{"virtualWorkspaces":true},"categories":["Other"],"activationEvents":["onView:workflows","onView:settings","workspaceContains:**/.github/workflows/**"],"main":"./dist/extension-node.js","browser":"./dist/extension-web.js","contributes":{"languages":[{"id":"github-actions-workflow","aliases":["GitHub Actions Workflow"],"filenamePatterns":["**/.github/workflows/**/*.yml","**/.github/workflows/**/*.yaml"],"configuration":"./language/language-configuration.json","icon":{"dark":"resources/icons/dark/lang.svg","light":"resources/icons/light/lang.svg"}}],"grammars":[{"language":"github-actions-workflow","scopeName":"source.github-actions-workflow","path":"./language/syntaxes/yaml.tmLanguage.json"},{"scopeName":"source.github-actions-workflow.github-actions-expression","path":"./language/syntaxes/expressions.tmGrammar.json","injectTo":["source.github-actions-workflow"]}],"configuration":{"title":"GitHub Actions","properties":{"github-actions.workflows.pinned.workflows":{"description":"Workflows to show in the status bar, identified by their paths","type":"array","scope":"window"},"github-actions.workflows.pinned.refresh.enabled":{"type":"boolean","description":"Auto-refresh pinned workflows. Note: this uses polling and counts against your GitHub API rate limit","default":false,"scope":"window"},"github-actions.workflows.pinned.refresh.interval":{"type":"number","description":"Time to wait between calls to update pinned workflows in seconds","default":30,"scope":"window"},"github-actions.remote-name":{"type":"string","description":"The name of the repository\'s git remote that points to GitHub","default":"origin","scope":"window"},"github-actions.use-enterprise":{"type":"boolean","markdownDescription":"If this is set to true, use the auth provider for the GitHub Enterprise URL configured in `github-enterprise.uri`","default":false,"scope":"window"}}},"commands":[{"command":"github-actions.explorer.refresh","category":"GitHub Actions","title":"Refresh","icon":{"dark":"resources/icons/dark/refresh.svg","light":"resources/icons/light/refresh.svg"}},{"command":"github-actions.explorer.current-branch.refresh","category":"GitHub Actions","title":"Refresh current branch","icon":{"dark":"resources/icons/dark/refresh.svg","light":"resources/icons/light/refresh.svg"}},{"command":"github-actions.explorer.openRun","category":"GitHub Actions","title":"Open workflow run","when":"viewItem =~ /workflow/"},{"command":"github-actions.explorer.openWorkflowFile","category":"GitHub Actions","title":"Open workflow","when":"viewItem =~ /workflow/"},{"command":"github-actions.explorer.triggerRun","category":"GitHub Actions","title":"Trigger workflow","when":"viewItem =~ /workflow/ && viewItem =~ /dispatch/","icon":{"dark":"resources/icons/dark/run.svg","light":"resources/icons/light/run.svg"}},{"command":"github-actions.workflow.run.open","category":"GitHub Actions","title":"Open workflow run","when":"viewItem =~ /run/","icon":"$(globe)"},{"command":"github-actions.workflow.logs","category":"GitHub Actions","title":"View job logs","when":"viewItem =~ /job/","icon":{"dark":"resources/icons/dark/logs.svg","light":"resources/icons/light/logs.svg"}},{"command":"github-actions.step.logs","category":"GitHub Actions","title":"View step logs","when":"viewItem =~ /step/","icon":"$(globe)"},{"command":"github-actions.workflow.run.rerun","category":"GitHub Actions","title":"Rerun workflow run","when":"viewItem =~ /run/ && viewItem =~ /rerunnable/"},{"command":"github-actions.workflow.run.cancel","category":"GitHub Actions","title":"Cancel workflow run","when":"viewItem =~ /run/ && viewItem =~ /cancelable/"},{"command":"github-actions.settings.secrets.manage","category":"GitHub Actions","title":"Add new secret","icon":"$(globe)"},{"command":"github-actions.settings.secret.add","category":"GitHub Actions","title":"Add new secret","icon":{"dark":"resources/icons/dark/add.svg","light":"resources/icons/light/add.svg"}},{"command":"github-actions.settings.secret.copy","category":"GitHub Actions","title":"Copy secret name"},{"command":"github-actions.settings.secret.update","category":"GitHub Actions","title":"Update secret","icon":{"dark":"resources/icons/dark/edit.svg","light":"resources/icons/light/edit.svg"}},{"command":"github-actions.settings.secret.delete","category":"GitHub Actions","title":"Delete secret","icon":{"dark":"resources/icons/dark/remove.svg","light":"resources/icons/light/remove.svg"}},{"command":"github-actions.settings.variable.add","category":"GitHub Actions","title":"Add new variable","icon":{"dark":"resources/icons/dark/add.svg","light":"resources/icons/light/add.svg"}},{"command":"github-actions.settings.variable.update","category":"GitHub Actions","title":"Update variable","icon":{"dark":"resources/icons/dark/edit.svg","light":"resources/icons/light/edit.svg"}},{"command":"github-actions.settings.variable.delete","category":"GitHub Actions","title":"Delete variable","icon":{"dark":"resources/icons/dark/remove.svg","light":"resources/icons/light/remove.svg"}},{"command":"github-actions.settings.variable.copy-name","category":"GitHub Actions","title":"Copy variable name"},{"command":"github-actions.settings.variable.copy-value","category":"GitHub Actions","title":"Copy variable value"},{"command":"github-actions.workflow.pin","category":"GitHub Actions","title":"Pin workflow","icon":"$(pin)"},{"command":"github-actions.workflow.unpin","category":"GitHub Actions","title":"Unpin workflow","icon":"$(pinned)"},{"command":"github-actions.sign-in","title":"Sign in to GitHub"}],"views":{"github-actions":[{"id":"github-actions.current-branch","name":"Current Branch","when":"github-actions.internet-access && github-actions.signed-in && github-actions.has-repos"},{"id":"github-actions.workflows","name":"Workflows","when":"github-actions.internet-access && github-actions.signed-in && github-actions.has-repos"},{"id":"github-actions.settings","name":"Settings","when":"github-actions.internet-access && github-actions.signed-in && github-actions.has-repos"},{"id":"github-actions.empty-view","name":"","when":"!github-actions.internet-access || !github-actions.signed-in || !github-actions.has-repos"}]},"viewsWelcome":[{"view":"github-actions.empty-view","contents":"Sign in to GitHub to display runs, workflows, and configure Actions settings.\\n[Sign in to GitHub](command:github-actions.sign-in)","when":"!github-actions.signed-in"},{"view":"github-actions.empty-view","contents":"Unable to connect to the GitHub API, please check your internet connection.\\n[Refresh](command:github-actions.explorer.refresh)","when":"github-actions.signed-in && !github-actions.internet-access"},{"view":"github-actions.empty-view","contents":"No GitHub repositories found. Please open a folder that contains a GitHub repository.","when":"github-actions.internet-access && github-actions.signed-in && !github-actions.has-repos"}],"viewsContainers":{"activitybar":[{"id":"github-actions","title":"GitHub Actions","icon":"resources/icons/light/explorer.svg"}]},"menus":{"view/title":[{"command":"github-actions.explorer.refresh","group":"navigation","when":"view == github-actions.workflows || view == github-actions.settings"},{"command":"github-actions.explorer.current-branch.refresh","group":"navigation","when":"view == github-actions.current-branch"}],"editor/title":[{"command":"github-actions.explorer.triggerRun","when":"(githubActions:activeFile =~ /rdispatch/ || githubActions:activeFile =~ /wdispatch/) && resourceExtname =~ /\\\\.ya?ml/","group":"navigation"}],"view/item/context":[{"command":"github-actions.explorer.openWorkflowFile","when":"viewItem =~ /workflow/"},{"command":"github-actions.workflow.pin","group":"inline@1","when":"viewItem =~ /workflow/ && viewItem =~ /pinnable/"},{"command":"github-actions.workflow.pin","when":"viewItem =~ /workflow/ && viewItem =~ /pinnable/"},{"command":"github-actions.workflow.unpin","group":"inline@2","when":"viewItem =~ /workflow/ && viewItem =~ /pinned/"},{"command":"github-actions.workflow.unpin","when":"viewItem =~ /workflow/ && viewItem =~ /pinned/"},{"command":"github-actions.explorer.triggerRun","group":"inline@10","when":"viewItem =~ /rdispatch/ || viewItem =~ /wdispatch/"},{"command":"github-actions.explorer.triggerRun","when":"viewItem =~ /rdispatch/ || viewItem =~ /wdispatch/"},{"command":"github-actions.workflow.run.open","when":"viewItem =~ /run\\\\s/","group":"inline"},{"command":"github-actions.workflow.logs","group":"inline","when":"viewItem =~ /job/ && viewItem =~ /completed/"},{"command":"github-actions.step.logs","group":"inline","when":"viewItem =~ /step/ && viewItem =~ /completed/"},{"command":"github-actions.workflow.run.cancel","when":"viewItem =~ /run/ && viewItem =~ /cancelable/"},{"command":"github-actions.workflow.run.rerun","when":"viewItem =~ /run/ && viewItem =~ /rerunnable/"},{"command":"github-actions.settings.secret.add","group":"inline","when":"viewItem == \'secrets\' || viewItem == \'environment-secrets\'"},{"command":"github-actions.settings.secret.update","when":"viewItem == \'repo-secret\' || viewItem == \'env-secret\'","group":"inline@1"},{"command":"github-actions.settings.secret.copy","when":"viewItem == \'repo-secret\' || viewItem == \'env-secret\' || viewItem == \'org-secret\'","group":"context"},{"command":"github-actions.settings.secret.delete","when":"viewItem == \'repo-secret\' || viewItem == \'env-secret\' ","group":"inline@2"},{"command":"github-actions.settings.variable.add","group":"inline","when":"viewItem == \'repo-variables\' || viewItem == \'environment-variables\'"},{"command":"github-actions.settings.variable.update","group":"inline@1","when":"viewItem == \'repo-variable\' || viewItem == \'env-variable\'"},{"command":"github-actions.settings.variable.delete","group":"inline@2","when":"viewItem == \'repo-variable\' || viewItem == \'env-variable\'"},{"command":"github-actions.settings.variable.copy-name","when":"viewItem == \'repo-variable\' || viewItem == \'env-variable\' || viewItem == \'org-variable\'","group":"context"},{"command":"github-actions.settings.variable.copy-value","when":"viewItem == \'repo-variable\' || viewItem == \'env-variable\' || viewItem == \'org-variable\'","group":"context"}],"commandPalette":[{"command":"github-actions.explorer.openRun","when":"false"},{"command":"github-actions.explorer.openWorkflowFile","when":"false"},{"command":"github-actions.explorer.triggerRun","when":"false"},{"command":"github-actions.workflow.run.open","when":"false"},{"command":"github-actions.workflow.logs","when":"false"},{"command":"github-actions.step.logs","when":"false"},{"command":"github-actions.workflow.run.rerun","when":"false"},{"command":"github-actions.workflow.run.cancel","when":"false"},{"command":"github-actions.settings.secrets.manage","when":"false"},{"command":"github-actions.settings.secret.add","when":"false"},{"command":"github-actions.settings.secret.copy","when":"false"},{"command":"github-actions.settings.secret.update","when":"false"},{"command":"github-actions.settings.secret.delete","when":"false"},{"command":"github-actions.settings.variable.add","when":"false"},{"command":"github-actions.settings.variable.update","when":"false"},{"command":"github-actions.settings.variable.delete","when":"false"},{"command":"github-actions.settings.variable.copy-name","when":"false"},{"command":"github-actions.settings.variable.copy-value","when":"false"},{"command":"github-actions.workflow.pin","when":"false"},{"command":"github-actions.workflow.unpin","when":"false"},{"command":"github-actions.sign-in","when":"false"}]}},"scripts":{"clean":"rimraf ./dist ./out","package":"npm run clean && vsce package","build":"webpack ","vscode:prepublish":"npm run build","watch":"webpack  --mode development --env esbuild","open-in-browser":"vscode-test-web --extensionDevelopmentPath=. .","lint":"eslint . --ext .ts","lint-fix":"eslint . --ext .ts --fix","format":"prettier --write \\"**/*.ts\\"","format-check":"prettier --check \\"**/*.ts\\"","test":"cross-env NODE_OPTIONS=\\"--experimental-vm-modules\\" jest","test-watch":"NODE_OPTIONS=\\"--experimental-vm-modules\\" jest --watch"},"devDependencies":{"@types/jest":"^29.0.3","@types/libsodium-wrappers":"^0.7.10","@types/uuid":"^3.4.6","@types/vscode":"^1.72.0","@typescript-eslint/eslint-plugin":"^5.40.0","@typescript-eslint/parser":"^5.40.0","@vscode/test-web":"*","cross-env":"^7.0.3","eslint":"^8.25.0","eslint-config-prettier":"^8.5.0","eslint-plugin-prettier":"^4.2.1","jest":"^29.0.3","node-loader":"^0.6.0","prettier":"^2.8.3","rimraf":"^3.0.1","source-map-loader":"^4.0.1","ts-jest":"^29.0.3","ts-loader":"^9.4.1","typescript":"^4.9.4","webpack":"5.91.0","webpack-cli":"5.1.4"},"dependencies":{"@actions/languageserver":"*","@actions/workflow-parser":"*","@octokit/rest":"^19.0.7","@vscode/vsce":"^2.19.0","buffer":"^6.0.3","crypto-browserify":"^3.12.0","dayjs":"^1.11.7","libsodium-wrappers":"^0.7.10","path-browserify":"^1.0.1","ssh-config":"^3.0.0","stream-browserify":"^3.0.0","timers-browserify":"^2.0.12","tunnel":"0.0.6","undici":"6.7.0","util":"^0.12.1","uuid":"^3.3.3","vscode-languageclient":"^8.0.2"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**************************!*\
  !*** ./src/extension.ts ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   activate: () => (/* binding */ activate),
/* harmony export */   deactivate: () => (/* binding */ deactivate)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api/canReachGitHubAPI */ "./src/api/canReachGitHubAPI.ts");
/* harmony import */ var _auth_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./auth/auth */ "./src/auth/auth.ts");
/* harmony import */ var _commands_cancelWorkflowRun__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commands/cancelWorkflowRun */ "./src/commands/cancelWorkflowRun.ts");
/* harmony import */ var _commands_openWorkflowFile__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./commands/openWorkflowFile */ "./src/commands/openWorkflowFile.ts");
/* harmony import */ var _commands_openWorkflowJobLogs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./commands/openWorkflowJobLogs */ "./src/commands/openWorkflowJobLogs.ts");
/* harmony import */ var _commands_openWorkflowStepLogs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./commands/openWorkflowStepLogs */ "./src/commands/openWorkflowStepLogs.ts");
/* harmony import */ var _commands_openWorkflowRun__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./commands/openWorkflowRun */ "./src/commands/openWorkflowRun.ts");
/* harmony import */ var _commands_pinWorkflow__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./commands/pinWorkflow */ "./src/commands/pinWorkflow.ts");
/* harmony import */ var _commands_rerunWorkflowRun__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./commands/rerunWorkflowRun */ "./src/commands/rerunWorkflowRun.ts");
/* harmony import */ var _commands_secrets_addSecret__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./commands/secrets/addSecret */ "./src/commands/secrets/addSecret.ts");
/* harmony import */ var _commands_secrets_copySecret__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./commands/secrets/copySecret */ "./src/commands/secrets/copySecret.ts");
/* harmony import */ var _commands_secrets_deleteSecret__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./commands/secrets/deleteSecret */ "./src/commands/secrets/deleteSecret.ts");
/* harmony import */ var _commands_secrets_updateSecret__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./commands/secrets/updateSecret */ "./src/commands/secrets/updateSecret.ts");
/* harmony import */ var _commands_triggerWorkflowRun__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./commands/triggerWorkflowRun */ "./src/commands/triggerWorkflowRun.ts");
/* harmony import */ var _commands_unpinWorkflow__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./commands/unpinWorkflow */ "./src/commands/unpinWorkflow.ts");
/* harmony import */ var _commands_variables_addVariable__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./commands/variables/addVariable */ "./src/commands/variables/addVariable.ts");
/* harmony import */ var _commands_variables_copyVariable__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./commands/variables/copyVariable */ "./src/commands/variables/copyVariable.ts");
/* harmony import */ var _commands_variables_deleteVariable__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./commands/variables/deleteVariable */ "./src/commands/variables/deleteVariable.ts");
/* harmony import */ var _commands_variables_updateVariable__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./commands/variables/updateVariable */ "./src/commands/variables/updateVariable.ts");
/* harmony import */ var _configuration_configuration__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./configuration/configuration */ "./src/configuration/configuration.ts");
/* harmony import */ var _git_repository__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./git/repository */ "./src/git/repository.ts");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./log */ "./src/log.ts");
/* harmony import */ var _logs_constants__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./logs/constants */ "./src/logs/constants.ts");
/* harmony import */ var _logs_fileProvider__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./logs/fileProvider */ "./src/logs/fileProvider.ts");
/* harmony import */ var _logs_foldingProvider__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./logs/foldingProvider */ "./src/logs/foldingProvider.ts");
/* harmony import */ var _logs_symbolProvider__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./logs/symbolProvider */ "./src/logs/symbolProvider.ts");
/* harmony import */ var _pinnedWorkflows_pinnedWorkflows__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./pinnedWorkflows/pinnedWorkflows */ "./src/pinnedWorkflows/pinnedWorkflows.ts");
/* harmony import */ var _store_store__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./store/store */ "./src/store/store.ts");
/* harmony import */ var _tracker_workflowDocumentTracker__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./tracker/workflowDocumentTracker */ "./src/tracker/workflowDocumentTracker.ts");
/* harmony import */ var _tracker_workspaceTracker__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./tracker/workspaceTracker */ "./src/tracker/workspaceTracker.ts");
/* harmony import */ var _treeViews_icons__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./treeViews/icons */ "./src/treeViews/icons.ts");
/* harmony import */ var _treeViews_treeViews__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./treeViews/treeViews */ "./src/treeViews/treeViews.ts");
/* harmony import */ var _workflow_languageServer__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./workflow/languageServer */ "./src/workflow/languageServer.ts");
/* harmony import */ var _commands_signIn__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./commands/signIn */ "./src/commands/signIn.ts");



































async function activate(context) {
    (0,_log__WEBPACK_IMPORTED_MODULE_22__.init)();
    (0,_log__WEBPACK_IMPORTED_MODULE_22__.log)("Activating GitHub Actions extension...");
    const hasSession = !!(await (0,_auth_auth__WEBPACK_IMPORTED_MODULE_2__.getSession)());
    const canReachAPI = hasSession && (await (0,_api_canReachGitHubAPI__WEBPACK_IMPORTED_MODULE_1__.canReachGitHubAPI)());
    // Prefetch git repository origin url
    const ghContext = hasSession && (await (0,_git_repository__WEBPACK_IMPORTED_MODULE_21__.getGitHubContext)());
    const hasGitHubRepos = ghContext && ghContext.repos.length > 0;
    await Promise.all([
        vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "github-actions.signed-in", hasSession),
        vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "github-actions.internet-access", canReachAPI),
        vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand("setContext", "github-actions.has-repos", hasGitHubRepos)
    ]);
    (0,_treeViews_icons__WEBPACK_IMPORTED_MODULE_31__.initResources)(context);
    (0,_configuration_configuration__WEBPACK_IMPORTED_MODULE_20__.initConfiguration)(context);
    // Track workflow documents and workspace changes
    (0,_tracker_workspaceTracker__WEBPACK_IMPORTED_MODULE_30__.initWorkspaceChangeTracker)(context);
    await (0,_tracker_workflowDocumentTracker__WEBPACK_IMPORTED_MODULE_29__.initWorkflowDocumentTracking)(context);
    const store = new _store_store__WEBPACK_IMPORTED_MODULE_28__.RunStore();
    // Pinned workflows
    await (0,_pinnedWorkflows_pinnedWorkflows__WEBPACK_IMPORTED_MODULE_27__.initPinnedWorkflows)(store);
    // Tree views
    await (0,_treeViews_treeViews__WEBPACK_IMPORTED_MODULE_32__.initTreeViews)(context, store);
    // Commands
    (0,_commands_openWorkflowRun__WEBPACK_IMPORTED_MODULE_7__.registerOpenWorkflowRun)(context);
    (0,_commands_openWorkflowFile__WEBPACK_IMPORTED_MODULE_4__.registerOpenWorkflowFile)(context);
    (0,_commands_openWorkflowJobLogs__WEBPACK_IMPORTED_MODULE_5__.registerOpenWorkflowJobLogs)(context);
    (0,_commands_openWorkflowStepLogs__WEBPACK_IMPORTED_MODULE_6__.registerOpenWorkflowStepLogs)(context);
    (0,_commands_triggerWorkflowRun__WEBPACK_IMPORTED_MODULE_14__.registerTriggerWorkflowRun)(context);
    (0,_commands_rerunWorkflowRun__WEBPACK_IMPORTED_MODULE_9__.registerReRunWorkflowRun)(context);
    (0,_commands_cancelWorkflowRun__WEBPACK_IMPORTED_MODULE_3__.registerCancelWorkflowRun)(context);
    (0,_commands_secrets_addSecret__WEBPACK_IMPORTED_MODULE_10__.registerAddSecret)(context);
    (0,_commands_secrets_deleteSecret__WEBPACK_IMPORTED_MODULE_12__.registerDeleteSecret)(context);
    (0,_commands_secrets_copySecret__WEBPACK_IMPORTED_MODULE_11__.registerCopySecret)(context);
    (0,_commands_secrets_updateSecret__WEBPACK_IMPORTED_MODULE_13__.registerUpdateSecret)(context);
    (0,_commands_variables_addVariable__WEBPACK_IMPORTED_MODULE_16__.registerAddVariable)(context);
    (0,_commands_variables_updateVariable__WEBPACK_IMPORTED_MODULE_19__.registerUpdateVariable)(context);
    (0,_commands_variables_deleteVariable__WEBPACK_IMPORTED_MODULE_18__.registerDeleteVariable)(context);
    (0,_commands_variables_copyVariable__WEBPACK_IMPORTED_MODULE_17__.registerCopyVariable)(context);
    (0,_commands_pinWorkflow__WEBPACK_IMPORTED_MODULE_8__.registerPinWorkflow)(context);
    (0,_commands_unpinWorkflow__WEBPACK_IMPORTED_MODULE_15__.registerUnPinWorkflow)(context);
    (0,_commands_signIn__WEBPACK_IMPORTED_MODULE_34__.registerSignIn)(context);
    // Log providers
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.registerTextDocumentContentProvider(_logs_constants__WEBPACK_IMPORTED_MODULE_23__.LogScheme, new _logs_fileProvider__WEBPACK_IMPORTED_MODULE_24__.WorkflowStepLogProvider()));
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.languages.registerFoldingRangeProvider({ scheme: _logs_constants__WEBPACK_IMPORTED_MODULE_23__.LogScheme }, new _logs_foldingProvider__WEBPACK_IMPORTED_MODULE_25__.WorkflowStepLogFoldingProvider()));
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.languages.registerDocumentSymbolProvider({
        scheme: _logs_constants__WEBPACK_IMPORTED_MODULE_23__.LogScheme
    }, new _logs_symbolProvider__WEBPACK_IMPORTED_MODULE_26__.WorkflowStepLogSymbolProvider()));
    // Editing features
    await (0,_workflow_languageServer__WEBPACK_IMPORTED_MODULE_33__.initLanguageServer)(context);
    (0,_log__WEBPACK_IMPORTED_MODULE_22__.log)("...initialized");
    if (true) {
        // In debugging mode, always open the log for the extension in the `Output` window
        (0,_log__WEBPACK_IMPORTED_MODULE_22__.revealLog)();
    }
}
function deactivate() {
    return (0,_workflow_languageServer__WEBPACK_IMPORTED_MODULE_33__.deactivateLanguageServer)();
}

})();

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;
//# sourceMappingURL=extension-node.js.map